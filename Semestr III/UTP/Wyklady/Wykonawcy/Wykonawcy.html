<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="Uniwersalne techniki programowania">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2010">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Narzêdzia programowania wspó³bie¿nego: wykonawcy</title>
</head>
<body>
<br>
<br>
<div align="Center">
<h1>Narzêdzia programowania wspó³bie¿nego: wykonawcy</h1>
</div>
<br>

</div>
<hr>
<i>G³ównym celem tego&nbsp; wyk³adu jest
przedstawienie&nbsp; œrodków programowania
wspó³bie¿nego, dostêpnych w pakiecie java.util.concurrent.
Rozpoczynamy od przypomnienia podstawowych pojêæ, po czym zajmiemy siê
podstawowymi&nbsp; koncepcjami "konkurencyjnej Javy". &nbsp;Najpiewr
uwagê skupimy na zadaniach i wykonawcach, aby potem zaj¹æ siê&nbsp; œrodkami synchronizacji i koordynacji watków.</i><br>
<hr>

<a name="Wykonawcy.1"></a><h2>1. Przypomnienie: w¹tki</h2>

<br>



<div class="def"><b><!---->W¹tek</b> - to sekwencja dzia³añ, która mo¿e
wykonywaæ siê równolegle&nbsp; z innymi sekwencjami dzia³añ w
kontekœcie danego procesu
(programu).<!----></div>


<br>


W systemach jednoprocesorowych wra¿enie równoleg³oœci dzia³ania w¹tków osi¹gane jest przez mechanizm przydzielania
czasu procesora poszczególnym wykonuj¹cym siê w¹tkom. Ka¿dy w¹tek uzyskuje
dostêp do procesora na krótki czas (<b>kwant czasu</b>), po czym "oddaje procesor"
innemu w¹tkowi. Zmiany s¹ tak szybkie, ¿e powstaje wra¿enie równoleg³oœci
dzia³ania.<br>


<br>


Najbardziej popularnym mechanizmem "zamiany w¹tków u procesora" jest tzw. <b>wyw³aszczanie</b> (<i>pre-emptive multistasking</i>) - o dostêpie
w¹tków do procesora decyduje systemowy zarz¹dca w¹tków: przydziela on w¹tkowi
kwant czasu procesora, po up³yniêciu którego odsuwa w¹tek od procesora i
przydziela kwant czasu procesora innemu w¹tkowi.<br>


<br>



Podstawowa ró¿nica pomiêdzy procesami i w¹tkami polega na tym, ¿e ró¿ne w¹tki
w ramach jednego procesu maj¹ dostêp do ca³ego kontekstu tego procesu (m.in.
przydzielonych mu zasobów).<br>



Wobec tego zamiana w¹tków jednego procesu "przy procesorze" jest wykonywana
szybciej ni¿ zamiana procesów (w¹tków ró¿nych procesów).<br>



Z punktu widzenia programisty wspólny dostêp wszystkich w¹tków jednego procesu
do kontekstu tego procesu ma zarówno zalety jak i wady.<br>



Zalet¹ jest mo¿liwoœæ ³atwego dostêpu do wspólnych danych programu. Wad¹
- brak ochrony danych programu przed równoleg³ymi zmianami, dokonywanymi
przez ró¿ne w¹tki, co mo¿e prowadziæ do niespójnoœci danych, a czego unikanie
wi¹¿e siê z koniecznoœci¹ synchronizacji dzia³ania w¹tków.<br>


<br>


W Javie uruchamianiem w¹tków i zarz¹dzaniem nimi zajmuje siê klasa <b>Thread</b>. <br>


<br>


Do wersji 1.5 obowi¹zywa³y nastêpuj¹ce zasady:<br>



<br>



<div class="syntax">Aby uruchomiæ w¹tek nale¿y stworzyæ obiekt klasy <b>Thread</b> i &nbsp;u¿yæ metody <b>start()</b> wobec tego obiektu.<br>



</div>


 <br>



Ale kod, wykonuj¹cy siê jako w¹tek (sekwencja dzia³añ, wykonuj¹ca siê równolegle
z innymi dzia³aniami programu) okreœlany jest przez obiekt klasy implementuj¹cej interfejs
<b>Runnable</b>. <br>



Interfejs ten zawiera deklaracjê metody <b>run()</b>, która przy implementacji musi byæ zdefiniowana. <br>



W³aœnie w metodzie <b>run()</b> zapisujemy kod, który bêdzie wykonywany jako w¹tek (równolegle z innymi w¹tkami programu). <br>



<br>



<div class="important"> &nbsp; &nbsp;<b>Metoda run() okreœla co ma robiæ w¹tek.</b></div>


 <br>



<br>



Klasa Thread implementuje interfejs Runnable (podaj¹c "pust¹" metodê run). <br>



<br>



St¹d pierwszy sposób tworzenia i uruchamiania w¹tku.<br>



<br>



<table bgcolor="#ccffff" border="1" cellpadding="2" cellspacing="2" width="100%">



  <tbody>



    <tr>



      <td style="background-color: rgb(156, 211, 215);" valign="top">



      <div align="center"><b>Pierwszy sposób tworzenia i uruchamiania w¹tku (Java 1.4)</b><br>



      </div>



      </td>



    </tr>



    <tr>



      <td style="background-color: rgb(156, 211, 215);" valign="top">



      <ol><li>Zdefiniowaæ w³asn¹ klasê dziedzicz¹c¹ Thread (np. class Timer extends Thread)</li><li>
Przedefiniowaæ odziedziczon¹ metod¹ run(), podaj¹c w niej dzia³ania, które ma wykonywaæ w¹tek</li><li>
Stworzyæ obiekt naszej klasy (np. Timer timer = new Timer(...);</li><li>
Wys³aæ mu komunikat start() (np. timer.start())&nbsp;</li></ol>



      </td>



    </tr>






  </tbody>
</table>


<br>


Jak wiemy, kod wykonywany przez w¹tek podajemy w metodzie run(). A
metoda run() mo¿e byæ zdefiniowana w dowolnej klasie implementuj¹cej interfejs
Runnable. <br>



Klasa Thread dostarcza zaœ konstruktora, którego argument jest&nbsp; typu Runnable. <br>



Konstruktor ten&nbsp; tworzy w¹tek, który bêdzie wykonywa³ kod zapisany w metodzie
run() w klasie obiektu, do którego referencjê przekazano wspomnianemu wy¿ej
konstruktorowi.<br>



<br>



St¹d drugi sposób tworzenia i uruchamiania w¹tków.<br>



<br>



<table bgcolor="#ccffff" border="1" cellpadding="2" cellspacing="2" width="100%">



  <tbody>


    <tr>


      <td style="background-color: rgb(156, 211, 215);" valign="top">


      <div align="center"><b>Drugi sposób tworzenia i uruchamiania w¹tku </b><b>(Java 1.4)</b></div>


      </td>


    </tr>


    <tr>


      <td style="background-color: rgb(156, 211, 215);" valign="top">


      <ol><li>Zdefiniowaæ klasê implementuj¹c¹ interfejs Runnable (np. class X implements Runnable).</li><li>Dostarczyæ w niej definicji metody run (co ma robiæ w¹tek).</li><li>Utworzyæ obiekt tej klasy (np.&nbsp; X x = new X(); )</li><li>&nbsp;Utworzyæ obiekt klasy Thread, przekazuj¹c w konstruktorze referencjê
do obiektu utworzonego w p.3 (np.Thread thread = new Thread(x);).</li><li>Wywo³aæ na rzecz nowoutworzonego obiektu klasy Thread&nbsp; metodê start ( thread.start();)<br>



        </li></ol>


      </td>


    </tr>




  </tbody>
</table>



<br>


<span style="font-weight: bold;">Koñczenie pracy w¹tku</span><br>


<br>


<div class="important">W¹tek koñczy pracê w sposób naturalny wtedy, gdy zakoñczy siê jego metoda run(). </div><br>



<br>



<div class="syntax">Jeœli chcemy programowo zakoñczyæ pracê w¹tku, to&nbsp; nale¿y zapewniæ w metodzie
run() sprawdzenie warunków zakoñczenia (ustalanych programowo) i jeœli s¹
spe³nione - spowodowaæ wyjœcie z run() albo przez "dobiegniêcie do koñca",
albo przez return. <br>


 Warunki zakoñczenia mog¹ byæ formu³owane w postaci
wartoœci jakiejœ zmiennej, które s¹ ustalane przez inne fragmenty kodu programu
(wykonywane w innym w¹tku). <br>



</div>


<br>


Do koñczenia pracy w¹tku mo¿liwe jest tak¿e u¿ycie metody interrupt()
ale wymaga to odpowiedniego przygotowania kodu w metodzie run(). Jest
to w³aœciwy sposób postêpowania, jeœli u¿ywamy nowych koncepcji
(serwisów wykonawców) z pakietu java.util.concurrent.
&nbsp;O tym mowa bêdzie w dalszej czêœci wyk³adu.
<hr>

<a name="Wykonawcy.2"></a><h2>2. Pakiet java.util.concurrent z lotu ptaka</h2>










Java zawsze by³a przygotowana na wspó³bie¿noœæ. Od pocz¹tku
&nbsp;jej istnienia, w samym jêzyku i jego pakietach, zawarto
odpowiednie konstrukcje (synchronize, synchronized, &nbsp;wait, notify,
notifyAll).<br>


Java umo¿liwia³a&nbsp; pisanie wspó³bie¿nych programów, ale <span style="font-weight: bold;">nie</span> zawsze w sposób skalowalny.<br>








Czyli wszystko dzia³a³o dobrze, dopóki o zasoby nie konkurowa³o
zbyt wiele w¹tków. Przy du¿ej konkurencji ("high-contention") tylko genialnie
napisane programy sprawdza³y siê i pod wzglêdem miarodajnoœci i pod
wzglêdem efektywnoœci.<br>








Genialne pisanie programu wymaga i du¿o wysi³ku i zwykle nie wychodzi.<br>








Pakiet <span style="font-weight: bold;"><!---->java.util.concurrent</span><!----> (opracowany g³ównie przez Douga Lea i obecny w Javie od wersji 1.5) zmienia tê
sytuacjê. Teraz doœæ prosto mo¿na napisaæ programy nastawione na
konkurencyjnoœæ (a wiêc nie tylko wspó³bie¿noœæ, ale i&nbsp; <span style="font-weight: bold;">skalowaln¹ wspó³bie¿noœæ</span>).
A dodatkowo mamy do dyspozycji nieprzebrane mnóstwo narzêdzi do
tworzenia ca³kiem w³asnych, przygotowanych na&nbsp; specyficzne
sytuacje, rozwi¹zañ problemów wspó³bie¿noœci,<br>


<br>


Pakiet java.util.concurrent:<br>


<ul><li>umo¿liwia separacjê zadañ i w¹tków,</li><li>pozwala na anulowanie zadañ,</li><li>dostarcza puli w¹tków prowadzonych przez Wykonawców,</li><li>zawiera&nbsp;bardziej efektywne przy "high contention" - bazowe synchronizatory (Lock),</li><li>umo¿liwia ³atw¹ realizacjê read/write locks,</li><li>udostêpnia nowe synchronizatory wy¿szego poziomu (semafory, bariery, zasuwy),</li><li>pozwala na u¿ycie blokuj¹cych kolejek (³atwa koordynacja zadañ),</li><li>dostarcza konkurencyjnych (efektywnych przy du¿ej konkurencji) kolekcji,</li><li>definiuje atomiki (dane podstawowych typów, bezpiecznie dostêpne wspó³bie¿nie).</li></ul>

<br>
<hr>

<a name="Wykonawcy.3"></a><h2>3. Separacja zadañ od sposobu ich wykonania</h2>



<br>
<!----><!---->


Od pocz¹tków Javy &nbsp;programiœci mieli wiele k³opotów
ze zrozumieniem pojêcia w¹tku (a szczególnie obiektów
klasy
Thread). Nawet zaawansowanym programistom wydawa³o siê, ¿e u¿yteczn¹
pracê wykonuje klasa Thread. Tymczasem&nbsp; kod w¹tku zapisywany jest
w metodzie run(), a klasa Thread tak naprawdê nic nie robi. To kod
metody run() wykonuje siê "w w¹tku" (czyli wspó³bie¿nie), choæ
czêsto mówimy nieco mylnie (potocznie): "w¹tek siê wykonuje".
&nbsp;Tymczasem wcale nie jesteœmy zainteresowani w¹tkami (obiektami
klasy Thread) tylko zadaniami (zapisanymi w metodzie run()),
które "poprzez w¹tki" siê wykonuj¹. Chcielibyœmy rozumowaæ
raczej w kategoriach zadañ do wykonania, a nie technicznych
szczegó³ów sposobu ich wykonania.<br>


<br>


Poczynaj¹c od Javy 1.5 sta³o siê to mo¿liwe. &nbsp;<span style="font-weight: bold;">Zadania "do wykonania" mog¹ byæ odseparowane od w¹tków</span> (od zarz¹dzanie
nimi, umartwiania siê nimi, œledzenia ich - co w dotychczasowej Javie
wcale nie by³o ³atwe, o ile w ogóle mo¿liwe).<br>







<br>




Dotychczas by³o tak:<br>







<br>




&nbsp;&nbsp;&nbsp; Runnable r = ...;<br>




&nbsp;&nbsp;&nbsp; Thread t = new Thread(r);<br>




&nbsp;&nbsp;&nbsp; t.start();<br>







<br>








<br>








to znaczy - trzeba by³o samemu&nbsp;uruchomiæ w¹tek i dalej martwiæ siê o jego los.<br>






<br>






Gdy mia³ wyprodukowaæ jakieœ wyniki&nbsp; trzeba
by³o o nie zadbaæ &nbsp;(doœæ ¿mudnie&nbsp; oprogramowaæ ich
przejêcie). <br>






<br>






Gdy by³o du¿o w¹tków - pojawia³ siê du¿y problem.
<br>
A co siê stanie, gdy nasza metoda run() zg³osi wyj¹tek?<br>








Interfejs Runnable nie przewidzia³ tego w deklaracji run().&nbsp;Pozostaje tylko RuntimeException.<br>







Sposoby jego obs³ugi &nbsp;w Javie "przedkonkurencyjnej" by³y i uci¹¿liwe i niezbyt niezawodne.<br>








<br>








Na te wszystkie&nbsp; problemy pakiet java.util.concurrent ma gotowe odpowiedzi.<br>








<br>








<table style="text-align: left; width: 100%; background-color: rgb(255, 255, 204);" border="1" cellpadding="2" cellspacing="2">








  <tbody>








    <tr>








      <td style="background-color: rgb(156, 211, 215);">Chcesz ³atwo tworzyæ pule w¹tków, i zarz¹dzaæ nimi bez &nbsp;trudnego programowania?</td>








      <td style="background-color: rgb(156, 211, 215);">U¿yj odpowiednich Serwisów Wykonawców (ExecutorService)</td>








      <td></td>








    </tr>








    <tr>








      <td style="background-color: rgb(156, 211, 215);">Chcesz myœleæ &nbsp;w kategoriach zadañ (Task), nie w¹tków?</td>








      <td style="background-color: rgb(156, 211, 215);">Daj Wykonawcom zadania do wykonania, oni zdecyduj¹
jak
najlepiej podzieliæ je miêdzy w¹tki, ale ogólna strategia
podzia³u i uruchamiania jest pod Twoj¹ kontrol¹ (mamy wybór
ró¿nych strategii)</td>








      <td></td>








    </tr>








    <tr>








      <td style="background-color: rgb(156, 211, 215);">Chcesz mieæ ³atwo dostêpne wyniki wspó³bie¿nych zadañ?</td>








      <td style="background-color: rgb(156, 211, 215);">U¿yj interfejsu Callable, zaufaj Wykonawcom i odbieraj wyniki w postaci FutureTask -
obiektu pozwalaj¹cego na asynchroniczne testy (wyniki ju¿ s¹? jeszcze
nie ma?), reagowanie na wyj¹tki, odczytywanie wyników zadañ i pod³¹czanie callbacków.</td>








      <td></td>








    </tr>
















  </tbody>
</table>








<br>







Pierwszym krokiem ku poprawie sytuacji jest <!----><span style="font-weight: bold;">odseparowanie zadañ do wykonania od &nbsp;mechanizmów tworzenia i uruchamiania w¹tków</span><!---->.<br>
<!----><!---->







Pakiet java.util.concurrent definiuje interfejs Executor:<br>







<br>







<pre>public interface Executor {
  void execute(Runnable);
}</pre>







Jego implementacje&nbsp; (nie my) winny zajmowac siê tworzeniem i uruchamianiem w¹tków.<br>
<!----><!---->







Sposób, polityka tworzenia i uruchamiania w¹tków spoczywa
na Wykonawcach (klasach implementuj¹cych interfejs Executor).<br>







<br>







A zatem napiszemy raczej tak (choæ jeszcze nie do koñca poprawnie):<br>







<br>







<pre>  Executor executor = ....;

  private void serviceConnections() {
    while (serverRunning) {
      try {
        final Socket conn = ss.accept();
        System.out.println("Connection established");

        Runnable serviceCode = new Runnable() {
           public void run() {
              serviceRequests(conn);
           }
        }

<b>        </b><span style="color: rgb(204, 0, 0); font-weight: bold;">executor.execute(serviceCode);</span>

      } catch (Exception exc) {
          exc.printStackTrace();
      }
    }
    try { ss.close(); } catch (Exception exc) { //... }
  }
</pre>







W szczególnoœci konkretny Wykonawca mo¿e prowadziæ&nbsp;pulê
w¹tków, zapewniaj¹c naszemu serwerowi odpowiedni¹
efektywnoœæ.&nbsp;<br>







<br>







<div class="notec">Tworzenie w¹tków jest kosztowne czasowo. <!---->Pule w¹tków
pozwalaj¹ na ponowne u¿ycie wolnych w¹tków, a tak¿e na ew.
limitowanie maksymalnej liczby&nbsp;w¹tków w puli<!---->.</div><br>







<br>







My rozumujemy w kategoriach <span style="font-weight: bold;">zadania </span>do wykonania (okreœlanegu tu przez kod Runnable), tworzeniem i uruchamianiem w¹tków zajmuja siê Wykonawcy.<br>







<br>







W Javie mamy do dyspozycji kilka rodzajów gotowych Wykonawców, fabrykowanych przez odpowiednie metody klasy <span style="font-weight: bold;">Executors</span> m.in.:<br>







<ul><li>Wykonawca uruchamiaj¹cy podane mu zadania w jednym w¹tku (po kolei) (<span style="font-style: italic; font-weight: bold;">Executors.newSingleThreadExecutor()</span>),</li><li>Wykonawca, prowadz¹cy pulê w¹tków o zadanych maksymalnych rozmiarach (<span style="font-style: italic; font-weight: bold;">Executors.newFixedThreadPool()</span>),</li><li>Wykonawca, prowadz¹cy pulê w¹tków o dynamicznych rozmiarach</li><li>(<span style="font-weight: bold; font-style: italic;">Executors.newCachedThreadPool()</span>),</li><li>Wykonawcy zarz¹dzaj¹cy tworzeniem i wykonaniem w¹tków w okreœlonym czasie lub z okreœlon¹ periodycznoœci¹ (<span style="font-weight: bold;">Executors.newScheduled....()</span>) </li></ul>







Mo¿emy wiêc napisaæ coœ takiego:<br>







<pre>import java.util.concurrent.*;


class Task implements Runnable {

  private String name;

  public Task(String name) {
    this.name = name;
  }

  public void run() {
    for (int i=1; i &lt;= 4; i++) {
      System.out.println(name + " " + i);
      Thread.yield();
    }
  }
}


public class Wykonawca {

  public static void main(String[] args) {
    Executor exec = Executors.newFixedThreadPool(2);
    for (int i=1; i&lt;=4; i++) {
      exec.execute(new Task("Task " + i));
    }
  }
}</pre>







Program wypisze nastêpuj¹ce wyniki:<br>







<div class="listing100"><br>







Task 1 1<br>







Task 2 1<br>







Task 1 2<br>







Task 2 2<br>







Task 1 3<br>







Task 2 3<br>







Task 1 4<br>







Task 2 4<br>







Task 3 1<br>







Task 4 1<br>







Task 3 2<br>







Task 4 2<br>







Task 3 3<br>







Task 4 3<br>







Task 3 4<br>







Task 4 4<br>







</div><br>







<br>







Zwróæmy&nbsp;uwagê, ¿e pula w¹tków jest ograniczona do
dwóch. Zatem najpierw wspólbie¿nie dzia³aj¹ dwa pierwsze
zadania, a po nich - trzecie i czwarte.<br>







<br>







Gdy nasze zadania zakoñcz¹ siê, Wykonawca nadal "dzia³a" i jest gotowy do przyjmowania nowych zadañ.<br>







<br>







<div class="def"><!---->Zamkniêcie Wykonawcy oznacza, i¿ nie bêdzie on&nbsp; ju¿ przyjmowa³
nowych zadañ do wykonania; jednak przekazane mu wczeœniej i jeszcze nie
zakoñczone - bêdzie wykonywa³<!---->.</div><br>







<br>
<!----><!---->







Us³ugê zamkniêcia dostarcza interfejs ExecutorService, który jest rozszerzeniem interfejsu Executor.<br>







<br>







<div class="important"><!---->Metody fabryczne klasy Executors zwracaj¹ Wykonawców implementuj¹cych ExecutorService<!----></div><br>







<br>







Zobaczmy.<br>







<br>







<pre>  public static void main(String[] args) {
    ExecutorService exec = Executors.newFixedThreadPool(2);
    for (int i=1; i&lt;=4; i++) {
      exec.execute(new Task("Task " + i));
    }
    Thread.yield();
    exec.shutdown();

    try {
      exec.execute(new Task("Task after shutdown"));
    } catch (RejectedExecutionException  exc) {
        exc.printStackTrace();
    }
    try {
      exec.awaitTermination(5, TimeUnit.SECONDS);
    } catch(InterruptedException exc) { exc.printStackTrace(); }
    System.out.println("Terminated: " + exec.isTerminated());

  }</pre>







<div class="listingful"><br>







.......<br>







Task 3 4<br>







Task 4 4<br>







Terminated: true<br>







java.util.concurrent.RejectedExecutionException<br>







&nbsp;&nbsp;&nbsp; at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:1477)<br>







&nbsp;&nbsp;&nbsp; at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:384)<br>







&nbsp;&nbsp;&nbsp; at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:856)<br>







&nbsp;&nbsp;&nbsp; at exec0.Wykonawca.main(Wykonawca.java:34)<br>







</div><br>







<br>







Poniewa¿ metoda shutdown() zamyka ExecutorService, zadanie "Task after
shutdown" nie zostanie uruchomione (powstanie wyj¹tek
RejectedExecutionException; ten wyj¹tek mo¿e powstawaæ równie¿
wtedy, gdy ExecutorService z innych powodów ni¿ zamkniêcie
odmawia wykonania zadania).<br>







<div class="notel">TimeUnit pozwala na lepsz¹ i wygodniejsz¹ granulacjê czasu - wszêdzie
tam gdzie wchodz¹ w grê opóŸnienia i oczekiwania.. S¹ dostêpne
sta³e, okreœlaj¹ce wybór jednostek:<br>







<ul><li>TimeUnit.SECONDS</li><li>TimeUnit.MICROSECONDS</li><li>TimeUnit.MILLISECONDS</li><li>TimeUnit.NANOSECONDS</li></ul>







</div><br>




Na koñcu programu - za pomoc¹ metody awaitTermination(...) wstrzymujemy
bie¿¹cy w¹tek dopóki Wykonawca nie zakoñczy wszystkich zadañ
(albo dopóki nie minie 5 sekund lub te¿ nie wyst¹pi przerwanie
bie¿¹cego w¹tku za pomoc¹ metody interrupt). Warto stosowaæ metodê
awaitTermination(), &nbsp;kiedy chcemy mieæ pewnoœæ, ¿e Wykonawaca
naprawdê zakoñczy³ dzia³anie i wyczyœci³ wszystkie swoje zajête zasoby
(np. bez tego nasz g³owny w¹tek mo¿e sie skoñczyæ wczeœniej ni¿
Wykonawcy i aplikacja nie zakoñczy dzia³ania).<br>







<br>







<div class="important">ExecutorService dostarcza tak¿e metody <span style="font-weight: bold;">shutdownNow()</span>,
która ma za zadanie zakoñczyæ dzia³anie wszystkich aktualnie
wykonuj¹cych siê zadañ (w¹tków) i zamkn¹æ Wykonawcê. </div><br>







<br>







Spróbujmy&nbsp;jej u¿yæ w naszym kodzie.<br>







Niech pêtla w run() wykonuje siê w nieskoñczonoœæ np. for (byte i=1; i&lt;=128; i++)<br>







W metodzie main - w miejsce shutdown() wstawmy kod:<br>







<pre>    try {
      Thread.sleep(1000);
    } catch(Exception exc) {}

    exec.shutdownNow();
</pre>







Co siê stanie? Nic. Dwa zadania (w¹tki) bêd¹ dzia³aæ w nieskoñczonoœæ (i nie zostan¹ zatrzymane).<br>







Dlaczego?<br>
<hr>

<a name="Wykonawcy.4"></a><h2>4. Koñczenie zadañ przez interrupt()</h2>



W poprzednim przyk³adzie zadania dziala³y&nbsp;w nieskoñczonoœæ gdy¿
metoda shutDownNow() koñczy dzia³aj¹ce zadania poprzez u¿ycie metody
interrupt() wobec odpowiednich w¹tków.<br>


<br>


<div class="important">Metoda
interrupt() ustala jedynie status w¹tku jako przerwany, a zakoñczenie
pracy w¹tku odbywa siê zawsze przez zakoñczenie jego kodu.</div><br>


<br>







Trzeba zatem zmodyfikowaæ kod metody run() np tak.<br>







<pre>  public void run() {
    for (byte i=1; i &lt;= 128 ; i++) {
      if (Thread.currentThread().isInterrupted()) return;
      System.out.println(name + " " + i);
      Thread.yield();
    }
  }</pre>







Teraz w¹tki zostan¹ zatrzymane i zadania zakoñczone.<br>







<br>






<div class="syntax">Pamiêtaæ nale¿y, ¿e w sytuacjach gdy w¹tek jest uœpiony lub
zablokowany z mo¿liwoœci¹ przerwania blokady (<span style="font-weight: bold;">sleep</span>, &nbsp;<span style="font-weight: bold;">wait</span> i jego
odpowiedniki w java.util.concurrent, przerywalne synchronizatory
(<span style="font-weight: bold;">interruptible locks</span>), przerywalne operacje we-wy (<span style="font-weight: bold;">interruptible
channels)</span>) koñczenie zadañ - czyli wywo³anie interrupt() - powoduje
zg³oszenie wyj¹tku InterruptedException i w obs³udze tego wyj¹tku
nale¿y zakoñczyæ wykonanie kodu w¹tku.</div><br>







<br>







<div class="important"><span style="font-weight: bold;">Mo¿liwoœæ wykonywania kodów
jako zadañ obs³ugiwanych przez Wykonawców powoduje, ¿e
poczynaj¹c od Javy 1.5 koñczenie pracy w¹tków musimy zapewniaæ
poprzez sprawdzanie stanu INTERRUPTED oraz obs³ugê wyj¹tku
InterruptedException</span></div><br>







<br>







Przyk³ad.<br>







<br>







<pre>class Interruptible  {

  Lock lock = new ReentrantLock();

  Runnable task1 = new Runnable() {
     public void run() {
       System.out.println("Task 1 begins");
       try {
         lock.tryLock(1000, TimeUnit.SECONDS);  // próba zamkniêcia rygla (czeka na wolny rygiel lub 1000 sekund)
         System.out.println("Task 1 entered");
       } catch(InterruptedException exc) {
           System.out.println("Task 1 interrupted");
       }
       System.out.println("Task 1 stopped");
     }
  };

  Runnable task2 = new Runnable() {
    public void run() {
      System.out.println("Task 2 begins");
      for (int i=1; i &lt;= 600; i++) {
        if (Thread.currentThread().isInterrupted()) break;
        // jakieœ obliczenie
        if (Thread.currentThread().isInterrupted()) break;  // chcemy przerwaæ mo¿liwie najszybciej
        try {                                               // sleep() jest przerywane pzrez interrupt()!
          Thread.sleep(1000);
        } catch (InterruptedException exc) { break; }
      }
      System.out.println("Task 2 stopped");
    }
  };


  Runnable task3 = new Runnable() {
    Scanner scan = new Scanner(  // musimy miec InterruptibleChannel, aby móc przerwaæ czekanie na wejœciu
                    new FileInputStream(FileDescriptor.in).getChannel(), "Cp852");
    public void run() {
      System.out.println("Task 3 begins");
      System.out.print("&gt;&gt;");
      while (scan.hasNextLine()) {
        try {
          String s = scan.nextLine();
          System.out.print('\n'+s + "\n&gt;&gt;");
        } catch (Exception exc) {
            <span style="color: rgb(51, 0, 51);">// Uwaga: scanner nie zg³asza wyj¹tków, ale przerywa dzialanie</span>
            exc.printStackTrace();
            break;
        }
      }
      System.out.println("Task 3 stopped - " + scan.ioException());  <span style="color: rgb(51, 0, 51);">// jaki wyj¹tek go przerwa³?</span>
    }
  };

  Interruptible() {
    ExecutorService exec = Executors.newCachedThreadPool();

    exec.execute(new Runnable() {        // w¹tek zamyka rygiel
                    public void run() {
                      lock.lock();
                    }
                 }
     );
    exec.execute(task1);
    exec.execute(task2);
    exec.execute(task3);
    JOptionPane.showMessageDialog(null, "Press Ok to stop all tasks");
    exec.shutdownNow();
  }

}</pre>


Gdy uruchomimy&nbsp;program&nbsp;(z metody main(), mo¿e w innej klasie) przez:<br>







<br>







&nbsp;&nbsp;&nbsp; new Interruptible();<br>


<br>







otrzymamy nastêpuj¹cy wynik:<br>


<br>


<div class="listingful"><br>







Task 1 begins<br>







Task 2 begins<br>







Task 3 begins<br>







&gt;&gt;ala ma kota<br>







^Z<br>







<br>







ala ma kota<br>


&gt;&gt;<br>


............................ <span style="color: rgb(255, 255, 102);">Teraz wciskamy Ok w dialogu</span><br>







Task 1 interrupted<br>







Task 1 stopped<br>







Task 2 stopped<br>







Task 3 stopped - java.nio.channels.ClosedByInterruptException<br>







</div>
<br>
<hr>

<a name="Wykonawcy.5"></a><h2>5. Odbiór wyników zadañ. Zadania "z prawdziwego zdarzenia".</h2>



<br>






Wróæmy teraz do innego, poruszonego wczeœniej, zagadnienia: <br>




<span style="font-weight: bold;">w
jaki sposób zapewniæ, aby zadania mog³y zwracaæ wyniki, ew.
sygnalizowaæ (ró¿ne) wyj¹tki i jak odbieraæ te wyniki od nich?</span><br style="font-weight: bold;">






<br>
<!----><!---->






Odpowiedz¹ na pierwsz¹ czêœæ pytania jest interfejs Callable.<br>








Ma on nastêpuj¹c¹ postaæ.<br>







<br>







<pre>public interface Callable&lt;V&gt; {
  V call() throws Exception;
}</pre>








<br>








W stosunku do interfejsu Runnable s¹ tu dwa - wa¿ne - udogodnienia.<br>







<ul><li>zwrot wyniku,</li><li>mo¿liwoœæ zg³oszenia wyj¹tku kontrolowanego.</li></ul>






Zarówno Callable, jak i Runnable okreœlaj¹ kod do&nbsp;
(ewentualnie wspó³bie¿nego) wykonania. To s¹ jak gdyby dwie
ró¿ne wersje definiowania zadania do wykonania.&nbsp;<br>






<br>






Mo¿na (wstêpnie) powiedzieæ tak - mamy dwa rodzaje zadañ.<br>






Takie które zwracaj¹ wyniki i takie które nie zwracaj¹ wyników.<br>


To ¿e kod zadania zwraca wynik jest realizowane przez implementacjê
Callable. Ale samo Callable (które zwraca wynik) nie wystarczy,
aby mo¿na&nbsp;by³o ten wynik ³atwo uzyskaæ. Zadanie jest uruchamiane
przez Wykonawcê i nie zawsze wiemy kiedy zostanie uruchomione. Wykonuje
siê asynchronicznie, zatem nie wiemy kiedy wynik bêdzie gotowy.<br>






<br>
<!---->






Dlatego wprowadzono interfejs <span style="font-weight: bold;">Future&lt;V&gt;</span><!---->, który - jak napisano w dokumentacji - reprezentuje wynik asynchronicznych obliczeñ i zawiera nastêpuj¹ce metody. <br>






<br>






<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">






  <tbody>






    <tr class="TableRowColor" bgcolor="white">






      <td align="right" valign="top" width="1%">boolean</td>







      <td>cancel(boolean&nbsp;mayInterruptIfRunning)

      <br>






&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Próbuje
anulowaæ wykonanie zadania (argument mówi o tym, czy mo¿na
przerwaæ wykonuj¹ce siê zadanie). Nie wykonuj¹ce siê (jeszcze) zadania
s¹ usuwane z listy zadañ Wykonawcy.</td>







    </tr>







    <tr class="TableRowColor" bgcolor="white">







      <td align="right" valign="top" width="1%">
      &nbsp;V</td>







      <td>get()

      <br>






&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pobiera wynik
zadania, jeœli zadanie siê nie zakoñczy³o - czeka (blokuje).
Oczekiwanie mo¿e byæ przerwane przez CancellationException (zadanie
anulowane), ExecutionException (kod zadania zg³osi³ wyj¹tek),
InterruptedException (metoda interrupt() wobec w¹tku, w którym
wykonywane jest zadanie).<br>






Wyj¹tki Execution i Interrupoted musz¹ byæ obs³ugiwane.</td>







    </tr>







    <tr class="TableRowColor" bgcolor="white">







      <td align="right" valign="top" width="1%">
      &nbsp;V</td>







      <td>get(long&nbsp;timeout,
    TimeUnit&nbsp;unit)

      <br>






&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pobiera wynik
zadania, jeœli zadanie siê nie zakoñczy³o - czeka (blokuje), ale nie
d³u¿ej ni¿ podany czas. Wyj¹tki jw. + TimeoutException </td>







    </tr>







    <tr class="TableRowColor" bgcolor="white">







      <td align="right" valign="top" width="1%">
      &nbsp;boolean</td>







      <td>isCancelled()

      <br>







&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy anulowane?<br>






      </td>







    </tr>







    <tr class="TableRowColor" bgcolor="white">







      <td align="right" valign="top" width="1%">
      &nbsp;boolean</td>







      <td>isDone()

      <br>






&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy zakoñczone
(w dowolny sposób, równie¿ przez anulowanie)?</td>






    </tr>












  </tbody>
</table>






<br>






Tak naprawdê Future opisuje nie tylko metody dotycz¹ce wyników
zadania, ale równie¿ wykonania zadania. Metoda cancel() -
dotyczy przecie¿ wykonania&nbsp;zadaniu.<br>






<br>






<div class="important"><!---->Zadania, które zwracaj¹ wyniki musz¹ wiêc mieæ nie
tylko&nbsp;kod &nbsp;podany jako Callable, ale równie¿ musz¹ byæ
Future.<!----></div><br>






<br>






Ale to znowu nie wystarczy!<br>






Zadania s¹ uruchamiane przez Wykonawców w zarz¹dzanych przez nich w¹tkach.<br>






Zatem zawsze <span style="font-weight: bold;">zadania musz¹ byæ Runnable</span>.<br>






Zwróæmy uwagê: w metodzie execute() Wykonawcy mo¿na podaæ tylko Runnable.
Dlaczego zatem Callable te¿ mo¿emy traktowaæ jako kod zadania do
wykonania? A skoro mo¿emy, to w jaki sposób ten kod &nbsp;jest uruchamiany
przez metodê execute()?<br>






<br>






Wróæmy na chwilê do naszych poprzednich przyk³adów (gdy "zadaniami" by³y zwyk³e Runnable).<br>






Zauwa¿my, to nie by³y "pe³nokrwiste" zadania.<br>






<br>


<div class="notec">"Prawdziwe"&nbsp;zadanie musi spe³niaæ nastêpuj¹ce warunki:<br>






<ul><li>zadanie musi pozwalaæ na asynchroniczne wykonanie w odrêbnym w¹tku (a wiêc w obecnej Javie byæ Runnable),</li><li>musi istnieæ mo¿liwoœæ traktowania zadania do wykonania&nbsp;
odrêbnie od sposobu i czasu jego uruchamiania w jakimœ w¹tku (separacja
przez Wykonawców),</li><li>musimy mieæ mo¿liwoœæ ³atwego uzyskania informacji o wyniku
zadania (a wynikiem mo¿e byæ nie tylko konkretna wartoœæ, ale
równie¿ informacja o tym&nbsp; "czy wykonanie kodu zakoñczy³o siê
normalnie", "czy powsta³&nbsp; wyj¹tek w trakcie wykonania?", "czy
zadanie zosta³o anulowane - przerwane w trakcie wykonania lub zakoñczone
przez odwo³anie przysz³ego wykonania?")</li><li>musimy mieæ mo¿liwoœæ, bez koniecznoœci operowania na w¹tkach -
anulowania zadania (w tym przerwania ju¿ wykonuj¹cego siê zadania).</li></ul></div>









Po³¹czenie czystego Runnable z execute(...) Wykonawców spe³nia tylko &nbsp;dwa pierwsze warunki.<br>






Odpytywanie o wyniki zadania (a tak¿e mo¿liwoœæ anulowania-przerywania zadañ) wymaga, by zadanie by³o Future.<br>






Po to, by móc obs³ugiwaæ wyj¹tki wykonania (nawet dla
&nbsp;kodów, które nie zwracaj¹ wyników) - kod
zadania musi byæ Callable.<br>






<br>






<div class="def"><!---->Zadanie jest obiektem implementuj¹cym interfejsy Runnable i Future, a
jego kod musi byæ zawarty w metodzie call() klasy implementuj¹cej
interfejs Callable<!----></div><br>






<br>






Co nie oznacza, ¿e ze zwyk³ego Runnable nie mo¿emy stworzyæ zadania!<br>






<br>






<span style="font-weight: bold;">W Javie implementacja pojêcia zadania zrealizowana jest jako klasa <!---->FutureTask</span><!---->.<br>






<br>






<pre>/*
* @since 1.5
* @author Doug Lea
*/
public class FutureTask&lt;V&gt; implements Future&lt;V&gt;, Runnable {
    // .....
    public FutureTask(Callable&lt;V&gt; callable) {
        if (callable == null)
            throw new NullPointerException();
        sync = new Sync(callable);
    }

    public FutureTask(Runnable runnable, V result) {
        sync = new Sync(Executors.callable(runnable, result));
    }
    // .....
    private final class Sync extends AbstractQueuedSynchronizer {
        // .....
        private final Callable&lt;V&gt; callable;
        // .....
        Sync(Callable&lt;V&gt; callable) {
            this.callable = callable;
        }
        // .....
    }
}</pre>






<span style="font-style: italic;">Fragment na podstawie ¿róde³ klasy FutureTask (SunMicrosystem 2005).</span><br>


<br>


A zatem tworz¹c zadanie mo¿emy podaæ w konstruktorze Callable. &nbsp;Jak widaæ,
to Callable zostanie u¿yte przez kompozycjê w wewnêtrznej klasie
Sync.<br>






Mo¿emy te¿ podaæ zwyk³e Runnable (z dodatkowym argumentem ustalaj¹cym
jego wynik). Jak widaæ, w klasie Executors mamy statyczne metody
"zamieniaj¹ce" Runnable na Callable (w FutureTask brakuje konstruktora
w postaci: &nbsp;FutureTask(Runnable), który móg³by
skorzystaæ ze statycznej metody klasy Executors&nbsp;
Callable&lt;Object&gt; callable(Runnable), która po prosto
przyjmuje, ¿e wynikiem call z wynikowego Callable jest null).<br>






<br>






No i teraz mo¿emy zrobiæ tak:<br>






<pre>Runnable r = new Runnable() {
  public void run() {
    // ...
  }
};

Callable&lt;String&gt; c = new Callable&lt;String&gt;() {
   public String call() throws&nbsp;Exception {
     String result;
     // ...
     return result;
   }
};


FutureTask&lt;Boolean&gt; task1 = new FutureTask&lt;Boolean&gt;(r, true);
FutureTask&lt;Object&gt; task2 = new FutureTask&lt;?&gt;(Executors.callable(r));
FutureTask&lt;String&gt; task3 = new FutureTask&lt;String&gt;(c);

Executor exec = Executors.new....();&nbsp;&nbsp;

exec.execute(task1);
exec.execute(task1);
exec.execute(task2);</pre>






<br>


Co wiêcej, wcale nie trzeba tworzyæ samodzielnie obiektów FutureTask.<br>






Interfejs ExecutorService zawiera trzy metody submit(...), które tworz¹ - i zwracaj¹ - dla nas Future.<br>






<br>






<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">






  <tbody>






    <tr class="TableRowColor" bgcolor="white">






      <td align="right" valign="top" width="1%"><font size="-1">






      <table summary="" border="0" cellpadding="0" cellspacing="0">






        <tbody>






          <tr align="right" valign="">






            <td nowrap="nowrap"><font size="-1">
            <code>&lt;</code></font>T&gt; Future&lt;T<font size="-1"><code>&gt;</code></font></td>







          </tr>













        </tbody>






      </table>







      </font></td>







      <td><code><b>submit</b>(Callable&lt;T&gt;&nbsp;task)</code>

      <br>







&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Submits a value-returning task for execution and returns a Future
 representing the pending results of the task.</td>







    </tr>







    <tr class="TableRowColor" bgcolor="white">







      <td align="right" valign="top" width="1%">
      &nbsp;Future&lt;?&gt;</td>







      <td><code><b>submit</b>(Runnable&nbsp;task)</code>

      <br>







&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Submits a Runnable task for execution and returns a Future
 representing that task.</td>







    </tr>







    <tr class="TableRowColor" bgcolor="white">







      <td align="right" valign="top" width="1%"><font size="-1">
      <code>
      </code>



      </font><font size="-1">


      <table summary="" border="0" cellpadding="0" cellspacing="0">







        <tbody>






          <tr align="right" valign="">







            <td nowrap="nowrap">
            &lt;T&gt; Future&lt;<font size="-1"><code>T&gt;</code></font></td>







          </tr>













        </tbody>






      </table>







      </font></td>







      <td><code><b>submit</b>(Runnable&nbsp;task,
       T&nbsp;result)</code>

      <br>







&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Submits a Runnable task for execution and returns a Future
 representing that task that will upon completion return
 the given result</td>






    </tr>












  </tbody>
</table>






<br>






Czyli w poprzednim przyk³adzie moglibyœmy napisaæ:<br>






<br>






<pre>ExecutorService exec = Executors.new....();&nbsp;&nbsp;

Future&lt;Boolean&gt; future1 = exec.submit(task1, true);
Future&lt;Object&gt; future2 = exec.submit(task1);
Future&lt;String&gt; future3 = exec.submit(task2);</pre>






Konkretna implementacja submit w klasie AbstractExecutorService
(któr¹ dziedziczy ThreadPoolExecutor zwracany przez
Executors.new....() wygl¹da mniej wiêcej tak:<br>






<br>






<pre>/*
 * @author Doug Lea
 */
public abstract class AbstractExecutorService implements ExecutorService {

    public Future&lt;?&gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        FutureTask&lt;Object&gt; ftask = new FutureTask&lt;Object&gt;(task, null);
        execute(ftask);
        return ftask;
    }

    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        FutureTask&lt;T&gt; ftask = new FutureTask&lt;T&gt;(task, result);
        execute(ftask);
        return ftask;
    }

    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {
        if (task == null) throw new NullPointerException();
        FutureTask&lt;T&gt; ftask = new FutureTask&lt;T&gt;(task);
        execute(ftask);
        return ftask;
    }

// ...
}
</pre>






<span style="font-style: italic;">Fragment na podstawie ¿róde³ klasy FutureTask (SunMicrosystem 2005).</span><br>


<br>


Rozwa¿my przyk³ad:<br>






<br>






<pre>import javax.swing.*;
import java.awt.event.*;
import java.util.List;
import java.util.concurrent.*;
import java.lang.reflect.*;

public class Exec1 extends JFrame implements ActionListener {

  int k = 0;
  int n = 15;
  JTextArea ta = new JTextArea(40,20);

  Exec1() {
    add(new JScrollPane(ta));
    JPanel p = new JPanel();
    JButton b = new JButton("Start");
    b.addActionListener(this);
    p.add(b);
    b = new JButton("Stop current");
    b.setActionCommand("Stop");
    b.addActionListener(this);
    p.add(b);
    b = new JButton("Curent result");
    b.setActionCommand("Result");
    b.addActionListener(this);
    p.add(b);
    b = new JButton("Shutdown");
    b.addActionListener(this);
    p.add(b);
    b = new JButton("ShutdownNow");
    b.addActionListener(this);
    p.add(b);
    add(p, "South");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    pack();
    setVisible(true);
  }

  public void actionPerformed(ActionEvent e)  {
    String cmd = e.getActionCommand();
    try {
      Method m = this.getClass().getDeclaredMethod("task"+cmd);
      m.invoke(this);
    } catch(Exception exc) { exc.printStackTrace(); }
  }


  class SumTask implements Callable&lt;Integer&gt; {

    private int taskNum,
                limit;

    public SumTask(int taskNum, int limit) {
      this.taskNum = taskNum;
      this.limit = limit;
    }

    public Integer call() throws Exception {
      int sum = 0;
      for (int i = 1; i &lt;= limit; i++) {
        if (Thread.currentThread().isInterrupted()) return null;
        sum+=i;
        ta.append("Task " + taskNum + " part result = " + sum + '\n');
        Thread.sleep(1000);
      }
      return sum;
    }
  };

  Future&lt;Integer&gt; task;

  //ExecutorService exec = Executors.newSingleThreadExecutor();
  ExecutorService exec = Executors.newFixedThreadPool(3);

  public void taskStart() {
    try {
      task = exec.submit(new SumTask(++k, 15));
    } catch(RejectedExecutionException exc) {
        ta.append("Execution rejected\n");
        return;
    }
    ta.append("Task " + k + " submitted\n");
  }

  public void taskResult() {
    String msg = "";
    if (task.isCancelled()) msg = "Task cancelled.";
    else if (task.isDone()) {
      try {
        msg = "Ready. Result = " + task.get();
      } catch(Exception exc) {
          msg = exc.getMessage();
      }
    }
    else msg = "Task is running or waiting for execution";
    JOptionPane.showMessageDialog(null, msg);
  }

  public void taskStop() {
    task.cancel(true);
  }

  public void taskShutdown() {
    exec.shutdown();
    ta.append("Executor shutdown\n");
  }

  public void taskShutdownNow() {
    List&lt;Runnable&gt; awaiting = exec.shutdownNow();
    ta.append("Eeecutor shutdown now - awaiting tasks:\n");
    for (Runnable r : awaiting) {
      ta.append(r.getClass().getName()+'\n');
    }

 }


  public static void main(String[] args) {
     new Exec1();
  }

}</pre>






<br>






Uwagi:<br>






<ol><li style="font-style: italic;">warto zaobserwowaæ, ¿e w call() nie musimy obs³ugiwaæ wyj¹tku InterruptedException przy sleep (throws Exception)</li><li style="font-style: italic;">jednak pisz¹c kody zadañ nie mo¿emy pozbyæ siê &nbsp;myœlenia w kategoriach w¹tków (isInterrupted(), sleep)</li><li><span style="font-style: italic;">shutdownNow zwraca listê zadañ
oczekuj¹cych na wykonanie w momencie zamkniêcia serwisu - to s¹
ogólnie Runnable, ale poniewa¿ zosta³y przekazane do wykonania jako FutureTasks - prawdziw¹ klas¹ jest FutureTask</span>.</li></ol>
<br>
<hr>

<a name="Wykonawcy.6"></a><h2>6. Obs³uga wyników zadañ za pomoc¹ odwo³añ zwrotnych</h2>







Bezpoœrednia konstrukcja (za pomoc¹ konstruktorów klasy) zadañ
jako FutureTask ma pewn¹ zaletê wobec submit(Callable) czy
submit(Runnable):&nbsp; <span style="font-weight: bold;">w ³atwy sposób mo¿emy dostarczaæ <!---->odwo³añ &nbsp;zwrotnych (callback) reaguj¹cych na zakoñczenie zadania<!---->.</span><br>




<br>




Klasa FutureTask dostarcza bowiem&nbsp;chronionej metody done(), która jest wywo³ywana po zakoñczeniu zadania.<br>






<br>






Mo¿na zrobiæ nawet tak:<br>






<br>






<pre>Callable&lt;Integer&gt; callable = ...;
ExecutorService exec = Executors.new...();
exec.execute( new FutureTask&lt;Integer&gt;(callable) {
    public void done() {
      // kod bêdzie wywo³any, gdy zadanie siê zakoñczy lub zostanie anulowane
    }
});
</pre>






Przyk³ad:<br>






<br>






<pre>import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.concurrent.*;


class  FutureTaskCallback&lt;V&gt; extends  FutureTask&lt;V&gt; {

  public FutureTaskCallback(Callable&lt;V&gt; callable) {
    super(callable);
  }

  public void done() {
    String result = "Wynik: ";
    if (isCancelled()) result += "Cancelled.";
    else try {
      result += get();
    } catch(Exception exc) {
        result += exc.toString();
    }
    JOptionPane.showMessageDialog(null, result);
  }

}


public class SimpleCallback extends JFrame {

  JTextField input = new JTextField(40),
             progress = new JTextField(40);

  String toReverse;

  Callable&lt;String&gt; reverseTask = new Callable&lt;String&gt;() {
    public String call() throws Exception {
      Thread t = Thread.currentThread();
      if (toReverse == null || toReverse.trim().equals(""))
        throw new IllegalArgumentException("Set string to reverse");
      if (t.isInterrupted()) return null;
      char[] org = toReverse.toCharArray();
      StringBuffer out = new StringBuffer();
      if (t.isInterrupted()) return null;
      for (int i = org.length-1; i&gt;=0; i--) {
        Thread.sleep(500);
        out.append(org[i]);
        if (t.isInterrupted()) return null;
        progress.setText(out.toString());
        if (t.isInterrupted()) return null;
      }
      return out.toString();
    }
  };

  ExecutorService exec = Executors.newSingleThreadExecutor();
  FutureTaskCallback&lt;String&gt; ft;


  public SimpleCallback() {
    Font f = new Font("Dialog", Font.PLAIN, 16);
    input.setFont(f);
    progress.setFont(f);
    JPanel p = new JPanel();
    JButton b = new JButton("Start");
    b.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        ft = new FutureTaskCallback&lt;String&gt;(reverseTask);
        toReverse = input.getText();
        exec.execute(ft);
      }
    });
    p.add(b);
    b = new JButton("Stop");
    b.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        if (ft != null) ft.cancel(true);
      }
    });
    p.add(b);
    Container cp = getContentPane();
    cp.setLayout(new BoxLayout(cp, BoxLayout.Y_AXIS));
    add(input);
    add(p);
    add(progress);
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    pack();
    setVisible(true);
  }

  public static void main(String[] args) {
     SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        new SimpleCallback();
      }
    });
  }

}</pre>
<br>
<br><br>
Rozwa¿my nieco bardziej uniwersalny i zaawansowany przyk³ad
dostarczenia asynchronicznej obs³ugi wyników zadañ.
Umówimy siê, ¿e metoda obs³ugi (dowolna metoda dowolnej klasy)
otrzymuje jako argumenty - wynik zadania oraz ew. wyj¹tek. Jeœli
wyj¹tek nie powsta³ (nie by³o ani CancellationException, ani
ExecutionException) - to ten drugi argument ma wartoœæ&nbsp;null. Jeœli zaœ powsta³ - to piewrszy argument ma wartoœæ null.<br>






<br>






Klasa Ftask dziedziczy FutureTask i przedefiniowuje metodê done w której wywo³uje metodê obs³ugi.<br>






<br>






<pre>import java.lang.reflect.Method;
import java.util.concurrent.*;

public class Ftask&lt;V&gt; extends FutureTask&lt;V&gt; {

  private Method handlerMethod;
  private Object handlerObject;

  public Ftask(Callable&lt;V&gt; callable, Object handler, String mname) throws Exception {
    super(callable);
    handlerObject = handler;
    handlerMethod = handler.getClass().getDeclaredMethod(mname, Object.class, Exception.class);
  }

  public void done() {
    V result = null;
    try {
      result = (V) this.get();
    } catch(Exception exc) {
      try {
        handlerMethod.invoke(handlerObject, null, exc);
      } catch(Exception ex) {
          ex.printStackTrace();
      }
      return;
    }
    try {
      handlerMethod.invoke(handlerObject, result, null);
    } catch(Exception exc) {
      exc.printStackTrace();
  }
}</pre>






<br>






Wprowadzimy te¿ klasê abstrakcyjnego zadania, która - dla
konkretnych instancjacji poprzez dziedziczenie - wymaga tylko
implementacji metody call():<br>






<br>






<pre>public abstract class AbstractTask&lt;V&gt; implements Callable&lt;V&gt; {

  private String   name;
  private FutureTask&lt;V&gt; task;

  public AbstractTask(String name, Object resultHandler, String handlerMethodName) throws Exception {
    this.name = name;
    task = new Ftask&lt;V&gt;(this, resultHandler, handlerMethodName);
  }

  public FutureTask&lt;V&gt; getTask() { return task; }
  public String getName() { return name; }

}</pre>






<br>






Teraz mo¿emy ich u¿yæ np. tak:<br>






<pre>class ResultHandler&lt;V&gt; {

  int x = 400, y = 50;
  public void handleResult(V result, Exception exc) {
    String msg;
    if (exc != null) msg = exc.toString();
    else msg = "Wynik = " + result;
    JFrame f = new JFrame("Task results");
    JLabel lab = new JLabel("        " + msg);
    f.add(lab);
    f.setBounds(x, y, 300, 100);
    f.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    x+=50;
    y+=50;
    f.setVisible(true);

  }
}</pre>






<pre>  class SumTaskA extends AbstractTask&lt;Integer&gt; {

    public SumTaskA(String taskName, ResultHandler h, String handlerMethod )
                 throws Exception
    {
      super(taskName, h, handlerMethod);
    }

    public Integer call() throws Exception {
      Future&lt;Integer&gt; task = this.getTask();
      int sum = 0;
      if (task.isCancelled()) return null;
      for (int i = 1; i &lt;= 10; i++) {
        if (task.isCancelled()) break;
        sum+=i;
        append(getName() + " part result = " + sum + '\n');
        Thread.sleep(1000);
      }
      return sum;
    }
  };


  ExecutorService exec = Executors.newFixedThreadPool(3);
  ResultHandler&lt;Integer&gt; handler = new ResultHandler&lt;Integer&gt;();
  SumTaskA task = new SumTaskA("Task 1", handler, "handleResults")
  exec.execute(task.getTask());
</pre>






<br>






Zwrócmy uwagê, ¿e wprowadzaj¹c AbstractTask (jako implementuj¹c¹
Callable i zawieraj¹c¹ Future przez kompozycjê) uzyskaliœmy mo¿liwoœæ
dostarczania takich implementacji metody call(), w której
rozumowanie w kategoriach w¹tków ograniczone jest do minimum,
np. zamiast pobieraæ bie¿¹cy w¹tek i sprawdzaæ czy jest Interrupted -
mo¿emy zastosowaæ metodê isCancelled().<br>




<br>




<br>






<div class="important"><span style="color: rgb(204, 27, 64); font-weight: bold;">Uwaga</span>:
FutureTask mo¿e znajdowaæ siê w czterech stanach: inicjalnym
(0), RUNNING (1) , RAN (2), CANCELLED(4). Po zakoñczeniu znajduje siê w
stanie RAN lub CANCELLED i nie mo¿e byæ ponownie uruchomione przez tego
samego Wykonawcê. </div><br>


<br>




Przyk³ad:<br>




<pre>import java.util.List;
import java.util.concurrent.*;

public class RepeatedTaskTest {

  FutureTask&lt;Object&gt; task = new FutureTask&lt;Object&gt;( new Callable&lt;Object&gt;() {
                                      public Object call() {
                                        for (int i= 1; i &lt;= 3; i++) {
                                          System.out.println(i);

                                        }
                                        return null;
                                      }
                                   }) {
           public void done() {
             System.out.println("Done.");
           }
  };

  public RepeatedTaskTest() {
    ExecutorService exec = Executors.newSingleThreadExecutor();
    System.out.println("Starting first task");
    exec.execute(task);
    try {
      System.out.println("Starting second task");
      exec.execute(task);
      Thread.sleep(5000);
    } catch(Exception exc) {
      exc.printStackTrace();
    }
    System.out.println("Executor shutdown now");
    List&lt;Runnable&gt; awaiting = exec.shutdownNow();
    for (Runnable r : awaiting) {
      System.out.println(r.getClass().getName()+'\n');
    }
    try {
      exec.awaitTermination(5, TimeUnit.SECONDS);
    } catch(InterruptedException exc) { exc.printStackTrace(); }

  }


  public static void main(String[] args) {
    new RepeatedTaskTest();
  }  </pre>




Program wyprowadzi:<br>




<div class="listing100"><br>




Starting first task<br>




Starting second task<br>




1<br>




2<br>




3<br>




Done.<br>




Executor shutdown now</div><br>


<br>


Drugie zadanie w ogóle siê nie wykona³o i nie powsta³ ¿aden wyj¹tek!<br>




<br>




Logika jest taka - jest tylko jedno zadanie. Ono siê wykona³o.
Wykonawca nie wykonuje ju¿ wykonanych zadañ. Wynik jest gotowy - ca³y
czas mo¿emy po niego siêgaæ. Nie ma ¿adnego wyj¹tku, bo wszystko jest w
porz¹dku - zadanie zosta³o wykonane.<br><br><br>
<br>
<hr>

<a name="Wykonawcy.7"></a><h2>7. Wykonawcy a pule w¹tków</h2>



<br>




Przyjrzyjmy siê teraz bli¿ej Wykonawcom. Ich klasy dostarczaj¹ doœæ rozbudowanych mo¿liwoœci. <br>




Interfejs ExecutorService zawiera kilku dodatkowych - nie znanych nam
jeszcze - metod, &nbsp;pod&nbsp; has³em "przekazywania do wykonania kolekcji
zadañ i uzyskiwania dostêpu do ich wyników":<br>




<br>




<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%">




  <tbody>




    <tr class="TableRowColor" bgcolor="white">




      <td align="right" valign="top" width="1%">




      <table summary="" border="0" cellpadding="0" cellspacing="0">




        <tbody>




          <tr align="right" valign="">




            <td nowrap="nowrap">
            &lt;T&gt; List&lt;Future&lt;T&gt;&gt;</td>





          </tr>









        </tbody>




      </table>





      </td>





      <td>invokeAll(Collection&lt;Callable&lt;T&gt;&gt;&nbsp;tasks)

      <br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the given tasks, returning a list of Futures holding
 their status and results when all complete.</td>





    </tr>





    <tr class="TableRowColor" bgcolor="white">





      <td align="right" valign="top" width="1%"><font size="-1">
      <code>
      </code>

      </font>


      <table summary="" border="0" cellpadding="0" cellspacing="0">





        <tbody>




          <tr align="right" valign="">





            <td nowrap="nowrap">
            &lt;T&gt; List&lt;Future&lt;T&gt;&gt;</td>





          </tr>









        </tbody>




      </table>





      </td>





      <td>invokeAll(Collection&lt;Callable&lt;T&gt;&gt;&nbsp;tasks,
          long&nbsp;timeout,
          TimeUnit&nbsp;unit)

      <br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the given tasks, returning a list of Futures holding
 their status and results
 when all complete or the timeout expires, whichever happens first.</td>





    </tr>





    <tr class="TableRowColor" bgcolor="white">





      <td align="right" valign="top" width="1%"><font size="-1">
      <code>
      </code>

      </font>


      <table summary="" border="0" cellpadding="0" cellspacing="0">





        <tbody>




          <tr align="right" valign="">





            <td nowrap="nowrap">
            &lt;T&gt; T</td>





          </tr>









        </tbody>




      </table>





      </td>





      <td>invokeAny(Collection&lt;Callable&lt;T&gt;&gt;&nbsp;tasks)

      <br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the given tasks, returning the result
 of one that has completed successfully (i.e., without throwing
 an exception), if any do. Pozosta³e zadania s¹ anulowane.</td>





    </tr>





    <tr class="TableRowColor" bgcolor="white">





      <td align="right" valign="top" width="1%"><font size="-1">
      <code>
      </code>

      </font>


      <table summary="" border="0" cellpadding="0" cellspacing="0">





        <tbody>




          <tr align="right" valign="">





            <td nowrap="nowrap">
            &lt;T&gt; T</td>





          </tr>









        </tbody>




      </table>





      </td>





      <td>invokeAny(Collection&lt;Callable&lt;T&gt;&gt;&nbsp;tasks,
          long&nbsp;timeout,
          TimeUnit&nbsp;unit)

      <br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes the given tasks, returning the result
 of one that has completed successfully (i.e., without throwing
 an exception), if any do before the given timeout elapses. Pozosta³ê zadania s¹ anulowane.</td>




    </tr>








  </tbody>
</table>




<br>




Zwrócmy uwagê, ¿e te odwo³ania s¹ blokuj¹ce - czekaj¹ na zakoñczenie&nbsp;zadañ (normalne - lub przez wyj¹tek).<br>




<br>




Przyk³ad:<br>




<br>




<pre>import java.util.concurrent.*;
import java.util.*;

class Eval implements Callable&lt;Integer&gt; {

  Integer num;

  public Eval(int n) {
    num = n;
  }

  public Integer call() throws Exception {
    Thread.sleep(1000);
    return num;
  }

}

public class InvokeTest {

  public static int sum(ExecutorService exec, List&lt;Callable&lt;Integer&gt;&gt; tasks) throws Exception {
    long start = System.currentTimeMillis();
    System.out.println("Start");
    List&lt;Future&lt;Integer&gt;&gt; results =  exec.invokeAll(tasks);  // InterruptedException
    long elapsed = System.currentTimeMillis() - start;
    System.out.println("End after " + elapsed/1000 + " sec.");
    int sum = 0;
    for (Future&lt;Integer&gt; r : results) sum += r.get();
    return sum;
  }

  public static void main(String[] args) {
    List&lt;Callable&lt;Integer&gt;&gt; taskList = new ArrayList&lt;Callable&lt;Integer&gt;&gt;();
    ExecutorService exec = Executors.newFixedThreadPool(10);
    for (int i=1; i &lt;=5; i++) {
      Callable&lt;Integer&gt; task = new Eval(i);
      taskList.add(task);
    }
    try {
      int result = sum(exec, taskList);
      System.out.println("Wynik: " + result);
    } catch(Exception exc) { exc.printStackTrace(); }
  }

}</pre>




&nbsp;<br>




Ale czym naprawdê s¹ Wykonawcy? <br>




Metody fabryczne klasy Executors tworz¹ dla nas wykonawcaów jako obiekty klasy ThreadPoolExecutor.<br>




Klasa zajmuje siê dynamicznym tworzeniem w¹tków (które
bêd¹ przydzielane do wykonania zadañ) i prowadzeniem ich puli -
zsynchronizowanej, blokuj¹cej kolejki w¹tków.<br>




<br>




Pula w¹tków charakteryzuje siê nastêpuj¹cymi parametrami:<br>




<br>


<ul><li>

poolCoreSize, </li><li>

poolMaximumSize, </li><li>

keepAliveTime, </li><li>

threadFactory, </li><li>

workQueue</li></ul>




które mo¿na ustalaæ w konstruktorze, pobieraæ za pomoc¹ metod
get.. i (niektóre) zmieniaæ w trakcie dzia³ania programu za
pomoc¹ metod set...<br>




<br>




Znaczenie tych parametrów jest nastêpuj¹ce.<br>




<span style="text-decoration: underline;"></span><br>




Niech n oznacza aktualn¹ liczbê w¹tków w puli (niektóre
mog¹ byæ nieaktywne) i niech zlecane jest nowe zadanie do wykonania
(exec()).<br>




<ul><li>gdy n &lt; poolCoreSize, to jest tworzony nowy w¹tek, nawet wtedy, gdy w puli s¹ nieaktywne w¹tki (a zatem zadanie,</li><li>gdy poolCoreSize &lt; n &lt; maximumPoolSize, to nowy w¹tek jest
tworzony tylko wtedy, gdy kolejka zadañ jest pe³na, jeœli nie jest
wype³niona, to zadanie jest dodawane do kolejki, a w¹tek nie jest
tworzony (bo byæ mo¿e bêdzie mo¿na ponownie u¿yæ innego),</li><li>w¹tki od 1 do poolCoreSize s¹ normalnie tworzone tylko "na
¿yczenie" (gdy przychodzi zadanie), mo¿na jednak utworzyæ &nbsp;te
w¹tki metod¹ prestartCoreThread lub prestartAllCoreThreads,</li><li>keepAliveTime okreœla okres czasu utrzymywania w puli
nieaktywnych w¹tków: nieaktywne w¹tki s¹ usuwane z puli, ale
tylko wtedy, gdy n &gt; corePoolSize (w przeciwnym razie nieaktywne nie
s¹ usuwane),</li><li><span style="text-decoration: underline;"></span>nowe w¹tki tworzone s¹ metodami fabrycznymi ThreadFactory; normalnie DefaultThreadFactory, ale mo¿na podaæ w³asn¹,</li><li>workQuee jest u¿ywane jako kolejka zadañ do wykonania <span style="font-weight: bold;">(czekaj¹cych!)</span> i musi implementowaæ interfejs BlockingQueue&lt;Runnable&gt;; standardowo jest to klasa LinkedBlockingQueue&lt;Runnable&gt;.</li></ul>




Co zwracaj¹ fabryczne metody klasy Executors?<br>




<br>


Widaæ to wyraŸnie na wyci¹gu z kodu Ÿród³owego:<br>




<pre>    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;());
    }

    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&lt;Runnable&gt;(),
                                      threadFactory);
    }

    public static ExecutorService newSingleThreadExecutor() {
        return new DelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;()));
    }

    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new DelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&lt;Runnable&gt;(),
                                    threadFactory));
    }

    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;());
    }

    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&lt;Runnable&gt;(),
                                      threadFactory);
</pre>




ród³o: kod JDK, Sun Microsystem<br>


<br>


Przyk³ad:<br>




<br>




<pre>import java.awt.*;
import java.awt.event.*;
import java.util.concurrent.*;
import javax.swing.*;
import java.lang.reflect.*;


class Code implements Callable&lt;Integer&gt; {

  String name;
  int num;

  public Code(String n, int sleep) {
     name = n;
     num = sleep;
  }

  public Integer call() throws Exception {
    Thread.sleep(num*1000);
    return num;
  }

  public String getName() { return name; }
}


class Task extends FutureTask&lt;Integer&gt; {
  Code code;

  public Task(Code c) {
    super(c);
    code = c;
  }

  public String getName() {
    return code.getName();
  }
}



public class ThreadPoolMethods extends JFrame implements ActionListener {

  ThreadPoolExecutor exec = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);

  public ThreadPoolMethods() {
    setLayout(new FlowLayout());
    JButton b = new JButton("Start");
    b.addActionListener(this);
    add(b);
    b = new JButton("Show");
    b.addActionListener(this);
    add(b);
    pack();
    setVisible(true);
  }

  public void actionPerformed(ActionEvent e) {
    String cmd = e.getActionCommand();
    if (cmd.equals("Start")) {
      int sleep = 5, step = 3;
      for (int k=1; k &lt;= 10; k++) {
        sleep += step;
        exec.execute(new Task(new Code("Task " + k, sleep)));
      }
      System.out.println("All tasks submitted");
    }
    else {
      try {
        printStat();
      } catch(Exception exc) { exc.printStackTrace(); }
      BlockingQueue&lt;Runnable&gt; que = exec.getQueue();
      System.out.println("Que size " + que.size());
      for (Runnable r : que) {
        Task t = (Task) r;
        System.out.println(t.getName());
      }
    }
  }

  void printStat() throws Exception {
    Method[] mets = ThreadPoolExecutor.class.getDeclaredMethods();
    for (Method m : mets) {
      String name = m.getName();
      if (name.startsWith("get")) {
        Object res = null;
        try {
          res = m.invoke(exec);
        } catch(Exception exc) {
          System.out.println("Unable to call " + name);
        }
        System.out.println(name + " = " + res);
      }
    }
  }

  public static void main(String[] args) {
    new ThreadPoolMethods();
  }
}</pre>




<br>




Wydruk:<br>



<div class="listing100"><br>



All tasks submitted<br>



getQueue = [exec3.Task@ee22f7, exec3.Task@39ab89, exec3.Task@2cb49d,
exec3.Task@105d88a, exec3.Task@cb6009, exec3.Task@e28b9,
exec3.Task@193a66f, exec3.Task@93d6bc]<br>



getActiveCount = 2<br>



getCompletedTaskCount = 0<br>



getCorePoolSize = 2<br>



Unable to call getKeepAliveTime<br>



getKeepAliveTime = null<br>



getLargestPoolSize = 2<br>



getMaximumPoolSize = 2<br>



getPoolSize = 2<br>



getRejectedExecutionHandler = java.util.concurrent.ThreadPoolExecutor$AbortPolicy@be0e27<br>



Unable to call getTask<br>



getTask = null<br>



getTaskCount = 10<br>



getThreadFactory = java.util.concurrent.Executors$DefaultThreadFactory@193385d<br>



<span style="font-weight: bold;"></span>Que size 8<br>



Task 3<br>



Task 4<br>



Task 5<br>



Task 6<br>



Task 7<br>



Task 8<br>



Task 9<br>



Task 10<br>



<br>



<span style="font-weight: bold;">&nbsp;i po kilku sekundach</span><br>



<br>



getQueue = [exec3.Task@2cb49d, exec3.Task@105d88a, exec3.Task@cb6009, exec3.Task@e28b9, exec3.Task@193a66f, exec3.Task@93d6bc]<br>



getActiveCount = 2<br>



getCompletedTaskCount = 2<br>



getCorePoolSize = 2<br>



Unable to call getKeepAliveTime<br>



getKeepAliveTime = null<br>



getLargestPoolSize = 2<br>



getMaximumPoolSize = 2<br>



getPoolSize = 2<br>



getRejectedExecutionHandler = java.util.concurrent.ThreadPoolExecutor$AbortPolicy@be0e27<br>



Unable to call getTask<br>



getTask = null<br>



getTaskCount = 10<br>



getThreadFactory = java.util.concurrent.Executors$DefaultThreadFactory@193385d<br>



Que size 6<br>



Task 5<br>



Task 6<br>



Task 7<br>



Task 8<br>



Task 9<br>



Task 10<br>



</div><br>



<br>



<br>


W pakiecie java.util.concurrent dostêpne s¹ te¿ klasy
wykonawców, zapewniaj¹cych wykonanie zadañ w sposób
rytmiczny &nbsp;b¹dŸ&nbsp; z podanym opóŸnieniem.<br>


<span style="font-weight: bold;">

Proszê zobaczyæ dokumentacjê.</span><br>



<br>
<hr>

<a name="Wykonawcy.8"></a><h2>8. Zadania i wykonawcy - podsumowanie</h2>

W podsumowaniu - rysunek, pokazuj¹cy powi¹zania pomiêdzy klasami i interfejsami.<br>


<br>


<img style="width: 622px; height: 562px;" alt="r" src="images/concur1.gif"><br>


<br>


<br>


I niektóre wnioski:<br>








<ul><li><span style="font-weight: bold;">Callable nie jest Runnable</span>
- nie nale¿y o nim myœleæ jako o maj¹cym zwi¹zek z Runnable, jest
raczej jego zamiennikiem - w tym sensie, ¿e to takie "Runnable co ma
wynik",</li><li>zadanie <span style="font-weight: bold;">(<span style="font-style: italic;">task</span>) mo¿e byæ Callable lub Runnable</span> (ale&nbsp;w przypadku<span style="font-weight: bold;"> Callable</span> to jest <span style="font-weight: bold;">kompozycja</span>!),</li><li><span style="font-weight: bold;">Future&nbsp;&nbsp;</span>(w szczególnoœci <span style="font-weight: bold;">FutureTask</span>, które <span style="font-weight: bold;">jest Runnable</span>!) mo¿emy: odpytywaæ o stan wykonania, zabijaæ lub te¿ pobieraæ wynik,</li><li><span style="font-weight: bold;">wykonawcom mo¿na podaæ</span> Callable, ale i Runnable (i w szczególnoœci <span style="font-weight: bold;">FutureTask</span>, co daje nam w ka¿dym przypadku kolekcjê w pe³ni zarz¹dzanych zadañ!),</li><li>jeszcze raz: <span style="font-weight: bold;">FutureTask jest Runnable</span>, a w zwi¹zku z tym mo¿e byæ argumentem metody submit Execut-orów,</li><li><span style="font-weight: bold;">FutureTask</span> po wykonaniu (lub przerwaniu) wo³a metodê <span style="font-weight: bold;">done()</span>. Dobre miejsce na handlery wyników!</li><li><span style="font-weight: bold;">ThreadPool</span>
ExecutorService po otrzymaniu zadañ do wykonania przez submit (nie wa¿ne czy
Callable czy Runnable) zwraca &nbsp;FutureTask. Bez specjalnego
tworzenia&nbsp;(obiektów typu Future) mo¿e tu byæ i cancel i
odpytywanie o koniec zadania!</li></ul>
<hr>

</body>
</html>