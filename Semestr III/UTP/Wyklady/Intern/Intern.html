<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="Uniwersalne techniki programowania">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2010">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Internacjonalizacja aplikacji</title>
</head>
<body>
<br>
<br>
<div align="Center">
<h1>Internacjonalizacja aplikacji</h1>
</div>
<br>

</div>
<hr>
<span style="font-style: italic;">Programy powinny prezentowaæ wartoœci liczb, dat, czasu w okreœlonych formatach,
Formaty te zale¿¹ od &nbsp;kraju lub regionu (jêzyka u¿ywanego w kraju/regionie
oraz innych kulturowo utrwalonych regu³). Krótko mówi¹c zale¿¹ od </span><i style="font-style: italic;"><b>lokalizacji</b></i><span style="font-style: italic;">
. Równie¿ treœæ komunikatów wyœwietlanych przez program lub opisów
jakichœ
elementów GUI (a nawet ikon czy dŸwiêków u¿ywanych w programie) jest
zale¿na
od lokalizacji. Zatem - z jednej strony - programy powinny byæ
dostosowane
do konkretnych lokalizacji.&nbsp; Z drugiej strony czêsto powstaje
potrzeba przygotowania
programów w taki sposób, by - bez rekompilacji - mog³y dzia³aæ w
ró¿nych lokalizacjach.
Tym w³aœnie zagadnieniom - szczególnie istotnym w takich krajach jak
Polska
- poœwiêcony jest niniejszy rozdzia³. Równoczesnie&nbsp; warto
zaznaczyæ,
¿e tak¿e poza sfer¹ internacjonalizacji i bez specjalnego zajmowania
siê
ustawieniami ergionalnymi prezentowane tu narzêdzia stanowi¹ istotny
element
warstzatu programistycznego. Bez nich niemo¿liwe jest bowiem
odpowiednie
formatowanie liczb i operowanie na datach. We "Wprowadzeniu do
programowania (Java)" poznaliœmy sposoby wczytywania zlokalizowanych
liczb za pomoc¹ skanera i zlokalizowane formatowania liczb i dat za
pomoc¹ formatora. Tutaj przedstawione zostanie szerszyw achlarz œrodków
i narzêdzi lokalizacji i&nbsp; internacjonalizacji aplikacji. </span><br>
<hr>

<a name="Intern.1"></a><h2>1. Lokalizacje</h2>
 <div class="notel">W jêzyku angielskim okreslane jest to terminem
locale. Po polsku nie ma dobrego odpowiednika, u¿ywamy wiêc s³owa lokalizacja
zarówno w znaczeniu locale jak i &nbsp;dla okreœlenia sposobu oprogramowania aplikacji
w taki sposób, by dzia³a³a ona w³asciwie dla danych ustwieñ regionalnych</div>Specyficzne
dla danego jêzyka, regionu/kraju - regu³y, dotycz¹ce prezentacji ró¿nych
informacji (np.formatowania liczb i dat, pisowni tekstów, porz¹dku alfabetycznego)
nazwiemy lokalizacj¹. <br>
<br>
Do rozwi¹zywania zagadnieñ lokalizacyjnych s³u¿y w Javie ca³y zestaw klas
(skupiony przede wszystkim w pakiecie java.text, ale nie tylko). Zestaw ten
zosta³ opracowany przez firmê Taligent, wchodz¹c¹ w sk³ad koncernu
IBM i wdro¿ony przez Sun w Javie w wersji 1.1,&nbsp; Bez wiêkszych zmian przetrwa³
on w kolejnych wersjach Javy do dziœ, natomiast zespó³ &nbsp;lokalizacyjny z Taligent
przekszta³ci³ siê w Unicode group w IBM Globalization Center of Competency
w Cupertino i zaj¹³ siê doskonaleniam i rozwijaniem swojego pierwotnego produktu
oraz przenoszeniem go do jêzyków C++ i C, a wszystko na zasadach "open source".<br>
W efekcie powsta³a biblioteka o nazwie  International Components for Unicode,
obejmuj¹cy poszerzone wersje klas lokalizacyjno-internacjonalizacyjnych,&nbsp;
a tak¿e pewne dodatkowe klasy, których w standardzie Javy brak. Biblioteka
wdra¿a najnowsze standardy Unicode (w tej chwili Unicode 4.0) i&nbsp; jest dostêpna
w wersjach dla jêzyków Java (ICU4J), &nbsp;C++ i C (ICU4C) na stronie <a href="http://www.icu-project.org/">http://www.icu-project.org/</a><br>
<br>
Generalnie bêdziemy siê tu zajmowaæ standardowymi klasami Javy, gdzieniegdzie tylko przywo³uj¹c dodatki i rozszerzenia z ICU4J <br>
<br>
W Javie lokalizacje reprezentowane s¹ przez obiekty klasy <b>Locale</b> z pakietu java.util.<br>
<br>
<div class="syntax">Lokalizacja okreœlana jest przez kombinacjê:<br>
<ul>
  <li>kodu jêzyka, </li>
  <li>kodu kraju,</li>
  <li>kodu wariantu.</li>
</ul>
Kody te - wartoœci typu String -&nbsp; podajemy przy tworzeniu obiektu klasy Locale
jako argumenty konstruktora tej klasy, przy czym mamy do dyspozycji trzy
przeci¹¿one konstruktory:<br>
<table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr class="TableRowColor" bgcolor="white"><td>Locale(String&nbsp;language)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr class="TableRowColor" bgcolor="white"><td>Locale(String&nbsp;language,
       String&nbsp;country)</td></tr><tr class="TableRowColor" bgcolor="white"><td>Locale(String&nbsp;language,
       String&nbsp;country,
       String&nbsp;variant)</td></tr></tbody>
</table>
<br>
Kod jêzyka - to kombinacja dwóch ma³ych liter, okreœlaj¹ca jêzyk wg standardu
ISO-639 (zob dostêpne kody : http://www.ics.uci.edu/pub/ietf/http/related/iso639.txt)<br>
Kod kraju - to dwuliterowa kombinacja dwóch du¿ych liter, okreœlaj¹ca kraj
wg standardu ISO-3166 (http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html)<br>
Kod wariantu - jest dodatkow¹&nbsp; informacj¹, któr¹ mo¿emy dodaæ i która nie
musi spe³niaæ ¿adnych standardów, wobec czego jest specyficzna w danycyh warunkach (np. pakietu lokalizacyjnego) lub dla danej
aplikacji.<br>
</div><br>
<br>
Przyk³ady:<br>
<br>
Locale a = new Locale("en", "GB"); &nbsp;// jêzyk angielski, kraj Wielka Brytania <br>
Locale b = new Locale("en", "US"); &nbsp;// jêzyk angielski, kraj Stany Zjednoczone<br>
Locale c = new Locale("en"); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// jêzyk angielski, kraj nieokreœlony<br>
<br>
Locale d = new Locale("pl", "PL", "Zakopane");<br>
// Powy¿ej definiujemy wariant lokalizacyjny - "Zakopane"<br>
// jêzyk jest polski, kraj - Polska<br>
// ale dodatkowo nasza aplikacja mo¿e skorzystaæ ze zdefiniowanego wariantu<br>
// jednak tylko nasze programy bêd¹ wiedzia³y co z takim wariantem nale¿y robiæ<br>
// mo¿e np. wyœwietlaæ komunikaty w gwarze?<br>
 Uwaga: dla niektórych lokalizacji
w Javie s¹ okreœlone warianty. Np. tradycyjny Tajski, albo -&nbsp; w pakietach
ICU4J - dla krajów Europejskiej Unii Monetarnej&nbsp; warianty PREEURO (przed
wprowadzeniem euro).<br>
<br>
Obiekt klasy Locale okreœla lokalizacjê (czyli wspomniane wczeœniej regu³y), <br>
Zastosowanie tych regu³ - przy przetwarzaniu&nbsp; i formatowaniu informacji -
spoczywa na obiektach innych klas. Te klasy, które bior¹ pod uwagê wymagania
lokalizacyjne nazywaj¹ siê lokalizacyjnie-czu³ymi (locale-sensitive).<br>
<br>
Nale¿¹ do nich:<br>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
  <tbody>
    <tr>
      <td valign="top">
      <div align="center"><b>Klasa<br>
      </b></div>
      </td>
      <td valign="top">
      <div align="center"><b>Przeznaczenie<br>
      </b></div>
      </td>
    </tr>
    <tr>
      <td valign="top">NumberFormat (i pochodne)<br>
      </td>
      <td valign="top">Do formatowania i wczytywania liczb<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Calendar (i pochodne)<br>
      </td>
      <td valign="top">Do operowania na datach i czasie<br>
      </td>
    </tr>
    <tr>
      <td valign="top">DateFormat (i pochodne)<br>
      </td>
      <td valign="top">Do formatowania i wczytywania dat i czasu<br>
      </td>
    </tr>
    <tr>
      <td valign="top">Collator<br>
      </td>
      <td valign="top">Do okreœlania porz¹dku alfabetycznego<br>
      </td>
    </tr>
    <tr>
      <td valign="top">BreakIterator<br>
      </td>
      <td valign="top">Do zlokalizowanego rozbioru tekstu<br>
      </td>
    </tr><tr><td>Formatter</td><td>Do formatowania liczb i czasu (daty, czas)</td></tr><tr><td>Scanner</td><td>Do wczytywania liczb</td></tr>
  </tbody>
</table>
<br>
Ka¿dy program w Javie - przy uruchomieniu, na podstawie w³aœciwoœci ustalonych dla platformy systemowej&nbsp; - uzyskuje tzw. <b>domyœln¹ lokalizacjê</b>
. &nbsp;Mo¿emy siê dowiedzieæ jaka to jest lokalizacja za pomoc¹ odwo³ania Locale.getDefault()
i mo¿emy zmieniæ tê lokalizacjê u¿ywaj¹c metody Locale.setDefault(Locale).<br>
<br>
Aby przetwarzaæ informacje w &nbsp;zlokalizowanej formie pos³ugujemy siê obiektami
klas lokalizacyjnie-czu³ych. Dla zastosowania domyœlnych regu³ lokalizacyjnych
uzyskujemy te obiekty za pomoc¹ statycznych metod get...Instance() <b>bez argumentu, okreœlaj¹cego lokalizacjê</b>. W przypadku klas Scanner i Formatter (gdzie nie ma metody getInstance) u¿ywamy konstruktorów &nbsp;lub metod (<b>bez argumentu, okreœlaj¹cego lokalizacjê).</b> <br>
Np. kod na listingu pokazuje domyœln¹ lokalizacjê i zgodnie z t¹ lokalizacj¹
wypisuje bie¿¹c¹ datê&nbsp;oraz liczbê 1234567.1, przy czym w trakcie dzia³ania
zmienia domyœln¹ lokalizacjê i ponawia wyprowadzanie informacji.<br>
<pre>import java.text.*;
import java.util.*;

public class DefLok {

  static public void report() {
    Locale defLoc = Locale.getDefault();
    System.out.println("Domyœlna lokalizacja : " + defLoc);
    DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
    NumberFormat nf = NumberFormat.getInstance();
    System.out.println(df.format(new Date()));
    System.out.println(nf.format(1234567.1));
  }

  public static void main(String[] args) {
    report();
    Locale.setDefault(new Locale("en"));
    report();
  }

}
</pre>
&nbsp;Wydruk programu:<br>
<div class="listing100"><br>
Domyœlna lokalizacja : pl_PL<br>
12 lipiec 2003<br>
1_234_567,1<br>
Domyœlna lokalizacja : en<br>
July 12, 2003<br>
1,234,567.1<br>
</div><br>
<br>
Zwróæmy uwagê:<br>
<ul>
  <li>formaty dat i liczb dla ró¿nych lokalizacji ró¿ni¹ siê,</li>
  <li>zmiana domyœlnej lokalizacji dotyczy wszystkich klas lokalizacyjnie-czu³ych.&nbsp;</li>
</ul>
Klasy lokalizacyjnie-czu³e pozwalaj¹ równie¿ na uzyskiwanie ich
obiektów
przetwarzaj¹cych informacje w sposób wymagany przez konkretn¹ (nie
domyœln¹)
lokalizacjê, W tym celu u¿ywamy statycznych metod get...Instance(...)
lub w przypadku klas Scanner i Formattor konstruktorów lub metod z<span style="font-weight: bold;"> argumentem
typu Locale - okreœlaj¹cym konkretn¹ lokalizacjê. </span><br>
<br>
Np. poni¿szy program wyprowadz datê w lokalizacji domyœlnej, a liczbê - najpierw
w domyœlnej, a póŸniej zgodnej z jêzykiem angileskim.<br>
<pre>import java.text.*;
import java.util.*;

public class MiscLok {

  public static void main(String[] args) {
    System.out.println("Domyœlna lokalizacja : " + Locale.getDefault());
    DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);
    System.out.println(df.format(new Date()));
    double num = 123.4;
    NumberFormat nf = NumberFormat.getInstance();
    System.out.println("Liczba " + num +
                       " w lokalizacji domyœlnej: " + nf.format(num));
    nf = NumberFormat.getInstance(new Locale("en"));
    System.out.println("Liczba " + num +
                       " w lokalizacji angielskiej: " + nf.format(num));
  }

}
</pre>
<br>
<div class="listing100">Domyœlna lokalizacja : pl_PL<br>
12 lipiec 2003<br>
Liczba 123.4 w lokalizacji domyœlnej: 123,4<br>
Liczba 123.4 w lokalizacji angielskiej: 123.4<br>
</div><br>
Uwaga: liczby ró¿ni¹ siê separatorem miejsc dziesiêtnych (przecinek dla Polski, kropka dla krajów anglojêzycznych).<br>
<br>
Zatem mo¿emy - w trakcie dzia³ania programu - ustalaæ lokalizacje zarówno
ogólnie (dla wszystkich klas lokalizacyjnie-czu³ych), jak i dla ka¿dego konkretnego
obiektu tych klas.<br>
<br>
Jednak nie wszystkie mo¿liwe lokalizacje (okreœlone w standardzie ISO) s¹
przez Javê podtrzymywane (nie dla wszystkich zdefiniowano regu³y formatowania liczb i czasu
czy te¿&nbsp; traktowania tekstów).<br>
<br>
Dostêpne z poziomu Javy lokalizacje mo¿na uzyskaæ za pomoc¹ metod <b>Locale[] getAvailableLocales()</b>
, zdefiniowanych w klasach Locale oraz wszystkich klasach lokalizacyjnie-czu³ych.
Metody te zwracaj¹ tablice dostêpnych lokalizacji. Generalnie, bêd¹ to te
same zestawy lokalizacji.<br>
<br>
Poni¿szy program wypisuje wszystkie dostêpne lokalizacje.<br>
<br>
<pre>import java.util.*;
import java.text.*;

public class Lokal1 {

  public static void main(String[] args) {

    // Tablica dostêpnych lokalizacji

    Locale[] loc = Locale.getAvailableLocales();

    System.out.println("Kod jêzyka" + "#" +
                       "Kod kraju" + "#" +
                       "Kod wariantu" +  "#" +
                       "Jêzyk" + "#" +
                       "Kraj" +  "#" + "Wariant"
                      );

    for (int i=0; i&lt;loc.length; i++) {
      String countryCode = loc[i].getCountry();  // kod kraju
      String langCode = loc[i].getLanguage();    // kod jêzyka
      String varCode  = loc[i].getVariant();     // wariant

      // lokalizacja opisana w jêzyku domyœlnej lokalizacji (polskim)
      String kraj =  loc[i].getDisplayCountry();
      String jezyk = loc[i].getDisplayLanguage();
      String wariant = loc[i].getDisplayVariant();
      System.out.println(langCode + "#" +
                         countryCode +  "#" +
                         varCode + "#" +
                         jezyk + "#" + kraj + "#" + wariant);

     }
  }

}
</pre>
Uwaga: warto w tym programie zwróciæ uwagê na u¿ycie ró¿nych metod wobec obiektów klasy Locale.<br>
Wynik dzia³ania programy pokazuje tablica (bêd¹ca jednoczeœnie przewodnikeim po aktualnie dostêpnych w Javie lokalizacjach). <br>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td>Kod jêzyka</td><td>Kod kraju</td><td>Kod wariantu</td><td>Jêzyk</td><td>Kraj</td><td>Wariant</td></tr><tr><td>ar</td><td><br>
</td><td><br>
</td><td>arabski</td><td><br>
</td><td><br>
</td></tr><tr><td>ar</td><td>AE</td><td><br>
</td><td>arabski</td><td>Zjednoczone Emiraty Arabskie</td><td><br>
</td></tr><tr><td>ar</td><td>BH</td><td><br>
</td><td>arabski</td><td>Bahrajn</td><td><br>
</td></tr><tr><td>ar</td><td>DZ</td><td><br>
</td><td>arabski</td><td>Algeria</td><td><br>
</td></tr><tr><td>ar</td><td>EG</td><td><br>
</td><td>arabski</td><td>Egipt</td><td><br>
</td></tr><tr><td>ar</td><td>IQ</td><td><br>
</td><td>arabski</td><td>Irak</td><td><br>
</td></tr><tr><td>ar</td><td>JO</td><td><br>
</td><td>arabski</td><td>Jordan</td><td><br>
</td></tr><tr><td>ar</td><td>KW</td><td><br>
</td><td>arabski</td><td>Kuwejt</td><td><br>
</td></tr><tr><td>ar</td><td>LB</td><td><br>
</td><td>arabski</td><td>Liban</td><td><br>
</td></tr><tr><td>ar</td><td>LY</td><td><br>
</td><td>arabski</td><td>Libia</td><td><br>
</td></tr><tr><td>ar</td><td>MA</td><td><br>
</td><td>arabski</td><td>Maroko</td><td><br>
</td></tr><tr><td>ar</td><td>OM</td><td><br>
</td><td>arabski</td><td>Oman</td><td><br>
</td></tr><tr><td>ar</td><td>QA</td><td><br>
</td><td>arabski</td><td>Katar</td><td><br>
</td></tr><tr><td>ar</td><td>SA</td><td><br>
</td><td>arabski</td><td>Arabia Saudyjska</td><td><br>
</td></tr><tr><td>ar</td><td>SD</td><td><br>
</td><td>arabski</td><td>Sudan</td><td><br>
</td></tr><tr><td>ar</td><td>SY</td><td><br>
</td><td>arabski</td><td>Syria</td><td><br>
</td></tr><tr><td>ar</td><td>TN</td><td><br>
</td><td>arabski</td><td>Tunezja</td><td><br>
</td></tr><tr><td>ar</td><td>YE</td><td><br>
</td><td>arabski</td><td>Jemen</td><td><br>
</td></tr><tr><td>be</td><td><br>
</td><td><br>
</td><td>bia³oruski</td><td><br>
</td><td><br>
</td></tr><tr><td>be</td><td>BY</td><td><br>
</td><td>bia³oruski</td><td>Bia³oruœ</td><td><br>
</td></tr><tr><td>bg</td><td><br>
</td><td><br>
</td><td>bu³garski</td><td><br>
</td><td><br>
</td></tr><tr><td>bg</td><td>BG</td><td><br>
</td><td>bu³garski</td><td>Bu³garia</td><td><br>
</td></tr><tr><td>ca</td><td><br>
</td><td><br>
</td><td>kataloñski</td><td><br>
</td><td><br>
</td></tr><tr><td>ca</td><td>ES</td><td><br>
</td><td>kataloñski</td><td>Hiszpania</td><td><br>
</td></tr><tr><td>cs</td><td><br>
</td><td><br>
</td><td>czeski</td><td><br>
</td><td><br>
</td></tr><tr><td>cs</td><td>CZ</td><td><br>
</td><td>czeski</td><td>Republika Czeska</td><td><br>
</td></tr><tr><td>da</td><td><br>
</td><td><br>
</td><td>duñski</td><td><br>
</td><td><br>
</td></tr><tr><td>da</td><td>DK</td><td><br>
</td><td>duñski</td><td>Dania</td><td><br>
</td></tr><tr><td>de</td><td><br>
</td><td><br>
</td><td>niemiecki</td><td><br>
</td><td><br>
</td></tr><tr><td>de</td><td>AT</td><td><br>
</td><td>niemiecki</td><td>Austria</td><td><br>
</td></tr><tr><td>de</td><td>CH</td><td><br>
</td><td>niemiecki</td><td>Szwajcaria</td><td><br>
</td></tr><tr><td>de</td><td>DE</td><td><br>
</td><td>niemiecki</td><td>Niemcy</td><td><br>
</td></tr><tr><td>de</td><td>LU</td><td><br>
</td><td>niemiecki</td><td>Luksemburg</td><td><br>
</td></tr><tr><td>el</td><td><br>
</td><td><br>
</td><td>grecki</td><td><br>
</td><td><br>
</td></tr><tr><td>el</td><td>GR</td><td><br>
</td><td>grecki</td><td>Grecja</td><td><br>
</td></tr><tr><td>en</td><td>AU</td><td><br>
</td><td>angielski</td><td>Australia</td><td><br>
</td></tr><tr><td>en</td><td>CA</td><td><br>
</td><td>angielski</td><td>Kanada</td><td><br>
</td></tr><tr><td>en</td><td>GB</td><td><br>
</td><td>angielski</td><td>Wielka Brytania</td><td><br>
</td></tr><tr><td>en</td><td>IE</td><td><br>
</td><td>angielski</td><td>Irlandia</td><td><br>
</td></tr><tr><td>en</td><td>IN</td><td><br>
</td><td>angielski</td><td>Indie</td><td><br>
</td></tr><tr><td>en</td><td>NZ</td><td><br>
</td><td>angielski</td><td>Nowa Zelandia</td><td><br>
</td></tr><tr><td>en</td><td>ZA</td><td><br>
</td><td>angielski</td><td>Republika Po³udniowej Afryki</td><td><br>
</td></tr><tr><td>es</td><td><br>
</td><td><br>
</td><td>hiszpañski</td><td><br>
</td><td><br>
</td></tr><tr><td>es</td><td>AR</td><td><br>
</td><td>hiszpañski</td><td>Argentyna</td><td><br>
</td></tr><tr><td>es</td><td>BO</td><td><br>
</td><td>hiszpañski</td><td>Boliwia</td><td><br>
</td></tr><tr><td>es</td><td>CL</td><td><br>
</td><td>hiszpañski</td><td>Chile</td><td><br>
</td></tr><tr><td>es</td><td>CO</td><td><br>
</td><td>hiszpañski</td><td>Kolumbia</td><td><br>
</td></tr><tr><td>es</td><td>CR</td><td><br>
</td><td>hiszpañski</td><td>Kostaryka</td><td><br>
</td></tr><tr><td>es</td><td>DO</td><td><br>
</td><td>hiszpañski</td><td>Republika Dominikany</td><td><br>
</td></tr><tr><td>es</td><td>EC</td><td><br>
</td><td>hiszpañski</td><td>Ekwador</td><td><br>
</td></tr><tr><td>es</td><td>ES</td><td><br>
</td><td>hiszpañski</td><td>Hiszpania</td><td><br>
</td></tr><tr><td>es</td><td>GT</td><td><br>
</td><td>hiszpañski</td><td>Gwatemala</td><td><br>
</td></tr><tr><td>es</td><td>HN</td><td><br>
</td><td>hiszpañski</td><td>Honduras</td><td><br>
</td></tr><tr><td>es</td><td>MX</td><td><br>
</td><td>hiszpañski</td><td>Meksyk</td><td><br>
</td></tr><tr><td>es</td><td>NI</td><td><br>
</td><td>hiszpañski</td><td>Nikaragua</td><td><br>
</td></tr><tr><td>es</td><td>PA</td><td><br>
</td><td>hiszpañski</td><td>Panama</td><td><br>
</td></tr><tr><td>es</td><td>PE</td><td><br>
</td><td>hiszpañski</td><td>Peru</td><td><br>
</td></tr><tr><td>es</td><td>PR</td><td><br>
</td><td>hiszpañski</td><td>Portoryko</td><td><br>
</td></tr><tr><td>es</td><td>PY</td><td><br>
</td><td>hiszpañski</td><td>Paragwaj</td><td><br>
</td></tr><tr><td>es</td><td>SV</td><td><br>
</td><td>hiszpañski</td><td>Salwador</td><td><br>
</td></tr><tr><td>es</td><td>UY</td><td><br>
</td><td>hiszpañski</td><td>Urugwaj</td><td><br>
</td></tr><tr><td>es</td><td>VE</td><td><br>
</td><td>hiszpañski</td><td>Wenezuela</td><td><br>
</td></tr><tr><td>et</td><td><br>
</td><td><br>
</td><td>estoñski</td><td><br>
</td><td><br>
</td></tr><tr><td>et</td><td>EE</td><td><br>
</td><td>estoñski</td><td>Estonia</td><td><br>
</td></tr><tr><td>fi</td><td><br>
</td><td><br>
</td><td>fiñski</td><td><br>
</td><td><br>
</td></tr><tr><td>fi</td><td>FI</td><td><br>
</td><td>fiñski</td><td>Finlandia</td><td><br>
</td></tr><tr><td>fr</td><td><br>
</td><td><br>
</td><td>francuski</td><td><br>
</td><td><br>
</td></tr><tr><td>fr</td><td>BE</td><td><br>
</td><td>francuski</td><td>Belgia</td><td><br>
</td></tr><tr><td>fr</td><td>CA</td><td><br>
</td><td>francuski</td><td>Kanada</td><td><br>
</td></tr><tr><td>fr</td><td>CH</td><td><br>
</td><td>francuski</td><td>Szwajcaria</td><td><br>
</td></tr><tr><td>fr</td><td>FR</td><td><br>
</td><td>francuski</td><td>Francja</td><td><br>
</td></tr><tr><td>fr</td><td>LU</td><td><br>
</td><td>francuski</td><td>Luksemburg</td><td><br>
</td></tr><tr><td>hi</td><td>IN</td><td><br>
</td><td>hindi</td><td>Indie</td><td><br>
</td></tr><tr><td>hr</td><td><br>
</td><td><br>
</td><td>chorwacki</td><td><br>
</td><td><br>
</td></tr><tr><td>hr</td><td>HR</td><td><br>
</td><td>chorwacki</td><td>Chorwacja</td><td><br>
</td></tr><tr><td>hu</td><td><br>
</td><td><br>
</td><td>wêgierski</td><td><br>
</td><td><br>
</td></tr><tr><td>hu</td><td>HU</td><td><br>
</td><td>wêgierski</td><td>Wêgry</td><td><br>
</td></tr><tr><td>is</td><td><br>
</td><td><br>
</td><td>islandzki</td><td><br>
</td><td><br>
</td></tr><tr><td>is</td><td>IS</td><td><br>
</td><td>islandzki</td><td>Islandia</td><td><br>
</td></tr><tr><td>it</td><td><br>
</td><td><br>
</td><td>w³oski</td><td><br>
</td><td><br>
</td></tr><tr><td>it</td><td>CH</td><td><br>
</td><td>w³oski</td><td>Szwajcaria</td><td><br>
</td></tr><tr><td>it</td><td>IT</td><td><br>
</td><td>w³oski</td><td>W³ochy</td><td><br>
</td></tr><tr><td>iw</td><td><br>
</td><td><br>
</td><td>hebrajski</td><td><br>
</td><td><br>
</td></tr><tr><td>iw</td><td>IL</td><td><br>
</td><td>hebrajski</td><td>Izrael</td><td><br>
</td></tr><tr><td>ja</td><td><br>
</td><td><br>
</td><td>japoñski</td><td><br>
</td><td><br>
</td></tr><tr><td>ja</td><td>JP</td><td><br>
</td><td>japoñski</td><td>Japonia</td><td><br>
</td></tr><tr><td>ko</td><td><br>
</td><td><br>
</td><td>koreañski</td><td><br>
</td><td><br>
</td></tr><tr><td>ko</td><td>KR</td><td><br>
</td><td>koreañski</td><td>Korea Po³udniowa</td><td><br>
</td></tr><tr><td>lt</td><td><br>
</td><td><br>
</td><td>litewski</td><td><br>
</td><td><br>
</td></tr><tr><td>lt</td><td>LT</td><td><br>
</td><td>litewski</td><td>Litwa</td><td><br>
</td></tr><tr><td>lv</td><td><br>
</td><td><br>
</td><td>³otewski</td><td><br>
</td><td><br>
</td></tr><tr><td>lv</td><td>LV</td><td><br>
</td><td>³otewski</td><td>£otwa</td><td><br>
</td></tr><tr><td>mk</td><td><br>
</td><td><br>
</td><td>macedoñski</td><td><br>
</td><td><br>
</td></tr><tr><td>mk</td><td>MK</td><td><br>
</td><td>macedoñski</td><td>Macedonia</td><td><br>
</td></tr><tr><td>nl</td><td><br>
</td><td><br>
</td><td>holenderski</td><td><br>
</td><td><br>
</td></tr><tr><td>nl</td><td>BE</td><td><br>
</td><td>holenderski</td><td>Belgia</td><td><br>
</td></tr><tr><td>nl</td><td>NL</td><td><br>
</td><td>holenderski</td><td>Holandia</td><td><br>
</td></tr><tr><td>no</td><td><br>
</td><td><br>
</td><td>norweski</td><td><br>
</td><td><br>
</td></tr><tr><td>no</td><td>NO</td><td><br>
</td><td>norweski</td><td>Norwegia</td><td><br>
</td></tr><tr><td>no</td><td>NO</td><td>NY</td><td>norweski</td><td>Norwegia</td><td>Nynorsk</td></tr><tr><td>pl</td><td><br>
</td><td><br>
</td><td>polski</td><td><br>
</td><td><br>
</td></tr><tr><td>pl</td><td>PL</td><td><br>
</td><td>polski</td><td>Polska</td><td><br>
</td></tr><tr><td>pt</td><td><br>
</td><td><br>
</td><td>portugalski</td><td><br>
</td><td><br>
</td></tr><tr><td>pt</td><td>BR</td><td><br>
</td><td>portugalski</td><td>Brazylia</td><td><br>
</td></tr><tr><td>pt</td><td>PT</td><td><br>
</td><td>portugalski</td><td>Portugalia</td><td><br>
</td></tr><tr><td>ro</td><td><br>
</td><td><br>
</td><td>rumuñski</td><td><br>
</td><td><br>
</td></tr><tr><td>ro</td><td>RO</td><td><br>
</td><td>rumuñski</td><td>Rumunia</td><td><br>
</td></tr><tr><td>ru</td><td><br>
</td><td><br>
</td><td>rosyjski</td><td><br>
</td><td><br>
</td></tr><tr><td>ru</td><td>RU</td><td><br>
</td><td>rosyjski</td><td>Rosja</td><td><br>
</td></tr><tr><td>sh</td><td><br>
</td><td><br>
</td><td>serbo-chorwacki</td><td><br>
</td><td><br>
</td></tr><tr><td>sh</td><td>YU</td><td><br>
</td><td>serbo-chorwacki</td><td>Jugos³awia</td><td><br>
</td></tr><tr><td>sk</td><td><br>
</td><td><br>
</td><td>s³owacki</td><td><br>
</td><td><br>
</td></tr><tr><td>sk</td><td>SK</td><td><br>
</td><td>s³owacki</td><td>S³owacja</td><td><br>
</td></tr><tr><td>sl</td><td><br>
</td><td><br>
</td><td>s³oweñski</td><td><br>
</td><td><br>
</td></tr><tr><td>sl</td><td>SI</td><td><br>
</td><td>s³oweñski</td><td>S³owenia</td><td><br>
</td></tr><tr><td>sq</td><td><br>
</td><td><br>
</td><td>albañski</td><td><br>
</td><td><br>
</td></tr><tr><td>sq</td><td>AL</td><td><br>
</td><td>albañski</td><td>Albania</td><td><br>
</td></tr><tr><td>sr</td><td><br>
</td><td><br>
</td><td>serbski</td><td><br>
</td><td><br>
</td></tr><tr><td>sr</td><td>YU</td><td><br>
</td><td>serbski</td><td>Jugos³awia</td><td><br>
</td></tr><tr><td>sv</td><td><br>
</td><td><br>
</td><td>szwedzki</td><td><br>
</td><td><br>
</td></tr><tr><td>sv</td><td>SE</td><td><br>
</td><td>szwedzki</td><td>Szwecja</td><td><br>
</td></tr><tr><td>th</td><td><br>
</td><td><br>
</td><td>tajlandzki</td><td><br>
</td><td><br>
</td></tr><tr><td>th</td><td>TH</td><td><br>
</td><td>tajlandzki</td><td>Tajlandia</td><td><br>
</td></tr><tr><td>th</td><td>TH</td><td>TH</td><td>tajlandzki</td><td>Tajlandia</td><td>TH</td></tr><tr><td>tr</td><td><br>
</td><td><br>
</td><td>turecki</td><td><br>
</td><td><br>
</td></tr><tr><td>tr</td><td>TR</td><td><br>
</td><td>turecki</td><td>Turcja</td><td><br>
</td></tr><tr><td>uk</td><td><br>
</td><td><br>
</td><td>ukraiñski</td><td><br>
</td><td><br>
</td></tr><tr><td>uk</td><td>UA</td><td><br>
</td><td>ukraiñski</td><td>Ukraina</td><td><br>
</td></tr><tr><td>zh</td><td><br>
</td><td><br>
</td><td>chiñski</td><td><br>
</td><td><br>
</td></tr><tr><td>zh</td><td>CN</td><td><br>
</td><td>chiñski</td><td>Chiny</td><td><br>
</td></tr><tr><td>zh</td><td>HK</td><td><br>
</td><td>chiñski</td><td>Hong Kong</td><td><br>
</td></tr><tr><td>zh</td><td>TW</td><td><br>
</td><td>chiñski</td><td>Tajwan</td><td><br>
</td></tr><tr><td>en</td><td><br>
</td><td><br>
</td><td>angielski</td><td><br>
</td><td><br>
</td></tr><tr><td>en</td><td>US</td><td><br>
</td><td>angielski</td><td>Stany Zjednoczone Ameryki</td><td><br>
</td></tr></tbody>
</table> Uwaga: &nbsp;tabela pokazuje lokalizacje dostêpne w Javie. Przy
u¿yciu biblioteki ICU4J uzyskamy wiêkszy zestaw dostêpnych lokalizacji.<br>
<br>
Nale¿y tu zaobserwowaæ nastêpuj¹ce cechy:<br>
<ul>
  <li>mo¿emy formowaæ lokalizacje tylko na podstawie jêzyka,</li>
  <li>dodatkowa specyfikacja kraju mo¿e ró¿nicowaæ formaty jêzykowe zgodnie z tradycjami kulturowymi danego kraju,</li>
  <li>istniej¹ kraje z kilkoma obowi¹zuj¹cymi jêzykami, </li>
  <li>dla niektórych lokalizacji podano dodatkowe warianty.</li>
</ul>
<br>
Poni¿szy przyk³adowy program pokazuje wykorzystanbie prostej klasy Locale w celu t³umaczenia nazw krajów na ró¿ne jêzyki.<br>
<pre>import java.util.*;
import java.text.*;
import javax.swing.*;

class CountryTranslator {

  public static void main(String[] args) {

    Locale[] loc = Locale.getAvailableLocales();
    Map map = new HashMap();
    String kraj;

    // Dodanie dostêpnych lokalizacji do mapy
    // klucz: nazwa kraju po poslku, wartoœc - lokealizacja
    for (int i=0; i&lt;loc.length; i++) {
      String countryCode = loc[i].getCountry();  // kod kraju
      if (countryCode.equals("")) continue;
      kraj =  loc[i].getDisplayCountry();
      map.put(kraj, loc[i]);
    }

    String msg = "Podaj kraj";
    String in = "";
    while((kraj = JOptionPane.showInputDialog(msg)) != null ) {
      // Pobieramy lokalizacjê dla podanego kraju
      Locale savedLoc = (Locale) map.get(kraj);
      if (savedLoc == null) continue;
      msg = "Podaj kody jêzyków, rozdzielone spacjami";
      while((in = JOptionPane.showInputDialog(null, msg, in)) != null ) {
        StringTokenizer st = new StringTokenizer(in);
        if (st.countTokens() == 0) continue;
        String rep = "Nazwa kraju " + kraj + ":\n";

        // Dla kolejnych kodów jêzyków
        // uzyskujemy nazwê kraju w jêzyku odpowiadaj¹cym
        // lokalizacji zwi¹zanej z kodem jêsyka
        while(st.hasMoreTokens()) {
          Locale lang = new Locale(st.nextToken());
          rep += lang.getDisplayLanguage() + "   =   " +
                 savedLoc.getDisplayCountry(lang) + "\n";
        }
      JOptionPane.showMessageDialog(null,rep);
      }
      msg = "Podaj kraj";
    }
    System.exit(0);
  }
}
</pre>
<img src="images/nazwykraj.jpg" alt="r" align="right" border="1" height="229" width="268">
W tym programie wykorzystaliœmy fakt, i¿ metody getDisplay... u¿yte bez argumentów
zwracaj¹ opisy w jêzyku lokalizacji domyœlnej (np. loc.getDisplayLanguage()
zwróci opis jêzyka po polsku), a u¿yte z argumentem-lokalizacj¹ zwracaj¹
opis w jêzyku podanej lokalizacji (np. loc1.getDisplayCountry(loc2) zwróci
nazwê kraju, zwi¹zanego z lokalizacj¹ loc1 w jêzyku lokalizacji loc2).<br>
Przyk³adowy wynik dzia³ania programu pokazano na rysunku.<br>
<br>

<a name="Intern.2"></a><h2>2. Formatowanie liczb</h2>




Gdy wyprowadzamy liczby rzeczywiste w postaci znakowej np. za pomoc¹ metody
System.out.println(...), to nie mamy wp³ywu na ich formatowanie (np. ile
jest pokazywanych miejsc dziesiêtnych). Np. wynikiem takiego fragmentu programu:<br>
<br>


&nbsp;&nbsp;&nbsp;&nbsp; double d = 10/3.0;<br>


&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(d);<br>
<br>


bêdzie:<br>
<br>


3.3333333333333335<br>
<br>


Bardzo czêsto bêdziemy potrzebowaæ "sformatowanego" wydruku liczby (np. z trzema miejscami dziesiêtnymi).<br><br>
Oczywiœcie
mo¿emy zastosowac metodê printf, która korzysta z formatora (obiektu
klasy Formatter z pakietu java.util). To jest najwygodniejsze
rozwi¹zanie w prostych przypadkach.<br>
Ale gdy w programie mamy
sekwencje wczytywania i wyprowadzania zlokalizowanych liczb
zastosowanie innych œrodków mo¿e okazaæ siê bardziej u¿yteczne.<br><br>
Mianowicie, w&nbsp; pakiecie java.text znajdziemy klasy, które umo¿liwiaj¹ formatowanie liczb.<br>
<br>


Aby w powy¿szym przyk³adzie uzyskaæ trzy miejsca dziesiêtne mo¿emy np. u¿yæ klasy NumberFormat:<br>
<pre>     NumberFormat nf = NumberFormat.getInstance();
     nf.setMaximumFractionDigits(3);
     String wynik = nf.format(d);
     System.out.println(wynik);

</pre>


Tutaj:<br>
<ul>
<li>statyczna metoda getInstance() zwraca obiekt formatuj¹cy - formator,</li><li>za pomoc¹ metody setMaximumFractionDigits(..) ustalamy, ¿e ten formator
ma formatowaæ liczby w taki sposób, by maksymalna liczba cyfr dziesiêtnych
wynosi³a 3,</li><li>po czym za pomoc¹ metody format uzyskujemy napis reprezeentuj¹cy liczbê
d, z maksymalnei trzema miejscami dziesiêtnymi i wypisujemy wynik, który
teraz bêdzie wygl¹da³ tak: 3,333</li><li>podkreœlmy jeszcze raz (omawialiœmy
to w poprzednim punkcie), ¿e sposób formatowania liczb jest zale¿ny od lokalizacji;
zastosowana tu lokalizacja domyœlna (polska) u¿ywa jako separatora miejsc
dziesiêtnych przecinka. <br>
    <br>
  </li>
</ul>
Wygodniejszy i bardziej uniwersalny sposób formatowania liczb polega na specyfikowaniu
wzorców formatu. Mog¹ one byæ stosowane wobec formatorów, które s¹ obiektami
klasy DecimalFormat. <br>
<br>
Klasa DecimalFormat jest podklas¹ klasy NumberFormat, a metoda getInstance()
z klasy NumberFormat tak naprawdê zwraca referencjê do obiektu tej w³aœnie
podklasy. <br>
<br>
Mo¿emy post¹piæ tak:<br>
<ul>
<li>stworzyæ obiekt klasy DecimalFormat, podaj¹c jako argument konstruktora wzorzec formatowania,</li><li>wywo³aæ metodê format na rzecz tego obiektu.</li>
</ul>


Na przyk³ad:<br>
<pre>     double d = 10/3.0;
     DecimalFormat dform = new DecimalFormat("###.###");
     String wynik = dform.format(d);
     System.out.println(wynik);
</pre>


Tutaj otrzymamy wynik: 3,333, bowiem zastosowany wzorzec formatowania mówi
o tym, ¿e napis reprezentuj¹cy liczbê ma zawieraæ cyfry na pozycjach calkowitych
(przy czym wiod¹ce zera nie bêd¹ pokazywane, a liczba cyfr bêdzie odpowiednia dla wyniku),
znak reprezentuj¹cy separator miejsc dziesiêtnych oraz co najwy¿ej trzy cyfry
na miejscach dziesiêtnych (przy czym nieznacz¹ce zera nie bêd¹ pokazywane,
a ostatnia pokazana cyfra bêdzie zaokr¹glona).<br>
<br>
<div class="syntax">Wzorce formatowania s¹ ³añcuchami znakowymi i maj¹ nastêpuj¹c¹ postaæ:<br>
<br>
[prefiks][czêœc_ca³kowita][.czêœæ_dziesiêtna][sufiks]
<br>
<br>
gdzie: <br>
<ul><li>prefiks i sufiks - dowolny ci¹g znaków oprócz znaków specjalnych,</li><li>czêœæ ca³kowita i czêœæ dziesiêtna - zero lub wiêcej znaków specjalnych&nbsp;
'#' albo zero lub wiêcej znaków specjalnych&nbsp; '0' oraz ew. pojedyncze inne
znaki specjalne.</li></ul><i>Uwagi: <br>
</i><ol><li><i>nawiasy kwadratowe oznaczaj¹ opcjonalnoœæ elememetu wzorca, z tym, ¿e co najmniej jeden z elementów musi wyst¹piæ;</i></li><li><i>jako wzorzec formatuj¹cy mo¿na podac dwa wzorce w powy¿szej postaci,
rozdzielone œrednikiem; pierwszy z nich bêdzie dotyczy³ liczb dodatnich,
drugi - ujemnych.</i></li></ol></div>
<br>
<br>


Najwa¿niejsze znaki specjalne u¿ywane we wzorcach formatuj¹cych podaje tabela.<br>
<br>
<table border="1">
<tbody><tr><th>Symbol</th><th>Opis</th></tr><tr><td>0</td><td>cyfra, jeœli jest nieznacz¹cym zerem pokazywana jako 0</td></tr><tr><td>#</td><td>cyfra, nieznacz¹ce zera nie s¹ pokazywane</td></tr><tr><td>.</td><td>miejsce separatora dziesiêtnego</td></tr><tr><td>,</td><td>miejsce separatora grup cyfr (np. tysiêcy)</td></tr><tr><td>E</td><td>miejsce separatora dla notacji &nbsp;in¿ynieryjnej lub naukowej ( np. 1E-11)</td></tr><tr><td>;</td><td>separator formatu dla liczb dodatnich i formatu dla liczb ujemnych<br>
&lt;
/td&gt;</td></tr><tr><td>-</td><td>znak minus</td></tr><tr><td>%</td><td>powoduje mno¿enie liczby przez 100 i pokazanie jej w postaci procentowej<br>
</td></tr><tr><td>¤</td><td>symbol waluty (np. z³); u¿yty dwukrotnie daje miêdzynarodowy symbol waluty </td></tr><tr><td>'</td><td>ujête w apostrofy znaki specjalne mog¹ byæ pokazywane w czêœci prefiks lub sufiks<br>
</td></tr></tbody>
</table>
<br>


Program na wydruku pokazuje jak mo¿na korzystaæ z ró¿nych formatów.<br>
<pre>import java.text.*;
import java.math.*;

public class Format1 {

  public static void show(double n1, Double n2, BigDecimal n3,
                          String format) {
    DecimalFormat df = new DecimalFormat(format);
    System.out.println("Format " + format);
    System.out.println("Liczba: " +  n1 + " wygl¹da tak: " + df.format(n1));
    System.out.println("Liczba: " +  n2 + " wygl¹da tak: " + df.format(n2));
    System.out.println("Liczba: " +  n3 + " wygl¹da tak: " + df.format(n3));
  }


  public static void main(String[] args) {
    double num1  = 1.346;
    Double num2  = new Double(0.765474);
    BigDecimal num3 = new BigDecimal("100.2189091");

    show(num1, num2, num3, "#.##");
    show(num1, num2, num3, "#.## %");
    show(num1, num2, num3, "#.0000");
    show(num1, num2, num3, "#.00 ¤");
    show(num1, num2, num3, "#.00 ¤¤");
    show(num1, num2, num3, "[ 000.0 ]");

 }

}
</pre>


Wyniki jego dzialania pokazuje wydruk.<br>
<div class="listing100"><br>
Format #.##<br>
Liczba: 1.346 wygl¹da tak: 1,35<br>
Liczba: 0.765474 wygl¹da tak: 0,77<br>
Liczba: 100.2189091 wygl¹da tak: 100,22<br>
Format #.## %<br>
Liczba: 1.346 wygl¹da tak: 134,6 %<br>
Liczba: 0.765474 wygl¹da tak: 76,55 %<br>
Liczba: 100.2189091 wygl¹da tak: 10021,89 %<br>
Format #.0000<br>
Liczba: 1.346 wygl¹da tak: 1,3460<br>
Liczba: 0.765474 wygl¹da tak: ,7655<br>
Liczba: 100.2189091 wygl¹da tak: 100,2189<br>
Format #.00 ¤<br>
Liczba: 1.346 wygl¹da tak: 1,35 z³<br>
Liczba: 0.765474 wygl¹da tak: ,77 z³<br>
Liczba: 100.2189091 wygl¹da tak: 100,22 z³<br>
Format #.00 ¤¤<br>
Liczba: 1.346 wygl¹da tak: 1,35 PLN<br>
Liczba: 0.765474 wygl¹da tak: ,77 PLN<br>
Liczba: 100.2189091 wygl¹da tak: 100,22 PLN<br>
Format [ 000.0 ]<br>
Liczba: 1.346 wygl¹da tak: [ 001,3 ]<br>
Liczba: 0.765474 wygl¹da tak: [ 000,8 ]<br>
Liczba: 100.2189091 wygl¹da tak: [ 100,2 ]</div>
<br>
<br>
   Zwrócmy uwagê, ¿e za pomoc¹ metody format(...) mo¿na formatowac nie
tylko liczby typu double, ale równie¿ typu long oraz obiekty klas pochodnych
od Number (np. Double, Float, Long, Integer) i BigInteger oraz BigDecimal.<br>
<br>
Klasy formatuj¹ce liczby
s¹ przygotowane na prezentacjê liczb wed³ug regu³ lokalizacyjnych. Jeœli
w metodzie getInstance() nie podamy lokalizacji - bêdzie u¿yta lokalizacja domyœlna, w naszym przypadku
polska, wedle której separatorem miejsc dziesiêtnych jest przecinek. <br>


Jak uzyskaæ kropkê zamiast przecinka? Mo¿emy zmieniæ lokalizacjê na tak¹,
w której seperatorem jest kropka (np. angielsk¹) np. tak:<br>
<pre>    DecimalFormat df = (DecimalFormat)
                       NumberFormat.getInstance(new Locale("en", "US"));
    df.applyPattern(format);

</pre>
Ale wtedy utracimy polskie symbole waluty, &nbsp;zamiast nich pojawi¹ siê dla
Stanów Zjednoczonych USD, dla innych anglojêzycznych krajów inne symbole,
a jeœli nie podamy kraju - XXX (nieznana waluta). <br>
<br>
Mo¿emy co prawda ustaliæ walutê za pomoc¹ metody setCurrency(...), u¿ytej wobec formatora, ale wykorzystajmy raczej to, ¿e<br>
<ul>
  <li>z ka¿d¹ lokalizacj¹ zwi¹zany jest zestaw symboli
u¿ywanych przy formatowaniu liczb (jest to obiekt klasy DecimalFormatSymbols),
</li>
  <li>mo¿emy go ³atwo uzyskaæ od formatora dla domyœlnej lokalizacji (metoda
getDecimalFormatSymbols())</li>
  <li>&nbsp;i zmieniæ wybrany symbol (za pomoca odpowiedniej
metody klasy DecimalFormatSymbols). </li>
</ul>

Zmiana separatora miejsc dziesiêtnych na kropkê mo¿e wygl¹daæ&nbsp; tak:<br>

<pre>DecimalFormat df = new DecimalFormat(format);  // formator w domyœlnej lokalizacji
DecimalFormatSymbols sym = df.getDecimalFormatSymbols(); // symbole
sym.setDecimalSeparator('.');                  // ustalenie separatora miejsc dziesiêtnych
</pre>


Teraz nasz program wyprowadzi np. zamiast 1,35 z³ &nbsp;napis 1.35 z³.<br>
Inne symbole u¿ywane przy formatowaniu i metody ich zmian opisane s¹ w dokumentacji.<br>
<br>


Zwykle jednak bêdziemy chcieli wypisywaæ liczby w takiej postaci, w jakiej
przyjêto dla danej lokalizacji i tutaj rola formatorów jest nieoceniona,
³atwo bowiem ustaliæ potrzebn¹ lokalizacjê (oprócz wspomnianych wczeœniej
sposobów mo¿na te¿ stworzyæ obiekt klasy DecimalFormatSymbols dla lokalizacji
okreœlanej przez argument konstruktora tej klasy i u¿yæ tego obiektu przy
tworzeniu formatora DecimalFormat - konstruktor DecimalFormat(String format,
DecimalFormatSymbols symbole)).<br>
<br>
Zwróæmy uwagê, ¿e metoda getInstance(...) klasy NumberFormat jest metod¹
fabryczn¹ - zwraca obiekt okreœlonej podklasy klasy NumberFormat. Obecnie
jest to obiekt klasy DecimalFormat, ale - jak napisano w dokumentacji -&nbsp;
to niekoniecznie musi byæ zagwarantowane w przysz³oœci, tak ¿e dla wiêkszej
przenoœnoœci kody nale¿a³a³oby przed formatowaniem dziesiêtnym sprawdzaæ
czy zwrócony przez getInstance() obui\iekt jest obiektem klasy DecimalFormat.<br>
Mo¿emy te¿ uzyskaæ specjalne formatory (bêd¹ce teraz równie¿ obiektami klasy
DecimalFormat, ale o specjalnych w³aœciwoœciach) do formatowania:<br>
<ul>
  <li>liczb ca³kowitych - metoda NumberFormat.getIntegerInstance(...)</li>
  <li>wartoœci wyra¿onych w walucie - metoda NumberFormat.getCurrencyInstance(...)</li>
  <li>wartoœci w procentach - metoda NumberFormat.getPercentInstance(...)</li>
</ul>

Te swoiste warianty s¹ jak gdyby prostsz¹ drog¹ uzyskiwania efektów podobnych
do u¿ycia wzorców formatowania, o ile zale¿y nam tylko na tych w³aœnie (ca³kowitych,
walutowych, procentowych) formatach.<br>
Oczywiœcie, wszystkie te metody maj¹ wersje z argumentem okreslaj¹cym lokalizacjê.<br>
<br>
Formatory potrafi¹ tak¿e dokonywaæ przekszta³ceñ odwrotnych: zamieniaæ napisy
reprezentuj¹ce liczby na postaæ binarn¹ tych liczb. Istotnie, jeœli mam jakiœ
tekst, w którym liczby podawane s¹ z przecinkami jako separatorami miejsc
dziesiêtnych, to metoda parseDouble z klasy Double nie da oczekiwanych wyników.
Zamiast niej mo¿emy zastosowaæ metodê parse(..) zdefiniowan¹ w klasach formatorów
i metoda ta poradzi sobie z dowolnymi sposobami zapisu liczb wedle ró¿nych
regu³ lokalizacyjnych (a tak¿e wedle ró¿nych formatów).<br><br>
<div class="notec">Uwaga: proste parsowanie napisów jako liczb uzyskamy za pomoc¹ klasy Scanner.</div>
<br>
Do zamiany napisów reprezentuj¹cych liczby w danym formacie na ich binarn¹
postaæ mo¿na zastosowaæ metodê parse(String) u¿yt¹ na rzecz formatora.<br>
Przy tym:<br>
<ul>
  <li>metoda parse(...) zwraca referencjê do obiektu podklasy klasy Number,
który - w zale¿noœci od wartoœci interpretowanego napisu mo¿e wskazywaæ na
Long lub Double,</li>
  <li>napis podlega interpretacji jako liczba zgodnie z&nbsp; lokalizacj¹ (np.
w polskiej lokalizacji u¿ycie przecinka jako sepratora miejsc dziesiêtnych),</li>
  <li>je¿eli formator &nbsp;nie dotyczy walut, procentów i nie uzyskano go wg
wzorca formatowania, który zawiera inne od specjalnych znaki, to przekszta³canie
napisu na liczbê bêdzie dokonywane dopóki mo¿na, tzn. dopóki kolejny znak
bêdzie stanowi³ (w danej lokalizacji) czêœæ liczby, pozosta³e znaki zostan¹
pominiête i nie wyst¹pi ¿aden wyj¹tek,</li>
  <li>dla prostego, ogólnego formatu liczbowego wyj¹tek wyst¹pi
tylko wtedy, gdy pocz¹tek napisu nie da siê zinterpretowaæ jako liczba (wyj¹tek
klasy ParseException)</li>
  <li>przy interpretacji napisów wg specyficznych formatów (np. walutowego
lub wg rozbudowanych wzorców formatowania) napis musi byæ zgodny z formatem
i niezaleznie od tego czy niezgodnoœæ wyst¹pi na pocz¹tku czy na koñcu -
powstanie wyj¹tek ParseException.</li>
</ul>
Program na listingu pokazuje prosty przyk³ad u¿ycia metody parse(...).<br>
<pre>import javax.swing.*;
import java.text.*;

public class Parse1 {

  public static void main(String[] args) {
    NumberFormat format = NumberFormat.getInstance();
    String in,
           msg = "Podaj liczbê";
    Number num = null;
    while ((in = JOptionPane.showInputDialog(msg)) != null) {
      System.out.println("Wejœcie: " + in);
      try {
        num = format.parse(in);
      } catch (ParseException exc) {
          System.out.println("Wadliwe dane: " + in);
          System.out.println(exc);
          continue;
      }
      System.out.println("Parse daje: " +
                          num.getClass().getName()+ " = " + num);
    }
    System.exit(0);
  }

}
</pre>
Na wydruku przedstawiono efekty dzia³ania programu dla ró¿nych danych wejœciowych:<br>
<div class="listing100"><br>
Wejœcie: 1<br>
Parse daje: java.lang.Long = 1<br>
Wejœcie: 1.111<br>
Parse daje: java.lang.Long = 1<br>
Wejœcie: 1,111<br>
Parse daje: java.lang.Double = 1.111<br>
Wejœcie: 1e16<br>
Parse daje: java.lang.Long = 1<br>
Wejœcie: 99999999999999999999999999999999999<br>
Parse daje: java.lang.Double = 1.0E35<br>
<br>
Wejœcie: -1,213<br>
Parse daje: java.lang.Double = -1.213<br>
Wejœcie: 212a<br>
Parse daje: java.lang.Long = 212<br>
Wejœcie: aaaa<br>
Wadliwe dane: aaaa<br>
java.text.ParseException: Unparseable number: "aaaa"<br>
</div><br>
<br>
Gdybyœmy w tym programie zamienili format na:<br>
<br>
NumberFormat format = NumberFormat.getCurrencyInstance();<br>
to:<br>
wprowadzenie napisu 23 - da³oby wyj¹tek ParseException<br>
wprowadzenie napisu 23 PLN - da³oby wyj¹tek ParseException<br>
wprowadzenie napisu 23z³ - da³oby wyj¹tek ParseException<br>
i tylko po wprowadzeniu w³aœciwiego domyœlnego formatu walutowego:<br>
23 z³<br>
uzyskalibyœmy liczbê 23.<br>
<br>
Jeœli natomiast u¿ylibyœmy wzorca formatowania:<br>
<br>
NumberFormat format = new DecimalFormat("[ #.0000 ]");<br>
<br>
to akceptowane by³yby wy³¹cznie napisy, reprezentuj¹ce poprawne liczby ujête w nawiasy kwadartowe (z okalaj¹cymi spacjami).<br>
<br>
W tych przypadkach, gdy b³¹d mo¿e pojawiæ siê nie tylko na samym pocz¹tku
napisu, u¿yteczna mo¿e okazaæ siê metoda getErrorOffset() z klasy ParseException,
która zwraca pozycjê w napisie, na której pojawi³ siê b³¹d.<br>
<br>
Zobaczmy na przyk³adzie zmodyfikowanego programu:<br>
<pre>  public static void main(String[] args) {
    NumberFormat format = new DecimalFormat("[ #.0000 ]");
    //...
    while ((in = JOptionPane.showInputDialog(msg)) != null) {
      System.out.println("Wejscie: " + in);
      try {
        num = format.parse(in);
      } catch (ParseException exc) {
          System.out.println("Wadliwe dane: " + in);
          System.out.println(exc);
          System.out.println("Wadliwa pozycja: " + exc.getErrorOffset());
          continue;
      }
      System.out.println("Parse daje: " +
                          num.getClass().getName()+ " = " + num);
    }
  }
</pre>
<br>
Przyk³adowy wydruk zmodyfikowanego programu :<br>
<div class="listing100"><br>
Wejscie: [23]<br>
Wadliwe dane [23]<br>
java.text.ParseException: Unparseable number: "[23]"<br>
Wadliwa pozycja: 0<br>
Wejscie: [ 23 ]<br>
Parse daje: java.lang.Long = 23<br>
Wejscie: [ 23<br>
Wadliwe dane: [ 23<br>
java.text.ParseException: Unparseable number: "[ 23 "<br>
Wadliwa pozycja: 4<br>
Wejscie: [ 23 a ]<br>
Wadliwe dane: [ 23 a ]<br>
java.text.ParseException: Unparseable number: "[ 23 a ]"<br>
Wadliwa pozycja: 4<br>
Wejscie: [ 23.000 ]<br>
Wadliwe dane: [ 23.000 ]<br>
java.text.ParseException: Unparseable number: "[ 23.000 ]"<br>
Wadliwa pozycja: 4<br>
Wejscie: [ 23, 00 ]<br>
Wadliwe dane: [ 23, 00 ]<br>
java.text.ParseException: Unparseable number: "[ 23, 00 ]"<br>
Wadliwa pozycja: 5<br>
Wejscie: [ 23,0 ]<br>
Parse daje: java.lang.Long = 23<br>
&nbsp;</div><br>
<br>
Inn¹ form¹ metody parse z klas formatorów jest:<br>
<br>
&nbsp;&nbsp;&nbsp; Number num = parse(String dane, ParsePosition pos);<br>
<br>
Tutaj u¿ywamy obiektu <i><b>pos</b></i> klasy <b>ParsePosition</b>, który okreœla bie¿¹c¹ pozycjê rozbioru napisu <b><i>dane</i></b> oraz ew. pozycjê (indeks) na której wyst¹pi³ b³¹d.<br>
Rozbiór danych (wedle formatu) rozpoczyna siê od pozycji okreslonej przez
podany obiekt klasy ParsePosition. Napis podlega interpretacji (dopóki kolejne
jego znaki mo¿na traktowaæ jako znaki liczby wg danego formatu), po czym
bie¿¹ca pozycja rozbioru (indeks) jest ustawiana za ostatnim zinterpretowanym
znakiem i zwracana jest liczba jako obiekt klasy Number. <br>
Ta metoda nie zg³asza ¿adnych wyj¹tków. W przypadku b³êdu&nbsp;interpretacji (a
w zale¿noœci od formatu - wystêpuje on albo tylko na pocz¹tku napisu, albo
gdzieœ dalej)&nbsp; zwracana jest wartoœæ null, bie¿¹ca pozycja nie ulega zmianie,
a &nbsp;indeks b³êdu ustawiany jest na znaku, który spowodow³¹ b³ad. Je¿eli nie
ma b³êdu indeks b³êdu ma wartoœæ -1.<br>
Pozycje (indeks)&nbsp; - bie¿¹cy i b³êdu - mo¿emy uzyskiwac od obiektu ParsePosition
za pomoc¹ metod getIndex() i getErrorIndex() oraz ustawiaæ za pomoc¹ odpowiednich
metod setIndex(...) i setErrorIndex(...).<br>
<br>
Program na wydruku pokazuje przyk³adowe u¿ycie tej metody parse do wyodrêbnienia
z pliku tekstowego wszystkich informacji zapisanych w formacie walutowym
(mo¿emy sobie wyobra¿aæ, ¿e jest to plik opisuj¹cy jakieœ wydatki, a naszym
zadaniem jest ich podsumowanie)<br>
<br>
<pre>.import java.io.*;
import java.text.*;
import java.util.*;

public class Parse2 {

  public static void main(String[] args) {

    // Format walutowy w domyœlnej lokalizacji
    // czyli w PL np. 12 z³
    NumberFormat format = NumberFormat.getCurrencyInstance();

    // Lista wartoœci wydatków (zapisanych w tekœcie pliku)
    List numList = new ArrayList();

    try {
      BufferedReader br = new BufferedReader(
                            new FileReader("testdata.txt")
                          );

      // czytanie kolejnych wierszu
      String in;
      while ((in = br.readLine()) != null) {

        int p = 0;                    // bie¿¹cy indeks rozbioru
        int last  = in.length() - 1;  // ostatni indeks w wierszu

        // Utworzenie pozycji rozbioru wiersza (od 0)
        ParsePosition ppos = new ParsePosition(0);

        // Dopóki nie dobiegliœmy do koñca wiersza
        while (p &lt;= last) {
           // Próbujemy pobraæ kolejn¹ liczbê w formacie walutowym
           Number num = format.parse(in, ppos);

           if (num == null)              // je¿eli b³¹d,
             p = ppos.getErrorIndex()+1; // indeks na znaku po b³êdzie
           else {                        // je¿eli uda³o siê sczytaæ wartoœæ
             numList.add(num);           // dodajemy j¹ do listy
             p =  ppos.getIndex();   // indeks na nastêpnym znaku po
           }
           ppos.setIndex(p);         // ustawiamy nastêpn¹ pozycjê
        }                            // od której kontynuacja rozbioru
      }
      br.close();
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    // Wypisanie i podsumowanie zapisanych w pliku wydatków
    System.out.println("Wydatki w z³:");
    double suma = 0;
    for (Iterator iter = numList.iterator(); iter.hasNext(); ) {
      Number val  = (Number) iter.next();
      System.out.println(val);
      suma += val.doubleValue();
    }
    System.out.println("Wydano w sumie: " + format.format(suma));
  }
}</pre>
<br>
Gdy u¿yjemy tego programu wobec&nbsp; pliku, zawieraj¹cego nastêpuj¹cy tekst:<br>
<br>
Wydano najpierw 123 z³ na 23 kilo jab³ek<br>
Kolejny wydatek obj¹³ 77,77 z³ (70 litrów maœlanki)<br>
a potem jeszcze dosz³o 999,99 z³ w 4 ratach.<br>
<br>
to w wyniku uzyskamy:<br>
<div class="listing100"><br>
Wydatki w z³:<br>
123<br>
77.77<br>
999.99<br>
Wydano w sumie: 1 200,76 z³<br>
</div><br>
<br>
Zwrócmy uwagê: tylko liczby zapisane w formacie walutowym zosta³y wyodrêbnione, inne liczby nie by³y brane pod uwagê.<br>
<br>
Przyk³ad ten pokazuje du¿¹ si³e klas formatorów. Ten program zadzia³a bez rekompilacji przy ka¿dej innej domyœlnej lokalizacji
i dla plików, w których dane zapisano w innej (w³aœciwiej dla tej lokalizacji)
walucie.<br>
<br>
Nieco brzydkie formatowanie wyniku w powy¿szym przyk³adzie mo¿na oczywiœcie
poprawiæ i to w doœæ prosty sposób. Oto przy formatowaniu liczb mamy swoisty
odpowiednik klasy ParsePosition. Tym razem jest to klasa <b>FieldPosition</b>
, która umo¿liwia uzyskiwanie informacji o pocz¹tku i koñcu pól sformatowanego
wyniku. W przypadku prostych liczb pola oznaczaj¹ czêœæ ca³kowit¹ i czêœæ
dziesiêtn¹, co jest identyfikowane przez sta³e statyczne z klasy NaumberFormat
o nazwach INTEGER_FIELD i FRACTIONAL_FIELD. U¿ycie FieldPosition w specjalnej
wersji metody format pozwala na dodatkowe formatowanie wyniku.<br>
<br>
Zatem, aby mieæ dodatkow¹ kontrolê nad formatowaniem:<br>
<ul>
  <li>tworzymy obiekt klasy FieldPosition, podaj¹c w konstruktorze o jaki rodzaj pola chodzi,</li>
  <li>po czym przekazujemy go jako ostatni argument specjalnej wersji metody
format, która ma te¿ jako argumenty liczbê do sformatowania i StringBuffer
do którego do³¹czany jest wynik formatowania,</li>
  <li>i po u¿yciu metody format(...) mo¿emy dowiedzieæ siê od obiektu FieldPosition
gdzie (na której pozycji) w&nbsp; buforze wynikowym zaczyna siê dane pole (metoda
getBeginIndex()) i gdzie siê koñczy (metoda getEndIndex()).</li>
</ul>
Pokazuje to poni¿szy program, który stanowi modyfikacjê poprzedniego przyk³adu
dokonan¹ z myœl¹ o wyrównywaniu wyprowadzanych wyników "na" separatorze miejsc
dziesiêtnych.<br>
<br>
<pre>public class ParseAndFormat {

  public static void main(String[] args) {

    // ... tutaj czêœæ analogiczna jak w poprzednim pzryk³adzie
    // ... czytanie danych z pliku i parsowanie liczb wg formatu walutowego
    // ... dla przejrzystoœci format ten (uzyskiwany z getCurrencyInstance())
    // ... nazwano cform (nazwa zmiennej)

    // Wypisanie i podsumowanie&nbsp;przeczytanych&nbsp;z pliku wydatków
    // formatowanie wyjœcia za pomoc¹ metody align (zob. dalej)
    // w której u¿ywamy FieldPosition

    // Format wyjœciowy - walutowy, z dwoma miejscami dziesiêtnymi
    DecimalFormat outform = new DecimalFormat("#.00 ¤");

    System.out.println("Wydatki w : " +
                        cform.getCurrency().getSymbol()); // symbol waluty
    double suma = 0;
    int i = 1;
    final int DOTPOS = 30; // pozycja separatora miejsc dziesiêtnych

    for (Iterator iter = numList.iterator(); iter.hasNext(); i++ ) {
      Number val  = (Number) iter.next();
      suma += val.doubleValue();
      System.out.println(
        align("Pozycja " + i, outform, val, DOTPOS)
      );
    }
    System.out.println(
        align("Wydano w sumie", outform, new Double(suma), DOTPOS)
    );
  }

  // Metoda wyrównuj¹ca liczby na separatorze miejsc dziesiêtnuych
  // Liczba v formatowana zgodnie z formatem f
  // poprzedzona jest napisem msg
  // i tak¹ liczb¹ kropek, by separatory miejsc dziesiêtnych
  // by³y wyrównane na pozycji width

  static StringBuffer align(String msg, Format f, Number v, int width) {

    //Interesuje nas pole - czêœæ ca³kowita liczby
    FieldPosition fp = new FieldPosition(NumberFormat.INTEGER_FIELD);

    // Bufor do którego zapisywana jest sformatowana liczba
    // na pocz¹tku bufora ju¿ zapisujemy msg (opis pozycji wydatków)

    StringBuffer out = new StringBuffer(msg);
    int msgLen = out.length();

    // formatowanie: v = liczba, out - bufor wynikowy, fp - opis pola
    <b>f.format(v, out, fp);</b>

    // Po sformatowaniu metoda fp.getEndIndex() zwraca
    // pozycjê koñca pola = czêœci ca³kowitej liczby
    // ³atwo obliczyæ liczbê dodatkowych (dotNum) "wype³niaczy",
    // potrzebnych, by separator dziesiêtny znalaz³ siê na pozycji width

    int dotNum = width - fp.getEndIndex();

    // Wstawiamy do bufora - jako wype³niacze - kropki
    while (dotNum-- &gt; 0) {
      out.insert(msgLen, '.');
    }
    return out;
  }

}
</pre>
Teraz wyniki przetwarzania naszego pliku tekstowego bêd¹ wygl¹dac nastêpuj¹co:<br>
<br>
<pre>Wydatki w : z³
Pozycja 1..................123,00 z³
Pozycja 2...................77,77 z³
Pozycja 3..................999,99 z³
Wydano w sumie............1200,76 z³
</pre>
Uwaga: program nie jest uniwesralny, gdy¿ pozycja "równania" na separatorze
miejsc dzisiêtnych jest niezale¿na od d³ugoœci poprzedzaj¹cego liczbê&nbsp; napisu
msg. Ogólnie, trzeba by najpierw okreœliæ maksymaln¹ d³ugoœæ napisów wyprowadzanych
przed kolejnymi liczbami i dosyosowaæ do tego wielkoœæ width. Pominêliœmy
jednak ten etap, aby nie zaciemniaæ ogólnego mechanimzu u¿ucia FieldPosition.<br>
<br>
Istniej¹ te¿&nbsp; inne sposoby formatowania liczb.<br>
Wœród podklas klasy NumberFormat znajdziemy klasê ChoiceFormat.<br>
Generalnie pozwala ona kojarzyæ dowolne napisy z &nbsp;(pó³otwartymi &nbsp;z prawej
strony) przedzia³ami liczb. Formatowanie za jej pomoc¹ polega na zast¹pieniu
liczby, "trafiaj¹cej" w dany przedzia³u, skojarzonym z tym przedzia³em napisem.<br>
<br>
Jedna z wersji konstruktorów klasy ChoiceFormat przyjmuje jako argumenty:<br>
<ul>
  <li>tablicê liczb typu double, okreœlaj¹ca pólotwarte (z prawej strony) przedzia³y liczbowe,</li>
  <li>tablicê napisów, kojarzonych z przedzia³ami.</li>
</ul>
Rozmiary obu tablic musz¹ byæ równe.<br>
Liczby w tablicy musz¹ byæ uporz¹dkowane w kolejnoœci rosn¹cej.<br>
<br>
<div class="syntax"><br>
Regu³y dzia³ania na zdefiniowanych przedzia³ach i kojarzeania liczb trafiaj¹cych
w dany przedzia³ z napisami mo¿na opisaæ w nastêpuj¹cy sposób.<br>
<br>
Je¿eli:<br>
<br>
double[] val = ( .... }; // przedzia³y liczbowe<br>
String[] &nbsp;msg = { ... }; //&nbsp; napisy <br>
<br>
ChoiceFormat cf = new ChoiceFormat(val, msg);<br>
<br>
double x = ...;<br>
String out = cg.format(x);<br>
<br>
to:<br>
<br>
gdy val[0] &lt; x, to out = msg[0], &nbsp; <br>
gdy val[0] &lt;= x &lt; val[1],&nbsp; to out == msg[0],<br>
gdy val[1] &lt;= x &lt; val[2], &nbsp;to out == msg[1].<br>
gdy val[2] &lt;= x &lt; val[3], &nbsp;to out == msg[2].<br>
...<br>
gdy val[val.length-2] &lt;= x &lt; val[val.length-1], to out == msg[msg.length-2]<br>
gdy val[val.length-1] &lt;= x , to out = msg[msg.length-1]&nbsp; <br>
<br>
</div><br>
<br>
Pokazuje to poni¿szy program:<br>
<pre>import java.text.*;

public class ChoiceForm {

  public static void main(String[] args) {
    double[] vals = {  -1, 0, 1, 10 };
    String[] msg  = { "x mniejsze od zera",
                      "0 &lt;= x &lt; 1",
                      "1 &lt;= x &lt; 10",
                      "x &gt;= 10"
                    };
    ChoiceFormat cf = new ChoiceFormat(vals, msg);
    String in;
    while ((in = JOptionPane.showInputDialog("Podaj x")) != null) {
      double x = Double.parseDouble(in);
      String out = cf.format(x);
      System.out.println(x + " : " + out);
    }
  }

}
</pre>
który mo¿e (w zale¿noœci od podawancyh liczb) wyprowadziæ np. taki wynik:<br>
<div class="listing100"><br>
11.0 : x &gt;= 10<br>
10.0 : x &gt;= 10<br>
9.99999 : 1 &lt;= x &lt; 10<br>
0.0 : 0 &lt;= x &lt; 1<br>
1.0 : 1 &lt;= x &lt; 10<br>
2.0 : 1 &lt;= x &lt; 10<br>
-0.5 : x mniejsze od zera<br>
-10000.0 : x mniejsze od zera<br>
</div><br>
<br>
<br>
Korzystaj¹c z klasy ChoiceFormat czasem wygodnie bêdzie pos³u¿yæ siê wzorcem formatowania.<br>
Wzorzec definiujemy w postaci ³añcucha znakowego (String):<br>
<br>
liczba sep napis | liczba sep napis | liczba sep napis ....<br>
<br>
gdzie kolejne, rozdzielone znakiem | fragmenty okreœlaj¹ kojarzone przedzia³ów
i napisów, a jako separatora (sep) mo¿emy u¿yæ znaków # lub &lt;.<br>
<br>
Wzorzec podajemy jako argument konstruktora klasy ChoiceFormat.<br>
<br>
Wyjaœnia to przyk³adowy program.<br>
<pre>import javax.swing.*;
import java.text.*;

public class ChoiceForm2 {

  public static void main(String[] args) {
    String pattern =
     "0#brak jablek |0&lt;niecala polowa jablka |"+
     "0.5#rowno pol jablka | 0.5&lt;ponad polowa jablka |" +
     "1#jedno jablko |1&lt;niecale dwa jablka |" +
     "2#dwa jablka |2&lt;wiecej ni¿ dwa jablka";

    ChoiceFormat cf = new ChoiceFormat(pattern);
    String in;
    while ((in = JOptionPane.showInputDialog("Ile jest jab³ek?")) != null) {
      double x = Double.parseDouble(in);
      String out = cf.format(x);
      System.out.println("Podano: " + x + " Wynik: " +  out);
    }
  }

}
</pre>
a jego mo¿liwy wynik wyhl¹da nastêpuj¹co:<br>
<div class="listing100"><br>
Podano: 0.0 Wynik: brak jablek<br>
Podano: 0.1 Wynik: niecala polowa jablka<br>
Podano: 0.5 Wynik: rowno pol jablka<br>
Podano: 0.6 Wynik: ponad polowa jablka<br>
Podano: 1.0 Wynik: jedno jablko<br>
Podano: 1.7 Wynik: niecale dwa jablka<br>
Podano: 2.0 Wynik: dwa jablka<br>
Podano: 2.1 Wynik: wiecej ni¿ dwa jablka<br>
Podano: 3.0 Wynik: wiecej ni¿ dwa jablka<br>
Podano: -1.0 Wynik: brak jablek<br>
</div><br>
<br>
Klasa ChoiceFormat jest szczególnie u¿yteczna przy internacjonalizacji napisów
w programie z wykorzystaniem kalsy MessageFormat - o czym bêdziemy mówiæ
dalej.<br>
<br>
<div class="notel">Uwaga: aby korzystaæ z klas pakietów ICU nale¿y udostêpniæ archiwum
JAR z tymi pakietami. Mo¿emy to uczyniæ na kilka sposobów:<br>
<ul>
  <li>umieœciæ archiwum w katalogu javax katalogu instalacyjnego Javy (wtedy
biblioteka ICU stanie siê standardowym rozszerzeniem - inaczej zwanym pakietem
opcjonalnym - i nasze progarmy bêd¹ mia³y do niej dostêp,</li>
  <li>umieœciæ nazwê archiwum JAR biblioteki ICU na œcie¿ce classpath,</li>
  <li>kompilowaæ i uruchamiaæ programy z opcj¹ -classpath, podaj¹c archiwum
JAR biblioteki ICU wraz z innymi elmentami œcie¿ki (%classpath%); przy uruchamianiu
klas z pakietu domyœlnego nie nale¿y zapomnieæ o podaniu jako elementu œcie¿ki
bie¿¹cego katalogu, oznaczanego kropk¹,</li>
</ul>
</div>W&nbsp;bibliotekach ICU4J znajdziemy znacznie bardziej
zaawansowany odpowiednik&nbsp; klasy ChoiceFormat - klasê&nbsp;
RuleBasedNumberFormat.<br>
Pozwala ona na formatowanie liczb za pomoc¹ definiowania zestawów regu³.<br>
Przyk³adowe zdefiniowane ju¿ regu³y dla formatora RuleBasedNumber to:<br>
<ul>
  <li>SPELLOUT - przedstawianie liczb w postaci s³ownej,</li>
  <li>ORDINAL - przedstawianie liczb jako liczebników porz¹dkowych (z odpowiednimi koñcówkami),</li>
  <li>DURATION -&nbsp; przekszta³canie liczb na jednostki czasu (godziny, minuty, sekundy).</li>
</ul>
Te regu³y s¹ ju¿ gotowe dla niektórych lokalizacji, nic nie stoi te¿ na przeszkodzie,
by tworzyæ w³asne regu³y (np. dla innych lokalizacji lub ca³kiem innego rodzaju).<br>
Opis sposobów definiowania regu³ zawarty jest w dokumentacji ICU4J, tu przyjrzymy
siê tylko przyk³adowym zastosowaniom gotowych regu³.<br>
<br>
Poni¿szy program pokazuje najpierw s³owny opis liczb w ró¿nych lokalizacjach
(niestety formator SPELLOUT nie jest spolszczony), po czym liczby porz¹dkowe
oraz czas (ale tylko po angielsku, bo formatory ORDINAL i DURATION nie s¹
zlokalizowane dla wiêkszoœci innych jezyków).<br>
<br>
<pre>import com.ibm.icu.text.*;  // podpakiet ICU - dla RuleBasedNumberFormat
import java.util.*;         // Locale
import javax.swing.*;       // JOptionPane


class RuleBasedNumberFormatTest {

  public static void main(String[] args) {

    // Lokalizacje
    Locale[] loc = { new Locale("en"),
                     new Locale("es"),
                     new Locale("de"),
                     new Locale("ru"),
                   };

    // Tablica formatorów typu SPELLOUT - dla ka¿dej lokalizacji jeden
    RuleBasedNumberFormat[] rbnfSpell =
                            new RuleBasedNumberFormat[loc.length];

    // Utworzenie formatorów SPELLOUT
    for (int i= 0; i &lt; loc.length; i++) {
      rbnfSpell[i] = new RuleBasedNumberFormat(
                         loc[i], RuleBasedNumberFormat.SPELLOUT
                     );
    }

    // Wartoœci do formatowania
    long[] values = { 5, 9, 10, 12, 20, 23, 111, 1001 };

    // Jako SPELLOUT
    show(values, rbnfSpell);

    // Jako liczby porz¹dkowe - tylko angielskie
    show(values,
         new NumberFormat[] { new RuleBasedNumberFormat(
                                 loc[0], RuleBasedNumberFormat.ORDINAL
                              )
                            }
        );

    // Formatowanie czasów wyra¿onych w sekundach
    // Tylko lokalizacja angielska
    long[] times = { 12, 800, 3712, 9600 };
    show(times,
         new NumberFormat[] { new RuleBasedNumberFormat(
                                  loc[0], RuleBasedNumberFormat.DURATION
                              )
                            }
    );
    System.exit(0);
  }

  // Ogólna metoda formatuj¹ca i pokazuj¹ca wyniki
  // Argumenty: tablica liczb do sformatowania
  //            tablica formatorów

  static void show(long[] val, NumberFormat[] rbnf) {
    String msg = "";
    for (int i=0; i &lt; val.length; i++) {
      msg += "\n" + val[i];
      for (int j=0; j&lt;rbnf.length; j++) {
        msg += " = " + rbnf[j].format(val[i]);
      }
    }
    JOptionPane.showMessageDialog(null, msg);
  }

}
</pre>
Wyniki dzia³ania programu pokazuj¹ kolejne rysunki.<br>
<br>
<img src="images/rbnf1.jpg" alt="r" border="1" height="246" width="504">
<br>
<br>
<img src="images/rbnf2.jpg" alt="r" align="left" border="1" height="246" width="268">
<img src="images/rbnf3.jpg" alt="r" align="right" border="1" height="170" width="268">
<br>
&nbsp; <br>
<br>
<br>
<br>
<br>
 
 
 
Omawiane formatory potrafi¹ wykonywaæ operacje odwrotne, np. przekszta³caæ
liczby wyra¿one s³ownie na ich wartoœci, a przy tym mo¿liwe jest ustawienie
opcji "lenientParse", która "luŸno" traktuje napisy (s³owne wyra¿enie liczb
mo¿e byæ ró¿ne np. ze spacjami, z myœlnikami, w ogóle bez znaków rozdizielaj¹cych
s³owa, z ró¿n¹ wielkoœci¹ liter itp.).<br>
<br>
Zobaczmy przyk³ad. Poni¿szy program "umie" odczytaæ s³owne (angielskie) opisy liczb i przekszta³ciæ je w liczby.<br>
<br>
<pre>import com.ibm.icu.text.*;  // podpakiet ICU - dla RuleBasedNumberFormat
import java.util.*;         // Locale
import java.text.*;         // ParsePosition
import javax.swing.*;       // JOptionPane


class LenientParseTest {

  public static void main(String[] args) {

    // formator typu SPELLOUT
    RuleBasedNumberFormat rbnf = new RuleBasedNumberFormat(
                                     new Locale("en"),
                                     RuleBasedNumberFormat.SPELLOUT
                                 );

    // Ustalenie "luŸnego" parsowania
    rbnf.setLenientParseMode(true);

    // Wartoœci do parsowania
    String[] snum = { "twenty-one", "TWENTYone",
                      "one hundred and one",
                      "one-hundred-and-one",
                      "one-hundred AND one",
                    };

    // Przekszta³cenie opisów na liczby

    for (int i=0; i&lt; snum.length; i++) {
      Number val = rbnf.parse(snum[i], new ParsePosition(0));
      System.out.println(snum[i] + "   =   " + val);
    }

  }

}
</pre>
<br>
Wynik programu:<br>
<div class="listing100"><br>
twenty-one&nbsp;&nbsp; =&nbsp;&nbsp; 21<br>
TWENTYone&nbsp;&nbsp; =&nbsp;&nbsp; 21<br>
one hundred and one&nbsp;&nbsp; =&nbsp;&nbsp; 101<br>
one-hundred-and-one&nbsp;&nbsp; =&nbsp;&nbsp; 101<br>
one-hundred AND one&nbsp;&nbsp; =&nbsp;&nbsp; 101<br>
</div><br>
<br>
Formator parsuje równie¿ liczby opisywane w innych popularnych jêzykach.<br>
<br>

<a name="Intern.3"></a><h2>3. Waluty</h2>

Klasa Currency z pakietu java.util opisuje waluty. Obiekty tego typu s¹ wykorzystywane
przez klasê DecimalFormat i mo¿emy je np. stosowaæ dla zmiany formatów walutowych
(metoda setCurrency(Currency) z klasy DecimalFormat).<br>
<br>
Klasa Currency mo¿e byæ u¿yteczna w ró¿nych sytuacjach.<br>
WyobraŸmy sobie taki scenariusz: mamy stworzyæ aplikacjê, która generuje
raporty o aktualnych kursach wybranych walut w kilku jêzykach. Aktualne kursy
pobieramy z jakiegoœ serwisu WEB na podstawie podanych miêdzynarodowych symboli
walut.<br>
Aby taki program mo¿na by³o napisaæ, trzeba wiedzieæ jakie s¹ symbole
walut i umieæ&nbsp; t³umaczyæ symbole walut na wybrane jêzyki.<br>
<br>
Informacje, które mo¿na uzyskaæ o walutach przedstawia w syntetycznej postaci poni¿szy program.<br>
<br>
<pre>import java.util.*;

public class Waluty {

  public static void main(String[] args) {
    // Domyœlna lokalizacja (w naszym przypadku polska)
    Locale def = Locale.getDefault();

    // Tablica dostêpnych lokalizacji
    Locale[] loc = Locale.getAvailableLocales();

    char[] zera = { '0', '0', '0', '0', '0', '0' }; // do pokazu walut

    for (int i=0; i&lt;loc.length; i++) {
      String countryCode = loc[i].getCountry();  // kod kraju
      String langCode = loc[i].getLanguage();    // kod jêzyka
      if (countryCode.equals("")) continue;

      // lokalizacja opisana w jêzyku domyœlnej lokalizacji (polskim)
      String kraj =  loc[i].getDisplayCountry(def);
      String jezyk = loc[i].getDisplayLanguage(def);

      // Waluta dla lokalizacji loc[i]
      Currency c = Currency.getInstance(loc[i]);
      String sym  =  c.getSymbol();      // symbol w domyœlnej lokalizacji (pl)
      String nsym = c.getSymbol(loc[i]); // symbol w danym kraju
      String icode = c.getCurrencyCode();     // miêdzynarod. kod waluty
      int cdig = c.getDefaultFractionDigits(); // ile mo¿e byæ miejsc dzies.

      System.out.println(loc[i]+" kraj: "+kraj+" jêzyk: "+jezyk +
        "\nwaluta: "+sym+" "+nsym+" "+icode +
                   " grosz = 1/1"+new String(zera,0,cdig)+" "+sym +
        "\n============================================================"
        );
     }
  }

}</pre>
Warto zwróciæ uwagê na informacjê jaka jest minimalna czeœæ podstawowej jednostki
pieniê¿nej (tu nazwaliœmy to "groszem"), uzyskiwan¹ za pomoc¹ metody getFractionDigits().<br>
&nbsp;<br>
Fragment wydruku dzia³ania programu przedstawiono poni¿ej:<br>
<div class="listing100"><br>
es_VE kraj: Wenezuela jêzyk: hiszpañski<br>
waluta: VEB Bs VEB grosz = 1/100 VEB<br>
============================================================<br>
et_EE kraj: Estonia jêzyk: estoñski<br>
waluta: EEK kr EEK grosz = 1/100 EEK<br>
============================================================<br>
fi_FI kraj: Finlandia jêzyk: fiñski<br>
waluta: EUR ? EUR grosz = 1/100 EUR<br>
============================================================<br>
fr_BE kraj: Belgia jêzyk: francuski<br>
waluta: EUR ? EUR grosz = 1/100 EUR<br>
============================================================<br>
fr_CA kraj: Kanada jêzyk: francuski<br>
waluta: CAD $ CAD grosz = 1/100 CAD<br>
============================================================<br>
fr_CH kraj: Szwajcaria jêzyk: francuski<br>
waluta: CHF SFr. CHF grosz = 1/100 CHF<br>
============================================================<br>
hu_HU kraj: Wêgry jêzyk: wêgierski<br>
waluta: HUF Ft HUF grosz = 1/100 HUF<br>
============================================================<br>
is_IS kraj: Islandia jêzyk: islandzki<br>
waluta: ISK kr. ISK grosz = 1/100 ISK<br>
============================================================<br>
ja_JP kraj: Japonia jêzyk: japoñski<br>
waluta: JPY ? JPY grosz = 1/1 JPY<br>
============================================================<br>
ko_KR kraj: Korea Po³udniowa jêzyk: koreañski<br>
waluta: KRW ? KRW grosz = 1/1 KRW<br>
============================================================<br>
pl_PL kraj: Polska jêzyk: polski<br>
waluta: z³ z³ PLN grosz = 1/100 z³<br>
============================================================<br>
pt_BR kraj: Brazylia jêzyk: portugalski<br>
waluta: BRL R$ BRL grosz = 1/100 BRL<br>
============================================================<br>
pt_PT kraj: Portugalia jêzyk: portugalski<br>
waluta: EUR ? EUR grosz = 1/100 EUR<br>
</div><br>
<br>
Pakiet ICU dostarcza dodatkowych mo¿liwoœci, gdy chodzi o waluty. M.in. mo¿emy
uzyskaæ bardziej opisow¹, stosowan¹ w podanej lokalizacji nazwê waluty. Pokazuje
to poni¿szy program.<br>
<pre>import javax.swing.*;
import java.awt.*;
import java.util.Locale;
import com.ibm.icu.util.Currency;


public class Waluty1 {

  public static void main(String[] args) {

    Locale def = Locale.getDefault();
    Locale en =  new Locale("en", "US");


    // Tablica dostêpnych lokalizacji
    Locale[] loc = Currency.getAvailableLocales();


    boolean[] b  = { false }; // dla getName() - oznacza normalny wynik
                              // w przeciwieñstwie do wyniku dla ChoiceFormat

    String out = "";

    for (int i=0; i&lt;loc.length; i++) {
      String kraj =  loc[i].getDisplayCountry(def);
      if (kraj.equals("")) continue;
      String lang = loc[i].getDisplayLanguage(def);
      String variant = loc[i].getVariant();

      // Waluta dla lokalizacji loc[i]
      Currency c = Currency.getInstance(loc[i]);

      String icode = c.getCurrencyCode();     // miêdzynarod. kod waluty

      // symbol w danym kraju
      String sym  =  c.getName(loc[i], Currency.SYMBOL_NAME, b);
      // nazwa w danym kraju
      String name = c.getName(loc[i], Currency.LONG_NAME, b);
      // nazwa po angielsku
      String enName = c.getName(en, Currency.LONG_NAME, b);


      out += kraj + " " + lang + " " + variant +
        "\nwaluta: "+icode+" "+sym+
        "\n"+ name + '\n' + enName +
        "\n------------------------------------------\n";
     }

     JFrame f = new JFrame();
     JTextArea ta = new JTextArea();
     ta.setFont(new Font("Dialog", Font.BOLD, 14));
     ta.setText(out);
     f.getContentPane().add(new JScrollPane(ta));
     f.pack();
     f.show();
  }

}
</pre>
<br>
<br>
Uwaga: aby móc bez problemów odczytywaæ znaki Unikosu wyniki pokazujemy w
polue tekstowym JTextArea (o programowaniu graficznych interfejsów u¿ytkownika
zob. czêœæ D ksi¹¿ki)<br>
Fragmenty wyników dzia³ania programu prezentuje poni¿szy rysunek.<br>
<br>
<img src="images/icucurr.jpg" alt="r" border="1" height="385" width="414">
<br>
<br>
<br>
<br>

<a name="Intern.4"></a><h2>4. Strefy czasowe</h2>
Strefy czasowe s¹ przedstawiane przez obiekty klasy TimeZone z pakietu java.util.<br>
Aby uzyskaæ aktualn¹, domyœln¹ dla komputera na którym dzia³a nasz program,
strefê czasow¹ stosujemy statyczn¹ metodê getDefault() z klasy TimeZone.<br>
O strefie czasowej mo¿emy dowiedzieæ siê wielu interesuj¹cych informacji, co pokazuje poni¿szy program.<br>
<pre>import java.util.*;

public class Strefy0 {

  public static void main(String[] args) {
    TimeZone tz = TimeZone.getDefault();

    // --- Informacje o strefie czasowej

    // identyfikator strefy
    String id = tz.getID();

    // ró¿nica wzglêdem czasu standardowego (UCT)
    int diff = tz.getRawOffset();

    // czy strefa u¿ywa czasu letniego
    boolean useDST = tz.useDaylightTime();

    // ile czasu trzeba dodaæ do lokalnego zegara
    // aby uzyskaæ czas bez ew. przesuniêcia letniego
    int dstSav = tz.getDSTSavings();

    // Nazwa strefy
    String defName = tz.getDisplayName();

    // Krótka nazwa strefy
    String shortName = tz.getDisplayName(useDST, TimeZone.SHORT);

    // Nazwa strefy w podanym jêzyku
    String locName = tz.getDisplayName(new Locale("fr"));

    // Dluga nazwa strefy
    String fullName = tz.getDisplayName(useDST, TimeZone.LONG);

    // D³uga nazwa strefy w podanym jêzyku
    String locFullName = tz.getDisplayName(useDST, TimeZone.LONG,
                         new Locale("es"));

    // Jaka jest aktualna ró¿nica czasu TERAZ wobec UCT,
    // z uwzglêdnieniem czasu letniego
    Date teraz = new Date();
    long ms = teraz.getTime();
    int offset = tz.getOffset(ms);


    System.out.println("ID = " + id);
    System.out.println("RawOffset = " + diff);
    System.out.println("useDaylightTime = " + useDST);
    System.out.println("DSTSavings = " + dstSav);
    System.out.println("DisplayName = " + defName);
    System.out.println("DisplayName short = " + shortName);
    System.out.println("DisplayName full = " + fullName);
    System.out.println("DisplayName locale(\"fr\") = " + locName);
    System.out.println("DisplayName full locale(\"es\") = " + locFullName);
    System.out.println("Offset = " + offset);
  }

}
</pre>
i jego wyniki:<br>
<div class="listing100"><br>
ID = Europe/Belgrade<br>
RawOffset = 3600000<br>
useDaylightTime = true<br>
DSTSavings = 3600000<br>
DisplayName = Central European Time<br>
DisplayName short = CEST<br>
DisplayName full = Central European Summer Time<br>
DisplayName locale("fr") = Heure d'Europe centrale<br>
DisplayName full locale("es") = Hora de verano de Europa Central<br>
Offset = 7200000<br>
</div><br>
<br>
Uwagi: <br>
<ul>
  <li>identyfikatory stref s¹ podawane w ró¿nej postaci, najczeœciej: region/miasto;
trzyliterowe identyfikatory stref czasowych (takie jak np. CET, AST, CST)
s¹ równie¿ dostêpne, ale nie powinny byæ u¿ywane ze wzglêdu na niejednoznacznoœæ
(CST - to zarówno U.S. Central Standard Time jak i China Standard Time); UTC,
GMT i Zulu - oznaczaj¹ czas standardowy;</li>
  <li>nasza strefa czasowa - to czas œrodkowoeuropejski, maj¹cy tu pierwszy dostêpny identyfikator Europe/Belgrad,</li>
  <li>ró¿nice czasu podawane s¹ w milisekundach,</li>
  <li>raw offset - pokazuje aktualn¹ ró¿nicê wobec czasu standardowego (UTC)
bez uwzglêdnienia przesuniêcia czasu letniego; jest to czas, który trzeba
dodaæ do UTC, aby uzyskaæ "prawdziw¹" godzinê&nbsp; (nie przesuniêt¹ z uwagi na czas letni)</li>
  <li>ró¿nica czasu dla podanej daty wobec UTC z uwzglêdnieniem czasu letniego pokazywana jest przez metodê getOffset().</li>
</ul>
W naszym programie mo¿emy skonstruowaæ dowoln¹ strefê czasow¹, u¿ywaj¹c metody
TimeZone.getTimeZone(String ID) i podaj¹c jako argument identyfikator strefy
czasowej.<br>
Listê dostêpnych identyfikatorów mo¿na uzyskaæ jako tablicê Stringów za pomoca odwo³ania TimeZone.getAvailableIDs().<br>
<br>
Poni¿szy przyk³adowy programik pokazuje jak mo¿na wyliczyæ aktualn¹ ró¿nicê
czasu pomiêdzy podanymi strefami czasowymi oraz jak mo¿na dowiedzieæ siê
jakie strefy czasowe maj¹ podan¹ ró¿nicê czasu wobec GMT.<br>
<br>
<pre>import java.util.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class Strefy1 {

  public static void main(String[] args) {

    // Konstruowanie stref czasowych
    TimeZone myTz = TimeZone.getTimeZone("Europe/Warsaw");
    TimeZone java = TimeZone.getTimeZone("Asia/Jakarta");
    TimeZone cuba = TimeZone.getTimeZone("America/Havana");

    // za pomoc¹ pokazanej dalej metody getDiffMsg
    // wyliczamy i pokazujemy aktualn¹ ró¿nicê czasu
    // pomiêdzy sterfami czasowymi

    System.out.println(getDiffMsg(myTz, java));
    System.out.println("--------------------------------------------------");
    System.out.println(getDiffMsg(myTz, cuba));
    System.out.println("--------------------------------------------------");
    System.out.println(getDiffMsg(cuba, java));
    System.out.println("--------------------------------------------------");

    // Jakie strefy czasowe maj¹ podan¹ ró¿nicê czasu wobec GMT

   for (int k = 12; k &lt;= 14; k++) {
     String[] ids = TimeZone.getAvailableIDs(k*3600000);
     Arrays.sort(ids);
     System.out.println(
      "Strefy czasowe maj¹ce ró¿nice +" + k + " godzin wobec GMT" );
     for (int i=0; i &lt; ids.length; i++) {
       System.out.println(ids[i]);
     }
     System.out.println("--------------------------------------------------");
   }
  }

  static String getDiffMsg(TimeZone z1, TimeZone z2) {
    Date data = new Date();
    long teraz = data.getTime();
    double offset1 = z1.getOffset(teraz)/3600000.0;
    double offset2 = z2.getOffset(teraz)/3600000.0;
    double diff;
    if (offset1 &gt; offset2)  diff = -(offset1 - offset2);
    else diff = offset2 - offset1;
    String out =  "Ró¿nica czasu pomiêdzy" + '\n' +
                  z1.getID() + " i " + z2.getID()  + '\n' +
                  "wynosi teraz : " + diff + " godz."  + '\n' +
                  "W strefie " + z1.getID() +
                       (z1.inDaylightTime(data) ? " " : " nie ") +
                       "dzia³a czas letni"  + '\n' +
                  "W strefie " + z2.getID() +
                       (z2.inDaylightTime(data) ? " " : " nie ") +
                       "dzia³a czas letni";

    return out;
  }

}
</pre>
Wydruk:<br>
<div class="listing100"><br>
Ró¿nica czasu pomiêdzy<br>
Europe/Warsaw i Asia/Jakarta<br>
wynosi teraz : 5.0 godz.<br>
W strefie Europe/Warsaw dzia³a czas letni<br>
W strefie Asia/Jakarta nie dzia³a czas letni<br>
--------------------------------------------------<br>
Ró¿nica czasu pomiêdzy<br>
Europe/Warsaw i America/Havana<br>
wynosi teraz : -6.0 godz.<br>
W strefie Europe/Warsaw dzia³a czas letni<br>
W strefie America/Havana dzia³a czas letni<br>
--------------------------------------------------<br>
Ró¿nica czasu pomiêdzy<br>
America/Havana i Asia/Jakarta<br>
wynosi teraz : 11.0 godz.<br>
W strefie America/Havana dzia³a czas letni<br>
W strefie Asia/Jakarta nie dzia³a czas letni<br>
--------------------------------------------------<br>
Strefy czasowe maj¹ce ró¿nice +12 godzin wobec GMT<br>
Antarctica/McMurdo<br>
Antarctica/South_Pole<br>
Asia/Anadyr<br>
Asia/Kamchatka<br>
Etc/GMT-12<br>
Kwajalein<br>
NST<br>
NZ<br>
Pacific/Auckland<br>
Pacific/Fiji<br>
Pacific/Funafuti<br>
Pacific/Kwajalein<br>
Pacific/Majuro<br>
Pacific/Nauru<br>
Pacific/Tarawa<br>
Pacific/Wake<br>
Pacific/Wallis<br>
--------------------------------------------------<br>
Strefy czasowe maj¹ce ró¿nice +13 godzin wobec GMT<br>
Etc/GMT-13<br>
Pacific/Enderbury<br>
Pacific/Tongatapu<br>
--------------------------------------------------<br>
Strefy czasowe maj¹ce ró¿nice +14 godzin wobec GMT<br>
Etc/GMT-14<br>
Pacific/Kiritimati<br>
--------------------------------------------------<br>
</div> 

<a name="Intern.5"></a><h2>5. Kalendarze</h2>



Informacje o datach i czasie s¹ w Javie reprezentowane przez obiekty klasy Calendar.<br>
<br>


<div class="syntax">Informacje o bie¿¹cej dacie i czasie mo¿emy uzyskaæ m.in. za pomoc¹ odwo³ania:<br>
<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Calendar c = Calendar.getInstance();<br>
<br>
   które zwraca obiekt - domyœlny kalendarz dla domyœlnej lokalizacji
ustawiony na bie¿¹c¹ datê i czas w strefie czasowej w³aœciwej dla domyœlnej
lokalizacji.<br>


</div><br>
<br>


Informacje o dacie i czasie s¹ zapisane w polach obiektu-kalendarza. Dostêp do tych pól uzyskujemy za pomoc¹ metody <b>get(...)</b>
 , u¿ytej na rzecz obiektu-kalendarza, z argumentem - sta³¹ statyczn¹ klasy
Calendar, okreslaj¹c¹ o jaki rodzaj informacji nam chodzi. Oprócz tego pewne
informacje, zwi¹zane z w³aœciwoœciami danego kalendarza lub dla danej lokalizacji
mo¿na uzyskaæ za pomoc¹ innych metod get... (np. jaki jest pierwszy dzieñ
tygodnia - niedziela czy poniedzia³ek - getFirstDayOfWeek()).<br>
<br>


Przyk³adowy program spe³nia funkcjê przewodnika po polach kalendarza,&nbsp; pokazuj¹
ich znaczenie oraz sposoby uzyskiwania ich wartoœci.<br>
<br>
<pre>import java.util.*;

public class Kal1 {

  public static void say(String s) { System.out.println(s+'\n'); }

  public static void main(String[] args) {

    // uzyskanie kalendarza domyœlnego
    // (obowi¹zuj¹cgo dla domyœlnej lokalizacji - tu dla Polski)
    // ustawionego na bie¿¹c¹ datê i czas

    <b>Calendar cal = Calendar.getInstance()</b>;

    say("ERA.............. " + <b>cal.get(Calendar.ERA)</b> +
        " (tu: 0=pne, 1=AD)");

    say("ROK.............. " + <b>cal.get(Calendar.YEAR)</b>);
    say("MIESI¥C.......... " + <b>cal.get(Calendar.MONTH)</b> +
        " (0-styczeñ, 2-luty, ..., 11-grudzieñ)");

    say("LICZBA DNI\n" +
        "W MIESI¥CU....... " + <b>cal.getActualMaximum(Calendar.DAY_OF_MONTH)</b>);

    say("DZIEÑ MIESI¥CA... " + <b>cal.get(Calendar.DAY_OF_MONTH)</b>);
    say("DZIEÑ MIESI¥CA... " + <b>cal.get(Calendar.DATE)</b>);
    say("TYDZIEÑ ROKU..... " + <b>cal.get(Calendar.WEEK_OF_YEAR)</b><b>)</b>;
    say("TYDZIEÑ MIESI¥CA. " + <b>cal.get(Calendar.WEEK_OF_MONTH)</b>);
    say("DZIEÑ W ROKU..... " + <b>cal.get(Calendar.DAY_OF_YEAR)</b>);

    say("PIERWSZY DZIEÑ\n" +
        "TYGODNIA......... " + <b>cal.getFirstDayOfWeek()</b> +
        " (1-niedziela, 2-poniedzia³ek, ..., 7 sobota)");

    say("DZIEÑ TYGODNIA... " + <b>cal.get(Calendar.DAY_OF_WEEK)</b> +
        " (1-niedziela, 2-poniedzia³ek, ..., 7-sobota)");

    say("GODZINA.......... " + <b>cal.get(Calendar.HOUR)</b> +
        " (12 godzinna skala; nastêpne odwolanie czy AM czy PM)");

    say("AM/PM............ " + <b>cal.get(Calendar.AM_PM)</b> +
        " (AM=0, PM=1)");

    say("GODZINA.......... " + <b>cal.get(Calendar.HOUR_OF_DAY)</b> +
        " (24 godzinna skala)");

    say("MINUTA........... " + <b>cal.get(Calendar.MINUTE)</b>);
    say("SEKUNDA.........  " + <b>cal.get(Calendar.SECOND)</b>);
    say("MILISEKUNDA:      " + <b>cal.get(Calendar.MILLISECOND)</b>);

    int msh = 3600*1000; // liczba milisekund w godzinie

    say("RÓ¯NICA CZASU\n" +
        "WOBEC GMT........ " + <b>cal.get(Calendar.ZONE_OFFSET</b>)/msh);

    say("PRZESUNIÊCIE\n" +
        "CZASU............ " + <b>cal.get(Calendar.DST_OFFSET)</b>/msh +
        " (w Polsce obowi¹zuje w lecie)");

  }

}
</pre>


Na wydruku pokazano wyniki dzia³ania programu, uruchomionego we wtorek 6 maja 2003 roku o godzinie 18:05:00.<br>


Wydruk:<br>
<pre>ERA.............. 1 (tu: 0=pne, 1=AD)

ROK.............. 2003

MIESI¥C.......... 4 (0-styczeñ, 2-luty, ..., 11-grudzieñ)

LICZBA DNI
W MIESI¥CU....... 31

DZIEÑ MIESI¥CA... 6

DZIEÑ MIESI¥CA... 6

TYDZIEÑ ROKU..... 19

TYDZIEÑ MIESI¥CA. 2

DZIEÑ W ROKU..... 126

PIERWSZY DZIEÑ
TYGODNIA......... 2 (1-niedziela, 2-poniedzia³ek, ..., 7 sobota)

DZIEÑ TYGODNIA... 3 (1-niedziela, 2-poniedzia³ek, ..., 7-sobota)

GODZINA.......... 6 (12 godzinna skala; nastêpne odwolanie czy AM czy PM)

AM/PM............ 1 (AM=0, PM=1)

GODZINA.......... 18 (24 godzinna skala)

MINUTA........... 5

SEKUNDA.........  0

MILISEKUNDA:      550

RÓ¯NICA CZASU
WOBEC GMT........ 1

PRZESUNIÊCIE
CZASU............ 1 (w Polsce obowi¹zuje w lecie)

</pre>
Uwaga: nale¿y zwróciæ baczn¹ uwagê na to, ¿e indeksowanie miesiêcy rozpoczyna
siê od 0, a nie od 1 (czyli styczeñ ma numer 0). Jest to fatalny b³¹d, który
pope³niono w pierwszej wersji Javy, wprowadzaj¹c klasê Date. Twórcy klasy
Calendar (firma Taligent) mieli tego œwiadomoœæ, ale - by nie wprowadzaæ
jeszcze wiêkszego zamieszania - pozostawili tê bardzo myl¹c¹ konwencjê.<br>
<br>
Za pomoc¹ metod set... kalendarza mo¿emy ustawiaæ jego bie¿¹c¹ datê i czas.<br>


Np. aby ustawiæ kalendarz na 7 maja 2003 roku na tê sam¹ godzinê co "teraz" mo¿emy napisaæ:<br>
<br>


&nbsp;&nbsp;&nbsp; Calendar c = Calendar.getInstance();<br>


&nbsp;&nbsp;&nbsp; c.set(2003, 4, 7); &nbsp;// rok 2003, indeks miesi¹ca = 4 (maj), dzieñ 7<br>
<br>


a jeœli chcemy zarazem ustaliæ godzinê 18 minut 05 napiszemy:<br>
<br>


&nbsp;&nbsp;&nbsp; c.set(2003, 4, 7, 18, 5);<br>
<br>


Mo¿emy te¿ zmieniaæ (ustawiaæ) wartoœci poszczególnych pól.<br>


S³u¿¹ do tego metody, które wykonuj¹ operacje na datach.<br>
<br>


<div class="syntax">Operacje na datach wykonujemy za pomoc¹ nastêpuj¹cych metod:<br>
<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>set</b>(id_pola, &nbsp;wartoœæ)<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>add</b>(id_pola, wartoœæ)<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>roll</b>(id_pola, wartoœæ) <br>
<br>


&nbsp;&nbsp;&nbsp; gdzie:<br>

 &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; id_pola - sta³a statyczna z klasy
Calendar, okreœlaj¹ca pole na którym wykonywana jest oparacja,<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; wartoœæ - nowa wartoœæ pola.<br>


</div><br>
<br>


Wszystkie w/w operacje uwzglêdniaj¹ regu³y danego kalendarza, a ró¿nica pomiêdzy nimi jest nastêpuj¹ca:<br>
<ul>
<li>set - ustala wartoœæ pola; jeœli trzeba&nbsp; dostosowuj¹c inne pola (np.
ustawienie pola DAY_OF_MONTH na wartoœæ 31 dla kalendarza ustawionego na
dowoln¹ datê w czerwcu spowoduje, ¿e kalendarz bêdzie wskazywa³ na 1 lipca,
gdy¿ w czerwcu jest tylko 30 dni),</li><li>add&nbsp; - dodaje do pola podan¹ wartoœæ, stosuj¹c przy tym arytmetykê
kalendarzow¹ (np. dodanie do 30 maja 2 dni spowoduje ustawienie kalendarza
na &nbsp;1 czerwca),</li><li>roll - równie¿ wykonuje dodawanie, ale przy tym nie zmienia wartoœci
"starszych" pól np. je¿eli dodajemy dni i oka¿e siê, ¿e nowa data znajdzie
siê w innym ni¿ teraz miesi¹cu, to miesi¹c nie zostanie zmieniony, zaœ "nadwy¿ka"
dni (poza koñcem bie¿¹cego miesi¹ca) bêdzie dodawana od pocz¹tku miesi¹ca.</li>
</ul>


Dok³adne regu³y obliczeniowe s¹ podane w dokumentacji klasy Calendar. <br>


Przyk³adowy program na wydruku testuje dzia³anie omówionych metod.<br>
<br>
<pre>import java.util.*;
import javax.swing.*;

public class TestKal {

  public static void main(String[] args) {
    String in;
    int d = 0;
    while ((in = JOptionPane.showInputDialog("DATE:")) != null) {
      d = Integer.parseInt(in);
      show("set",  "DATE", Calendar.DATE, d);
      show("add",  "DATE", Calendar.DATE, d);
      show("roll", "DATE", Calendar.DATE, d);
    }
    System.exit(0);
  }

  static void say(String s) { System.out.println(s); }


  static void show(String oper, String what, int field, int value) {
    Calendar c = Calendar.getInstance();
    say("Teraz jest: " + c.getTime());
    say("Operacja: " + oper + "(Calendar." + what + ", " + value + ")");
    if (oper.equals("set")) c.set(field, value);
    else if (oper.equals("add")) c.add(field, value);
         else if (oper.equals("roll")) c.roll(field,value);

    say("Aktualne ustawienia kalendarza: " + c.get(Calendar.YEAR) + '/'
                               + (c.get(Calendar.MONTH) + 1) + '/' +
                               + c.get(Calendar.DATE));
     say("-----------------------------------------------------------");
  }

}
</pre>


a wydruk jego dzialania (dla kilku wprowadzonych wartoœci pola Calendar.DATE, okreslaj¹cego dzieñ miesi¹ca)
ilustruje dzia³anie metod set, add i roll oraz róznice miêdzy nimi:<br>


<div class="listing100"><br>


Teraz jest: Mon May 05 07:27:43 CEST 2003<br>


Operacja: set(Calendar.DATE, 7)<br>


Aktualne ustawienia kalendarza: 2003/5/7<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:43 CEST 2003<br>


Operacja: add(Calendar.DATE, 7)<br>


Aktualne ustawienia kalendarza: 2003/5/12<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:43 CEST 2003<br>


Operacja: roll(Calendar.DATE, 7)<br>


Aktualne ustawienia kalendarza: 2003/5/12<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:55 CEST 2003<br>


Operacja: set(Calendar.DATE, 31)<br>


Aktualne ustawienia kalendarza: 2003/5/31<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:55 CEST 2003<br>


Operacja: add(Calendar.DATE, 31)<br>


Aktualne ustawienia kalendarza: 2003/6/5<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:55 CEST 2003<br>


Operacja: roll(Calendar.DATE, 31)<br>


Aktualne ustawienia kalendarza: 2003/5/5<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:58 CEST 2003<br>


Operacja: set(Calendar.DATE, 32)<br>


Aktualne ustawienia kalendarza: 2003/6/1<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:58 CEST 2003<br>


Operacja: add(Calendar.DATE, 32)<br>


Aktualne ustawienia kalendarza: 2003/6/6<br>


-----------------------------------------------------------<br>


Teraz jest: Mon May 05 07:27:58 CEST 2003<br>


Operacja: roll(Calendar.DATE, 32)<br>


Aktualne ustawienia kalendarza: 2003/5/6</div><br>
<b><i>Uwaga: CEST oznacza Central European Summer Time</i></b><br>
<br>


Zwróæmy uwagê na metodê getTime(). Wykorzystano j¹ w omawianym programie,
by ³atwo wypisaæ datê i czas w jakiejœ ludzkiej postaci,<br>


Metoda ta zwraca obiekt klasy <b>Date</b>, reprezentuj¹cy datê i czas dla danego ustawienia kalendarza. <br>
Klasa
ta w dawnych wersjach Javy by³a stosowana do dzialania na datach i czasie,
ale poniewa¿ nie by³a ona zlokalizowana ani nie uwzglêdnia³a mo¿liwoœc istnienia
ró¿nych kalendarzy, to w tej chwili wiêkszoœæ jej metod &nbsp;jest zdezaktualizowana
i zamiast nich nale¿y stosowaæ metody klasy Calendar.<br>


Jednak klasa Date nadal jest&nbsp; przydatna, bo neiktóre mteody wymagaj¹ jej jako argumentu. <br>
<br>
<br>
Mówiliœmy ju¿ o tym, ¿e Calendar.getInstance() zwraca domyœlny kalendarz
dla domyœlnej lokalizacji i zwi¹zanej z ni¹ strefy czasowej.<br>
Mo¿emy te¿ uzyskaæ inne kalendarze:<br>
<ul>
  <li>dla domyœlnej lokalizacji, ale ustawiony na podan¹ strefê czasow¹ (Calendar.getInstance(TimeZone)),</li>
  <li>dla podanej lokalizacji (Calendar.getInstance(Locale)),</li>
  <li>dla podanej lokalizacji i strefy czasowej (Calendar.getInstance(TimeZone,Locale)),</li>
</ul>
Oto prosty przyk³ady. <br>
W poni¿szym fragmencie kodu:<br>
<pre>    TimeZone tz = TimeZone.getTimeZone("Asia/Jakarta");
    Calendar c = Calendar.getInstance(tz);
    System.out.println("Current time: " + c.getTime());
    System.out.println("Java time: " +
         c.get(Calendar.HOUR_OF_DAY) + ":" + c.get(Calendar.MINUTE));

</pre>
kalendarz ustawiany jest na strefê czasow¹ Javy (wyspy, nie jêzyka). Metoda
getTime() zwróæi&nbsp; aktualny czas w domyœlnej lokalizacji, ale pola kalendarza
s¹ ustawiane z uwzglêdnieniem ró¿nicy czasu.<br>
W wyniku otrzymamy.<br>
<div class="listing100">Current time: Fri Jul 18 12:44:47 CEST 2003<br>
Java time: 17:44</div><br>
<br>
Czym ró¿ni¹ siê kalendarze dla ró¿nych lokalizacji?<br>
Przede wszystkim rodzajem kalendarza. Klasa Calendar jest klas¹ abstrakcyjn¹.
Konkretne klasy kalendarzy s¹ jej podklasami. Najczêœciej spotkamy siê z
klas¹ GregorianCalendar (która reprezentuje kalendarz gregoriañski).<br>
Ale nawet w standardzie Javy znajdziemy te¿ inny kalendarz - mianowicie buddyjski
- w³aœciwy np. dla lokalizacji tajskiej. Zobaczmy.<br>
Nastêpuj¹cy fragment kodu:<br>
<pre>    Calendar c = Calendar.getInstance();
    System.out.println(c.getClass().getName());
    c = Calendar.getInstance(new Locale("th", "TH"));
    System.out.println(c.getClass().getName());
</pre>
wyprowadzi:<br>
<div class="listing100">java.util.GregorianCalendar<br>
sun.util.BuddhistCalendar<br>
</div><br>
<br>
Du¿o wiêcej kalendarzy znajdziemy w pakiecie ICU.<br>
Mamy tam kalendarze: buddyjski, tradycyjny chiñski, tradycyjny japoñski, islamski, hebrajski. <br>
<br>
Sposób u¿ycia tych kalendarzy oraz tó¿nice pomiêdzy nimi pokazuje poni¿szy program.<br>
<pre>import com.ibm.icu.util.*;
import com.ibm.icu.text.*;

public class MiscCal {

  public static void main(String[] args) {
    Calendar[] kal = {
               Calendar.getInstance(),   // domyœlny kalendarz - gregoriañski
               new GregorianCalendar(),  // jeszcze raz - ale inaczej tworzony
               new BuddhistCalendar(),   // buddyjski
               new ChineseCalendar(),    // chiñski
               new JapaneseCalendar(),   // japoñski
               new IslamicCalendar(),    // islamski
               new HebrewCalendar(),     // hebrajski
               };
    java.util.Date teraz = new java.util.Date(); // aktualny czas
    System.out.println("Teraz jest: " + teraz);  // po angielsku

    // przebiegamy po klaendarzach
    // ustawiamy je na bie¿¹cy czas
    // i pokazujemy wartoœci takich pól jak rok, miesi¹c itp.

    for (int i=0; i&lt;kal.length; i++) {
      kal[i].setTime(teraz);
      String className = kal[i].getClass().getName();
      String name = className.substring(className.lastIndexOf(".") + 1);
      System.out.println(name + " - " +
            "era " + kal[i].get(Calendar.ERA) +
            "; rok " + kal[i].get(Calendar.YEAR) +
            (name.equals("ChineseCalendar") ?
                  " czyli " + kal[i].get(Calendar.EXTENDED_YEAR)  : "") +
            "; mies " + kal[i].get(Calendar.MONTH) +
            "; dzieñ mies. " + kal[i].get(Calendar.DAY_OF_MONTH) +
            "; dzieñ tyg. " + kal[i].get(Calendar.DAY_OF_WEEK)
            );
    }
  }

}
</pre>
Program wyprowadzi nastêpuj¹ce wyniki.<br>
<div class="listing100">Teraz jest: Fri Jul 18 15:02:24 CEST 2003<br>
GregorianCalendar - era 1; rok 2003; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
GregorianCalendar - era 1; rok 2003; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
BuddhistCalendar - era 0; rok 2546; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
ChineseCalendar - era 78; rok 20 czyli 4640; mies 5; dzieñ mies. 19; dzieñ tyg. 6<br>
JapaneseCalendar - era 235; rok 15; mies 6; dzieñ mies. 18; dzieñ tyg. 6<br>
IslamicCalendar - era 0; rok 1424; mies 4; dzieñ mies. 18; dzieñ tyg. 6<br>
HebrewCalendar - era 0; rok 5763; mies 10; dzieñ mies. 18; dzieñ tyg. 6<br>
</div><br>
<br>
Kalendarze ró¿ni¹ siê przede wszystkim er¹ i&nbsp; rokiem. W buddyjskim lata liczone
s¹ od narodzin Buddy. W tradycyjnym japoñskim zliczanie czasu odbywa siê
w ten sposób, ¿e panowanie ka¿dego Cesarza oznacza now¹ erê, a rok intronizacji
jest pierwszym rokiem tej ery. Tradycyjny chiñski kalendarz jest kalendarzem
ksiê¿ycowym (co od razu widaæ w rachubie miesiêcy). Lata s¹ liczone na dwa
ró¿ne sposoby. Pierwszy polega na numerowaniu lat kolejno poczynaj¹c od 61
roku panowania cesarza Szy Huang Ti &nbsp;(2637 r. pne). Drugi sposób bierze za
pocz¹tek kalendarza tê sama datê, ale u¿ywa 60- letnich cykli, w ka¿dym z
których lata numerowane s¹ od pocz¹tku. Pole&nbsp; ERA chiñskiego kalendarza pokazuje
numer cyklu, pole YEAR - numer roku w danym cyklu (od 1 do 60), a pole EXTENDED_YEAR
aktualny numer roku, liczony sekwencyjnie wed³ug pierwszego sposobu. Kalendarz
hebrajski jest kalendarzem lunisolarnym (zatem zliczanie miesiêcy ma ciekawe,
ró¿ne od kalendarza gergoriañskiego, w³asciwoœci). Kalendarz islamski rozpoczyna
rachubê lat od daty pielgrzymki Mohameta do Medyny (czwartek, 15 lipca 622
roku ). <br>
Oczywiœcie, nie sposób tutaj wdawaæ sie w dalsz¹ dyskusjê tych zagadnieñ
(zainteresowanych odsy³am do bogatej literatury, dotycz¹cej ró¿nych kalendarzy,
dostêpnej równie¿ w Internecie).<br>
Zauwa¿my tylko, ¿e istnieje jeszcze wiele innych kalendarzy (do ciekawszych,
a zarazem bardzo skomplikowanych nalezy np. kalendarz balijski, obowi¹zuj¹cy
tradycyjnei na wyspie Bali). Klasa Calendar (szczególnie w wersji pakietu
ICU, gdzie pod k¹tem u³atwieñ dziedziczenia jej konstrukcja zosta³a mocno
przebudowana) jest przygotowana do tego, by w miarê prosto mo¿na by³o tworzyæ jej podklasy, reprezentuj¹ce konkretne kalendarze,<br>
<br>
Dostosowanie kalendarza do lokalizacji nie polega tylko na zmianie samego
kalendarza. Ten sam kalendarz - np. gregoriañski - w ró¿nych lokalizacjach
mo¿e siê ró¿niæ np. pierwszym dniem tygodnia. W Polsce pierwszym dniem tygodnia
jest poniedzia³ek (indeks 2). &nbsp;Dla innych krajów - mo¿e byæ to inny dzieñ
tygodnia.<br>
Poni¿szy program pokazuje wszystkie kraje dla których pierwszy dzieñ tygodnia nie jest poniedzia³kiem.<br>
<br>
<pre>import com.ibm.icu.util.Calendar;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;
import java.util.Iterator;
import java.text.DateFormatSymbols;

public class FirstDoW {

  public static void main(String[] args) {
    // Domyœlna lokalizacja (w naszym przypadku polska
    Locale def = Locale.getDefault();

    // Chcemy mieæ dni tygodnia po polsku
    DateFormatSymbols dafs = new DateFormatSymbols(def);
    String[] wdays = dafs.getWeekdays();  // dni tygodnia po polsku


    // Tablica dostêpnych lokalizacji (z pakietu ICU!!!)
    Locale[] loc = Calendar.getAvailableLocales();

    // Mapa: klucz = kraj, wartoœæ = piewrwszy dzieñ tygodnia
    Map fdowMap = new TreeMap();

    for (int i=0; i&lt;loc.length; i++) {

      // Uzyskanie kalendarza dla danej lokalizacji
      // (bêd¹ to kalendzrae gregoriañskie, bo taka jest w³aœciwoœæ pakietu ICU)
      Calendar c = Calendar.getInstance(loc[i]);

      // indeks pierwszego dnia tygodnia w tym kalendarzu
      int fdow = c.getFirstDayOfWeek();
      // je¿eli to poniedzia³ek - nie interesuej nas
      if (fdow == 2) continue;

      // lokalizacja opisana w jêzyku domyœlnej lokalizacji (polskim)
      String country = loc[i].getDisplayCountry(def);
      if (country.equals("")) continue; // pomijamy te bez kraju

      if (!fdowMap.containsKey(country)) fdowMap.put(country, wdays[fdow]);
    }

    System.out.println("Gdzie pierwszy dzieñ tygodnia nie jest poniedzia³kiem?");
    for (Iterator it = fdowMap.keySet().iterator(); it.hasNext(); ) {
      // Jaki jest pierwszy dzieñ tygodnia
      String country = (String) it.next();
      String fday = (String) fdowMap.get(country);
      System.out.println(country  +  " = " + fday);
    }
  }
</pre>
Wydruk programu:<br>
<div class="listing100">Gdzie pierwszy dzieñ tygodnia nie jest poniedzia³kiem?<br>
Albania = niedziela<br>
Algeria = sobota<br>
Arabia Saudyjska = sobota<br>
Armenia = niedziela<br>
Australia = niedziela<br>
Bahrajn = sobota<br>
Botswana = niedziela<br>
Chiny = niedziela<br>
Chorwacja = niedziela<br>
Dziewicze Wyspy Stanów Zjednoczonych = niedziela<br>
D¿ibuti = sobota<br>
Egipt = sobota<br>
Erytrea = sobota<br>
Etiopia = sobota<br>
FO = niedziela<br>
Filipiny = niedziela<br>
GL = niedziela<br>
Hong Kong = niedziela<br>
Indie = sobota<br>
Irak = sobota<br>
Iran = sobota<br>
Islandia = niedziela<br>
Izrael = niedziela<br>
Japonia = niedziela<br>
Jemen = sobota<br>
Jordan = sobota<br>
Jugos³awia = niedziela<br>
Kanada = niedziela<br>
Katar = sobota<br>
Kenia = sobota<br>
Korea Po³udniowa = niedziela<br>
Kuwejt = sobota<br>
Liban = sobota<br>
Libia = sobota<br>
MO = niedziela<br>
Macedonia = niedziela<br>
Malta = niedziela<br>
Maroko = sobota<br>
Nowa Zelandia = niedziela<br>
Oman = sobota<br>
Republika Czeska = niedziela<br>
Republika Po³udniowej Afryki = niedziela<br>
Rumunia = niedziela<br>
Singapur = niedziela<br>
Somalia = sobota<br>
Stany Zjednoczone Ameryki = niedziela<br>
Sudan = sobota<br>
Syria = czwartek<br>
S³owacja = niedziela<br>
S³owenia = niedziela<br>
Tajlandia = niedziela<br>
Tajwan = niedziela<br>
Tanzania = sobota<br>
Tunezja = sobota<br>
Wietnam = niedziela<br>
Zimbabwe = niedziela<br>
Zjednoczone Emiraty Arabskie = sobota<br>
</div><br>
<br>
 Ju¿ w tym przyk³adzie natknêliœmy siê na kwestie pokazywania dat wed³ug
regu³ danej lokalizacji (tu chodzi³o o nazwy dni tygodnia). Skorzystaliœmy
przy tym z klasy DateFormatSymbols, jej obiektu utworzonego dla domyœlnej
lokalizacji (polskiej) i metody getWeekDays(), która - wo³ana na jego rzecz
- zwraca nazwy dni tygodnia w jêzyku danej lokalizacji. <br>
Ogólnie, wyprowadzanie dat i czasu w przyjaznej dla u¿ytkownika postaci wymaga
ich formatowania za pomoca klasy DateFormat, która &nbsp;pos³uguje siê klas¹ DateFormatSymbols.
Klasa DateFormat s³u¿y&nbsp;równie¿ do przekszta³acania tekstów (napisów) reprezentuj¹cych
daty na obiekty klasy Date. <br>
<br>

<a name="Intern.6"></a><h2>6. Formatowanie dat</h2>


Przy formatowaniu dat podobnie jak w przypadku liczb musimy najpierw uzyskaæ odpowiedni formator
za&nbsp; pomoc¹&nbsp;statycznych metod getXXXInstance(...) z klasy DateFormat, a nastêpnie
na jego rzecz u¿yæ metody format z argumentem typu Date.<br>
<br>


Mo¿emy zastosowaæ:<br>
<ul>
<li>formator dla dat - metody getDateInstance(...)</li><li>formator dla czasu - metody getTimeInstance(...)</li><li>formator dla daty i czasu - metody getDateTimeInstance(...)</li><li>domyœlny formator dla daty i czasu - metoda getInstance().</li>
</ul>


Argumenty w/w metod okreœlaj¹ lokalizacjê oraz&nbsp;styl formatowania .<br>


Mamy do dyspozycji cztery style formatowania okreœlone przez statyczne sta³e
klasy DateFormat: SHORT, MEDIUM, LONG, FULL, a ew. dodatkowy argument metod
getXXXInstance(...) okreœla lokalizacjê za pomoc¹ referencji do obiektu
klasy Locale.<br>
<br>
Oprócz tego mo¿emy pos³u¿yæ siê wzorcami formatowania.<br>
<br>
Najprostsze sposoby formatowania dla domyœlnej i kilku wybranych lokalizacji pokazuje poni¿szy kod.<br>
<pre>import java.util.*;
import java.text.*;
import javax.swing.*;

public class Daty {

  public static void main(String[] args) {
    Date teraz = new Date();

    int[] styles = { DateFormat.SHORT, DateFormat.MEDIUM,
                     DateFormat.LONG, DateFormat.FULL };

    String outMsg = "";

    for (int i=0; i &lt; styles.length; i++) {

      DateFormat df = DateFormat.getDateTimeInstance(
                                    styles[i],          // styl daty
                                    DateFormat.FULL     // styl czasu
                      );

      outMsg += df.format(teraz) + '\n' + "-----------------\n" ;
    }
    System.out.println(outMsg);


    Locale[] llist = { new Locale("de"),
                       new Locale("fr"),
                       new Locale("es"),
                       new Locale("ar"),
                       new Locale("ru"),
                       new Locale("th")
                     };
    outMsg = "";
    for (int i=0; i &lt; llist.length; i++) {
      DateFormat df = DateFormat.getDateTimeInstance(
                                    DateFormat.FULL,    // styl daty
                                    DateFormat.FULL,    // styl czasu
                                    llist[i]            // lokalizacja
                      );
      outMsg += df.format(teraz) + '\n' + "-----------------\n" ;
    }
    JOptionPane.showMessageDialog(null, outMsg);
    System.exit(0);
  }

}
</pre>
Program wypisze na konsoli daty w domyœlnej lokalizacji (pl) i wszystkich
stylach oraz czas w stylu FULL. W pokazanym okienku komunikatów zobaczymy
tê sam¹ informacjê sformatowan¹ dla killku innych lokalizacjach (styl daty
i czasy FULL).<br>
<br>
<div class="listing100"><br>

03-07-18 16:47:57 CEST<br>

-----------------<br>

2003-07-18 16:47:57 CEST<br>

-----------------<br>

18 lipiec 2003 16:47:57 CEST<br>

-----------------<br>

pi¹tek, 18 lipiec 2003 16:47:57 CEST<br>

-----------------<br>

</div><br>
<br>
<img src="images/daty1.jpg" alt="r" border="1" height="305" width="433">
<br>
<br>
<br>
<br>
Metoda getXXXInstance() klasy DateFormat zwraca (zlokalizowany, jeœli mo¿na)
obiekt klasy SimpleDateFormat. Za pomoc¹ tej klasy mo¿emy &nbsp;zastosowaæ wzorce
formatowania do pokazywania (i parsowania) dat i czasu.<br>
<br>
Wzorzec formatowania sk³ada siê z liter ('a' - 'z', 'A' - 'Z')), które maj¹
specjalne znaczenie i s¹ interpretowane jako sk³adowe daty/czasu (lub zarezerwowane)
oraz innych symboli, które s¹ po prostu kopiowane przy formatowaniu. Litery
ujête w apostrofy nie s¹ interpretowane.<br>
Litery, maj¹ce specjalne znaczenie pokazuje tablica.<br>
<br>
<table border="0" cellpadding="0" cellspacing="3">
<tbody><tr bgcolor="#ccccff"><th align="left">Litera
         </th><th align="left">&nbsp;Znaczenie
         </th><th align="left">Typ
         </th><th align="left">Przyk³ad
     </th></tr><tr><td><code>G</code></td><td>Era&nbsp;
         </td><td>Tekst</td><td><code>AD</code></td></tr><tr bgcolor="#eeeeff"><td><code>y</code></td><td>Rok
         </td><td>Rok</td><td><code>1996</code>; <code>96</code></td></tr><tr><td><code>M</code></td><td>Miesi¹c w roku
         </td><td>Miesi¹c</td><td><code>July</code>; <code>Jul</code>; <code>07</code></td></tr><tr bgcolor="#eeeeff"><td><code>w</code></td><td>Tydzieñ w roku
         </td><td>Liczba<br>
</td><td><code>27</code></td></tr><tr><td><code>W</code></td><td>Tydzieñ w &nbsp;miesi¹cu</td><td>Liczba</td><td><code>2</code></td></tr><tr bgcolor="#eeeeff"><td><code>D</code></td><td>Dzieñ roku
         </td><td>Liczba</td><td><code>189</code></td></tr><tr><td><code>d</code></td><td>Dzieñ miesi¹ca
         </td><td>Liczba</td><td><code>10</code></td></tr><tr bgcolor="#eeeeff"><td><code>F</code></td><td>Dzieñ tygodnia&nbsp;
         </td><td>Liczba</td><td><code>2</code></td></tr><tr><td><code>E</code></td><td>Dzieñ tygodnia
         </td><td>Tekst</td><td><code>Tuesday</code>; <code>Tue</code></td></tr><tr bgcolor="#eeeeff"><td><code>a</code></td><td>Tekst &nbsp;Am/pm&nbsp;
         </td><td>Tekst</td><td><code>PM</code></td></tr><tr><td><code>H</code></td><td>Godzina dnia (0-23)
         </td><td>Liczba</td><td><code>0</code></td></tr><tr bgcolor="#eeeeff"><td><code>k</code></td><td>Godzina dnia (1-24)
         </td><td>Liczba</td><td><code>24</code></td></tr><tr><td><code>K</code></td><td>Godzina&nbsp; am/pm (0-11)
         </td><td>Liczba</td><td><code>0</code></td></tr><tr bgcolor="#eeeeff"><td><code>h</code></td><td>Gdodzina am/pm (1-12)</td><td>Liczba</td>
<td><br>
</td><td><code>12</code></td></tr><tr><td><code>m</code></td><td>Minuta
         </td><td>Liczba</td><td><code>30</code></td></tr><tr bgcolor="#eeeeff"><td><code>s</code></td><td>Sekunda
         </td><td>Liczba</td><td><code>55</code></td></tr><tr><td><code>S</code></td><td>Milisekunda</td><td>Liczba</td><td><code>978</code></td></tr><tr bgcolor="#eeeeff"><td><code>z</code></td><td>Strefa czasowa
         </td><td>Symbol strefy<br>
</td><td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td></tr><tr><td><code>Z</code></td><td>Strefa czasowa
         </td><td>Symbol RFC 822&nbsp;</td><td><code>-0800</code></td></tr></tbody>
</table>
<br>
Poszczególne specjalne litery s¹ we wzorcach formatowania powtarzane okreœlon¹ liczbê razy.<br>
Przy tym:<br>
<ul>
  <li>dla sk³adowych typu Tekst : jeœli przy formatowaniu powtórzono literê
4 lub wiêcej razy stosowana jest pe³na forma (np. EEEE - "wtorek"), przy
parsowaniu - liczba liter nie ma znaczenia,</li>
  <li>dla sk³adowej typu Rok:&nbsp; jeœli podano dwie litery YY - dostaniemy dwie cyfry
roku, w przeciwnym &nbsp;razie rok jest traktowany jako typu Liczba,</li>
  <li>dla sk³adowych typu Miesi¹c: jeœli podano 3 lub wiêcej liter mamy
miesi¹c w postaci s³ownej (traktowany jak Tekst), w przeciwnym razie jako
typu Liczba,<br>
  </li>
  <li>dla sk³adowych typu Liczba:&nbsp; liczba liter okreœla minimaln¹ liczbê
cyfr (nie ma to znaczenia przy parsowaniu, o ile nie trzeba oddzielaæ dwóch
stycznych pól).</li>
</ul>Przyjrzyjmy
siê&nbsp; kilku przyk³adom zastosowania wzorców formatowania dat.<br>
<br>
Poni¿szy program:<br>
<pre>import java.util.*;

public class Daty1 {

  public static void main(String[] args) {

    Calendar c = Calendar.getInstance();
    Date teraz = c.getTime();

    SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateInstance();

    String[] pattern = {"dd-MM-yyyy",
                        "MMMM, 'dzieñ 'dd ( EE ), 'roku 'yyyy GGGG",
                        "EEEE, dd MMM yyyy 'r.'"
                       };
    for (int i=0; i&lt;pattern.length; i++) {
      df.applyPattern(pattern[i]);
      System.out.println(df.format(teraz));
    }

  }

}
</pre>
wyprowadzi:<br>
<div class="listing100"><br>
18-07-2003<br>
lipiec, dzieñ 18 ( Pt ), roku 2003 n.e.<br>
pi¹tek, 18 lip 2003 r.<br>
</div><br>
<div class="notec">Wygodnym sposobem formatowania dat i czasu jest
u¿ycie obiektu klasy Formatter z pakietu java.utils i/lun metod
korzystaj¹cych z tej klasy np. String.format(...) lub printf(...) (zob.
kurs "Wprowadzenie do programowania").<br><br>
Niestety, odwrotna
operacja - przekszta³canie napisów w daty - nie jest dostêpna w
nowszych klasach Javy takich jak Formattrr czy Scanner i musimy
korzystaæ z klasy DateFormat.</div><br>
<br>
Przy parsowaniu z u¿yciem zdefiniowanych wzorców formatowania teksty (zapisane
zgodnie z tymi wzorcami) przekszta³cane s¹ na daty (obiekty klasy Date).
Regu³y parsowania s¹ podobne jak w przypadku klasy NumberFormat (przypopmnijmy
sobie omówione wczesniej zasady zg³aszania wyj¹tków oraz pos³ugiwanie siê
klas¹ ParseException).<br>
Poni¿szy przyk³adowy fragment:<br>
<pre>&nbsp;  public static void main(String[] args) {


    SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateInstance();

    String[] pattern = {"dd-MM-yyyy",
                        "MMMM, 'dzieñ 'dd ( EE ), 'roku 'yyyy GGGG",
                        "EEEE, dd MMM yyyy 'r.'"
                       };

    for (int i=0; i&lt;pattern.length; i++) {

      String in=JOptionPane.
                showInputDialog("WprowadŸ datê wg wzorca " + pattern[i]);
      df.applyPattern(pattern[i]);
      Date data = df.parse(in, new ParsePosition(0));
      System.out.println(data);
    }
  }

</pre>
po wprowadzeniu w dialogach tekstów:<br>
12-12-1999<br>
lipiec, dzieñ 18 ( Pt ), roku 2003 n.e.<br>
wtorek, 12 lipiec 2003 r.<br>
<br>
wyprowadzi na konsolê:<br>
Sun Dec 12 00:00:00 CET 1999<br>
Fri Jul 18 00:00:00 CEST 2003<br>
Sat Jul 12 00:00:00 CEST 2003<br>
<br>
Zwróæmy uwagê: b³êdny dzieñ tygodnia (wtorek zamiast soboty) nie spowodowa³
b³êdu interpretacji, ale uzyskana data jest w³aœciwa (nazwa dnia tygodnia
zosta³a skorygowana).<br>
<br>
Oczywiœcie, formatowanie i parsowanie podlega zasadom lokalizacji.<br>
Istotnych informacji lokalizacyjnych dostarcza klasa DateFormatSymbols. Mieliœmy
okazjê z niej korzystaæ przy okazji uzyskiwania nazw dni tygodnia po polsku.
Zobaczmy teraz jakich jeszcze informacji mo¿emy siê po niej spodziewaæ.<br>
<br>
Przyk³adowy program tworzy obiekty klasy DateFormatSymbols dla kilku lokalizacji
i wywo³uje na ich rzecz metody takie jak getWeekdays() (zwracaj¹c¹ nazwê
dni tygodnia) czy getMonths() (nazwy dni miesi¹ca). Nazwy metod pozyskuj¹cych
zlokalizowane informacje s¹ samoobjaœniaj¹ce sie, wynik dzia³ania programu
pokazujemy w obszarze wielowierszowego pola edycyhnego (JTextArea) po to
by w³aœciwie by³y interpretowane znaki Unicode (zob. rysunek).<br>
<br>
<pre>import java.util.*;
import java.text.*;
import java.awt.*;
import javax.swing.*;

public class DateFormatSymbolsShow {

  String[] lang = { "fr", "es", "de", "ru" };

  String out = "";

  public DateFormatSymbolsShow() {
    for (int i=0; i&lt;lang.length; i++) {
      Locale  loc = new Locale(lang[i]);
      DateFormatSymbols dfs = new DateFormatSymbols(loc);
      out += '\n' + loc.getDisplayLanguage();
      // nazwy er
      addToOut("Ery: ", dfs.getEras());
      // nazwy miesiêcy
      addToOut("Miesi¹ce: ", dfs.getMonths());
      // skróty miesiêcy
      addToOut("Miesi¹ce - skróty: ", dfs.getShortMonths());
      // nazwy dni tygodnia
      addToOut("Dni tygodnia: ", dfs.getWeekdays());
      // skróty nazw dni tygodnia
      addToOut("Dni tygodnia - skróty: ", dfs.getShortWeekdays());
    }
    JTextArea ta = new JTextArea(out);
    ta.setFont(new Font("Dialog", Font.BOLD, 14));
    JFrame f = new JFrame();
    f.getContentPane().add(ta);
    f.pack();
    f.show();
  }

  void addToOut(String msg, String[] s) {
    out += "\n" + msg;
    for (int i=0; i&lt;s.length; i++) {
      out += ' ' + s[i];
    }
  }

  public static void main(String[] args) {
    new DateFormatSymbolsShow();
  }

}
</pre>
<br>
<br>
<img src="images/datefsym.jpg" alt="r" border="1" height="487" width="734">
<br>
<br>
<br>
Zwykle nie korzystamy z klasy DateFormatSymbols (jest ona u¿ywana automatycznei
przy formatowaniu dat), Czasem jednak mo¿e zajœæ taka potrzeba. Wtedy mo¿na
u¿yc konstruktora klasy SimpleDateFormat, dostarczaj¹c mu oprócz pierwszego
argumentu (wzorca formatowania) argument drugi - refrencjê do obiektu DateFormatSymbols.<br>
<br>
Wykorzystamy to teraz do poprawieniu b³êdów gramatycznych, które nieuchronnie
powstaj¹ przy formatowaniu dat w jêzyku polskim ze wzglêdu na brak uwzglêdnienia
w³aœciwej odmiany nazw miesiêcy (nb uwa¿ny Czytelnik zapewne zauwa¿y³, ¿e
lokalizacje dokonywane przez "lokalnych" ekspertów firm Sun i IBM s¹ czêsto
nieco powierzchowne; b³êdy gramatyczne i ortograficzne dotycz¹ nie tylko
polskiego, co mo¿na by³o spostrzec w kilku przyk³adach z tego rozdzia³u).
Przy okazji zobaczymy, ¿e w³aœciwoœci lokalizacyjne formatowania dat mo¿na
³atwo zmieniaæ (za pomoc¹ rozlicznych metod set... z klasy DateFormatSymbols).<br>
<br>
<pre>import java.util.*;
import java.text.*;

public class DateFormatPol {

  public static String polskaData(Date data) {
    String[] mies = { "stycznia", "lutego", "marca", "kwietnia",
                      "maja", "czerwca", "lipca", "sierpnia",
                      "wrzeœnia", "paŸdziernika", "listopada",
                      "grudnia"
                    };
    DateFormatSymbols dfs = new DateFormatSymbols();
    dfs.setMonths(mies);
    SimpleDateFormat df = new SimpleDateFormat("dd MMMM yyyy", dfs);
    return df.format(data);
  }



  public static void main(String[] args) {
    System.out.println( polskaData( new Date() ) );
  }

}
</pre>

<br>
Prrzyk³adowy listing programui:<br>
<div class="listing33r">20 lipca 2003<br>
</div> <br>
<br>

<a name="Intern.7"></a><h2>7. Zlokalizowany rozbiór tekstów</h2>



W czêœci A omawialiœmy rozbiór tekstów za pomoc¹ klasy StringTokenizer.
Oczywiœcie, zastosowane tam proste regu³y wyodrêbniania fragmentów napisów
tak naprawdê nie nadaj¹ siê do przetwarzania "jêzyka pisanego".<br>
Tê - mo¿e nie na codzieñ potrzebn¹, ale wart¹ odnotowania - funkcjê spe³nia klasa <i><b>BreakIterator</b></i>
 z pakietu java.text. &nbsp;Warto te¿ wspomnieæ o tej klasie dlatego, ¿e zastosowano
w niej - na pierwszy rzut oka - ma³o intuicyjne, ale, okazuje siê, wygodny
mechanizm analizy sk³adniowej.<br>
<br>


Klasa ta pozwala dzieliæ tekst <b>pisany w danym jêzyku</b> na elementy takie jak: zdania, wiersze (wiersz jest czêœci¹ zdania od pocz¹tku linii do jej koñca lub <b><i>znaku przeniesienia</i></b>), s³owa, znaki.<br>


Do wyodrêbniania ka¿dego z w/w elementów tekstu trzeba stworzyæ odrêbny iterator. S³u¿¹ temy
statyczne metody klasy: getSentenceInstance(...), getLineInstance(...), getWordInstance(...)
, getCharacterInstance(...).<br>
<br>


Metody iteratora (zwi¹zanego z danym elementem tekstu) umo¿liwiaj¹ m.in.<br>
<ul>
<li>pobranie indeksu pierwszej pozycji podzia³u tekstu na elementy (zdania, wiersza etc) - metoda first().</li><li>pobranie indeksu ostatniej pozycji podzia³u tekstu na elementy (zdania, wiersza etc)&nbsp; - metoda last(),</li><li>pobranie indeksu &nbsp;nastêpnej pozycji podzia³u tektsu na elementy (zdania, wiersza etc) - metoda next(),</li><li>pobranie indeksu &nbsp;poprzedniej&nbsp;pozycji podzia³u tektsu na elementy (zdania, wiersza etc) - metoda previous(),</li><li>swobodny wybór elementów tekstu - np. pobranie indeksu poz
ycji podzia³u tekstu oddalonego
o n pozycji od bie¿¹cego "w przód" lub &nbsp;"w ty³" - metody next(int n) lub
preceding(int n).</li>
</ul>

Metody te nie tylko zwracaj¹ pozycjê, ale przesuwaj¹ bie¿¹c¹ pozycjê
podzia³u tekstu. Dlatego w³aœnie klasa zosta³a nazwana BreakIterator - jej
metody pozwalaj¹ iterowaæ poprzez pozycje podzia³u tekstu.<br>
<br>


Ale uwaga! Iterator s³u¿¹cy do wyodrêbniania s³ów - w przeciwieñstwie do
innych iteratorów (np. zdañ) - zwraca indeksy elementów (s³ów) oraz indeksy
separatorów elementów-s³ów. To czy na danej pozycji zaczyna siê akurat
kolejne s³owo czy te¿ ci¹g znaków dziel¹cych s³owa musimy sprawdziæ samodzielnie.<br>
<br>


Program testuj¹cy wraz z komentarzami pokazuje sposób u¿ycia BreakIteratora.<br>
<br>
<pre>import java.text.BreakIterator;

public class BreakIteratorTest {

  // Metoda wypisuj¹ca na konsoli
  //  - zdania - jeœli przekazano jako argument typ wartoœæ 0
  //  - lub s³owa - jeœli przekazano jako argument typ wartoœæ 1
  // wyodrêbnione z tekstu txt

  private static void show(int typ, String txt) {
    String[] head = { "Zdania", "S³owa" }; // Nag³ówek: dla typ==0 "Zdania"
                                           //           dla typ==1 "S³owa"

    // Uzyskanie odpowiedniego breakiteratora
    // dla typ == 0 bêdzie to iterator "po zdaniach"
    // dla typ == 1 bêdzie to iterator "po s³owach"
    BreakIterator bri = (typ == 0 ? BreakIterator.getSentenceInstance()
                                  : BreakIterator.getWordInstance()
                        );
    System.out.println(head[typ]); // Wypisanie nag³ówka

    // Po stworzeniu iteratora a przed jego u¿yciem
    // nale¿y ustaliæ tekst, który bêdzie przetwarzany

    bri.setText(txt);

    // Iterowanie

    int start = bri.first();  // pozycja pierwszego podzia³u na elementy
    int end   = bri.next();   // pozycja nastêpnego podzia³u na elementy

    while (end != BreakIterator.DONE) { // dopóki mo¿na dzieliæ tekst

      // Wyodrêbniamy element
      String elt = txt.substring( start, end);

      // Wypisujemy element je¿eli to jest iterator dla zdañ
      // albo je¿eli to jest iterator dla s³ów, a elementem jest s³owo
      // Czy to jest s³owo stwierdzamy za pomoc¹ metody
      // isIteratorWord(...) - zob. dalej

      if (typ == 0 | (typ == 1 &amp;&amp; isIteratorWord(elt)))
         System.out.println(start + ": " +  elt);


      start = end;        // pocz¹tek nastêpnego (po wypisanym) elementu
      end = bri.next();   // pozycja  nastêpnego podzia³u
    }
  }

  // Metoda stwierdza czy element wyodrêbniony przez iterator s³ów
  // jest s³owem. Bêdzie nim ka¿dy element, który zawiera choæ jedn¹
  // literê lub cyfrê. Czy dany znak jest liter¹ lub cyfr¹
  // stwierdzamy za pomoc¹ statycznej metody z klasy Character
  // Character.isLetterOrDigit(znak)

  private static boolean isIteratorWord(String elt) {
    int l = elt.length();
    for (int i=0; i &lt; l; i++)
      if (Character.isLetterOrDigit(elt.charAt(i))) return true;
    return false;
  }


  public static void main(String[] args) {

    String s = "Ala Kot-Kotowska ma kota. A mleko? "+
               "Pies go wych³epta³ (swobodnie) - 0.1 litra. " +
               "Tak? Nie! Chyba nie... A mo¿e? By³a¿by to \"hañba\"?!!!";

    show(0, s); // poka¿ zdania
    show(1, s); // poka¿ s³owa
  }

}
</pre>



Wydruk dzia³ania programu pokazano .... poni¿ej:<br>
<br>


Zdania<br>


0: Ala Kot-Kotowska ma kota. <br>


26: A mleko? <br>


35: Pies go wych³epta³ (swobodnie) - 0.1 litra. <br>


79: Tak? <br>


84: Nie! <br>


89: Chyba nie... <br>


102: A mo¿e? <br>


110: By³a¿by to "hañba"?!!!<br>


S³owa<br>


0: Ala<br>


4: Kot-Kotowska<br>


17: ma<br>


20: kota<br>


26: A<br>


28: mleko<br>


35: Pies<br>


40: go<br>


43: wych³epta³<br>


55: swobodnie<br>


68: 0.1<br>


72: litra<br>


79: Tak<br>


84: Nie<br>


89: Chyba<br>


95: nie<br>


102: A<br>


104: mo¿e<br>


110: By³a¿by<br>


118: to<br>


122: hañba<br>
<br>
<br>
BreakIterator pozwala doœæ wygodnie dzia³aæ na tekstach. Oczywiœcie - i to
jest jego równie wa¿na zaleta - BreakIterator przygotowany jest do przetwarzania
tekstów zgodnie z ustawieniami lokalizacyjnymi (dla ró¿nych jêzyków). Inaczej
wygl¹da tekst i jego podzia³ na zdania czy s³owa w jêzyku niemieckim, inaczej
w angielskim, inaczej w chiñskim. BreakIterator bêdzie umia³ dokonaæ w³aœciwego
rozbioru w ka¿dym z tych przypadkóe.<br>
Tak jak zawsze w przypadku klas lokalizacyjnie-czu³ych ustawiæ odpowiednie
przetwarzanie mo¿na za pomoc¹ metod statycznych. które zwracaj¹ iterator
dla odpowiednich elementów (zdania, s³owa, itp.), a maj¹ za argument referencjê
do obiektu klasy Locale, który okreœla lokalizacjê.<br>
<br>

<a name="Intern.8"></a><h2>8. Porównywanie i sortowanie napisów</h2>


Ró¿ne jêzyki implikuj¹ ró¿ny alfabetyczny porz¹dek napisów.<br>
W³aœciwe porównywanie napisów mo¿emy przeprowadziæ za pomoc¹ obiektu klasy <b>Collator</b> z pakietu java.text.<br>
<br>
Jest to klasa lokalizacyjnie-czu³a, zatem w³aœciw¹ instancjê kolatora dla
domyœlnej lokalizacji uzyskamy za pomoc¹ odwo³ania Collator.getInstance().
Mo¿emy te¿ uzyskaæ kolator dla dowolnej lokalizacji, podaj¹c w metodzie getInstance(...) argument-lokalizacjê<br>
<br>
Maj¹c obiekt-kolator dla okreslonej (domyœlnej lub podanej) lokalizacji mo¿emy
za pomoc¹ metody compare(...) wywo³anej na jego rzecz uzyskaæ w³asciwy dla
danej lokalizacji wynik porównania dwóch napisów podanych jako argumenty
metody.<br>
<br>
£atwo siê domyœliæ, ¿e klasa Collator implementuje interfejs Comparator.
Zatem porównania uzyskiwane za pomoca metody compare(...) kolatora ³atwo
uczyniæ podstaw¹ sortowania tablic i kolekcji, a tak¿e decydowania o dodawaniu
elementów do uporz¹dkowanych zbiorów i map.<br>
<br>
Zobaczmy najprostszy przyk³ad. Niech domyœlna lokalizacja bêdzie lokalizacj¹
polsk¹, Jak posortowaæ tablicê napisów w tej lokalizacji ? Regu³a jest prosta:<br>
<ul>
  <li>uzyskaæ kolator dla lokalizacji domyslnej (polskiej) - metoda Collator.getInstance(),</li>
  <li>podaæ ten kolator jako komparator w metodzie Arrays.sort(...)&nbsp;</li>
</ul>
Poni¿szy program - oprócz wspomnianej wy¿ej procedury - pokazuje, ¿e porz¹dek
napisów w róznych lokalizacjach jest ró¿ny (przy sortowaniu polskich napisów
powinniœmy oczywiœcie stosowaæ kolator dla lokalizacji polskiej)\.<br>
<br>
<pre>import java.util.*;
import java.text.*;

public class Kolator0 {

  static void sortShow(String msg, String[] txt, Collator col) {
    String[] copyTxt = (String[]) txt.clone();
    Arrays.sort(copyTxt, col);
    System.out.println(msg);
    for (int i=0; i &lt; copyTxt.length; i++) {
      System.out.println(copyTxt[i]);
    }
  }


  public static void main(String[] args) {
    String[] txt = { "bela", "Ala", "¹", "¥", "¹", "ala" , "Be", "Ala",
                     "alabama", "be", "Be", "1", "æ", "my", "My", "Myk", "myk"  };
    Collator col = Collator.getInstance();
    sortShow("Sort pol", txt, col);
    Collator col1 = Collator.getInstance(new Locale("en"));
    sortShow("Sort en", txt, col1);
  }

}
</pre>
Program wyprowadzi na konsolê:<br>
<div class="listing100"><br>
Sort pol<br>
1<br>
ala<br>
Ala<br>
Ala<br>
alabama<br>
¹<br>
¹<br>
¥<br>
be<br>
Be<br>
Be<br>
bela<br>
æ<br>
my<br>
My<br>
myk<br>
Myk<br>
Sort en<br>
1<br>
¹<br>
¹<br>
¥<br>
ala<br>
Ala<br>
Ala<br>
alabama<br>
be<br>
Be<br>
Be<br>
bela<br>
æ<br>
my<br>
My<br>
myk<br>
Myk<br>
</div><br>
<br>
W jaki sposób (dla ró¿nych lokalizacji) uzyskujemy w³aœciwe porównania?<br>
Otó¿ konkretne kolatory s¹ obiektami klasy RuleBasedCollator, która jest podklas¹ klasy Collator.<br>
Uporz¹dkowanie za pomoc¹ kolatorów klasy RuleBasedCollator odbywa siê na
podstawie porównywanie znaków w oparciu o regu³y zapisane za pomoc¹ prostej
sk³adni. Regu³y te okreœlaj¹ cztery (a w pakieice ICU nawet piêæ) porz¹dki:<br>
<ul>
  <li>podstawowy (PRIMARY), w którym rozró¿niane s¹ (zdefiniowane w zestawie regu³&nbsp; jako rozró¿nialne) znaki,</li>
  <li>drugorzêdny (SECONDARY) , który okreœla porz¹dek napisów identycznych
ze wzglêdu na porz¹dek podstawowy, ale ró¿ni¹cych siê akcentowanymi znakami
(to dotyczy np. jêzyków francuskiego, hiszpañskiego, angielskiego),</li>
  <li>trzeciorzêdny (TERTIARY), który napisy identyczne wedle dwóch poprzednich porz¹dków rozró¿nia na podstawie wielkoœci liter,</li>
  <li>identycznoœci (IDENTICAL): rozró¿niaj¹cy wszelkie znaki, nawet te uznane
za takie same wedle trzech poprzednicj porz¹dków (np. w wielu lokalizacjach
znaki \u0001 i \u0002 s¹ uznawane za takie same wedle trzech w/w porz¹dków,
natomiast porz¹dek identycznoœci bêdzie je rozró¿nia³)<br>
  </li>
</ul>
Stosowany dla danego kolatora porz¹dek nazywa siê <i><b>si³¹ kolatora</b></i>.<br>
Nawet nie znaj¹c regu³ danego kolatora mo¿emy ustalaæ jego si³ê (np. czy
napisy ró¿ni¹ce siê tylko wielkoœci¹ liter maj¹ byæ rozrózniane). S³u¿y temu
metoda setStrength(...) z argumentem okreœlaj¹cym si³ê kolatora (jedna ze
sta³ych statycznych&nbsp; klasy Collator o nazwach PRIMARY, SECONDARY, TERTIARY,
IDENTICAL).<br>
<br>
W modyfikacji poprzedniego przyk³adowego programu ustalimy si³ê kolatora
na PRIMARY (domyœlnie jest TERTIARY). W polskiej lokalizacji (wedle regu³
dla niej okreslonych) nie bêd¹ teraz rozró¿niane wielkie i ma³e litery.<br>
<br>
<pre>  public static void main(String[] args) {
    String[] txt = { "bela", "Ala", "¹", "¥", "¹", "ala" , "Be", "Ala",
                     "alabama", "be", "Be", "1", "æ", "my", "My", "Myk", "myk"  };
    Collator col = Collator.getInstance();
    sortShow("Sort TERTIARY", txt, col);
    col.setStrength(Collator.PRIMARY);
    sortShow("Sort PRIMARY", txt, col);
}</pre>
Program wyprowadzi napisy w dwóch ró¿nych porz¹dkach, odpowiadj¹cych dwóm ró¿nym si³om kolatora:<br>
<div class="listing100"><br>
Sort TERTIARY<br>
1<br>
ala<br>
Ala<br>
Ala<br>
alabama<br>
¹<br>
¹<br>
¥<br>
be<br>
Be<br>
Be<br>
bela<br>
æ<br>
my<br>
My<br>
myk<br>
Myk<br>
Sort PRIMARY<br>
1<br>
Ala<br>
ala<br>
Ala<br>
alabama<br>
¹<br>
¥<br>
¹<br>
Be<br>
be<br>
Be<br>
bela<br>
æ<br>
my<br>
My<br>
Myk<br>
myk<br>
</div><br>
<br>
Oczywiœcie, mo¿emy sami definiowaæ regu³y dla obiektów klasy RuleBasedCollator.<br>
Regu³y s¹ zapisywane jak ³añcuchy znakowe w postaci:<br>
<br>
&nbsp;&nbsp;&nbsp; &lt;relacja&gt; tekst &lt;relacja&gt; tekst ....<br>
<br>
gdzie relacja wprowadzana jest za pomoc¹ znaków:<br>
&lt; &nbsp;- wiêksze wedle pierwszego porz¹dku (rozró¿niania liter)<br>
; &nbsp;- &nbsp;wiêksze wedle drugirgo porz¹dku (rozró¿niania akcentowanych liter),<br>
, &nbsp; - wiêksze wedle trzeciego porz¹dku (wielkoœæ liter)<br>
= - równe<br>
a tekst jest dowolym ci¹giem znaków wy³¹czaj¹c znaki specjalne i znaki opisuj¹ce
w/w relacje (jeœli takie znaki chcemy w³¹czyæ do porównañ ujmujemy je w apostrofy).<br>
<br>
Na przyk³ad:<br>
<br>
9 &lt; a, A &lt; b, B &lt; c, C<br>
<br>
Mo¿emy te¿ u¿yæ znaku &amp;, który ³ogicznie ³¹czy&nbsp; regu³y np:<br>
a &lt; b &amp; b &lt; c<br>
jest identyczne z :<br>
a &lt; b &lt; c<br>
<br>
przy tym jednak nale¿y uwa¿aæ na kolejnoœæ, bowiem po³¹czone regu³y s¹ stosowane w kolejnoœci od lewej do prawej i np. <br>
a &lt; c &amp; a &lt; b<br>
nie jest to¿same z <br>
a &lt; b &amp; a &lt; c<br>
<br>
Stworzenie pe³nego zestawu regu³ dla kolatora mo¿e byæ doœæ pracoch³onne. trzeba bowiem uwzglêdniæ wiele mo¿liwych znaków.<br>
Zobaczmy najpierw jak wygl¹da fragment regu³ dla kolatora w lokalizacji polskiej. <br>
Regu³y te mo¿emy uzyskaæ za pomoc¹ odwo³ania:<br>
<pre>    Collator col = Collator.getInstance();
    String rules = ((RuleBasedCollator) col).getRules();
</pre>
i pokazaæ np. w oknie:<br>
<br>
<img src="images/regulu.jpg" alt="r" border="1" height="174" width="491">
<br>
<br>
<br>
Spróbujmy teraz rozpatrzyæ uproszczony przyk³ad (abstrahuj¹c od wielu mo¿liwych
znaków). Przyk³ady sortowania pokaza³y nam, ¿e&nbsp; rozró¿nienie pomiêdzy du¿ymi
i ma³ymi literami &nbsp;nie jest pierwszorzêdne: tylko w przypadku gdy napisy
s¹ takie same kolator bierze pod uwagê tê ró¿nicê i ustawia wtedy ma³e litery
przed wielkimi. Widaæ to zreszt¹ w zestawie regu³ np. ... &lt; a, A &lt;
b, B &nbsp;rozróznia&nbsp;najpierw litery a i b (bez uwzglêdneinia ich wielkoœci),
a dopiero gdy napisy (sk³adaj¹cy siê z tych liter) s¹ takie same bierze pod
uwagê<br>
&nbsp;ich wielkoœæ.<br>
&nbsp;Stworzymy wiêc przyk³adowy inny zestaw regu³, który (przy sortowaniu rosn¹cym)
ustawi wyraz&nbsp; "Polska" na pocz¹tku, a inne napisy posortuje w porz¹dku -
najpierw du¿e litery, póŸniej ma³e (z uwzglêdnieniem polskich znaków i tego,
¿e polskie odpsoiedniki znaleŸc sie maj¹ po "normalnych" literach np. ¹ po
a).<br>
Obrazuje to poni¿szy program:<br>
<pre>import java.util.*;
import java.text.*;

public class Kolator1 {

  static void sortShow(String msg, String[] txt, final Collator col) {
    String[] copyTxt = (String[]) txt.clone();
    Arrays.sort(copyTxt, col);
    System.out.println(msg);
    for (int i=0; i &lt; copyTxt.length; i++) {
      System.out.println(copyTxt[i]);
    }
  }


  public static void main(String[] args) {

    // Napisy do posortowania
    String[] txt = { "bela", "Ala", "¹", "¥", "¹", "ala" , "Be", "Ala",
                     "alabama", "be", "Be", "1", "Æwik³a", "æwik³a",
                     "æwikla", "Polska",
                     "My", "my", "Myk", "myk"  };

    // Domyœlny polski kolator
    Collator col = Collator.getInstance();
    sortShow("Default sort", txt, col);

    // Nowe regu³y
    String rules = " &lt; Polska &lt; A &lt; ¥ &lt; B &lt; C &lt; Æ &lt; D &lt; E &lt; Ê &lt; F &lt; G &lt; H" +
                  " &lt; I &lt; J &lt; K &lt; L &lt; £ &lt; M &lt; N &lt; Ñ &lt; O &lt; P &lt; Q &lt; R &lt; S &lt; Œ" +
                  " &lt; T &lt; U &lt; V &lt; W &lt; X &lt; Y &lt; Z &lt;  " +
                  " &lt; a &lt; ¹ &lt; b &lt; c &lt; æ &lt; d &lt; e &lt; ê &lt; f &lt; g &lt; h" +
                  " &lt; i &lt; j &lt; k &lt; l &lt; ³ &lt; m &lt; n &lt; ñ &lt; o &lt; p &lt; q &lt; r &lt; s &lt; œ" +
                  " &lt; t &lt; u &lt; v &lt; w &lt; x &lt; y &lt; z &lt; Ÿ";

    try {
      col = new RuleBasedCollator(rules);
    } catch (ParseException exc) {
        System.out.println("Wadliwa regu³a na pozycji " + exc.getErrorOffset());
        System.out.println(exc);
        System.exit(1);
    }

    sortShow("My new rules sort", txt, col);

  }

}
</pre>

który wyprowadzi:<br>
<div class="listing100"><br>
Default sort<br>
1<br>
ala<br>
Ala<br>
Ala<br>
alabama<br>
¹<br>
¹<br>
¥<br>
be<br>
Be<br>
Be<br>
bela<br>
æwikla<br>
æwik³a<br>
Æwik³a<br>
my<br>
My<br>
myk<br>
Myk<br>
Polska<br>
<br>
My new rules sort<br>
Polska<br>
Ala<br>
Ala<br>
¥<br>
Be<br>
Be<br>
Æwik³a<br>
My<br>
Myk<br>
ala<br>
alabama<br>
¹<br>
¹<br>
be<br>
bela<br>
æwikla<br>
æwik³a<br>
my<br>
myk<br>
1</div><br>
<br>
Je¿eli sortowanie jakiegoœ zestawu napisów ma siê powtarzaæ wielokrotnie,
to dla zwiêkszenia efektywnoœci dzia³ania mo¿na przyporz¹dkowaæ napisom klucze
i sortowaæ te klucze (klucze s¹ sortowane szybciej). <br>
Sposób postêpowania jest nastêpuj¹cy:<br>
<ul>
  <li>stworzyæ kolekcjê lub tablicê na przechowywanie kluczy (obiektó klasy CollationKeys),</li>
  <li>dla ka¿dego napisu, który ma podlegaæ porz¹dkowaniu (sortowaniu) uzysk¹c
klucz do kolatora za pomoc¹ wywo³ania metody getCollationKey(napis) z klasy
Collator,</li>
  <li>wstawiæ klucz do tablicy lub kolekcji,</li>
  <li>posortowaæ tablicê lub kolekcjê,</li>
  <li>teraz klucze w tablicy/kolekcji s¹ ustwaione w porz¹dku napisów, okreœlanym przez kolator</li>
  <li>¿eby pokazaæ wynik sortowania przebiegamy tablicê/kolekcjê kluczy i
od ka¿dgeo klucza za pomoc¹ odwo³ania getSourceString() uzyskujemy skojarzony
z nim napis.</li>
</ul>
Ilustruje to poni¿szy program.<br>
<pre>import java.util.*;
import java.text.*;

public class Kolator2 {

  public static void main(String[] args) {

    // Napisy do posortowania
    String[] txt = { "bela", "Ala", "¹", "¥", "¹", "ala" , "Be", "Ala",
                     "alabama", "be", "Be", "1", "Æwik³a", "æwik³a",
                     "æwikla", "Polska",
                     "My", "my", "Myk", "myk"  };

    // Domyœlny polski kolator
    Collator col = Collator.getInstance();

    // Lista kluczy
    List keys = new ArrayList();

    // Uzyskanie kluczy dla napisów
    // wartoœci kluczy uzyskujemy od kolatora
    for (int i=0; i&lt;txt.length; i++) {
      CollationKey key = col.getCollationKey( txt[i] );
      keys.add(key);
    }

    // Sortowanie
    // porównywane mog¹ byæ tylko klucze uzyskane od tego samego kolatora!

    Collections.sort(keys);

    // Pokazanie wyniku
    // mamy klucze u³o¿one w okreœlonym porz¹dku napisów, które reprezentuj¹
    // musimy pobraæ napis skojarzony z kluczem

    for (Iterator it = keys.iterator(); it.hasNext(); ) {
      CollationKey key = (CollationKey) it.next();
      String napis = key.getSourceString();
      System.out.println(napis);
    }
  }

}
</pre>
<br>
<br>

<a name="Intern.9"></a><h2>9. Internacjonalizacja aplikacji i dodatkowe zasoby (resource bundle)</h2>

Nie tylka liczby, daty, czas powinny byæ w aplikacjach przygotowane do prezentacji
zgodnie z wymaganiami &nbsp;danej lokalizacji. Równie¿ komunikacja aplikacji z
u¿ytkownikiem powinna przebiegaæ w jêzyku &nbsp;u¿ytkownika.<br>
Wszelkiego rodzaju napisy i komunikaty dla u¿ytkownika powinny byæ lokalizacyjnie przygotowane.<br>
Czêstym b³êdem przy tworzeniu aplikacji "produkcyjnych" jest nieuwzglêdnianie
tego warunku. Oto ktoœ przygotowuje aplikacjê, u¿ywaj¹c do komunikowania
siê z u¿ytkownikiem napisów w jezyku polskim. Wszystko dzia³a poprawnie,
klient jest zadowolony. Nagle okazuje siê, ¿e ta sama aplikacja powinna dzia³aæ
w londyñskiej centrali firmy i wszystkie komunikaty, napisy itp. trzeba przerabiaæ
na angielski. Kosztuje to wiele wysi³ku, powoduje powstawanie b³êdów w programie
itd.<br>
<br>
Generalnie wiêc aplikacja powinna byæ od pocz¹tku przygotowana na dzia³anie
w ró¿nycyh œrodowiskach jêzykowych. A to oznacza koniecznoœæ odseparowania
jêzykowych w³aœciwoœci apliakcji (takich jak jêzyk komunikatów) od samego
jej kodu.<br>
<br>
Mechanizmem umo¿liwiaj¹cycm takie odseparowanie w Javie s¹ tzw. dodatkowe zasobu (ResourceBundle).<br>
Istniej¹ dwa rodzaje dodatkowych zasobów: oparte na klasach (ListResourceBoundle)
i na czystych, tekstowych plikach w³aœciwoœci (PropertiesResourceBundle).<br>
<br>
Pliki w³aœciwoœci umo¿liwiaj¹ odseparowanie napisów, klasy ListResourceBundle - dowolnych obiektów.<br>
<br>
Aby odseparowaæ napisy i dostarczyæ ich ró¿nych wersji jezykowych z apomoc¹ plików w³aœciwoœci:<br>
tworzymy plik w³aœciwoœci o wybranej nazwie i rozszerzeniu np. HelloMessages.properties<br>
w pliku tym zapisujmey pary: klucze = napis,<br>
dla ka¿dej lokalizacji barnej pod uwagê w naszej apliakcji towrzymy dodatkowy
plik w³aœciwoœci o nazwie zupelnienej o sufiks, wskazuj¹cy na lokalizacje
(np. HelloMessages_pl.properties)<br>
zapisujemy w nim (pod tymi samymi kluczami) napisy w jêzyku danej lokalizacji.<br>
w naszym programie u¿ywamy zdefiniowanych napisów poprzez mechanizm odwo³ania
do do okreœlonego przez aktualn¹ lokalizacjê dodatkowego zasobu (np. ResourceBundle
msgs = ResourceBundle.getBundle("HelloMessages", lokalizacja) i pobranie
napisu, znajduj¹cego siê pod podanym kluczen (np. String value = msgs.getString(key);<br>
Java odnajdzie odpowiedni plik w³aœciwoœci (np. HelloMessages_pl.properties)
i pobierze z niego napis, odpowidaj¹ce podanemu kluczowi; jeœli takiego pliku
nie bêdzie - to zostanie wybrany plik o mo¿liwie bliskiej nazwie (np. gdy
szukany jest &nbsp;niestniej¹cy plik HelloMessages_pl_PL.properties, to wynikiem
mo¿e byæ sitneij¹cy plik HelloMessages_pl.properties) albo plik bez sufiksu
w nazwie, który pe³ni rolê domyœlnego przy braku odpowiednio zlokaalizowanych.<br>
<br>
Jako prosty przyk³ad stworzymy dwa pliki wartoœci klucz=napis: domyœlny i dla lokazliacji poslkiej:<br>
<br>
Plik HelloMessages.properties<br>
# Komunikaty w aplikacji Hello - domyœlne przy braku pliku dla danej lokalizacji<br>
hello = Hello!<br>
bye = Good bye!<br>
<br>
Plik HelloMessages_pl.properties <br>
# Komunikaty w aplikacji Hello - po polsku<br>
hello = Dzieñ dobry!<br>
bye = Do widzenia.<br>
<br>
Uwaga: klucze (hello, bye) s¹ takie same.<br>
<br>
Plików tych i mechanizmu dodatkowych zasobó u¿yjemy w proœciutkiej aplikacji
Hello (dziêki czemu komunikacja z u¿ytkownikiem naprawdê bêdzie odseparowana
od kodu Ÿród³owego).
<pre>import java.util.*;

public class Hello {

  static void sayHello() {
    Locale defLoc = Locale.getDefault();
    ResourceBundle msgs =
                   ResourceBundle.getBundle("HelloMessages", defLoc);
    String powitaj  = msgs.getString("hello");
    String pozegnaj = msgs.getString("bye");
    System.out.println(powitaj);
    System.out.println(pozegnaj);
 }


  public static void main(String[] args) {
    sayHello(); // tutaj dzia³a domyœlna lokalizacja pl_PL
    // zmieniamy domyœln¹ lokalizacjê
    Locale.setDefault(new Locale("en"));
    sayHello();
  }

}
</pre>
Wynik dzia³ania programu:<br>
<div class="listing100"><br>
Dzieñ dobry!<br>
Do widzenia.<br>
Hello!<br>
Good bye!<br>
</div><br>
Uwagi: <br>
<ul>
  <li>pierwsza para napisów powstaje, gdy¿ domyœln¹ lokalziacj¹ jest pl_PL,
getBundle(defLoc) nie znajduje pliku w³aœciwoœci o takim sufiksie, ale znajduje
bliski mu z sufiksem pl,&nbsp; </li>
  <li>przy drugim odwo³aniu do sayHelli poszukiwany jest plik HelloMessages_en.properties,
a poniewa¿ go nie ma - u¿ywany jest domyœlny HelloMessages.properties</li>
</ul>
Tak naprawdê ResourceBundle.getBundle(..) szuka najpierw klas dziedzizcacych
ListResourceBundle, a dopiero póŸniej plików w³aœciwoœci.<br>
<br>
U¿ycie ListResourceBundle wymaga od nas pisania kodu (i to jest wada w stosunku
do mechanizmu plików w³aœciwoœci), ale równowczeœnie pozwala na wprowadzenie
"pod kluczami" - innych obiektów ni¿ napisy (np. jakichœ liczb, obrazów,
dŸwiêkó - oczywiœciê zlokalizowancyh).<br>
<br>
Nasze zlokalizowane listy zasobów s¹ klasami, które:<br>
<ul>
  <li>maj¹ nazwy zgodne z opisan¹ wczeœniej (przy okazji plikó w³asciwoœci) konwenccj¹&nbsp; (sufiksy wskazuj¹ce na lokalizacjê)</li>
  <li>dziedzicz¹ klasêe ListResourceBundle,</li>
  <li>dostarczaj¹ publicznej metody Object[][] getContents() która zwraca
tablicê odpowiednioœci klucze - wartoœci, przy czym zaróno klucze jak i odpowidaj¹ce
im wartoœci mog¹ byæ dowolnymi obiektami.</li>
</ul>
Przyk³ad:<br>
<pre>public class CountryInfo_pl_PL extends ListResourceBundle {

   public Object[][] getContents() {
	return contents;
    }

    private Object[][] contents = {
	{ "name", "Polska" },
	{ "flag",  new ImageIcon("PolskaFlaga.gif") },
    };
}
</pre>
<br>
Uzyskiwanie wartoœci z takich zasobów odbywa siê w nastêpuj¹cy sposób:<br>
<br>
<pre>ResourceBundle&nbsp;info =
		ResourceBundle.getBundle("CountryInfo", currentLocale);

String nazwaKraju = info.getString("name");
ImageIcon flaga = (ImageIcon) info.getObject("flag");
</pre>
Uwaga: je¿eli wartoœæ nie jest Stringiem nale¿y zastosowaæ metodê getObject()
i dokonaæ zawê¿aj¹cej konwersji do w³aœciwego typu.<br>
<br>
<br>
Dodatkowe zasoby (w specjalnej formie) razem z formatorem MessageFormat s¹
u¿ywane do generowania z³o¿onych komunikatów, które opisywane s¹ za pomoc¹
szablonu z wymiennymi parametrami. <br>
<br>
Opanowanie tego zagadnienia pozostawiamy Czytelnikowi jako dodatkowe
æwiczenie z dokumentacj¹ (klasa MessageFormat). Poni¿szy pzryk³adowy
program korzysta z tej klasy do internacjonalizacji aplikacji, która
"symuluje" wyp³aty z bankomatu.<br><br>
<div style="text-align: left;">
<span style="font-style: italic;">Zobacz dzia³anie programu (uwaga: dokonanie wyp³aty przez Enter na polu tekstowym)</span></div> 
<applet codebase="demo" code="starterApplet.StarterApplet.class" archive="StarterApplet.jar" align="left" height="70" vspace="20" width="250">
<param name="className" value="msg.Msg1">
<param name="title" value="Demo programu Msg1"><param name="sourceCode" value="msg/source.html">
<param name="hasArgs" value="no"><param name="hasConsole" value="no">
</applet>
<br><br><br><br><br><br><br>
<pre>package msg;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import java.text.*;
import java.util.*;
import java.beans.*;

@SuppressWarnings("serial")
public class Msg1 extends JFrame  {

  private JPanel panel = new JPanel();
  private JTextArea log = new JTextArea(20, 40);
  private String parseErrorPattern;
  private String reportPattern;
  private String exceedPattern;
  private double limit = 1000;
  private double sum;

  public Msg1() {
    panel.add(new JLabel());
    final JTextField tf = new JTextField(10);
    panel.add(tf);
    JButton b = new JButton();
    b.setActionCommand("pl_PL");
    b.addActionListener(locChanger);
    panel.add(b);
    b = new JButton();
    b.setActionCommand("en_GB");
    b.addActionListener(locChanger);
    panel.add(b);
    add(panel, "North");

    localize(Locale.getDefault());

    
    add(log);

    tf.addActionListener( new ActionListener() {
          public void actionPerformed(ActionEvent e) {
            ParsePosition p = new ParsePosition(0);
            String txtNum = tf.getText().trim();
            Number val = NumberFormat.getInstance().parse(txtNum, p);
            String out;
            if (p.getIndex() != txtNum.length())
              out = MessageFormat.format(parseErrorPattern, txtNum);
            else if (sum + val.doubleValue() &gt; limit)
              out = MessageFormat.format(exceedPattern, limit);
            else {
              sum += val.doubleValue();
              Date date = Calendar.getInstance().getTime();
              out = MessageFormat.format(reportPattern, date, val);
            }
            log.append(out+'\n');
          }
       });
    
    // Inicjacja fontów
    Font f = new Font("Dialog", Font.PLAIN, 18);
    log.setFont(f);
    for (Component c : panel.getComponents()) c.setFont(f);

    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    pack();
    setLocationRelativeTo(null);
    setVisible(true);
  }

  private void localize(Locale loc) {
    limit = 1000;
    sum = 0;
    log.setText("");
    Locale.setDefault(loc);
    ResourceBundle info =
                   ResourceBundle.getBundle("msg.Info");  <span style="font-weight: bold;">// uwaga nale¿y podac nazwê pakietu</span>
    String[] txt = {
                       info.getString("enterData"),
                       "",
                       info.getString("polish"),
                       info.getString("english"),
                   };
    Component[] c = panel.getComponents();
    for (int i=0; i&lt;c.length; i++) {
      Statement stmt = new Statement(c[i], "setText",
                            new Object[] { txt[i] } );
      try {
        stmt.execute();
      } catch(Exception exc) { exc.printStackTrace(); }
    }
    panel.invalidate();
    parseErrorPattern = info.getString("parseError");
    reportPattern = info.getString("report");
    exceedPattern = info.getString("exceedError");
  }


  ActionListener locChanger =  new ActionListener() {
    public void actionPerformed(ActionEvent e) {
      String symloc = e.getActionCommand();
      String[] locArg = symloc.split("_");
      localize(new Locale(locArg[0], locArg[1]));
    }
  };

  public static void main(String[] args) {
     SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        new Msg1();
      }
    });
  }

}</pre>
<br>
Wykorzystane w programie ListResourceBundle wygl¹daj¹ tak:<br>
<pre>package msg;

import java.util.*;
public class Info_en_GB extends ListResourceBundle {

   public Object[][] getContents() {
     return contents;
   }

   private Object[][] contents = {
      { "english", "English" },
      { "polish", "Polish" },
      {  "enterData", "Withdrawal" },
      { "report",
         "At {0,time} on {0,date} value of {1,number,currency} was withdrawed" },
      { "parseError", "Invalid value format: {0}" },
      { "exceedError", "Total ammount {0,number,currency} exceeded" },
   };

}</pre>
<br>
<pre>package msg;

import java.util.*;
public class Info_pl_PL extends ListResourceBundle {

   public Object[][] getContents() {
     return contents;
   }

   private Object[][] contents = {
     {  "english", "Angielski" },
     {  "polish", "Polski" },
     {  "enterData", "Wyp³ata" },
     {  "report", "Dnia {0,date} o godzinie {0,time}" +
                  " wyp³acono {1,number,currency}" },
     {  "parseError", "Nieprawid³owy format wartoœci do wyp³aty {0}" },
     {  "exceedError", "Mo¿liwa suma wyp³at {0,number,currency}" +
                     " zosta³a przekroczona" },
   };

}</pre>

</body>
</html>