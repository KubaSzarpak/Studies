<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="Content-Type"
 content="text/html; charset=windows-1250"> <meta name="author"
 content="Krzysztof Barteczko"> <meta name="description"
 content="Uniwersalne techniki programowania"> <meta name="copyright"
 content="(c) Krzysztof Barteczko PJWSTK 2010"> <link rel="stylesheet"
 type="text/css" href="../STYLE/common.css"> <title>Dynamiczna Java:
refleksja</title></head>
<body><br>
<br>
<div align="center"><h1>Dynamiczna Java: refleksja</h1>
</div><br>
<hr><i>Dynamiczne programowanie pozwala na&nbsp;tworzenie bardzo
elastycznych i uniwersalnych aplikacji. W Javie ma ono wiele aspektów.<br>
</i><span
 style="font-style: italic;">Java jest jêzykiem interpretowanym.
Kompilator tworzy kod bajtowy, ten zaœ podlega interpretacji przez
wirtualn¹ maszynê Javy. </span><span style="font-style: italic;">Daje
to podstawy do dynamicznego, w fazie wykonania, kszta³towaniu
mechanizmów
dzia³ania programu. Osi¹gamy to dziêki tzw. refleksji.</span><br
 style="font-style: italic;"><span style="font-style: italic;">
Refleksja stanowi równie¿ podstawowy, niskopoziomowy mechanizm,
wykorzystywany
przy programowaniu komponentowym (JavaBeans).&nbsp; </span> <hr>
<a name="Reflex.1"></a><h2>1. Dynamiczne ³adowanie klas</h2>
W klasie Object zdefiniowano metodê getClass. Zastosowana wobec
dowolnego obiektu
zwraca odnoœnik do jego klasy, do obiektu klasy java.lang.Class. <br>
<br>
<div class="important">Obiekty klasy Class s¹ klasami (to wa¿ne: tu
same klasy s¹ obiektami) </div><br>
<br>
Mo¿emy wobec takich obiektów stosowaæ ró¿ne metody klasy Class z
pakietu java.lang, np. <br>
<br>
<ul><li>
getSuperClass() - zwracaj¹c¹ obiekt klasy Class oznaczaj¹cy klasê
bazow¹ danej klasy, </li><li>
getInterfaces() - zawracaj¹c¹ tablicê obiektów, zawieraj¹c¹ interfejsy
danej klasy, </li><li>
newInstance() - tworz¹c¹ nowy obiekt danej klasy. </li></ul>
Obiektów-klas nie mo¿emy tworzyæ za pomoc¹ wyra¿enia new. <br>
Jedynie poprzez u¿ycie odpowiednich metod uzyskujemy odnoœniki do tych
obiektów. <br>
<br>
Jedn¹ z takich metod jest statyczna metoda klasy Class: <br>
<br>
<b>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; forName(String
NazwaKlasy); </b><br>
<br>
Np. pisz¹c: <br>
<br>
Class c = Class.forName("javax.swing.JButton"); <br>
<br>
lub <br>
<br>
Class c = javax.swing.JButton.class; &nbsp;&lt;--- <b>nazwa_klasy.<i>class</i></b>
jest <b>litera³em</b> oznaczaj¹cym<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp;obiekt-klasê<br>
<br>
uzyskujemy odnoœnik do&nbsp; klasy przycisków i mo¿emy siê nim
pos³u¿yæ przy tworzeniu obiektu: <br>
<br>
JButton b = (JButton) c.newInstance(); <br>
&nbsp;&nbsp; <br>
W statycznym przypadku, gdy wszystko jest ustalone "w Ÿródle" programu,
sens
takich konstrukcji jest niewielki. Ale bardzo czêsto warto od³o¿yæ
pewne
ustalenia do fazy wykonania programu, zwiêkszaj¹c jego elastycznoœæ i
uniwersalnoœæ.
Wtedy dynamiczna reprezentacja obiektów-klas bardzo siê przydaje. <br>
<br>
Najprostszy przyk³ad: odroczenie ustalenia sposobu obs³ugi akcji na
przycisku
do fazy wykonania programu pokazano na poni¿szym wydruku.&nbsp; Jako
argument
podajemy nazwê klasy, której obiekt obs³uguje akcjê. Mo¿emy mieæ wiele
takich
(wariantowych) klas i bez ¿adnej rekompilacji zmieniaæ sposoby obs³ugi
klikniêcia
w przycisk.<br>
<pre>package dynload;
import javax.swing.*;

class Main extends JFrame {

  static void exit(String s) {
    System.out.println(s);
    System.exit(1);
  }


  Main(String actionClassName) {
    Class actionClass = null;
    Action act = null;
    try {
      actionClass =  Class.forName(actionClassName);
      act = (Action) actionClass.newInstance();
    } catch (Exception exc) {
        exit("Obiekt klasy akcji nie mo¿e byæ utworzony");
    }

    JButton b = new JButton();
    b.setAction(act);
    add(b);
    setDefaultCloseOperation(DISPOSE_ON_CLOSE);
    pack();
    setLocationRelativeTo(null);
    setVisible(true);  }
  
  public static void main(String args[]) {
    final String in = JOptionPane.showInputDialog("Podaj nazwê klasy:");
    if (in != null) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          new Main(in);
        }
      });  
     
    }
  }

}

</pre>Uwaga:
w powy¿szym przypadku newInstance zwraca referencjê do obiektu klasy
Object - st¹d potrzeba konwersji do typu Action.<br>
<br>
Jeœli teraz przygotujemy dwie klasy, opisuj¹ce ró¿ne akcje np.<br>
<pre>package dynload;
import javax.swing.*;
import java.awt.event.*;

public class DialogAction extends AbstractAction {

  final static String ACTION_NAME = "Show msg";

   public DialogAction() {
     super(ACTION_NAME);
   }

   public void actionPerformed(ActionEvent e) {
     JOptionPane.showMessageDialog(null, ACTION_NAME);
   }

}
</pre>i<br>
<pre>package dynload;
import javax.swing.*;
import java.awt.event.*;

public class PrintAction extends AbstractAction {

  final static String ACTION_NAME = "Print";

   public PrintAction() {
     super(ACTION_NAME);
   }

   public void actionPerformed(ActionEvent e) {
     System.out.println("Wykonan akcja: " + ACTION_NAME);
   }

}
</pre>to
uruchomienie g³ównego programu z argumentem: DialogAction:<br>
<br>
java Main dynload.DialogAction<br>
<br>
spowoduje, ¿e przycisk w oknie uzyska nazwê Show Msg, a jego
klikniecie otworzy okienko komunikaty.<br>
<br>
Natomiast po uruchomieniu programu z argumentem PrintAction<br>
<br>
java Main dynload.PrintAction<br>
<br>
nada przyciskowi nazwê Print, a jego klikniêcie wyprowadzi
komunikat na konsolê.<br>
<br>
Uwaga: jak widaæ podawane nazwy klas winny byæ kwalifikowane nazw¹
pakietu.<br>
<br>
Takie mo¿liwoœci istnia³y w Javie od zawsze. Ale samo dynamiczne
³adowanie
klas to zdecydowanie za ma³o, by mo¿na by³o tworzyæ naprawdê elastyczne
programy.
Dopiero w wersji 1.1&nbsp; Java zyska³a prawdziw¹ elastycznoœæ dziêki
wprowadzeniu
mechanizmów refleksji.<br>
<br>
<a name="Reflex.2"></a><h2>2. Mechanizm refleksji</h2>
<br>
Podstawowy programistyczny interfejs refleksji (<b>Core Reflection
API</b>) realizowany jest przez klasy pakietu <b>java.lang.reflect</b>&nbsp;
oraz rozbudowan¹ klasê Class z pakietu java.lang.<br>
<br>
<div class="def"><b>Refleksja</b> oznacza mo¿liwoæ wykonywania W
TRAKCIE WYKONANIA PROGRAMU nastêpuj¹cych dzia³añ:&nbsp; <br>
<ul><li>uzyskiwania pe³nej informacji o charakterystykach klasy (pola,
metody, ich charakterystyki) </li><li>dzia³añ na polach danego
obiektu, poprzez ich nazwy,&nbsp; </li><li>aktywowanie metod na rzecz
danego obiektu poprzez ich nazwy i z podaniem argumentów.</li></ul>
</div><br>
<br>
U¿ycie refleksji pozwala m.in. na: <br>
&nbsp; <br>
<ul><li>stwierdzenie jakie i z jakimi argumentami metody wystêpuj¹ w
danej
klasie (np. podawanej dynamicznie w trakcie wykonania programu) </li><li>dynamiczne
wywo³ywanie metod (specyfikowanych w trakcie wykonania programu)
na rzecz jakiego obiektu (te¿ dynamicznie ustalanego), </li><li>dynamiczne
uzyskiwanie i modyfikacje wartoœci pól obiektu. </li></ul>
Uzywaj¹c mechanizmów refleksji do metod i pól odwo³ujemy siê poprzez
ich nazwy, a nie identyfikatory. <br>
Na czym polega ró¿nica wobec statycznego przypadku? <br>
<br>
W statyce odwo³ania s¹ skonkretyzowane na etapie kompilacji. <br>
Piszemy np. b.getText(). I tak ju¿ zostanie na zawsze. <br>
W dynamice konstrukcja jest ca³kiem inna - w³aœnie pos³uguj¹ca siê
nazw¹ metody. Piszemy raczej tak: b.invokeMethod("getText"). <br>
Tu invokeMethod jest nasz¹ w³asn¹ metod¹. Jako argument podajemy nazwê
metody
klasy, a poniewa¿ jest to String, mo¿emy go zmieniaæ w ka¿dym momencie
wykonania
programu. Np. mo¿emy napisaæ: b.invokeMethod(s), a kolejne podstawienia
pod
s ró¿nych nazw metod bêdzie zmieniaæ znaczenie tej linii programu.
W³aœnie
w invokeMethod u¿ywamy œrodków refleksji.
<br>
&nbsp;<br>
Klasy pakietu java.lang.reflect
<br>
<table border="1" cellspacing="1" width="623">
<tbody><tr><td style="font-weight: bold; text-align: center;"
 valign="middle" width="14%">Klasa</td><td
 style="font-weight: bold; text-align: center;" valign="middle"
 width="86%">Przeznaczenie</td></tr><tr><td valign="middle" width="14%">Array&nbsp;</td><td
 valign="middle" width="86%">Tworzenie tablic, uzyskiwanie i ustalanie
wartoœci elementów</td></tr><tr><td valign="middle" width="14%">Constructor&nbsp;</td><td
 valign="middle" width="86%">Informacja i dostêp do danego konstru
ktora danej klasy. W szczególnoœci wykorzystanie dla tworzenia obiektu.</td></tr><tr><td
 valign="middle" width="14%">Field&nbsp;</td><td valign="middle"
 width="86%">Informacja i dostêp do pola obiektu. Pobranie i zmiana
wartoœci pola.</td></tr><tr><td valign="middle" width="14%">Method&nbsp;</td><td
 valign="middle" width="86%">Informacja o danej metodzie danej klasy.
Dynamiczne wywo³anie metody na rzecz danego obiektu.
</td></tr><tr><td valign="middle" width="14%">Modifier&nbsp;</td><td
 valign="middle" width="86%">Uzyskiwanie informacji o modyfikatorach
sk³adowej obiektu lub klasy.</td></tr></tbody>
</table><br>
&nbsp;<br>
U¿yteczne metody klasy java.lang.Class
<br>
&nbsp; <table border="1" cellspacing="1" width="623">
<tbody><tr><td style="font-weight: bold; text-align: center;"
 valign="middle" width="45%">Metoda</td><td
 style="font-weight: bold; text-align: center;" valign="middle"
 width="55%">Przeznaczenie</td></tr><tr><td valign="middle" width="45%">getClasses()&nbsp;
<br>
getDeclaredClasses()&nbsp;</td><td valign="middle" width="55%">Zwraca
tablicê obiektów klasy Class, które s¹ sk³adowymi danej klasy.</td></tr><tr><td
 valign="middle" width="45%">getConstructors()&nbsp; <br>
getDeclaredConstructors()</td><td
 valign="middle" width="55%">Zwraca tablicê obiektów klasy Constructor;
s¹ to konstruktory danej klasy</td></tr><tr><td valign="middle"
 width="45%">getConstructor(Class[])
getDeclaredConstructor(Class[])&nbsp;</td><td valign="middle"
 width="55%">Zwraca obiekt konstruktor (obiekt klasy konstruktor),
który ma podane typy argumentów&nbsp;</td></tr><tr><td valign="middle"
 width="45%">getMethods()&nbsp; <br>
getDeclaredMethods()&nbsp;</td><td
 valign="middle" width="55%">Zwraca tablicê, zawieraj¹c¹ odnoœniki do
metod klasy. Metody s¹ obiektami klasy Method.</td></tr><tr><td
 valign="middle" width="45%">getMethod(String, Class[]) <br>
getDeclaredMethod(String,
Class[])&nbsp;</td><td valign="middle" width="55%">Zwraca metodê o
podanej nazwie i podanych argumentach jako obiekt klsy Method.</td></tr></tbody>
</table><br>
Uwaga : Rozró¿nienie pomiêdzy metodami maj¹cymi i nie
maj¹cymi w nazwie tekstu "Declared" jest nastêpuj¹ce: <ul><li> metody
bez "Declared" zwracaj¹ sk³adowe tylko publiczne, ale jednoczeœnie
równie¿ dziedziczone, </li><li> metody z "Declared" zwracaj¹ wszystkie
sk³adowe (równie¿ prywatne i zabezpieczone), ale bez dziedziczonych </li></ul><br>
<a name="Reflex.3"></a><h2>3. Proste przyk³ady wykorzystania refleksji</h2>
Przypomnijmy sobie najpierw
prezentacjê ró¿nych rodzajów ramek (wyklad o komponentach GUI). <br>
Pos³u¿y³
jej nastêpuj¹cy program, w którym w sposób dynamiczny uzyskujemy
informacje
o polach klasy.<br>
<pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import java.lang.reflect.*;

public class Ramki extends JFrame {

   // Pola klasy okreœlaj¹ ró¿ne rodzaje ramek
   private Border
     // empty = BorderFactory.createEmptyBorder(),
     blackLine = BorderFactory.createLineBorder(Color.black),
     blueLine3 = BorderFactory.createLineBorder(Color.blue, 3),
     // titled1 = BorderFactory.createTitledBorder("Tytu³"),
     titled2 = new TitledBorder(blueLine3,"Tytu³",
                   TitledBorder.CENTER, TitledBorder.CENTER,
                   new Font("Dialog", Font.BOLD | Font.ITALIC, 16),
                   Color.blue),
     etched = BorderFactory.createEtchedBorder(),
     etchedC = BorderFactory.createEtchedBorder(Color.red, Color.yellow),
     // raisedBevel = BorderFactory.createRaisedBevelBorder(),
     // loweredBevel = BorderFactory.createLoweredBevelBorder(),
     matteColor = BorderFactory.createMatteBorder(5, 10, 5, 15, Color.red),
     matteIcon = new MatteBorder(new ImageIcon("FastForward24.gif")),
     softBevR = new SoftBevelBorder(SoftBevelBorder.RAISED),
     softBevL = new SoftBevelBorder(SoftBevelBorder.LOWERED),
     compound1 = BorderFactory.createCompoundBorder(softBevR, softBevL),
     compound2 = BorderFactory.createCompoundBorder(blueLine3, compound1),
     compound3 = BorderFactory.createCompoundBorder(compound1, matteIcon);


  Ramki() {
    super("Prezentacja ramek");
    getContentPane().setLayout (new GridLayout(0,4,5,5));

    // Klasa tego obiektu
    Class c = getClass();

    // Uzyskanie tablicy wszystkich zadeklarowanych pól tej klasy
    Field[] field = c.getDeclaredFields();

    // Przebiegamy po polach-ramkach
    for (int i=0; i&lt; field.length; i++) {

      // Nazwa pola (zmiennej) - opisuj¹cego kolejn¹ ramkê
      String fldName = field[i].getName();

      // Tê nazwê wypiszemy na etykiecie
      JLabel l = new JLabel(fldName, JLabel.CENTER);

      // Uzyskanie referencji do obiektu, reprezentowanego przez
      // pole field[i] tego (this) obiektu. Czyli - do kolejnej ramki

      Object ramka = null;
      try {
        ramka = field[i].get(this);
      } catch (IllegalAccessException exc) { // Ten wyjatek mo¿e wyst¹piæ
          exc.printStackTrace();             // gdy dostêp do pola jest zabroniony
      }                                      // np. z innej klasy do prywatnego pola

      // Dostaliœmy oczywiœcie ramkê, ale jako Object
      // - konieczna konwersja do Border

      l.setBorder((Border) ramka);

      getContentPane().add(l);
    }

    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    pack();
    show();
  }

  public static void main(String[] args) {
    new Ramki();
  }
}
</pre>Skrupulatny
Czytelnik zapewne zauwa¿y, zê prezentacja jest teraz nieco inna ni¿ w
rozdziale o GUI (zob. rysunek).<br>
<br>
<img src="images/Ramki.jpg" alt="r" border="1" height="263"
 width="531">
<br>
<br>
W programie, w definicjach pól klasy zmieniono (w stosunku do
poprzedniej
prezentacji) niektóre w³asciwoœci ramek, niektóre zaœ ramki usuniêto
(za
pomoc¹ komentarzy). Wszystkie manipulacje na zestawie ramek do
prezentacji
- dziêki refleksji - wykonujemy wy³¹cznie "na" polach klasy
(definiuj¹cych
ramki). Mo¿emy wiêc w prosty sposób dodac nowe ramki, i - jak
widzieliœmy
- usun¹æ inne.<br>
Takie zastosowanie refleksji&nbsp; znacznie ograniczy³o pracoch³onnoœci
pisania kodu. <br><br>
Drugi przyk³ad dotyczy dynamicznego wywo³ania
metod.<br>
Program daje u¿ytkownikowi wybór co do nastêpstw
przyciœniêcia
jakiego przycisku. Co wiêcej, wyborów takich u¿ytkownik mo¿e dokonywaæ
w
fazie wykonania programu. <br>
Zestaw mo¿liwych akcji (na przyciskach) bêdzie zawarty w klasie
ActionsSet np. <br>
<pre>public class ActionSet {

 public void dodaj() { show("Dodaj"); }
 public void usuñ() { show("Usuñ"); }
 public void zast¹p() { show("Zast¹p"); }
 public void szukaj() { show("Szukaj"); }
 public void otwórz() { show("Otwórz"); }

 private void show(String string) {
   JOptionPane.showMessageDialog(null, string);
 }

}</pre>Opcje
dla u¿ytkownika bêd¹ przedstawione w menu kontekstowym, otwieranym
na przycisku. Z tego menu mo¿e on wybraæ (wielokrotnie i ró¿nie w
trakcie
dzia³ania programu) co konkretnie ma siê staæ, jeœli przyciœnie ten
przycisk.<br>
<br>
Poni¿szy wydruk pokazuje konstrukcjê programu. Warto zwróciæ
uwagê&nbsp;na zmienn¹ liczbê argumentow metod refleksji.<br>
<pre>import java.lang.reflect.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class ReflectionTest extends JFrame implements ActionListener {

  Method currAction = null; // bie¿¹ca metoda obs³ugi
  Class actionClass = null; // klasa obs³ugi
  Object actionObject = null; // obiekt obs³ugi
  JPopupMenu popUp = null; // menu kontekstowe z wyborem obs³ugi
  JButton b;

  public ReflectionTest() {
    super("Test refleksji");
    try {
      actionClass = Class.forName("ActionSet");
      actionObject = actionClass.newInstance();
    } catch (Exception exc) {
      throw new RuntimeException("Wadliwa klasa obs³ugi");
    }

    popUp = new JPopupMenu();
    createMenuItems();

    b = new JButton("U¿yj prawego klawisza myszki, by ustaliæ akcjê");
    b.setFont(new Font("Dialog", Font.BOLD, 24));
    b.addActionListener(this);
    b.setComponentPopupMenu(popUp); 

    setLayout(new FlowLayout());
    add(b);
    setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    pack();
    setLocationRelativeTo(null);
    setVisible(true);
  }

  void createMenuItems() {
    Method mets[] = null;
    try {
      mets = actionClass.getMethods();
    } catch (Exception exc) {
      throw new RuntimeException("Niedostêpna info o metodach klasy obs³ugi");
    }

    for (Method m : mets) {
      if (m.getDeclaringClass() == actionClass) {
        String name = m.getName();
        JMenuItem mi = new JMenuItem(name);
        mi.addActionListener(this);
        popUp.add(mi);
      }
    }
  }

  void setCurrentAction(String action) {
    try {
      currAction = actionClass.getMethod(action); // zm. liczba arg.!!!
      b.setText("Teraz akcj¹ jest: " + currAction.getName() + " - kliknij!");
    } catch (Exception exc) {
      throw new RuntimeException("Nieznana metoda obs³ugi");
    }
  }

  public void actionPerformed(ActionEvent e) {
    Object src = e.getSource();
    if (src instanceof JMenuItem)
      setCurrentAction(((JMenuItem) src).getText());
    else {
      try {
        currAction.invoke(actionObject); // zmienna liczba arg. !!!
      } catch (Exception exc) {
        JOptionPane.showMessageDialog(null, "Akcja na przycisku nieustalona!");
      }
    }
  }

  public static void main(String args[]) {
    new ReflectionTest();
  }

}
</pre><br>
<br><br>
W programie korzystamy z klasy Method.
Uzyskuj¹c odnoœnik do konkretnej metody,
mo¿emu ustaliæ j¹ jako obs³uguj¹c¹ zdarzenie (metoda setCurrentAction).
Przy
zajœciu zdarzenia mo¿emy "poœrednio" (dynamicznie) wywo³aæ jego
obs³ugê.
S³u¿y temu metoda invoke z klasy Method, u¿yta w actionPerformed. <br><br>
Ogólnie:<br><br>
<ul><li>uzyskanie
metody o nazwie name zadeklarowanej w klasie c i maj¹cej okreœlone
przez t1, t2, ... typy argumentów:</li></ul><div
 style="margin-left: 40px;">String name = ....<br>
Class t1 = ....<br>
Class
t2 - ...<br>
Method m = c.getDeclaredMethod(name [, t1 [, t2 ...] )<br>
</div><br>
<div
 style="margin-left: 40px;">w szczegolnoœci metoda o nazwie name bez
argumentów mo¿e byæ uzyskana przez getMethod(name).<br>
</div><br>
<ul><li>wywolanie
metody m na rzecz obiektu trg z argumentami x, y, z:</li></ul><div
 style="margin-left: 40px;">m.invoke(trg, x, y, x)<br>
</div><br>
<br>
<hr>
<a name="Reflex.4"></a><h2>4. Refleksja w uniwersalnych modelach danych</h2>
Wa¿ne zastosowanie zanjduje refleksja w budowie uniwersalnych modeli
danych. Zobaczymy to na przyk³adzei modelu danych dla tabeli, który
mo¿e byæ zastosowane dla dwolnych tabel dowolnych obiektów. Dane s¹
reprezentowane jako lista obiektów - ka¿dy obiekt-element listy jest
pokazywany w atbeli jako wiersz, a wartoœciami kolumn s¹ wartoœci
przekazanych przy konstrukcji modelu pól obiektu.<br><br><br>
<pre>package generictable;

import java.lang.reflect.*;
import java.util.*;

import javax.swing.table.*;

public class GenTabModel&lt;T&gt; extends AbstractTableModel {
  
  private List&lt;T&gt; rows;
  private Field[] fields;
  private String[] cnames;
  
  public GenTabModel(List&lt;T&gt; rows, String[] fnames, String[] cnames) {
    super();
    if (rows.size() == 0) throw new IllegalArgumentException("Empty objects list");
    Class&lt;?&gt; klas = rows.get(0).getClass();
    fields = new Field[fnames.length];
    try {
      for (int i = 0; i &lt; fnames.length; i++) {
        fields[i] = klas.getDeclaredField(fnames[i]);
        fields[i].setAccessible(true);
      }
    } catch (NoSuchFieldException exc) {
      IllegalArgumentException ilae = new IllegalArgumentException("Field not found", exc );
      throw ilae;
    }
    this.rows = rows;
    this.cnames = cnames;
  }

  @Override
  public int getColumnCount() {
    return cnames.length;
  }

  @Override
  public int getRowCount() {
    return rows.size();
  }
  
  @Override
  public String getColumnName(int c) {
    return cnames[c];
  }
  
  @Override
  public Class&lt;?&gt; getColumnClass(int c) {
    try {
      return fields[c].get(rows.get(0)).getClass();
    } catch (Exception exc) {
      exc.printStackTrace();
      return Object.class;
    }
  }

  @Override
  public Object getValueAt(int r, int c) {
    T obj = rows.get(r);
    try {
      return fields[c].get(obj);
    } catch (IllegalArgumentException exc) {
        exc.printStackTrace();
        return null;
    } catch (IllegalAccessException exc) {
        exc.printStackTrace();
        return null;
    }
  }
  
  @Override
  public boolean isCellEditable(int rowIndex, int columnIndex) {
    return true;
  }
  
  @Override
  public void setValueAt(Object value, int r, int c) {
    T obj = rows.get(r);
    try {
      fields[c].set(obj, value);
    } catch (Exception exc) {
      exc.printStackTrace();
    }
  }

}
</pre>Ten
model mo¿e byæ zastosowany np. do pokazania informacji o pracownikach:<br>
Klasê
parcowników pokazuje poni¿szy wydruk:<br><br>
<pre>public class Employee {
  
  private static final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
  
  private String name;
  private Date born;
  private Double salary;
  
  
  public Employee(String nam, String dat, Double sal) {
    name = nam;
    try {
      born = format.parse(dat);
    } catch (ParseException exc) {
        exc.printStackTrace();
        born = null;
    }
    salary = sal;
  }

  public String toString()
  {
      final String TAB = "; ";
      String retValue = "";
      retValue = 
          this.name + TAB +
          format.format(this.born) + TAB +
          this.salary;
      return retValue;
  }
  
  

}</pre><br>
a
utworzenie tabeli testowy program:<br>
<pre>import java.util.*;

import generictable.*;

import javax.swing.*;


public class TestTab extends JFrame {
  
  public TestTab() {
    
    List&lt;Employee&gt; list = Arrays.asList(
        new Employee("Kowalski Jan", "1960-10-12", 2700.5),
        new Employee("Malinowskiski Jan", "1980-12-12", 1700.3),
        new Employee("Kotek Kazimierz", "1950-11-05", 3700.1)
        );
    
    GenTabModel&lt;Employee&gt; tm = new GenTabModel&lt;Employee&gt;(
        list,
        new String[] { "name", "born", "salary" },
        new String[] { "Nazwisko", "Data urodzenia", "Pensja" });

    JTable tab = new JTable(tm);
    add ( new JScrollPane(tab) );
    setSize(300,300);
    setVisible(true);
  }

  public static void main(String[] args) {
    new TestTab();
  }

}</pre><br>
Rysunek
pokazuje tabelê pracowników:<br><br>
<img
 style="width: 300px; height: 119px;" alt="r" src="images/tabprac.jpg"><br><br>
Tak
samo ³atwo bêdzie mozna u¿yæ &nbsp;tego modelu dla ka¿dgo innego
przypadku - np. jakichœ kont z punktrami pracowników:<br><br>
<pre>public class Accounts {
  
  private String id;
  private Employee emp;
  private Integer points;
  
  public Accounts(String id, Employee emp, Integer points) {
    this.id = id;
    this.emp = emp;
    this.points = points;
  }
  
  public String toString() {
    return id + "; " + emp + "; " + points;
  }
  
}</pre>
<pre>import java.util.*;

import generictable.*;

import javax.swing.*;


public class TestTab2 extends JFrame {
  
  public TestTab2() {
    
    List&lt;Accounts&gt; list = Arrays.asList(
        new Accounts("1", new Employee("Kowalski Jan", "1960-10-12", 2700.5), 10),
        new Accounts("2", new Employee("Malinowskiski Jan", "1980-12-12", 1700.3), 20),
        new Accounts("3", new Employee("Kotek Kazimierz", "1950-11-05", 3700.1), 6)
        );
    
    GenTabModel&lt;Accounts&gt; tm = new GenTabModel&lt;Accounts&gt;(
        list,
        new String[] { "id", "emp", "points" },
        new String[] { "Ident", "Pracownik", "Punkty" });

    JTable tab = new JTable(tm);
    add ( new JScrollPane(tab) );
    setSize(300,300);
    setVisible(true);
  }

  public static void main(String[] args) {
    new TestTab2();
  }

}</pre>
<br>
i uzyskaæ ca³kiem inn¹ tabelê:<br><br>
<img
 style="width: 300px; height: 116px;" alt="r" src="images/tabpunkt.jpg"><br><br><br>
<a
 name="Reflex.5"></a><a name="Reflex.5"></a><h2>5. Wykorzystanie refleksji w klasach sparametryzowanych</h2> Wszelkie uogólnienia klas sparametryzowanych,
których nie mo¿na wprowadziæ
bezpoœrednio ze wzglêdu na ograniczenia zwi¹zane z zastosowaniem
parametrów
typu - mo¿na wprowadziæ poœrednio za pomoc¹ œrodków refleksji.<br>
<br>
Rozpatrzmy schematyczny przyk³ad: dodanie do kodu klasy Para&lt;S,
T&gt; konstruktora kopiuj¹cego oraz metody dodawania dwóch par. <br>
W
ten sposób bêdziemy mieli ju¿ spory fragment uogólnionego
kodu, nadaj¹cego siê do zastosowania dla dowolnych instancji par
dowolnych typów, zachowuj¹c przy tym zalety generics (m.in. dopisywanie
przez kompilator konwersji zawê¿aj¹cych).<br>
Listing jest suto
komentowany, a sam kod pokazuje (oczywiœcie tylko schematycznie) jedno
z mo¿liwych podejœæ.<br><br>
Wydruk: konstruktor kopiuj¹cy i dodawanie
dwóch par (zastosowanie refleksji)<br>
<pre>import java.lang.reflect.*;

class Para&lt;S, T&gt; {
  S first;
  T last;

  public Para() {}

  public Para(S f, T l) {
    first = f;
    last = l;
  }

  // konstruktor kopiuj¹cy
  public Para(Para&lt;S,T&gt; p) {
    // nie mo¿emy u¿yæ new, ale mo¿emy zastosowaæ refleksjê
    try {
      first = (S) getInstance(p.first);  <b>// unchecked, ale jest gwarancja</b>
      last = (T) getInstance(p.last);    <b>// ¿e typy bêd¹ w³aœciwe</b>
    } catch (Exception exc) {
        throw new UnsupportedOperationException("Copy constructor not available",
                                                 exc.getCause());
    }
  }

  private Object getInstance(Object o) throws Exception {
     Class type = o.getClass();
     Constructor c = null;
     Object arg = null;
     try {  <b>// czy jest konstruktor kopiuj¹cy?</b>
       c = type.getConstructor(type);
       arg = o;
     } catch (Exception exc) {  <b>// nie ma kopiuj¹cego</b>
          if (type.getSuperclass() == java.lang.Number.class) { <b>// mo¿e s¹ pochodne od Number?
</b>             c = type.getConstructor(java.lang.String.class);
             arg = o.toString();
          }
     }
     if (c == null) { <b>// ani kopiuj¹cy, ani ze Stringa nie jest bezpiecznie</b>
       // utworzyæ obiekt za pomoc¹ konstruktora bezparametrowego (newInstance)
       // pobraæ od klasy Properties (PropertyDescriptor[])
       // dla wszystkich setterów wywo³aæ odpowiednie gettery na oryginale,
       // a zwrócone wartoœci podaæ jako argumenty setterom
       // (i wo³aæ je po kolei na kopii)
       throw new UnsupportedOperationException("Valid constructor not found in" +
                                                type);  // bo tego nie robimy
     }
     else return c.newInstance(arg);
  }

  // dodawanie par
  public Para&lt;S, T&gt; add(Para&lt;S, T&gt; p) {
    Para&lt;S, T&gt; wynik = new Para&lt;S, T&gt;(); <b>// nie mo¿na new T(), ale mo¿na new X&lt;T&gt;!</b>
    try {
      wynik.first = (S) addObjects(first, p.first); <b>// unchecked, </b>
      wynik.last = (T) addObjects(last, p.last);    <b>// ale typ jest gwarantowany</b>
      return wynik;
    } catch(Exception exc) {
       throw new UnsupportedOperationException("Addition not allowed",
                                                exc.getCause());
    }
  }

  private Object addObjects(Object o1, Object o2) throws Exception {

    if (o1 instanceof String) return (String) o1 + o2; <b>// konkatenacja</b>

    if (o1 instanceof Number) { <b>// dzia³ania na klasach opakowuj¹cych typy proste</b>
&nbsp;
      double d = ((Number) o1).doubleValue() + ((Number) o2).doubleValue();
      String s = String.valueOf(d);
      Constructor c = null;
      try {                   <b>// wynik musi byæ specyficznego typu (np. Integer)</b>
        c = o1.getClass().getConstructor(java.lang.String.class);
        return c.newInstance(s);
      } catch(Exception exc) {       // np. gdy new Integer("1.0");
          int l = s.indexOf('.');    // bierzemy tylko cyfry przed kropk¹
          s = s.substring(0, l);
          return c.newInstance(s);
      }
    }

<b>    // Ani String ani Number - wiêc musi mieæ metodê add(...)</b>

    Class typ = o1.getClass();
    Method m = typ.getDeclaredMethod("add", typ);
    return m.invoke(o1, o2);
  }


  public S getFirst() { return first; }
  public T getLast()   { return last; }

  public void setFirst(S f) { first = f; }
  public void setLast(T l) { last = l; }

  public String toString() {
    return first + " " + last;
  }

}

class Value {
   int val;

   Value(int n) { val = n; }

   public Value add(Value v) {
      return new Value(val + v.val);
   }

   public String toString() {
     return "" + val;
   }

}


public class GenTest4 {

  public static void main(String[] args) {
    Para&lt;String, Integer&gt; p1 = new Para&lt;String, Integer&gt;("A", 1);
    Para&lt;String, Integer&gt; p2 = new Para&lt;String, Integer&gt;(p1);
    System.out.println(p2);
    Para&lt;String, Integer&gt; wynik = p1.add(p2);
    System.out.println(wynik);
    // Para &lt;String, String&gt; ps = new Para &lt;String, String&gt;("c", "d");
    // wynik = p1.add(ps); &lt;=== kompilator wykrywa b³êdy
    Para&lt;Value, Value&gt; v1 = new Para&lt;Value, Value&gt;(new Value(1), new Value(2));
    Para&lt;Value, Value&gt; v2 = new Para&lt;Value, Value&gt;(new Value(3), new Value(4));
    Para&lt;Value, Value&gt; vv = v1.add(v2);
    System.out.println(vv);
  }

}
</pre>Wynik:<br>
<div class="listing100"><br>
A 1<br>
AA 2<br>
4 6<br>
</div><br>
<br>
Przy kompilacji tego przyk³adu dostaniemy sporo ostrze¿eñ "unchecked
cast".
Starannie napisany kod pozwala jednak ustrzec siê b³êdów w fazie
wykonania.<br>
<br>
<hr>
<a name="Reflex.6"></a><h2>6. Refleksja wobec generics</h2>
Jak wiemy, w Javie nastêpuje &nbsp;czyszczenie typów sparametryzwanych
(zob. materialy "Podstaw programowania" nt. typów surowych i
czyszczenia typów).<br><br>
Nie
nale¿y jednak s¹dziæ, ¿e z kodu binarnego (pliku klasowego) znikaj¹
wszystkie informacje o generics. W fazie wykonania mo¿na dowiedzieæ siê
ca³kiem sporo o typach sparametryzowanych, u¿ywaj¹c nowych,
wprowadzonych wraz z generics, metod refleksji. <br>
Jest wszak¿e jedno
(bardzo istotne) ograniczenie - zapisana (i dostêpna) informacja
dotyczy typów statycznych, a nie dynamicznych.<br>
Mo¿na np. pytaæ o
generyczny typ pól klasy, wyników i parametrów metod.<br>
Zobaczmy
przyk³ad.<br><br>
W kontekœcie:<br>
<pre>class Para&lt;S, T&gt; {
  S first;
  T last;
  // ...
}
</pre>poni¿szy
program:<br><br>
<pre>public class Test1 {

  private Para&lt;String, String&gt; p1 = new Para&lt;String,String&gt;("A", "B");
  
  Test1() {
    try {
      Type typ1 = getClass().getDeclaredField("p1").getGenericType();
      System.out.println("Typ pola p1: " + typ1);
      
      // Ale
      Type typ2 = p1.getClass().getDeclaredField("first").getGenericType();
      System.out.println("Typ pola first: " + typ2);
      
    } catch (Exception exc) {
        exc.printStackTrace();
    }
  }

  public static void main(String[] args)  {
    new Test1();
  }

}</pre>wyprowadzi
nastêpuj¹ce wyniki:<br><br>
<div class="listing100">Typ pola p1:
testy1.Para&lt;java.lang.String, java.lang.String&gt;<br>
Typ pola
first: S</div><br>
W
obu przypadkach (pola p1 z klasy Test1&nbsp; i pola first z klasy
Para&lt;S,T&gt;)&nbsp;informacja dotyczy <span
 style="font-weight: bold;">typów
statycznych</span> (deklarowanych w programie i zarejestrowanych przez
kompilator). Czyszczenie typów sprawia, ¿e nie mo¿emy siê dowiedzieæ,
i¿ aktualnym typem pola first jest String (a nie formalny parametr S,
zapamiêtany przez kompilator).<br><br>
W tym kontekœcie warto zwróciæ
uwagê na&nbsp;ciekawostkê: w klasie Class jest metoda
getGenericSuperclass(), ale nie ma metody getGenericClass(). <br>
Samo
getClass() zwróci nam zawsze "surowy typ" klasy sparametryzowanej. To
jest typ dynamiczny, aktualny i nie dostaniemy informacji o
parametryzacji. Dla typów dynamicznych taka informacja nie mo¿e byæ
generowana i wobec tego nie ma sensu w hipotetycznej metodzie
getGenericClass(). A co z getGenericSuperclass()?<br><br>
Wyjaœnienia
dostarczaj¹ poni¿szy kody Ÿród³owy:<br><br><br>
<pre>import java.lang.reflect.*;

public class Test2 {

  void showParameterTypeInfo(Object o) {
    Class klasa = o.getClass();
    Type typ = klasa.getGenericSuperclass();
    System.out.println(klasa + "\n" + typ);
  } 
  
  Test2() {
    
    System.out.println("Normalny obiekt");
    Para&lt;String, Integer&gt; p1 = new Para&lt;String, Integer&gt;("a", 10);
    showParameterTypeInfo(p1);
    
    // Drobna zmiana: utworzymy obiekt anonimowej 
    // klasy wewnêtrznej dziedzicz¹cej Para&lt;String, Integer&gt;

    System.out.println("Obiekt klasy wewnêtrznej - typ statyczny!");
    Para&lt;String, Integer&gt; p2 = new Para&lt;String, Integer&gt;("a", 10) {};
    showParameterTypeInfo(p2);

    
  }

  public static void main(String[] args)  {
    new Test2();
  }

}</pre>Wynik
dzialania tego programu wygl¹da nastêpuj¹co:<br>
<div class="listing100">Normalny
obiekt<br>
class testy1.Para<br>
class java.lang.Object<br>
Obiekt klasy
wewnêtrznej - typ statyczny!<br>
class testy1.Test2$1<br>
testy1.Para&lt;java.lang.String,
java.lang.Integer&gt;</div><span style="font-family: monospace;"><br>
</span>Zmienna
p1 jest lokalna (nie mo¿emy wiêc skorzystaæ z getGenericType() (jak w
przypadku pól). Parametr metody showParameterInfo <span
 style="font-style: italic;"></span>ma typ dynamiczny i jedyne o czym
mo¿emy siê dowiedzieæ to surowy typ przekazanego argumentu.<br>
Natomiast
dodanie nawiasów klamrowych na koñcu deklaracji zmiennej lokalnej p2
pozwoli³o na uzyskanie&nbsp;pe³nej informacji o jej sparametryzowanym
typie! A to dlatego, ¿e klas¹ tej zmiennej jest anonimowa klasa
wewnêtrzna, dziedzicz¹ca Para&lt;String, Integer&gt;. Typ wyznaczany
przez tê nadklasê jest statyczny - wiêc informacja o parametrach typu
jest dostêpna. <br>
<hr></body></html>