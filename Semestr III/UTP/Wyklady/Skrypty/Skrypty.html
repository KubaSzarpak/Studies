<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="Content-Type"
 content="text/html; charset=windows-1250"> <meta name="author"
 content="Krzysztof Barteczko"> <meta name="description"
 content="Uniwersalne techniki programowania"> <meta name="copyright"
 content="(c) Krzysztof Barteczko PJWSTK 2010"> <link rel="stylesheet"
 type="text/css" href="../STYLE/common.css"> <title>Skrypty w Javie</title></head>
<body><br>
<br>
<div align="center"><h1>Skrypty w Javie</h1>
</div><br>
<hr><span style="font-style: italic;">Zajmiemy siê teraz tematem
integracji Javy z&nbsp; jêzykami
skryptowymi. Tu dynamiczne programowanie w Javie przekracza bariery
jednej platformy i otwiera przebogate mo¿liwoœci w tworzeniu
ró¿norodnych aplikacji.&nbsp; </span> <hr>
<a name="Skrypty.1"></a><h2>1. Wprowadzenie</h2>
<br>
W Javie 6 wbudowano mo¿liwoœæ uruchamiania skryptów z poziomu
aplikacji. Naturalnie, taka mo¿liwoœc istnia³a zawsze, ale teraz
mechanizmy i interfejsy zosta³y ustandaryzowane, a w pakietach Javy
mamy javax.script, dodstarczaj¹cy gotowych klas i interfejsów do
wykorzystania w tym celu.<br>
<i><br>
</i><span style="font-weight: bold;">Co
mo¿e robiæ aplikacja Javy ?</span><br>
<ul><li>wywo³ywaæ skrypt,</li><li>wywo³ywac
wybrane funkcje/metody ze skryptu,</li><li>odczytywaæ informacje
(zmienne) zmienione lub dostarczone przez skrypt</li></ul><br>
<span
 style="font-weight: bold;">Co mo¿e robiæ skrypt ?</span><br>
<ul><li>korzystaæ
z mo¿liwoœci swojego jêzyka skryptowego</li><li>korzystaæ z bibliotek
Javy</li><li>odczytywaæ informacje z aplikacji (dostêp do zmiennych)</li></ul><br>
<span
 style="font-weight: bold;">Jakie s¹ tego&nbsp;zastosowania
?</span><br>
<ul><li>prototypowanie aplikacji</li><li>testowanie
aplikacji</li><li>wzbogacanie aplikacji o mo¿liwoœci jêzyków
skryptowych (np. niektóre fragmenty ³atwiej napisaæ w skrypcie)</li><li>dostarczanie
u¿utkownikowi œrodków prgramistycznego dostêpu do œrodowiska aplikacji</li><ul><li>np.
makra-programy do elastycznych obliczeñ</li></ul><ul><li>np. makra
edycyjne</li></ul></ul><br>
<a name="Skrypty.2"></a><h2>2. Motory skryptowe i dostêp do nich z aplikacji Javy</h2>
<div class="def">Motor skryptowy (<span
 style="font-weight: bold; font-style: italic;">script engine</span>)
- to komponent software'wy, który wykonyje programy napisane w
jêzyku skryptowym. Wykonanie polega na interpretacji, sk³adaj¹cej siê z
nastêpuj¹cych faz: parsowanie kodu,&nbsp; utworzenie tablicy symboli do
przechowywania wartoœci, w³aœciwe wykonanie. Motor skryptowy nazywany
jest tak¿e interpreterem</div><br><br>
<span style="font-weight: bold;">Java
Script Engines (JSE)</span> - to motory skryptowe zrealizowane jako
modu³y napisane w Javie (pliki .jar) i eksponuj¹ce <span
 style="font-weight: bold;">jednolity interfejs programistyczny, zgodny
ze specyfikacj¹ JSR-223</span>. <br>
Oczywiœcie,
mog¹ one u¿ywac odwo³añ do funkcji rodzimych, a zatem mog¹ "powierzaæ"
w³asciwe wykonanie skryptu interpreterom, które maj¹ odpowiednie
API do takiego wspó³dzia³ania.<br><br>
W bibliotekach Javy 1. 6&nbsp;
dostêpny jest JSE dla jêzyka JavaScript w wersji Rhino.<br>
Dodatkowe
motory skryptowe s¹ dostêpne na stronie: <a
 href="https://scripting.dev.java.net/">https://scripting.dev.java.net/</a>.<br>
Mog¹
powstawaæ (i powstaj¹) nowe motory skryptowe.<br><br>
Tabela przedstawia
wybrane motory skryptowe<br><br>
<table border="1"><tbody><tr><th>
Language
</th><th>
Description
</th><th>
Implementation
</th></tr>
<tr><td>
<a href="http://en.wikipedia.org/wiki/Awk">AWK</a>
</td><td>
AWK is a general purpose language that is designed for processing
text-based
data, either in files or data streams. Jawk is Java-like, Awk-like
reporting
language.
</td><td>
<a href="http://jawk.sourceforge.net/">Jawk</a>
</td></tr>
<tr><td>
<a href="http://jcp.org/en/jsr/detail?id=274">BeanShell</a>
</td><td>
BeanShell is a small, free, embeddable Java interpreter with object
scripting
language features, written in Java. BeanShell dynamically executes
standard
Java syntax and extends it with common scripting conveniences such as
loose
types, commands, and method closures like those in Perl and JavaScript.
</td><td>
<a href="http://www.beanshell.org/">BeanShell 2.0b5</a>
</td></tr>
<tr><td>
<b>ejs</b>
</td><td>
"ejs" (Embedded JavaScript) is JSP-like templating engine for
JavaScript.
It supports the usual &lt;%= expr %&gt;, &lt;% code %&gt; syntax. This
engine
is completely implemented in JavaScript. You need to use JavaScript
engine to
use this script engine.
</td><td>
Implementation contained in one JavaScript file.
</td></tr>
<tr><td>
<a href="http://freemarker.sourceforge.net/">FreeMarker</a>
</td><td>
FreeMarker is a Java-based general purpose template engine.
</td><td>
<a href="http://freemarker.sourceforge.net/">FreeMarker 2.3.8</a>
</td></tr>
<tr><td>
<a href="http://www.jcp.org/en/jsr/detail?id=241">Groovy</a>
</td><td>
Groovy is an agile dynamic language for the Java 2 Platform that has
many of the
features that people like so much in languages like Python, Ruby and
Smalltalk,
making them available to Java developers using a Java-like syntax.
</td><td>
<a href="http://groovy.codehaus.org/">Groovy 1.0 jsr-06</a>
</td></tr>
<tr><td>
<a href="http://jaskell.codehaus.org/">Jaskell</a>
</td><td>
Jaskell is a lazy functional programming language. It stands for
"Java Haskell". It features higher-order functions, function currying,
string interpolation, lazy evaluation, dynamic typing.
</td><td>
<a href="http://jaskell.codehaus.org/">Jaskell 1.0</a>
</td></tr>
<tr><td>
<a href="http://java.sun.com/docs/books/jls">Java</a>
</td><td>
<a href="http://java.sun.com/">http://java.sun.com</a>
</td><td>
<a href="http://www.jcp.org/en/jsr/detail?id=199">Java Compiler API
(JSR 199)</a>
</td></tr>
<tr><td>
<a href="http://www.mozilla.org/js">JavaScript</a>
</td><td>
Web Browser's native JS interpreter is wrapped as javax.script API.
Note that this script engine works only under web browsers. i.e., only
within Java applets.
</td><td>
Web Browser's JS implementation (tested with Firefox 1.5.0)
</td></tr>
<tr><td>
<a href="http://jakarta.apache.org/commons/jelly/">Jelly</a>
</td><td>
Jelly is a tool for turning XML into executable code. So Jelly is a
Java
and XML based scripting and processing engine. Jelly borrows many good
ideas
from both JSP custom tags, Velocity, Cocoon, Ant. In this script
engine,
&lt;script&gt; tag has been added. Any JSR-223 compliant language may
be used.
Also, expressions [${xxx}] may be from any scripting language rather
than
Jexl alone.
</td><td>
<a href="http://jakarta.apache.org/commons/jelly/">Jelly 1.0</a>
</td></tr>
<tr><td>
<a href="http://www.singularsys.com/jep/">JEP</a>
</td><td>
JEP is a Java library for parsing and evaluating mathematical
expressions.
JEP supports BigInteger, BigDecimal, complex, Vector/Matrix/Tensor
arithmetic.
</td><td>
<a href="http://www.singularsys.com/jep/">JEP (Java Math Expression
Parser) 2.4.0</a>
</td></tr>
<tr><td>
<a href="http://jakarta.apache.org/commons/jexl/">Jexl</a>
</td><td>
Java Expression Language (JEXL) is an expression language engine which
can be embedded in
applications and frameworks. JEXL is inspired by Jakarta Velocity and
the Expression Language
defined in the JavaServer Pages Standard Tag Library version 1.1 (JSTL)
and JavaServer Pages
version 2.0 (JSP).
</td><td>
<a href="http://jakarta.apache.org/commons/jexl/">Jexl 1.0</a>
</td></tr>
<tr><td>
<b>jst</b>
</td><td>
"jst" (JavaScript Templates) is JSP/ASP/PHP-like templating engine for
JavaScript. This engine uses TrimPath's JavaScript Templates
implementation.
This script engine is implemented in JavaScript. You need to use
JavaScript engine to use this script engine.
</td><td>
<a href="http://www.trimpath.com/project/wiki/JavaScriptTemplates">TrimPath
JavaScript Templates (1.0.38)</a>
</td></tr>
<tr><td>
<a href="http://www.judoscript.com/">JudoScript</a>
</td><td>
A scripting language built atop Java, and is a powerful general-purpose
programming
language with intimate Java scripting support. JudoScript, or Judo for
short, is a
general-purpose, Java scripting and multi-domain language. A
full-fledged general-purpose
scripting language with full capability of Java scripting, JudoScript
intimately supports
most of today's key computing areas.
</td><td>
<a href="http://www.judoscript.com/">JudoScript 0.9</a>
</td></tr>
<tr><td>
<a href="http://www.ognl.org/">OGNL</a>
</td><td>
OGNL stands for Object-Graph Navigation Language; it is an expression
language for
getting and setting properties of Java objects. You use the same
expression for both
getting and setting the value of a property
</td><td>
<a href="http://www.ognl.org/">OGNL 2.6.9</a>
</td></tr>
<tr><td>
<a href="http://pnuts.dev.java.net/">Pnuts</a>
</td><td>
Pnuts is a simple but powerful scripring language that is embeddable
into Java applications.
It has an extensible module system and a lot of ready-to-use modules.
</td><td>
<a href="http://pnuts.dev.java.net/">Pnuts 1.1</a>
</td></tr>
<tr><td>
<a href="http://www.python.org/">Python</a>
</td><td>
Python is a dynamic object oriented programming language that can be
used for many kinds
of software development. It offers strong support for integration with
other languages and tools,
comes with extensive standard libraries, and can be learned in a few
days time.
</td><td>
<a href="http://jython.sourceforge.net/">Jython 2.1</a>
</td></tr>
<tr><td>
<a href="http://www.ruby-lang.org/">Ruby</a>
</td><td>
Ruby is the interpreted scripting language for quick and easy
object-oriented programming.
It has many features to process text files and to do system management
tasks (as in Perl).
It is simple, straight-forward, extensible, and portable.
</td><td>
<a href="http://jruby.sourceforge.net/">JRuby 0.9.0</a>
</td></tr>
<tr><td>
<a href="http://www.schemers.org/">Scheme</a>
</td><td>
Scheme is a statically scoped and properly tail-recursive dialect of
the Lisp programming language
invented by Guy Lewis Steele Jr. and Gerald Jay Sussman. It was
designed to have an exceptionally
clear and simple semantics and few different ways to form expressions.
A wide variety of programming
paradigms, including imperative, functional, and message passing
styles, find convenient expression
in Scheme.
</td><td>
<a href="http://sisc.sourceforge.net/">SISC 1.15.3</a>
</td></tr>
<tr><td>
<a href="http://sleep.hick.org/">Sleep</a>
</td><td>
Sleep is a Java-based scripting language heavily inspired by Perl.
</td><td>
<a href="http://sleep.hick.org/">Sleep 2.0</a>
</td></tr>
<tr><td>
<a href="http://www.tcl.tk/">Tcl</a>
</td><td>
Tcl (Tool Command Language) is a very powerful but easy to learn
dynamic programming language,
suitable for a very wide range of uses, including web and desktop
applications, networking,
administration, testing and many more. Open source and
business-friendly, Tcl is a mature yet
evolving language that is truly cross platform, easily deployed and
highly extensible.
</td><td>
<a href="http://tcljava.sourceforge.net/">Jacl 1.3.3</a>
</td></tr>
<tr><td>
<a href="http://jakarta.apache.org/velocity/">Velocity</a>
</td><td>
Velocity is a Java-based general purpose template engine.
</td><td>
<a href="http://jakarta.apache.org/velocity/">Velocity 1.4</a>
</td></tr>
<tr><td>
<a href="http://www.w3.org/TR/xpath">XPath</a>
</td><td>
JDK already includes <a
 href="http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/xpath/package-summary.html">javax.xml.xpath</a>
package for XPath. But to extend XPath with user defined functions and
variables, user needs to learn different set of
interfaces/classes in this (and few other) package(s). We are adding a
javax.script engine on top of javax.xml.xpath API
- so that user can set variables, functions in ScriptContext and call
"eval" method on ScriptEngine. Any Java method,
constructor may be used as XPath extension function - no need to wrap
it as "XPathFunction".
</td><td>
JDK implementation of javax.xml.xpath is used.
</td></tr>
<tr><td>
<a href="http://www.w3.org/TR/xslt">XSLT</a>
</td><td>
JDK already includes <a
 href="http://java.sun.com/j2se/1.5.0/docs/api/javax/xml/transform/package-summary.html">javax.xml.transform</a>
package for XSLT. But to use XSLT, user needs to learn different set of
interfaces/classes in
this (and few other) package(s). We are adding a javax.script engine on
top of javax.xml.transform API
- so that user can set source, result in ScriptContext and call "eval"
method on ScriptEngine.
By default, ScriptContext's input Reader and output Writer are used for
transform source and
result.
</td><td>
JDK implementation of javax.xml.transform is used.
</td></tr>
</tbody></table><span style="font-weight: normal;">Wszystkie w/w JSE s¹
dostêpne z w/w strony jako archiwum katalogów </span><b>sr223-engines.zip.</b><br><br>
Dodatkowe
JSE wg specyfikacji JSR 223:&nbsp;
<ul><li>AppleScript (<a href="https://jasconn.dev.java.net/">https://jasconn.dev.java.net</a>
- <b>Mac OS X only</b>)
</li><li>Bex script (<a href="http://bexscript.sourceforge.net/">http://bexscript.sourceforge.net</a>)
</li><li>PHP (<a href="http://www.caucho.com/resin-3.0/quercus/">http://www.caucho.com/resin-3.0/quercus/</a>)
- pure Java implementation of PHP.
</li><li>PHP (<a href="http://php-java-bridge.sourceforge.net/">http://php-java-bridge.sourceforge.net/</a>)
- uses native PHP implementation through remoting.
</li><li>Python (<a href="http://jepp.sourceforge.net/">http://jepp.sourceforge.net/</a>)
- uses the native Python implementation to implement JSR 223 engine.</li><li><br>
</li></ul><div class="important">Aby JSE by³ dostêpny z poziomu
aplikacji Javy jego JAR
musi byæ widoczny dla ClassLoadera (np. umieszczony na œcie¿ce
CLASSPATH.</div><br>
Dostêp do JSE z poziomu aplikacji Javy jest
realizowany za poœrednictwem zarz¹dcy motorów -&nbsp; <span
 style="font-weight: bold;">ScriptEngineManager</span>. Zajmuje siê on
m.in.&nbsp; wyszukiwaniem i instancjacj¹ odpowiednich JSE. <br><br>
Do
odnajdywania JSE s³u¿¹ nastêpuj¹ce metody klasy ScriptEngineManager.<br>
<table
 summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody></tbody></table><br>
<table
 summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody><tr><td
 style="background-color: rgb(255, 255, 255);">&nbsp;ScriptEngine</td><td
 style="background-color: rgb(255, 255, 255);"><br>
getEngineByName(String&nbsp;shortName)
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wyszukuje i
tworzy JSE dla podanej nazwy motoru (lub jej aliasu)</td></tr><tr
 class="TableRowColor" bgcolor="white"><td align="right" valign="top"
 width="1%">
&nbsp;ScriptEngine</td>
<td>getEngineByExtension(String&nbsp;extension)
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wyszukuje i
tworzy JSE dla podanego rozszerzenia plików skryptowych.</td>
</tr><tr class="TableRowColor" bgcolor="white">
<td align="right" valign="top" width="1%">&nbsp;ScriptEngine</td>
<td>getEngineByMimeType(String&nbsp;mimeType)
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j.w. - tylko
dla &nbsp;podanego typu MIME</td>
</tr></tbody></table><br><br>
<table summary="" border="1"
 cellpadding="3" cellspacing="0" width="100%"><tbody></tbody></table><table
 summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody></tbody></table><br>
<div
 style="text-align: center;">Uzyskanie JSE:<br>
</div><br>
<pre>ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(<span
 style="font-style: italic; font-weight: bold;">nazwa_motoru</span>);</pre><br>
A
jakie s¹ nazwy?<br>
To
oczywiœcie podaje dokumentacja konkretnych JSE. Ale mo¿emy siê tego
sami szybko dowiedzieæ. Sprawdzenie nazw jest u¿yteczne wtedy, gdy
nazwy siê powtarzaj¹ dla ró¿nych JSE (np. javascript) i wtedy trzeba
zastosowac rozró¿niaj¹ce aliasy.<br><br>
Metainformacje o JSE uzyskujemy
za pomoc¹ interfejsu <span style="font-weight: bold;">ScriptEngineFactory</span>.<br>
Tak
naprawdê ScriptEngineManager odnajduje w³aœnie odpowiednie fabryki dla
danych JSE i za pomoc¹ ich metod fabrycznych tworzy obiekty
ScriptEngine.<br><br>
Uwaga: ScriptEngineManager stosuje mechanizm <span
 style="font-weight: bold;">service provider</span> zob.<br><br>
<a
 href="http://java.sun.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider">http://java.sun.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider</a><br><br>
do
wykrywania fabryk.<br><br>
Wymaga to aby JARy JSE w katalogu <span
 style="font-weight: bold;">META-INF</span> &nbsp;zawiera³y podkatalog <span
 style="font-weight: bold; font-style: italic;">services</span> z
plikiem o nazwie <span style="font-weight: bold;">javax.script.ScriptEngineFactory</span>,
zawieraj¹cym nazwê klasy bêd¹cej fabryk¹ tworz¹c¹ obiekty danego JSE.
Np. groovy-engine.jar w tym pliku zawiera nazwê
com.sun.script.groovy.GroovyScriptEngineFactory.&nbsp; <br><br><br>
Wszystkie
znane zarz¹dzcy fabryki mo¿na uzyskaæ za pomoca metody:<br><br>
<pre>ScriptEngineManager mgr ...
List&lt;ScriptEngineFactory&gt; factories = mgr.getEngineFactories();</pre><br>
Przyk³adowy
program pokazuje dostêpne informacje. <br><br>
<pre>import java.util.*;
import javax.script.*;

public class DiscoverEngines {
  
  public static void main(String[] args) {

    ScriptEngineManager mgr = new ScriptEngineManager();
   
    List&lt;ScriptEngineFactory&gt; factories = mgr.getEngineFactories();
    
    for (ScriptEngineFactory factory : factories) {
    
      System.out.println("ScriptEngineFactory Info");
      
      String engName = factory.getEngineName();
      String engVersion = factory.getEngineVersion();
      System.out.println("Script Engine: " + engName + " v. " + engVersion);

      List&lt;String&gt; engNames = factory.getNames();
      for(String name : engNames) System.out.println("Engine Alias: " + name);
      
      String langName = factory.getLanguageName();
      String langVersion = factory.getLanguageVersion();
      System.out.println("Language: " + langName + " v. " +  langVersion);
      
      List&lt;String&gt; exts = factory.getExtensions();
      for(String ext : exts) System.out.println("Script file extension: " + ext);
      
      System.out.println("-------------------------------------------");
    }    
  }

}</pre>W
przypadku gdy na œcie¿ce classpath&nbsp; znajduj¹ siê JSE dla browserjs
i groovy otrzymamy wynik:<br><br>
<div class="listing100"><br>
ScriptEngineFactory
Info<br>
Script Engine: groovy v. <br>
Engine Alias: groovy<br>
Language:
groovy v. 1.0<br>
Script file extension: groovy<br>
-------------------------------------------<br>
ScriptEngineFactory
Info<br>
Script Engine: Browser JavaScript Engine v. 1.5<br>
Engine
Alias: js<br>
Engine Alias: javascript<br>
Engine Alias: JavaScript<br>
Engine
Alias: ecmascript<br>
Engine Alias: ECMAScript<br>
Engine Alias: BrowserJS<br>
Engine
Alias: NativeJS<br>
Language: JavaScript v. 1.5<br>
Script file
extension: js<br>
-------------------------------------------<br>
ScriptEngineFactory
Info<br>
Script Engine: Mozilla Rhino v. 1.6 release 2<br>
Engine Alias:
js<br>
Engine Alias: rhino<br>
Engine Alias: JavaScript<br>
Engine Alias:
javascript<br>
Engine Alias: ECMAScript<br>
Engine Alias: ecmascript<br>
Language:
ECMAScript v. 1.6<br>
Script file extension: js<br>
-------------------------------------------<br>
</div><br>
<a name="Skrypty.3"></a><h2>3. Wykonanie skryptów</h2>
Skrypty traktowane s¹ jako ci¹gi znaków:<br>
<ul><li>zapisane jako
String, </li><li>lub czytane z dowolnego strumienia typu Reader.</li></ul><br>
Skrypt
mo¿e byæ wywo³any jako ca³oœæ lub te¿ - jesli jêzyk skryptowy to
dopuszcza - mo¿e byæ wywo³ana wybrana funkcja lub metoda ze skryptu.<br><br>
Do
<span style="font-weight: bold;">wykonania ca³ego skryptu</span> s³u¿y
metoda <span style="font-weight: bold;">eval</span> wo³ana na rzecz
obiektu typu ScriptEngine.<br><br>
<div class="syntax"><br><br>
<div
 style="margin-left: 40px;">ScriptEngine eng &nbsp;= ...;<br>
<span
 style="font-weight: bold;">eng.eval( skrypt);</span><br><br>
gdzie:<br>
&nbsp;&nbsp;&nbsp;
skrypt - jest typu String lub typu Reader<br>
</div><br>
Uwaga: przy
wywo³aniu eval nalezy obs³ugiwac wyj¹tek ScriptException<br>
</div><br><br>
Przyk³ad
1.<br><br>
<pre>import javax.script.*;


public class GroovyTest {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("groovy");
    try {
      String script = "\"Ala ma kota i psa\".tokenize().each { println it + ' ' + it.length()}";
      engine.eval(script);
    } catch (ScriptException e) {
      e.printStackTrace();
    }
  }

}</pre>Uwagi:<br>
<ol><li>treœc
skryptu sformu³owano w jêzyku Groovy jako String</li><li>warto
zwróciæ uwagê na moc tego jêzyka - metoda tokenize(), konstrukcja each
oraz tzw. domkniêcie (zamiast definiowania tradycyjnej funkcji) bardzo
u³atwia programowanie.</li></ol><br>
Wynik:<br>
<div class="listing100"><br>
Ala
3<br>
ma 2<br>
kota 4<br>
i 1<br>
psa 3<br>
</div><br><br>
Skrypt mo¿na
wczytaæ te¿ bezpoœrednio z pliku:<br><br>
<pre>import java.io.*;
import javax.script.*;

public class GroovyTest2 {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("groovy");

    try {
      engine.eval(new FileReader("test1.groovy"));
    } catch (ScriptException e) {
      e.printStackTrace();
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    }
  }

}</pre><br><br>
Wywo³anie
<span style="font-weight: bold;">okreœlonej funkcji</span> lub <span
 style="font-weight: bold;">metody</span>
- zdefiniowanej w &nbsp;skrypcie - jest mo¿liwe wtedy gdy ScriptEngine
implementuje interfejs Invocable. Nale¿y to zawsze sprawdziæ, a
nastêpnie dokonaæ konwersji do Invocable i wywolac metodê <span
 style="font-weight: bold;">invokeFunction</span> lub <span
 style="font-weight: bold;">invokeMethod</span>.<br><br>
<table
 summary="" border="1" cellpadding="3" cellspacing="0" width="100%"><tbody><tr
 class="TableRowColor" bgcolor="white"><td align="right" valign="top"
 width="1%"><font size="-1">
<code>&nbsp;Object</code></font></td>
<td><code><b>invokeFunction</b>(String&nbsp;name, Object...&nbsp;args)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wo³a funkcje
name zdefiniowan¹ w skrypcie z argumentami args i zwraca wynik w
postaci Object. Konwersje z typów wyniku funkcji do typów Javy s¹
zalezne od implementacji jêzyka skryptowego.<br>
Przy braku funkcji
zg³asza wyj¹tek NoSuchMethodException. Skrypt powinien byæ wczesniej
przygotowany przez wywo³anie eval.</td>
</tr><tr class="TableRowColor" bgcolor="white">
<td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;Object</code></font></td>
<td><code><b>invokeMethod</b>(Object obj, String&nbsp;name,
Object...&nbsp;args)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Wywo³uje
metodê name na rzecz obiektu obj z argumentami args.</td></tr></tbody></table><br>
Przyk³ad.<br><br>
W
pliku test1.js mamy nastêpuj¹cy zestaw funkcji:<br><br>
<pre>function square(n) {
  return n*n;
}

function cube(n) {
  return n*n*n;
}</pre>Bêdziemy
je wywo³ywac z aplikacji Javy podaj¹c nazwê funkcji i argument:<br><br>
<pre>import java.io.*;
import javax.script.*;
import javax.swing.*;

public class InvokeTest {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("rhino");

    if (!(engine instanceof Invocable))
      throw new RuntimeException("Engine not invocable");

    Invocable eng = (Invocable) engine; // konieczna konwersja

    try {
      engine.eval(new FileReader("test1.js")); // przygotowanie skryptu
      String in;
      while ((in = JOptionPane.showInputDialog("Podaj nazwe funkcji i argument")) != null) {
        String[] call = in.split(" ");
        double res = (Double) eng.invokeFunction(call[0], call[1]); // wo³anie wybranej funkcji
        System.out.println("Wynik " + res);
      }
    } catch (ScriptException e) {
      e.printStackTrace();
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (NoSuchMethodException e) {
      e.printStackTrace();
    }
  }

}</pre><br><br>
Skrypty
- o ile dany JSE to dopuszcza - mog¹ byæ tak¿e <span
 style="font-weight: bold;">kompilowane</span> (do symbolicznej
postaci) co przyspiesza wielokrotne wykonanie. &nbsp;W tym przypadku:<br>
<ul><li>JSE
winien implementowaæ interfejs <span style="font-weight: bold;">Compilable</span>,</li><li>skompilowan¹
postaæ skryptu uzyskujemy z <span style="font-weight: bold;">engine.compile(skrypt)</span>
w postaci wyniku typu <span style="font-weight: bold;">CompiledScript</span>,</li><li>na
rzecz tego wyniku&nbsp;wo³amy metodê <span style="font-weight: bold;">eval()</span>.</li></ul><br>
<a name="Skrypty.4"></a><h2>4. Wymiana danych</h2>
Wymiana danych pomiêdzy aplikacj¹ i skryptem odbywa siê poprzez zestawy
par: klucz - wartoœæ,&nbsp;zwane &nbsp;wi¹zaniami (<span
 style="font-weight: bold; font-style: italic;">bindings</span>). W
tych parach kluczem jest nazwa zmiennej, a wartoœci¹ - wartoœæ zmiennej.<br>
Wi¹zania
s¹ obiektami klas implementuj¹cych interfejs Bindings. Interfejs ten
rozszerza interfejs Map&lt;String, Object&gt;, zatem wi¹zania mog¹ byæ
traktowane &nbsp;generalnie tak jak mapy (np. dodawanie za pomoc¹ put,
pobieranie za pomoc¹ get). <br>
Wi¹zania mog¹ byæ nastêpuj¹cych
rodzajów:<br><br>
<ul><li>GLOBAL_SCOPE
- wi¹zanie globalnego zakresu (jego elementy s¹ dostêpne dla wszystkich
JSE tworzonych przez tego samego zarz¹dce ScriptEngineManager)</li><li>ENGINE_SCOPE
- wi¹zanie "zakresu motoru" dostêpne dla danego JSE (ca³y czas w cyklu
jego zycia, nie tylko w trakcie wykonania konkretnego skryptu),</li><li>wi¹zania
dodatkowych zakresów - oprócz GLOABAL_SCOPE i ENGINE_SCOPE mog¹ byæ
dodatkowe zakresy,</li><li>wi¹zanie tworzone ad hoc i podawane
&nbsp;jako argument metody eval: <span style="font-weight: bold;">eval(skrypt,
Bindings).</span>&nbsp;</li></ul><br>
Zakresy s¹ zarz¹dzane przez <span
 style="font-weight: bold;">ScriptContext</span> (który oprócz tego
daje dostêp do strumieni we-wy i b³êdów JSE).<br><br>
Co jest w
wi¹zaniach i jak z nimi postêpowaæ?<br><br>
Automatycznie
wszystkie zmienne utworzone w trakcie wykonania skryptu (w skrypcie),
s¹ dodawane do wi¹zania zakresu SCRIPT_ENGINE (lub jeœli w eval podano
argument Bindings - do tego w³aœnie wi¹zania). W aplikacji mo¿emy:<br>
<ul><li>pobraæ
mapê wi¹zañ zakresu SCRIPT_ENGINE - metody getBindings(..) z klas
implementuj¹cych ScriptEngine lub ScriptContext i z tej mapy pobieraæ
wartoœci zmiennych,</li><li>pobraæ wartoœci zmiennych za pomoc¹ metod
get(key, value) ze ScriptEngine lub getAttribute(key,
ScriptContext.ENGINE_SCOPE) z interfejsu ScriptContext</li><li>pobieraæ
wartoœci z mapy Bindings przekazanej w eval.</li></ul><br>
Zmienne
aplikacji Javy mo¿emy dodawaæ do wi¹zañ za pomoc¹ metod:<br>
<ul><li>scriptManager.put(key,
value) // dodaje do zakresu &nbsp;GLOBAL_SCOPE</li><li>engine.put(key,
value) &nbsp;// dodaje do zakresu ENGINE_SCOPE</li><li>scriptContext.setAttribute(key,
value, scope) // dodaje do wybranego zakresu</li><li>put lub putAll na
rzecz Bindings danego zakresu lub w³asnych (przekazanych w eval)</li></ul>Te
zmienne bêd¹ bezpoœrednio dostêpne w skrypcie pod nazwami = kluczom.<br><br>
Przyk³ady
(JSE = Rhino):<br><br>
<pre>....
      String script = "a =1; b = 2; c =2;";
      engine.eval(script);
      showBindings();
....


  private static void showBindings() {
    System.out.println("Show bindings");
    ScriptContext ctx = engine.getContext();   // uzyskanie biez¹cego kontekstu
    List&lt;Integer&gt; scopes = ctx.getScopes();    // z tego kontekstu - jakie s¹ zakresy
    for (Integer scope : scopes) {             // dla ka¿dego zakresu.... :
      System.out.println("Scope: " + scope);
      Bindings bnd = ctx.getBindings(scope);            // wi¹zania
      System.out.println(bnd.getClass().getName());     // jaka to klasa?
      for (String key : bnd.keySet()) {                 // co jest w wi¹zaniach?
        System.out.println(key + " = " + bnd.get(key));
      }
    }
  }</pre>Wynik:<br>
<div
 class="listing100"><br>
Show bindings<br>
Scope:
100 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &lt;--- to jest ENGINE_SCOPE<br>
javax.script.SimpleBindings
&nbsp; &nbsp; // wi¹zania s¹ klasy SimpleBindings<br>
b
= 2.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// zmienna ze
skryptu<br>
c = 2.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; //
zmienna ze skryptu<br>
println =
sun.org.mozilla.javascript.internal.InterpretedFunction@dd5b<br>
a
= 1.0 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// zmienna ze
skryptu <br>
context = javax.script.SimpleScriptContext@c4bcdc<br>
print
= sun.org.mozilla.javascript.internal.InterpretedFunction@4b4333<br>
Scope:
200 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &lt;--- zakres GLOBAL_SCOPE<br>
javax.script.SimpleBindings
&nbsp; &nbsp;// nic w nim nie ma bo nic nie dodaliœmy<br>
</div><br><br>
Wi¹zania
zakresu ENGINE_SCOPE trwaj¹ wraz z motorem - kolejne skrypty mog¹ je
uzupe³niaæ:<br><br>
<pre>      String script = "a =1; b = 2; c =2;";
      engine.eval(script);
      script = "xyz = 10;";
      engine.eval(script);
      showBindings();</pre>showBindings
poka¿e m.in.<br><br>
<div class="listing100"><br>
b = 2.0<br>
c = 2.0<br>
a
= 1.0<br>
xyz = 10.0<br>
</div><br><br>
£atwo mo¿emy przekazac zmienn¹ do
skryptu:<br><br>
<pre>      String txt = "Ala ma kota";
      engine.put("txt", txt);
      script = "println('Ze skryptu : ' + txt + a + b + c + xyz);";
      engine.eval(script);
</pre>Dostaniemy
(txt pochodzi z aplikacji, zmienne a, b, c, xyz z wykonañ poprzednich
skryptów :<br><br>
L100<br>
Ze skryptu : Ala ma kota12210<br><br><br>
Mo¿emy
u¿yæ w³asnych Bindings:<br>
<pre>      Bindings sb = new SimpleBindings();
      int i = 1000;
      Date data = new Date();
      sb.put("i", i);
      sb.put("data", data);
      script = "println('Ze skryptu : ' + data + ' liczba ' + i); hhh = 7777;"; 

<span
 style="color: rgb(255, 0, 0);">      </span><span
 style="font-weight: bold; color: rgb(204, 0, 0);">engine.eval(script, sb);  // podajemy jako drugi argument Bindings</span>

      showBindings();
      System.out.println("A co jest w naszych bindings?");
      for (String key : sb.keySet()) {
        System.out.println(key + " = " + sb.get(key));
      }
      System.out.println("Koniec naszych");
</pre>Wynik:<br><br>
<div class="listingful">Ze skryptu : Tue Oct 10
09:35:44 CEST 2008 liczba 1000<br>
Show bindings<br>
Scope: 100<br>
javax.script.SimpleBindings<br>
b
= 2.0<br>
c = 2.0<br>
println =
sun.org.mozilla.javascript.internal.InterpretedFunction@15dfd77<br>
a =
1.0<br>
context = javax.script.SimpleScriptContext@c4bcdc<br>
txt = Ala
ma kota<br>
print =
sun.org.mozilla.javascript.internal.InterpretedFunction@1abc7b9<br>
xyz
= 10.0<br>
Scope: 200<br>
javax.script.SimpleBindings<br>
A co jest w
naszych bindings?<br>
hhh = 7777.0<br>
println =
sun.org.mozilla.javascript.internal.InterpretedFunction@1621e42<br>
context
= javax.script.SimpleScriptContext@b09e89<br>
data = Tue Oct 10 09:35:44
CEST 2006<br>
print =
sun.org.mozilla.javascript.internal.InterpretedFunction@1787038<br>
i =
1000<br>
Koniec naszych<br>
</div><br>
Tutaj
widaæ, ¿e domyœlny ENGINE_SCOPE nie jest zmieniany, &nbsp;w
przekazanych wi¹zaniach znajdziemy dodane przez nas zmienne (i mog¹ one
byæ u¿yte w skrypcie), dodatkowo znajd¹ siê tam &nbsp;zmienne opisuj¹ce
kontekst (contezt, println, print).<br><br>
Okazuje siê, ¿e nasze
wi¹zania zastêpuj¹ domyœlny ENGINE_SCOPE i dlatego w poni¿szym
fragmencie zmienna txt nie jest znana (chocia¿ jest w wi¹zaniach
zakresu ENGINE):<br>
<pre>      script = "println('Ze skryptu liczba = ' + i); print('Ze skryptu txt: '); println(txt);";
      engine.eval(script, sb);
</pre>Wynik:<br>
<div
 class="listing100"><br>
Ze skryptu liczba = 1000<br>
Ze
skryptu txt: javax.script.ScriptException:
sun.org.mozilla.javascript.internal.EcmaError: ReferenceError: "txt" is
not defined. (&lt;Unknown source&gt;#1) in &lt;Unknown source&gt; at
line number 1<br>
</div><br><br>
Naturalnie, mo¿emy ³¹czyæ wi¹zania:<br><br>
<pre>      Bindings eb = engine.getBindings(ScriptContext.ENGINE_SCOPE);  // wi¹zania motoru
      eb.putAll(sb);  // dodajemy do nich nasze
      script = "println('Ze skryptu : ' + txt + ' liczba ' + i);";
      engine.eval(script);
      showBindings();
</pre>Teraz
bêd¹ znane zmienne zarówno z zakresu ENGINE jak i z naszych Bindings.<br><br>
<div
 class="listing100"><br>
Ze skryptu : Ala ma kota liczba 1000<br>
Show
bindings<br>
Scope: 100<br>
javax.script.SimpleBindings<br>
hhh = 7777.0<br>
b
= 2.0<br>
c = 2.0<br>
println =
sun.org.mozilla.javascript.internal.InterpretedFunction@fa9cf<br>
a = 1.0<br>
data
= Tue Oct 10 10:08:19 CEST 2006<br>
context =
javax.script.SimpleScriptContext@c4bcdc<br>
txt = Ala ma kota<br>
print =
sun.org.mozilla.javascript.internal.InterpretedFunction@55571e<br>
i =
1000<br>
xyz = 10.0<br>
</div><br><br>
Nalezy zwróciæ uwagê, ¿e Bindings
dzialaj¹ tak jak ka¿da mapa. Nie mo¿emy liczyæ na to, ¿e po dodaniu
zmiennej <span style="font-weight: bold; font-style: italic;">i</span>
oraz <span style="font-style: italic; font-weight: bold;">txt</span>
do Bindings, wykonaniu skryptu i zmianie wartoœci zmiennych ponowne
wykonanie skryptu dostrze¿e te zmiany:<br><br>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 99;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; txt = "Nowy tekst";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; engine.eval(script);
</pre>L100<br>
Ze
skryptu : Ala ma kota liczba 1000<br><br><br>
Oczywiœcie,
w mapie s¹ referencje (jako wartoœci), ale przecie¿ przy dodawaniu
zmiennych typów prostych do mapy nastêpuje boxing (i refrencja wskazuje
na wtedy utworzony obiekt). To samo dotyczy zmiennej txt - referencja w
mapie wskazuje na napis "Ala ma kota" &nbsp;(a nie na nowy napis "Nowy
tekst").<br>
Wyjœciem z sytuacji jest albo u¿ycie obiektów klas
modyfikowalnych albo ponowne ³adowanie mapy Bindings po zmianie
wartoœci na poziomie aplikacji.<br><br>
Uwaga: jako kluczy oznaczaj¹cych
nazwy zmiennych (lub inn¹ informacjê przekazywan¹ pomiêdzy skryptem i
aplikacj¹) nie wolno u¿ywaæ nazw zarezerwowanych, które zaczynaj¹ siê
od javax.script. Obecnie zdefiniowane s¹ nastêpuj¹ce klucze
zarezerwowane.<br><br><br>
<table
 style="background-color: rgb(255, 255, 204);" border="1"
 cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td style="background-color: rgb(255, 255, 255);">javax.script.argv</td><td
 colspan="1" rowspan="6"
 style="background-color: rgb(255, 255, 255); text-align: center;">Zobacz
w dokumentacji znaczenie podanych zmiennych</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.filename</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.engine</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.engine_version</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.language</td></tr>
<tr><td style="background-color: rgb(255, 255, 255);">javax.script.language_version</td></tr>
</tbody></table><br>
<i><br>
</i><a name="Skrypty.5"></a><h2>5. Kontekst</h2>
<br>
Wspomniany ju¿ ScriptContext zapewnia ³¹cznoœæ pomiêdzy aplikacj¹ i
skryptem.<br>
Ka¿dy skrypt wykonywany jest w jakimœ kontekœcie (w
szczególnoœci - domyœlnym).<br>
Mo¿emy zmieniæ kontekst domyœlny,
podaj¹c w³asny kontekst w metodzie eval:<br>
eval(skrypt, ScriptContext)<br><br>
Mo¿emy
te¿ modyfikowac domyœlny kontekst.<br><br>
Oprócz wi¹zañ (zakresów) -
kontekst zapewnia dostêp do strumieni wejœcia, wyjœcia oraz b³êdów dla
skryptu.<br>
<i><br>
</i>Poni¿szy fragment pokazuje jak mo¿na przechwyciæ
wyjœcie skryptu:<br><br>
<pre>      // Zobaczmy co mo¿na zrobiæ z Writerem
      StringWriter sw = new StringWriter();
      engine.getContext().setWriter(new PrintWriter(sw));
      script = "println('To powinno pójœæ na nowy Writer');";
      engine.eval(script);

      JOptionPane.showMessageDialog(null, sw.toString());</pre>W
rezultacie poka¿e siê okienko dialogowe (komunikatów) z napisem "To
powinno pójœæ na nowy Writer".<br>
<i><br>
</i>
<a name="Skrypty.6"></a><h2>6. Dostêp do obiektów Javy ze skryptów</h2>
<br>
Motory skryptowe zgodne ze specyfikacj¹ JSR-223 umo¿liwiaj¹ w
skryptach dostêp do klas z pakietów Javy.<br>
Szczegó³y (w tym sk³adnia
wywo³ania konstruktorów i&nbsp; metod) zale¿ne s¹ od implementacji
jêzyka skryptowego.<br>
Generalnie poslugujemy siê &nbsp;kwalifikowanymi
nazwami klas (np. javax.swing.JFrame).<br>
W jêzykach, które umo¿liwiaj¹
dodanie do przestrzeni nazw nazw pakietów i klas Javy mo¿na stosowac
konstrukcjê typu import.<br><br>
Oczywiœcie, mo¿emy te¿ odwo³ywaæ siê do
naszych w³asnych klas - do ich publicznych metod.<br><br>
Przyk³ady.<br>
<pre>public class SwingFromRhino {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("rhino");
    
    String script = engine.getFactory().getProgram(
        "importPackage (javax.swing)",
        "f = new JFrame('Okno')",
        "f.setSize(200,200)",
        "f.show()"
        );
    
    System.out.println(script);
    
    try {
      engine.eval(script);
    } catch (ScriptException e) {
      e.printStackTrace();
    }

  }

}</pre>Warto
zwróciæ uwagê na metodê z getProgram(String ...) interfejsu
ScriptEngineFactory, która zwraca gotowy do wykonania&nbsp; program,
sk³adaj¹cy siê z indtrukcji podanych jako argumenty, zgodnie ze
sk³adni¹ danego jêzyka skryptowego.<br><br>
W tym kontekœcie warto
swpomnieæ te¿ o innych u¿ytecznych metodach pomocniczych interfejsu
ScriptEngineFactory:<br>
<table summary="" border="1" cellpadding="3"
 cellspacing="0" width="100%"><tbody><tr class="TableRowColor"
 bgcolor="white"><td align="right" valign="top" width="1%">
&nbsp;String</td>
<td>getMethodCallSyntax(String&nbsp;obj, String&nbsp;m,
String...&nbsp;args)
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca
napis,
który mo¿e byæ u¿yty w danym jêzyku skryptowym do wywolania metody
klasy Javy na rzecz obiektu&nbsp;<span style="font-style: italic;"></span></td>
</tr><tr class="TableRowColor" bgcolor="white">
<td align="right" valign="top" width="1%">&nbsp;String</td>
<td>getOutputStatement(String&nbsp;toDisplay)
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca
napis,
który mo¿e byæ u¿yty jako instrukcja danego jêzyka skryptowego do
wyprowadzenia napisu toDisplay</td></tr></tbody></table><br><br>
Przyk³ad.<br>
<pre>class Person {
  String name;

  public Person(String name) {
    super();
    this.name = name;
  }


  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }

}

public class Groovy2 {

  public static void main(String[] args) {
    ScriptEngineManager manager = new ScriptEngineManager();
    ScriptEngine engine = manager.getEngineByName("groovy");
    try {

      Person p = new Person("Ala");
      String call = engine.getFactory().getMethodCallSyntax("p", "setName", "\"Pies\"");

      System.out.println(call);
      engine.put("p", p);

      engine.eval(call);
      System.out.println(p.getName());

      String out = engine.getFactory().getOutputStatement(p.getName());
      System.out.println(out);
      engine.eval(out);

    } catch (ScriptException e) {
      e.printStackTrace();
    }

  }

}</pre><br>
Wynik:<br>
<div
 class="listing100"><br>
p.setName("Pies")<br>
Pies<br>
println("Pies")<br>
Pies<br>
</div><br><br>
<br>
<a name="Skrypty.7"></a><h2>7. Przyk³ad: programowanie skryptowe na zmiennych aplikacji</h2>
<br>
W poni¿szym programie przedstawiono:<br>
<ul><li>automatyczne
przekazywanie zmiennych aplikacji do œrodowiska skryptowego, w tym
tablic,</li><li>wykonywanie na nich obliczeñ w skrypcie (w tym na
tablicach),</li><li>uzyskiwanie wyników obliczeñ w aplikacji,</li><li>komunikacjê
skryptu z elementami GUI (np. pole tekstowe).</li></ul>Wykonywany
skrypt wygl¹da nastêpuj¹co:<br>
<pre>importPackage(javax.swing);
a = a + 1;
b = 33;
c = a + b;
sum = 0;
for (i in arr) { 
  arr[i] = arr[i]*2;
  sum += arr[i];
}
JOptionPane.showMessageDialog(null, "Suma = " + sum);
infoText.setText("Suma = " + sum);
</pre>przy
czym zmienne a, b, c s¹ zmiennymi liczbowymi z aplikacji, arr - tablica
z aplikacji, infoText - pole tekstowe z aplikacji.<br><br>
Aplikacja ma
nastêpuj¹c¹ postaæ:<br>
<pre>class Varman {
  
  private Object vars;
  private Bindings bindings;
  private Field[] fields;
  
  public Varman(Bindings bindings, Object vars) {
    this.vars = vars;
    this.bindings = bindings;
    fields = vars.getClass().getDeclaredFields();
    for (int i = 0; i &lt; fields.length; i++) {
      try {
        String name = fields[i].getName();
        if (name.indexOf("this\$") != -1) continue;
        Object value =  fields[i].get(vars);
        bindings.put(name, value);
      } catch (Exception e) {
        e.printStackTrace();
      } 
    }
  }
  
  public void getVars() {
    for (int i = 0; i &lt; fields.length; i++) {
      String name = fields[i].getName();
      if (name.indexOf("this\$") != -1) continue;      
      Object value =  bindings.get(name);
      try {
        fields[i].set(vars, value);
      } catch (Exception e) {
        e.printStackTrace();
      } 
    }
  }
  
  public String getVarsPageView() {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; fields.length; i++) {
      try {
        String name = fields[i].getName();
        if (name.indexOf("this\$") != -1) continue;
        Object value = fields[i].get(vars);
        if (fields[i].getType().isArray()) {
          StringBuilder tmp = new StringBuilder("{ ");
          tmp.append(Array.get(value, 0));
          for (int j=1; j &lt; Array.getLength(value); j++) tmp.append(", ").append(Array.get(value, j));
          tmp.append(" }");
          value = tmp;
        }
        sb.append('\n').append(name).append(" = ").append(value);
      } catch (Exception e) {
        e.printStackTrace();
      } 
    }
    return sb.toString();
  }
}


public class CalcJs1 {

  private ScriptEngineManager manager = new ScriptEngineManager();
  private ScriptEngine engine = manager.getEngineByName("rhino");
  private Bindings bindings = engine.createBindings();
  
  private class Var {
    double a = 7, b, c, d, e, f;
    int[] arr = { 1, 2, 3 };
  }
  
  public CalcJs1() {
    Var v = new Var();
    Varman vm = new Varman(bindings, v);
    showInfoFrame(bindings);
    try {
      engine.eval(new FileReader("testCalc.js"), bindings);
    } catch (FileNotFoundException e) {
      e.printStackTrace();
    } catch (ScriptException e) {
      e.printStackTrace();
    }
    vm.getVars();
    JOptionPane.showMessageDialog(null, vm.getVarsPageView(), "Wyniki", 1);
    for (int i = 0; i &lt; v.arr.length; i++) {
      System.out.println("arr " +i+ " = " + v.arr[i]);
    }
  }  
  
  private void showInfoFrame(Bindings bindings) {
    JFrame f = new JFrame("Wyniki");
    JTextField tf = new JTextField("Na razie nie ma wyniku               ");
    f.add(tf);
    f.pack();
    f.setLocation(600, 300);
    f.setVisible(true);
    bindings.put("infoText", tf);
  }

  public static void main(String[] args) {
    new CalcJs1();
  }
  

}</pre><br><br>
<a
 target="_self" href="mm/Prezent1.htm">Pokaz dzia³ania aplikacji</a>.<a
 href="mm/Prezent1.htm"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt="r"
 src="../STYLE/video2.gif"></a><br><br>
<br>
<a name="Skrypty.8"></a><h2>8. Przyk³ad: wykorzystanie mo¿liwoœci JavaScript w apletach Javy</h2>
<br>
W tym przyk³adzie stworzymy aplet, dostarczaj¹cy "eleganckiego"
menu.<br>
Jedna z opcji menu daje mo¿liwoœæ zmiany stylu strony.<br>
Aby
uzyskaæ zmianê stylu wykorzystamy motor skryptowy dla natywnych
przegl¹darek (BrowserJS) i napiszemy odpowiedni skrypt js, który bêdzie
wykonywany po wyborze opcji w menu apletu.<br><br>
<a
 href="mm/Prezent2.htm" target="_self">Demonstracja dzia³ania</a><a
 href="mm/Prezent2.htm"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt="r"
 src="../STYLE/video2.gif"></a><br><br>
Skrypt:<br><br>
<pre>function chgStyle(cssFile) {
  var link = document.getElementById("slink");
  link.setAttribute('href', cssFile);
}</pre>Aplet:
<pre>import java.awt.*;
import java.awt.event.*;
import java.io.*;

import javax.script.*;
import javax.swing.*;

@SuppressWarnings("serial")
public class Konfigurator extends JApplet implements ActionListener {

  ScriptEngine engine;
  String[] cssFiles = { "style/first.css", "style/second.css", "style/third.css", "style/last.css" };
  String[] opis = { "Surowy", "Kolorowy", "Powiêkszony", "S³oneczny" };
  String script;

  @Override
  public void init() {
    ClassLoader myloader = getClass().getClassLoader();
    ScriptEngineManager manager = new ScriptEngineManager(myloader);
    engine = manager.getEngineByName("BrowserJS");
    engine.put("applet", this);
    
    BufferedReader br;
    StringBuilder sb = new StringBuilder();
    try {
      br = new BufferedReader(new FileReader("menu.js"));
      for (String line; (line = br.readLine()) != null;)
        sb.append(line).append('\n');
    } catch (IOException e1) {
      e1.printStackTrace();
    }
    
    script = sb.toString();
    
    JMenu[] menu = { new JMenu("Wygl¹d"), new JMenu("Spis treœci"), 
                     new JMenu("Wa¿ne linki"), new JMenu("Wyszukiwanie"),  new JMenu("Pomoc") }; 
    for (int i = 0; i &lt; opis.length; i++) {
      JMenuItem mi = new JMenuItem(opis[i]);
      mi.setActionCommand(cssFiles[i]);
      mi.addActionListener(this);
      menu[0].add(mi);
    }
     
    JMenuBar mb = new JMenuBar();
    for (int i = 0; i &lt; menu.length; i++) {
      if (i == menu.length-1) mb.add(Box.createHorizontalGlue());
      mb.add(menu[i]);
      menu[i].addMouseListener(new MouseAdapter() {
        Color back; 
        @Override
        public void mouseEntered(MouseEvent e) {
          Component c = e.getComponent();
          back = c.getForeground();
          c.setForeground(Color.BLUE);
        }

        @Override
        public void mouseExited(MouseEvent e) {
          e.getComponent().setForeground(back);
        }
        
      });
    }

    this.setJMenuBar(mb);
  }
  
   public void actionPerformed(ActionEvent e) {
        try {
          String name = e.getActionCommand();
          engine.eval(script);
          if (engine instanceof Invocable) {
            Invocable inv = (Invocable) engine;
            inv.invokeFunction("chgStyle", name);
          }
          else JOptionPane.showMessageDialog(null, "Engine not invocable");
        } catch (Exception exp) {
          throw new RuntimeException(exp);
        }
  }
   
}</pre><br>
<br>
<hr></body></html>