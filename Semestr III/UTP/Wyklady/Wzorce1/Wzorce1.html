<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="Content-Type"
 content="text/html; charset=windows-1250"> <meta name="author"
 content="Krzysztof Barteczko"> <meta name="description"
 content="Uniwersalne techniki programowania"> <meta name="copyright"
 content="(c) Krzysztof Barteczko PJWSTK 2010"> <link rel="stylesheet"
 type="text/css" href="../STYLE/common.css"> <title>Wzorce projektowe
(1)</title></head>
<body><br>
<br>
<div align="center"><h1>Wzorce projektowe (1)</h1>
</div><br>
<hr><p><i>Prawid³owe programowanie wymaga w³aœciwego zastosowania
wzorców projektowych. Zaczynamy od wprowadzenia pojêcia
wzorców projektowych, przedstawienia historii ich rozwoju i
klasyfikacji&nbsp; oraz omówienia podstawowych wzorcó-zasad
programowania obiektowego..</i><br>
</p><hr>
<a name="Wzorce1.1"></a><h2>1. Co to s¹ wzorce projektowe (design patterns) ?</h2>
<div class="def"><br>
<!----><a name="ind.5.1"></a>Wzorce projektowe -
to wielokrotnie powtórzone (powtarzaj¹ce siê) i pozytywnie
zweryfikowane schematy rozwi¹zañ czêsto spotykanych problemów
projektowych.<!---->&nbsp;<br>
<br>
Wzorce projektowe dotycz¹ architektury ca³ej aplikacji, a nie
pojedynczej klasy,<br>
</div><br>
<br>
Wzorce projektowe nie s¹ wynajdywane, ale <b>odkrywane</b>. Jakiœ
subtelny, œwietny sposób rozwi¹zania jakiegoœ problemu nie jest wzorcem
projektowym. <br>
<b>Wzorzec musi byæ zastosowany wielokrotnie, niejako pojawiæ siê w
codziennej
praktyce projektowej, potwierdziæ swoje znaczenie. W tej praktyce jest
dostrzegany
i w³aœnie odkrywany</b>.<br>
<br>
Wzorców nie nale¿y myliæ z tzw. applications framework (przyk³adowo
JCF nie
jest wzorcem projektowym). Te ostatnie dotycz¹ raczej bardziej
technicznych
szczegó³ów, w tym implementacyjnych i znajduj¹ siê na ni¿szym poziomie
abstrakcji
ni¿ wzorce.<br>
<hr style="width: 100%; height: 2px;"><br>
<a name="Wzorce1.2"></a><h2>2. Czy i po co stosowaæ wzorce projektowe?</h2>
<br>
<div class="important">Stosowanie wzorców projektowych pozwala na
pisanie lepszych, bardziej efektywnych,
skalowalnych, ³atwiej modyfikowalnych, mniej nara¿onych na b³êdy
programów</div><br>
<br>
Przede wszystkim dlatego, ¿e w codziennej praktyce, doœwiadczeniu
ca³ych
rzesz projektantów i programistów te w³aœnie problemy s¹ w centrum
uwagi i
te w³aœnie problemy s¹ &nbsp;rozwi¹zywane tak czy inaczej. Dobre
rozwi¹zania sprawdzaj¹
sie, powtarzaj¹, w koñcu trafiaj¹ do "spisu" wzorców projektowych.
Wzorce
s¹ dobrze opisane, wyjaœnione na konkretnych przyk³adach - daj¹ wiêc
szansê
na poznanie dobrych metod programowania i zastosowanie ich po to, by
u³atwiæ
proces tworzenia i wdra¿ania aplikacji czy systemów.<br>
<br>
<div class="important">ALE! - Nie nale¿y na si³ê stosowaæ wzorców
projektowych!!!</div><br>
<hr style="width: 100%; height: 2px;"><br>
<a name="Wzorce1.3"></a><h2>3. Historia rozwoju wzorców projektowych</h2>
<br>
Termin "wzorce projektowe"&nbsp; pochodzi z prac architekta
Christophera Alexandra. <br>
Pierwszym wzorcem projektowym by³a architektura MVC w Smalltalku.<br>
<br>
Prze³omowe znaczenie mia³a wydana w po³owie lat 90-tych ksi¹¿ka
“Design Patterns: Abstraction and Reuse of Object
Oriented-Design”, &nbsp;autorstwa tzw. Gang Of Four - GoF (E. Gamma, R.
Helm, R. Johnson, J. Vlissides), w której sklasyfikowano&nbsp;i dobrze
opisane 23 wzorce projektowe.<br>
<br>
<br>
Rozwój wzorców: <br>
<ul> <li>wzorce przetwarzania rozproszonego, </li> <li>
wzorce dla aplikacji WEB,</li> <li>
J2EE Patterns Catalog.</li>
</ul><br>
Ostatnio pojawia³o siê i rozwija siê&nbsp;<b> zainteresowanie wzorcem
"Inverse of Control" (w sensie Dependency Injection). </b>Ten temat
poruszymy w wyk³adzie 14.<br>
<hr style="width: 100%; height: 2px;"><br>
<a name="Wzorce1.4"></a><h2>4. Wzorce programowania obiektowego</h2>
<br><br>
<a name="Wzorce1.5"></a><h2>4.1. K³opoty z przedefiniowaniem metody equals()</h2>
<!----><a name="ind.4.1"></a>Przedefiniowanie metody equals()<!----> ma
sens wtedy, gdy mo¿na porównywaæ "treœci"
obiektów "na równoœæ". Tworz¹c uniwersalne klasy (klasy ponownego
u¿ytku)
powinniœmy zawsze rozwa¿yæ przedefiniowanie metody equals() i dokonaæ
tego,
jeœli tylko porównywanie obiektów "na równoœæ" ma sens, nawet gdy
aktualnie
nie jest to nam potrzebne. Nasza klasa mo¿e przecie¿ byæ u¿yta w innych
programach,
w których stwierdzanie czy jakieœ jej obiekty s¹ sobie znaczeniowo
równe
bêdzie istotne.<br>
 Z przedefiniowania metody equals mo¿emy jednak
zrezygnowaæ
wtedy, gdy ew. j¹ definicjê w klasie dziedziczonej przez nasz¹ klasê
uznamy za ca³kowicie wystarczaj¹ce, Zazwyczaj jednak bêdziemy metodê
equals() w jakiœ sposób w naszych klasach definiowaæ<br>
<br>
Czêstym b³êdem jest definiowanie metody equals z parametrem
konkretnej klasy
np. Car czy Pies. Taka definicja jest w stosunku do definicji z klasy
Object
przeci¹¿ona, a nie przedefiniowana, co - w sytuacji konwersji do Object
(czêstej
w przypadku tablic obiektowych lub kolekcji) - uniemo¿liwia
polimorficzne
odwo³ania.<br>
<br>
Innym b³êdem jest nieprzestrzeganie ogólnych regu³ definiowania
metody equals.<br>
<br>
Regu³y te s¹ nastêpuj¹ce:<br>
<ul> <li>metoda zwraca wynik true, jeœli obiekty s¹ takie same lub
false w przeciwnym razie,</li> <li>obiekty ró¿nych klas nie s¹ takie
same,</li> <li>je¿eli &nbsp;referencja przekazana jako argument jest
równa null, to obiekty nie s¹ takie same,</li> <li>metoda equals nie
powinna sygnalizowaæ ¿adnego wyj¹tku, chyba, ¿e porównanie
obiektów danej klasy "na równoœæ" jest niedopuszczalne, co
sygnalizujemy
za pomoc¹ wyj¹tku UnsupportedOperationException.</li>
</ul>Dla spe³nienia tych ogólnych wymagañ wystarczy zdefiniowaæ metodê
equals w nastêpuj¹cy sposób:<br>
<br>
<div class="syntax"><br>
<br>
class Klasa {<br>
<br>
&nbsp;&nbsp;&nbsp; public boolean equals(Object o) {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if ( !(o instanceof &nbsp;Klasa)
) return false;<br>
&nbsp; &nbsp; &nbsp; &nbsp; Klasa obiektPorównywany = (Klasa) o;<br>
&nbsp; &nbsp; &nbsp; &nbsp; // kod stwierdzaj¹cy czy ten obiekt (this)
jest taki sam jak przekazany<br>
&nbsp; &nbsp; &nbsp; &nbsp; // jeœli tak - zwracamy true<br>
&nbsp; &nbsp; &nbsp; &nbsp; // jeœli nie - zwracamy false<br>
&nbsp; &nbsp; }<br>
<br>
}<br>
</div><br>
<br>
Zwróæmy uwagê:<br>
<ul> <li>jeœli <i><b>o</b></i> nie jest obiektem tej klasy w której
zdefiniowano
metodê equals albo jest to null - wynikiem operatora instanceof&nbsp;
jest false
i obiekty nie s¹ równe,</li> <li>aby porównaæ obiekty (zazwyczaj)
trzeba bêdzie u¿yæ w³asnych metod
klasy Klasa lub odwo³aæ siê do jej pól - st¹d koniecznoœæ konwersji
zawê¿aj¹cej
z formalnego typu Object do typu Klasa, przy czym mo¿liwoœæ
przeprowadzenia
tej konwersji jest zagwarantowana, gdy¿ wczeœniej stwierdziliœmy ju¿,
¿e <i><b>o</b></i> jest typu Klasa.</li>
</ul><br>
Pokazany szablon jest bardzo ogólny i nie mówi nic o tym jak nale¿y
pisaæ
kod stwierdzaj¹cy czy obiekty s¹ równe. Wbrew pozorom okazuje siê
czêsto,
¿e nie jest to zadanie trywialne, szczególnie w sytuacji gdy nasza
klasa
dziedziczy faktyczn¹ klasê parametru metody equals.<br>
<br>
Idzie g³ównie o to, ¿e equals wprowadza relacj¹ równowa¿noœci,
która - oczywiœcie - musi byæ m.in.:<br>
<ul> <li>symetryczna: x.equals(y) == y.equals(x)</li> <li>przechodnia:
&nbsp;x.equals(y) &amp;&amp; y.equals(z) =&gt; x.equals(z)</li>
</ul>Rozwa¿my przyk³ad: niech klasa Worker (robotnik) dziedziczy klasê
Person (osoba).<br>
Klasa Person ma jeden atrybut - powiedzmy nazwisko/imiê (name), klasa
Worker dodaje swój atrybut - pensjê (salary). <br>
<br>
<pre>class Person {
  private String name;

  public Person(String s) {
    name = s;
  }

  // ...
}

class Worker extends Person {
  private int salary;

  public Worker(String name, int sal) {
    super(name);
    salary = sal;
  }
  // ...
}

</pre>
<br>
W klasie Person ³atwo jest zdefiniowaæ metodê equals:<br>
<pre>  public boolean equals(Object o) {
    if (!(o instanceof Person)) return false;
    Person p1 = (Person) o;
    return name.equals(p1.name);
  }
</pre>W&nbsp;klasie
Worker mo¿emy zrobiæ to na kilka sposobów. Wydawa³oby siê, ¿e np.
taki sposób jest ca³kiem naturalny i spe³nia kontrakt dla metody equals:<br>
<br>
<pre>  public boolean equals(Object o) {
    if (!(o instanceof Worker)) return false;
    Worker w = (Worker) o;
    return super.equals(o) &amp;&amp; salary == w.salary;
  }
</pre>
Przetestujmy to. Poni¿szy fragment kodu:<br>
<br>
<pre>    Person p = new Person("Jan");
    Person p1 = new Person("Jan");
    Worker w = new Worker("Jan", 1000);
    Worker w1 = new Worker("Jan", 1000);
    System.out.println("p i p1 oper ==: " + (p == p1) + ", equals: " + p.equals(p1));
    System.out.println("w i w1 oper ==: " + (w == w1) + ", equals: " + w.equals(w1));
    System.out.println("p i w equals: " + p.equals(w));
    System.out.println("w i p equals: " + w.equals(p));
</pre>
wyprowadzi na konsolê:<br>
<div class="listing100">p i p1 oper ==: false, equals: true<br>
w i w1 oper ==: false, equals: true<br>
p i w equals: true<br>
w i p equals: false</div>
<br><br>
 Okazuje siê, ¿e przy porównywaniu osób miêdzy sob¹ oraz
osób-robotników
miêdzy sob¹ wszystko jest w porz¹dku. Ale gdy porównujemy osobê-Jana i
robotnika-Jana
(co mo¿emy spokojnie robiæ, bo sygnatura metody na to nam pozwala)
metoda
equals nie spelnia warunku symetrycznoœci: p.equals(w) daje inny wynik
ni¿
w.equals(p). Dzieje siê tak dlatego, ¿e w pierwszym przypadku nie brana
jest
pod uwagê pensja, zatem Jan bez pensji (nie bêd¹cy robotnikiem) jest
tym
samym co&nbsp; Jan-robotnik (z pensj¹ 1000). W drugim przypadku
uzyskujemy false,
bowiem obiekt-argument nie nale¿y do klasy Worker,<br>
<br>
Spróbujmy wiêc inaczej zdefiniowaæ metodê equals w klasie Worker.
Pomys³
na zachowanie symetrycznoœci relacji równowa¿noœci mo¿e byæ nastêpuj¹cy:<br>
je¿eli przekazany argument nie jest typu Worker - to pomijamy pensjê i
porównujemy
obiekty tak jak by oba by³y "tylko" osobami, w przeciwnym razie
porównujemy
równie¿ pensjê.<br>
<pre>  public boolean equals(Object o) {
    if (!(o instanceof Person)) return false;
    if (!(o instanceof Worker)) return super.equals(o);
    Worker w = (Worker) o;
    return super.equals(o) &amp;&amp; salary == w.salary;
  }
</pre>Poprzedni
program wyprowadzi teraz dobre wyniki dla jednolitych porównañ
(dwóch osób lub dwóch osób-robotników) oraz wynik symetryczny dla
porównañ
"krzy¿owych" (osoba - robotnik, robotnik-osoba):<br>
<div class="listing100">p i p1 oper ==: false, equals: true<br>
w i w1 oper ==: false, equals: true<br>
p i w equals: true<br>
w i p equals: true</div>
<br>
<br>
Czy jednak s¹ to dobre wyniki? &nbsp;Czy osoba-Jan to taki sam
(logicznie) obiekt
co robotnik-Jan z pensj¹ 1000? Wydawa³oby siê, ¿e to raczej w¹tpliwe
rozumowanie,
ale przecie¿ taki jest sens dziedziczenia: kiedy robotnika-Jana
porównujemy
z osob¹-Janem musimy braæ pod uwagê tylko wspólne cechy - to, ¿e oba
obiekty
reprezentuj¹ osoby (w szczególnoœci tê sam¹ osobê). <br>
<br>
Niestety, ³atwo siê przekonaæ, ¿e teraz nowe equals nie spe³nia
warunku przechodnioœci.<br>
Potwierdza to nastêpuj¹cy fragment:<br>
<pre>    Person p = new Person("Jan");
    Worker w = new Worker("Jan", 1000);
    Worker w1 = new Worker("Jan", 2000);
    System.out.println("p i w equals: " + p.equals(w));
    System.out.println("p i w1 equals: " + p.equals(w1));
    System.out.println("w i w1 equals: " + w.equals(w1));
</pre>który
wyprowadzi wyniki jawnie naruszaj¹ce regu³ê przechodnioœci:<br>
<div class="listing100">p i w equals: true<br>
p i w1 equals: true<br>
w i w1 equals: false</div>
<br>
<br>
Czy mo¿emy coœ z tym zrobiæ? Niestety, nie. <br>
Okazuje siê, ¿e w sytuacji, gdy dziedziczymy jak¹œ klasê i klasa
pochodna
<b>dodaje</b> swoje w³asne, <b>nowe atrybuty</b> (pola), <b>które s¹
wa¿ne dla wyniku porównania</b> -&nbsp; nie ma ¿adnego sposobu, aby
zachowaæ przechodnioœæ metody equals.<br>
<br>
Czy musimy siê tym martwiæ? &nbsp;Na pewno tak, bo to nie jest
tylko kwestia jakichœ
wyszukanych wymagañ teoretycznych. Byæ mo¿e w obecnej Javie g³ówne
znaczenie
metody equals polega na tym, ¿e stanowi ona kryterium umieszczania
elementów
w pewnych strukturach danych (kolekcjach), które nie dopuszczaj¹
powtarzaj¹cych
siê elementów . W tym kontekœcie naruszeni\e
symetrycznoœci i/lub przechodnioœci&nbsp; metody equals mo¿e prowadziæ
do zale¿nego
od kolejnoœci dodawania elementów stanu kolekcji, co oczywiœcie jest
niepo¿¹dane.<br>
<br>
Istniej¹ trzy wyjœcia z tej sytuacji (ale ka¿de ma swoje wady).<br>
<br>
 Pierwsze - na pewno niedobre, ale za to doœæ pragmatyczne - nie
martwiæ
siê brakiem przechodnioœci operacji equals. Wymaga ono jednak pe³nej
œwiadomoœci
tego jak dzia³a nasze "nieprzechodnie" equals i praktycznie nadaje siê
do
zastosowania tylko pod warunkiem, ¿e tworzone przez nas klasy bêd¹
stosowane
wy³¹cznie do budowy jakiejœ konkretnej aplikacji, i nie bêd¹ stanowiæ
czêœci
ogólniejszego, szerzej dostêpnego API. Niestety nigdy nie mamy
gwarancji,
¿e oba te warunki bêd¹ spe³nione w jakimœ choæ trochê d³u¿szym okresie.
<br>
<br>
Drugim rozwi¹zaniem jest zapewnienie, by metoda equals mog³a
porównywaæ wy³¹cznie obiekty
œciœle tych samych klas, inaczej mówi¹c, by wymaganie, ¿e "obiekty
ró¿nych
klas s¹ ró¿ne" by³o spe³nione w bardzo œcis³ym tego s³owa znaczeniu. W
omawianym,
standardowym szablonie metody equals() do sprawdzenia przynale¿noœci do
klasy
stosowany jest operator instanceof. &nbsp;Zwraca on wartoœæ true, jeœli
jego lewy
operand reprezentuje obiekt, który nale¿y do klasy podanej jako operand
prawy&nbsp;
lub <b>dowolnej jej nadklasy</b>.<br>
Zatem w metodzie equals klasy Person argumentem mo¿e byæ obiekt
dowolnej
podklasy klasy Person i obiekt ten zostanie uznany za obiekt klasy
Person
(st¹d wynika³a niesymetrycznoœæ operacji equals).<br>
Mo¿na jednak naprawdê sprawdziæ do jakiej konkretnie klasy nale¿y
obiekt.<br>
S³u¿y do tego metoda getClass(), zwracaj¹ca klasê obiektu ma rzecz
którego
zosta³a wywo³ana. Dla obiektu <i><b>p</b></i> klasy Person getClass()
zwróci obiekt oznaczaj¹cy
klasê Person, a dla obiektu <i><b>w</b></i> klasy Worker - obiekt
oznaczaj¹cy klasê Worker,
Te dwa obiekty nie bêd¹ to¿same (w przeciwieñstwie: <i><b>p instanceof
Person</b></i> zwróci true i <i><b>w instanceof Person</b></i> zwróci
true)<br>
Moglibyœmy zatem zdefiniowaæ metody equals w nastêpuj¹cy sposób:<br>
<br>
<pre>// W klasie Person

  public String getName() {
     return name;
  }
&nbsp;
  public boolean equals(Object o) {
    if (o == null) return false;
    if (getClass() != o.getClass()) return false;
    Person p1 = (Person) o;
    return name.equals(p1.name);
  }


// W klasie Worker

  public boolean equals(Object o) {
    if (o == null) return false;
    if (getClass() != o.getClass()) return false;
    Worker w = (Worker) o;
    return getName().equals(w.getName()) &amp;&amp; salary == w.salary;
  }


</pre>
Te definicje spe³niaj¹ kontrakt metody equals (m.in. zapewniaj¹
symetrycznoœæ
i przechodnioœæ), ale bardzo utrudniaj¹ stwierdzenie czy np. dwa
obiekty odzwierciedlaj¹ce
dwóch robotników (powiedzmy elektronika i malarza - z ró¿nymi pensjami)
nie
reprezentuj¹ przypadkiem tej samej osoby ("Jana"), wystêpuj¹cej w dwóch
rolach
(zatrudnionej na dwa etaty). A tak¿e stwierdzenie - czy "Jan" jako
obiekt
klasy Person ¿yj¹cy w jakimœ programie symulacyjnym, powiedzmy przed
tygodniem
czasu programu, nie jest dziœ &nbsp;tym samym co "Jan" - nowy obiekt
klasy Worker
- czyli tym samym "Janem", &nbsp; tyle, ¿e teraz, od dziœ,&nbsp;
zatrudnionym jako
robotnik. Obie metody equals() wo³ane dla obiektu "Jan" klasy Person i
&nbsp;"Jan"
klasy Worker stwierdz¹, ¿e obiekty nie s¹ takie same, bo nale¿¹ do
ró¿nych
klas. W pewnym sensie pozbyliœmy siê wiêc tu zalet polimorfizmu
("treœciowo"
prezentowane metody equals nie korzystaj¹ z ró¿norodnoœci swoich
argumentów,
raczej tê ró¿norodnoœæ "ucinaj¹"). <br>
A z drugiej strony - polimorficzne odwo³ania do equals - przeszkadzaj¹!
&nbsp;Przychodzi
bowiem do g³owy nastêpuj¹cy pomys³: jeœli chcemy porównaæ
Jana-robotnika
z Janem-osob¹, dostarczmy w klasie Worker metody zwracaj¹cej referencjê
do
obiektu klasy Worker jako referencjê do obiektu klasy Person:<br>
<br>
Person asPerson() { return (Person) this; }<br>
<br>
i porównujmy tak:<br>
<br>
Person p = new Person("Jan");<br>
Worker w = new Worker("Jan", 1000);<br>
p.equals(w.asPerson())<br>
w.asPerson().equals(p);<br>
<br>
Nie uzyskamy po¿¹danego efektu (wartoœci true w porównaniach),
bowiem metoda
getClass() wo³ana jest polimorficznie i dla obiektu klasy Worker (nawet
jeœli
odwo³ujemy siê do niego za pomoc¹ referencji typu Person) zawsze zwróci
klasê
Worker.<br>
<br>
Pozostaje nam wiêc tylko w klasie Person dostarczyæ nowej metody,
porównuj¹cej
"tylko" osoby, np. equalsAsPerson(Person). &nbsp;Klasy pochodne
odziedzicz¹ tê
metodê i bêd¹ mog³y j¹ spokojnie stosowaæ:<br>
<br>
<pre>  public boolean equalsAsPerson(Object o) {
    if (!(o instanceof Person)) return false;
    Person p1 = (Person) o;
    return name.equals(p1.name);
  }
</pre>
<br>
Teraz porównanie "Janów" jako osób bêdziemy mogli przeprowadzæ w
naszych programach za pomoc¹ tej metody.<br>
To jednak jest znowu tylko "lokalne" rozwi¹zanie: jakieœ ogólne
algorytmy,
zewnêtrzne wobec naszego programu (np. dzia³aj¹ce na kolekcjach), bêd¹
niekiedy
wykorzystywaæ metodê equals i nie bêd¹ umia³y stwierdziæ, ¿e "Jan" z
klasy
Person jest tym samym co "Jan" z klasy Worker.<br>
<br>
Trzecim mo¿liwym rozwi¹zaniem problemu jest zastosowanie <b>kompozycji
zamiast dziedziczenia</b>.<br>
<br>
Klasa Worker bêdzie wykorzystywaæ klasê Person przez kompozycjê. W
obu klasach
wrócimy do standardowej wersji metody equals, a w klasie Worker -
dodatkowo
- dostarczymy metody zwracaj¹cej <b>widok</b> na obiekt tej klasy jako
na Person,<br>
<pre>class Person {

  private String name;

  public Person(String s) {
    name = s;
  }

  public boolean equals(Object o) {
    if (!(o instanceof Person)) return false;
    Person p1 = (Person) o;
    return name.equals(p1.name);
  }

}

class Worker {

  private Person person;  // kompozycja
  private int salary;

  public Worker(Person p, int sal) {
    person = p;
    salary = sal;
  }

  public Person asPerson() { // zwraca <b>widok</b> na obiekt jako Person
    return person;
  }

  public boolean equals(Object o) {
    if (!(o instanceof Worker)) return false;
    Worker w = (Worker) o;
    return person.equals(w.person) &amp;&amp; salary == w.salary;
  }

}
</pre><br>
Teraz equals spe³nia swój kontrakt i zachowuje wszystkie w³aœciwoœci
relacji
rónowa¿noœci, a jednoczeœnie - stosuj¹c metodê asPerson() z klasy
Worker mo¿emy
porównywaæ jej obiekty traktowane jako obiekty klasy Person z obiektami
klasy Person.<br>
Jest to niew¹tpliwie rozwi¹zanie najlepsze, jednak - ogólnie - powoduje
utratê
zalet dziedziczenia (w tym przyk³adzie tego nie widaæ, ale gdyby klasy
by³y
bardziej rozbudowane, albo inne, to niew¹tpliwie moglibyœmy trochê
¿a³owaæ
polimorfizmu).<br>
<br>
Zastanówmy siê te¿ czy&nbsp; opisane k³opoty nie wynikaj¹ z
mno¿enia bytów
ponad miarê? Mo¿e nie powinniœmy mieæ w programie jednoczeœnie "Jana"
jako
obiektu klasy Person i "Jana" jako obiektu klasy Worker. "Jan" - jako
osoba
- jest przecie¿ jeden. Pokazany sposób kompozycji zaprzecza tej
obserwacji.
Dziedziczenie by³oby wiêc tu bardziej naturalne: klasê Person
nale¿a³oby
uczyniæ abstrakcyjn¹ i operowaæ tylko na obiektach konkretnych jej
podklas,&nbsp;
takich jak Worker czy Teacher. Ale to nie usunê³oby problemu: &nbsp; w
szczególnoœci
musielibyœmy umieæ porównywaæ czy robotnik i nauczyciel nie jest
przypadkiem
tym samym Janem w dwóch ró¿nych rolach. Jak widzieliœmy takie
porównanie
jest sensownie mo¿liwe tylko przy kompozycji, a ta z kolei ³amie
naturalny
porz¹dek, ¿e i Jan-robotnik i Jan-nauczyciel jest osob¹ (jest typu
Person).<br>
Jednak nawet jeœli uznaæ, ¿e dziedziczenie klasy Person w klasach
Worker i Teacher&nbsp; nie jest najszczêœliwszym
pomys³em i ¿e kompozycja dobrze opisuje sytuacjê (bycie osob¹ jest <b>aspektem</b>
robotnika, nauczyciela, pacjenta, ucznia etc), to powinniœmy zabroniæ
mo¿liwoœci
niezale¿nego od ról jakie spe³niaj¹ osoby tworzenia obiektów klasy
Person.
A to w &nbsp;Javie nie bêdzie ³atwe. Klasa Person nie mo¿e byæ
abstrakcyjna (bo
musimy utworzyæ jej obiekt wkomponowany w klasy-role). Z kolei
dostarczenie
- zamiast publicznego - chronionego (protected) konstruktora w klasie
Person
nie ogranicza mo¿liwoœci jego u¿ycia do podklas, bowiem sk³adowe
chronione
s¹ dostêpne równie¿ &nbsp;z innych klas pakietu, niekoniecznie
dziedzicz¹cych
dan¹ klasê. Dotyczy to zreszt¹ wszelkich innych mo¿liwych sposobów
inicjacji
pól klasy Person z poziomu podklas. Zabronienie istnienia abstrakcyjnej
"osoby-w-ogóle"
w przypadku kompozycji nie jest mo¿liwe.<br>
<br>
Kompozycja ma wiêc tak¿e swoje wady.<br>
<br>
Zastanawiaj¹c siê nad wyborem sposobu ponownego wykorzystania klas
musimy jednak pamiêtaæ, ¿e problem z nieprzechodnioœci¹
relacji wyznaczanej przez equals w sytuacji dziedziczenia,
rozszerzaj¹cego
zakres pól klasy o atrybuty wa¿ne dla porównañ jest ogólny i mo¿e
wyst¹piæ nawet wtedy, gdy
zastosowanie dziedziczenia jest &nbsp;nie budz¹cym
¿adnych w¹tpliwoœci,i ze wszech miar uzasadnionym i po¿¹danym,
rozwi¹zaniem .<br>
<br>
Koñcz¹c omawianie metody equals nale¿y jeszcze przypomnieæ, ¿e
równolegle
z przedefiniowaniem metody equals nale¿y równie¿ -&nbsp;w
sposób zgodny z metod¹
equals - przedefiniowaæ metodê hashCode, a tak¿e metodê compareTo(), o
ile klasy bêd¹ implementowaæ interfejs Comparable.&nbsp; <br>
<hr><br>
<a name="Wzorce1.6"></a><h2>4.2. Kompozycja a dziedziczenie</h2>
Mo¿na odnieœæ wra¿enie, ¿e dziedziczenie
jest znacznie potê¿niejszym &nbsp;(daj¹cym wiêksze mo¿liwoœci) sposobem
ponownego
wykorzystania klas ni¿ kompozycja. I ¿e - choæ bardziej skomplikowane
od kompozycji - daje
programiœcie wiêksz¹ elastycznoœæ i ³atwoœæ tworzenia i wykorzystania
kodów
"ponownego u¿ytku".<br>
Niew¹tpliwie wra¿enie to nie jest mylne.<br>
<br>
Ale z dziedziczeniem zwi¹zane s¹ pewne problemy.<br>
Na jeden z nich natknêliœmy siê przed chwil¹ przy próbie w³aœciwego
zdefiniowania metody equals().<br>
<br>
Innym jest tzw.&nbsp;<b>"s³aba hermetyzacja"</b> kodu klasy bazowej.<br>
<br>
Rozpatrzmy przyk³ad. Mamy oto ogóln¹ klasê kontenerów na butelki. I
chcemy
mieæ ró¿ne specyficzne klasy takich kontenerów&nbsp; (np. skrzynki piwa
lub Coca-Coli,
albo mo¿e lodówki sklepowe etc).<br>
Oczywiœcie, skrzynka piwa <b>jest</b> kontenerem na butelki, zatem
naturalne
jest tu dziedziczenie (klasa BeerBox odziedziczy BottleContainer) i
wykorzystanie
w innej klasie (nazwanej dalej Inhe1):<br>
<pre>class BottleContainer {

  private&nbsp;int bottlesCount;

  public BottleContainer(int n) {
    bottlesCount = n;
  }

  public&nbsp;int getCount() {
    return bottlesCount;
  }

  public String toString() {
    return "BottleContainer, bottles = " + bottlesCount;
  }
}

class BeerBox extends BottleContainer {

  public BeerBox(int n) { super(n); }

  public String toString() {
    return "BeerBox, bottles = " + getCount();
  }
}

class Inhe1 {
  public static void main(String[] args) {
    BeerBox bb = new BeerBox(10);
    int&nbsp;n = bb.getCount();
    //...
  }
}

</pre>Tu
za³o¿yliœmy, ¿e ogólnie kontenery mog¹ zawieraæ tylko pe³ne butelki
(st¹d typ int w klasie BottleContainer).<br>
Mo¿e kiedyœ zmienimy interfejs klasy bazowej w taki sposób, ¿e metoda
getCount() bêdzie mia³a inny typ wyniku - double (niepe³ne butelki).<br>
<br>
<pre>class BottleContainer {&nbsp;

 private&nbsp;double bottlesCount;

  public BottleContainer(double n) {
    bottlesCount = n;
  }


  public&nbsp;double getCount() {
    return bottlesCount;
  }
}
</pre>
<br>
W tym przyk³adzie klasa BeerBox nie bêdzie wymaga³a ¿adnych zmian,
ale w
klasie Inhe1 wykorzystuj¹cej BeerBox wyst¹pi¹ b³êdy w kompilacji (bo
spodziewanym
typem wyniku jest int, a nie double i trzeba by u¿yæ konwersji
zawê¿aj¹cej, aby to siê skompilowa³o). <br>
<br>
<font color="#ff0000"><b>
Mówi siê, ¿e klasa BeerBox<!----> <a name="ind.4.3"></a>"s³abo
hermetyzuje" kod klasy BottleContainer,
gdy¿ zmiana interfejsu tej klasy powoduje, i¿ ponowne wykorzystanie
hierarchii
dziedziczenia w innych klasach staje siê niemo¿liwe. Co gorsza, po
takiej ew. zmianie, wadliwy staje
siê kod klas ju¿ skompilowanych i byæ mo¿e dzialaj¹cych od d³ugiego
czasu<!---->.<br>
</b></font><br>
Okazuje siê, ¿e kompozycja pozwala unikn¹æ takich
problemów. W naszym "butelkowym" przyk³adzie
zastosowanie kompozycji mo¿e wygl¹daæ tak.<br>
<br>
<pre>class BottleContainer {

  private&nbsp;int bottlesCount;

  public BottleContainer(int&nbsp;n) {
    bottlesCount = n;
  }

  public&nbsp;double getCount() {
    return bottlesCount;
  }

}

class BeerBox  {

  // wykorzystanie klasy BottleContainer przez kompozycjê

  private BottleContainer cont;

  public BeerBox(int n) {
    cont = new BottleContainer(n);
  }

  public&nbsp;int getCount() {
    return&nbsp; cont.getCount();
  }

}

class Compos1 {

  public static void main(String[] args) {
    BeerBox bb = new BeerBox(10);
    int n = bb.getCount();
    // ...
  }
}
</pre>
<br>
Mamy tu dwie klasy, które tworz¹ "zestaw ponownego u¿ycia":
klasê BottleContainer i BeerBox. Przez inne klasy (np. Compos1) <b>bezpoœrednio</b>
u¿ywana jest&nbsp; klasa BeerBox. Klasa BottleContainer u¿ywana jest
poœrednio.
I teraz, jeœli &nbsp;- podobnie jak w przyk³adzie z dziedziczeniem -
w&nbsp; klasie
BottleContainer zmienimy interfejs (czyli np. zmienimy typ zwracanego
przez
metodê getCount() wyniku na double), to - bêdziemy musieli zmieniæ coœ
w
implementacji klas bezpoœrednio wykorzystywanych przez inne klasy (tu:
BeerBox),
ale ich interfejsy pozostan¹ bez zmian i w zwi¹zku z tym nie trzeba
bêdzie&nbsp;
nic zmieniaæ w klasach wykorzystuj¹cych nasz zestaw klas pojemników na
butelki:<br>
<pre>class BottleContainer {

 private&nbsp;<b>double</b>  bottlesCount;
&nbsp;// ...

  public&nbsp;<b>double</b> getCount() {
    return bottlesCount;
  }

}

class BeerBox {

  private BottleContainer cont;

  // ...

  public int getCount() {
    return (int) cont.getCount();  // drobna zmiana implementacji
  }

}

// nie wymaga zmian po zmianie interfejsu klasy BottleContainer
class Compos1 {
  public static void main(String[] args) {
    BeerBox bb = new BeerBox(10);
    int n = bb.getCount();
  }

</pre>Jest
to sytuacja korzystniejsza w stosunku do "s³abej hermetyzacji" kodu
przy dziedziczeniu, bowiem - w koñcu - zwykle klasy takie jak
BottleContainer
i BeerBox s¹ kontrolowane przez twórców jakiegoœ API, zaœ u¿ytkownicy
API
zwykle korzystaj¹ z klas <b>bezpoœredniego</b> ponownego u¿ycia (w
naszym przyk³adzie BeerBox).<br>
<br>
Oczywiœcie, przy dziedziczeniu ³atwiejsze ni¿ przy kompozycji jest
dodawanie
nowych klas jakiegoœ API (w naszym &nbsp;przyk³adzie np. lodówek, pó³ek
z wod¹
mineraln¹, pojemników z Col¹ itp.). £atwiejsze i bardziej naturalne
jest
te¿ zastosowanie polimorfizmu.<br>
<br>
No, w³aœnie, czy kompozycja w ogóle&nbsp; umo¿liwia wykorzystanie
odwo³añ polimorficznych?<br>
Na pierwszy rzut oka - nie bardzo.<br>
<br>
<a name="Wzorce1.7"></a><h2>4.3. Polimorfizm kompozycji - zastosowanie interfejsów.</h2>
<br>
<div class="important">Umiejêtne zastosowanie interfejsów
pozwala korzystaæ z dobrodziejstw polimorfizmu nawet przy kompozycji!</div><br>
<br>
Dla przyk³adu: wprowadzaj¹c interfejs Stringable z metod¹ String
asString()
i implementuj¹c go w klasach skrzynek piwa (BeerBox) i lodówek (Frige)
uczynimy
referencje do obiektów tych klas typu Stringable i bêdziemy mogli
u¿ywaæ
polimorficznego odwo³ania do metody asString np. w poni¿szej metodzie
getInfo(Stringable).<br>
<br>
<br>
<pre>interface Stringable {
  public String asString();
}

class BottleContainer {
 // ...
}

class BeerBox implements Stringable  {

  private BottleContainer cont;

  public BeerBox(int n) {
    cont = new BottleContainer(n);
  }

  public int getCount() {
    return cont.getCount();
  }

  public String asString() {
    return "BeerBox, bottles = " + getCount();
  }
}

class Frige implements Stringable  {

  private BottleContainer cont;

  public Frige(int n) {
    cont = new BottleContainer(n);
  }

  public int getCount() {
    return cont.getCount();
  }

  public String asString() {
    return "Frige, bottles = " + getCount();
  }
}


class Compos1 {

  static String  getInfo(Stringable s) {
    return s.asString();
  }

  public static void main(String[] args) {
    BeerBox bb = new BeerBox(10);
    Frige fr = new Frige(20);
    System.out.println(getInfo(bb));
    System.out.println(getInfo(fr));
  }
}
</pre><br>
<a name="Wzorce1.8"></a><h2>4.4. Regu³y ponownego wykorzystania klas</h2>
<br>
<b>
Po pierwsze</b>, nale¿y staraæ siê dostosowywaæ sposób
ponownego wykorzystania
do dziedziny problemu. Dziedziczenia u¿ywamy wtedy, kiedy spe³niona
jest
relacja "B jest A", ale czasem okazuje siê, ¿e taka relacja jest
pozorna lub mo¿e ulegaæ zmianom w cyklu ¿yciowym obiektów.
Dobrym testem jest postawienie pytania czy zawsze, w ka¿dych
okolicznoœciach
dzia³ania naszego programu mo¿na sensownie myœleæ o rozszerzaj¹cej
konwersji
referencyjnej typu podklasy do typu nadklasy.<br>
<br>
<b>
Po drugie</b>, z wyborem sposobu wykorzystania klas zwi¹zane s¹ kwestie
efektywnoœciowe:
kompozycja okazuje siê niekiedy bardziej pracoch³onna i wolniejsza przy
wykonaniu
programu, ale z kolei w niektórych okolicznoœciach pozwala oszczêdzaæ
pamiêæ
(tworzenie obiektu, definiowanego w ramach kompozycji jako pole klasy
mo¿e
byæ <b>odroczone w czasie</b> do momentu kiedy bêdzie on potrzebny, co
w danym przebiegu
programu mo¿e nie nast¹piæ nigdy; przy dziedziczeniu zawsze wydzielana
jest
pamiêæ dla pól nadklasy).<br>
<br>
<b>
Po trzecie</b>, wreszcie nie nale¿y nadu¿ywaæ ani dziedziczenia ani
kompozycji.
Jak widzieliœmy dziedziczenie ma swoje wady, zwi¹zane przede wszystkim
ze
"<b>s³ab¹ hermetyzacj¹</b>" (a tak¿e<!----> <a name="ind.4.6"></a>"<b>kruchoœci¹</b>"
klasy bazowej - niekiedy zmiana
jej interfejsu powoduje koniecznoœæ zmian w interfejsach wielu klas
dziedzicz¹cych<!---->,
np. jeœli zmienimy typ zwracanego wyniku w metodzie, która w podklasach
jest
przedefiniowywana). Z kolei kompozycja - która pozwala unikaæ takich
problemów
- jest czêsto mniej naturalna i w zwi¹zku z tym kody klas s¹
trudniejsze
do "prowadzenia" (uzupe³nieñ, modyfikacji), a rozbudowa API o nowe
klasy du¿o trudniejsza ni¿ przy zastosowaniu dziedziczenia. <br>
<br>
<br>
<a name="Wzorce1.9"></a><h2>4.5. Kopie obiektów</h2>
Jak wiemy, w Javie przy pracy z obiektami pos³ugujemy siê referencjami.
Zatem, jeœli mamy obiekt klasy A:<br>
<br>
A a = new A();<br>
<br>
to deklaracja:<br>
<br>
A a1 = a;<br>
<br>
nie stworzy nowego obiektu, a jedynie now¹ referencjê, za pomoc¹
której bêdziemy
siê mogli odwo³ywaæ do tego samego obiektu, co oznaczany przez
referencjê
a.<br>
<br>
Czasami jednak bêdziemy potrzebowaæ kopii, innego, nowego obiektu
(powiedzmy
klasy A), który ma te same elementy, o takich samych wartoœciach co
orygina³.<br>
<br>
U pocz¹tków Javy wprowadzono<!----> <a name="ind.4.8"></a>mechanizm
klonowania obiektów. <br>
Polega on na tym, ¿e w klasie Object zdefiniowano zabezpieczon¹ metodê
clone(),
która zwraca nowy obiekt ze skopiowanymi polami orygina³u<!---->. <br>
<br>
To<!----> <a name="ind.4.9"></a>kopiowanie jest <b>p³ytkie</b>:
pola orygina³u, które oznaczaj¹ referencje
do obiektów, kopiowane s¹ jako referencje (nie ma przy tym tworzenia
kopii
obiektów na &nbsp;które te referencje wskazuj¹)<!---->. <br>
Czêsto takie zachowanie nie bêdzie
odpowiednie (bo kopia nie bêdzie niezale¿na, bêdzie mia³a wspólne
czêœci danych z
orygina³em). Dlatego metodê clone() "przeznaczono" do przedefiniowania.
<br>
Jednoczeœnie
jednak, poniewa¿ nie wiadomo co tak naprawdê ma oznaczaæ klonowanie w
konkretnych
przypadkach i czy w ogóle klonowanie (takie czy inne) dla obiektów
jakiejœ
klasy jest dopuszczalne, wprowadzono interfejs Cloneable, którego
implementacja
w klasie daje sygna³, ¿e klonowanie jest dopuszczalne. <br>
Interfejs nie ma ¿adnych
metod, jest tylko znacznikiem, który mówi - "obiekty tej klasy mog¹ byæ
klonowane".
<br>
Jeœli klasa nie implementuje tego interfejsu, to u¿ycie metody
clone() (zdefiniowanej
w klasie Object, albo te¿ przedefiniowanej w danej klasie) powoduje
powstanie
wyj¹tku CloneNotSupportedException. Wyj¹tek ten jest zg³aszany przez
clone()
z klasy Object i wymaga obs³ugi, niezale¿nie od tego czy implementujemy
interfejs
Cloneable czy te¿ nie.<br>
<br>
Zobaczmy przyk³ady.<br>
<pre>class A implements Cloneable {

  private int a = 3;
  int get() { return a; }

  public Object clone() {
    try {
      return super.clone();
    } catch (CloneNotSupportedException exc) {
        throw new Error("Dziêkujemy za klonowanie!");
    }
  }
}


class Cloning1 {

  public static void main(String[] args) {
    A a = new A();
    A a1 = a;
    A a2= (A) a.clone();
    System.out.println(a.get() + " " + a1.get() + " " + a2.get());
    System.out.println("a==a1: " + (a==a1) + "  a==a2: " + (a==a2));
  }

}
</pre>W
programie tym zapewniamy klonowanie obiektów klasy A zgodnie z
wymaganiami
specyfikacji metody clone(), Ca³kiem wystarczaj¹ce przy tym jest
wywo³anie
metody clone z nadklasy (w tym przypadku Object). Widzimy, ¿e po
klonowaniu
mamy dwa ró¿ne obiekty o tej samej zawartoœci.<br>
<div class="listing100"><br>
3 3 3<br>
a==a1: true&nbsp; a==a2: false<br>
</div><br>
<br>
Ju¿ w tym przyk³adzie jednak natykamy siê na trochê nonsensown¹
koniecznoœæ
obs³ugi wyj¹tku CloneNotSupportedException, który - poniewa¿ nasza
klasa
A implementuje interfejs Cloneable - nie mo¿e wyst¹piæ w ¿adnej
sytuacji!<br>
<br>
Takie proste, zapewniane przez domyœln¹ implementacjê metody
clone(0 w klasie
Object, kopiowanie obiektów, jest czêsto niewystarczaj¹ce, bowiem jest
p³ytkie,
<br>
<br>
Np. je¿eli mamy klasê B, której polem jest tablica liczb ca³kowitych,
to
p³ytkie kopiowanie&nbsp; przepisze do nowego obiektu referencjê do tej
tablicy,
ale tablica pozostanie ta sama (w obu obiektach: oryginale i kopii) i
je¿eli
bêdziemy&nbsp; zmieniaæ elementy tablicy za poœrednictwem orygina³u, to
bêd¹
siê one równie¿ zmieniaæ w kopii i odwrotnie. Np. poni¿szy program:<br>
<br>
<pre>class B implements Cloneable {

  private int[] arr = {1, 2, 3};

  public int[] get() { return arr; }
  public void set(int i, int val) { arr[i] = val; }


  public Object clone() {
    try {
      return super.clone();
    } catch (CloneNotSupportedException exc) {
        throw new Error("Dziêkujemy za klonowanie!");
    }
  }

}


class Cloning2 {

  static void show(String nam, int[] arr) {
    System.out.println(nam);
    for (int i=0; i&lt;arr.length; i++) System.out.print(" " + arr[i]);
    System.out.println("");
  }

  public static void main(String[] args) {
    B x  = new B();
    B x1 = (B) x.clone();
    show("x", x.get());
    show("x1 - nowy obiekt kopia x" , x1.get());
    x.set(1, 10);
    show("x1 - p³ytka kopia, nie jest niezale¿nym obiektem!", x1.get());
  }
</pre>
wyprowadzi nastêpujace wyniki:<br>
<div class="listing100"><br>
x<br>
&nbsp;1 2 3<br>
x1 - nowy obiekt kopia x<br>
&nbsp;1 2 3<br>
x1 - p³ytka kopia, nie jest niezale¿nym obiektem!<br>
&nbsp;1 10 3<br>
</div><br>
<br>
Musimy zatem inaczej zdefiniowaæ metodê clone, tak by uzyskaæ kopiê
g³êbok¹,
odtwarzaj¹c¹ stan wszystkich obiektów, oznaczanych przez pola klasy,<br>
Mo¿e to wygl¹daæ tak:<br>
<pre>class B implements Cloneable {

  private int[] arr = {1, 2, 3};

  public int[] get() { return arr; }
  public void set(int i, int val) { arr[i] = val; }


  public Object clone() {
    try {
      B&nbsp;copy = (B) super.clone();
      copy.arr = (int[]) arr.clone();
      return copy;
    } catch (CloneNotSupportedException exc) {
        throw new Error("Dziêkujemy za klonowanie!");
    }
  }
</pre>U¿ywamy
tu metody clone wobec tablicy arr. Metoda ta zapewnia utworzenie
nowej tablicy i skopiowanie do niej wszystkich elementów tablicy&nbsp;
oryginalnej
(klonowanej). W rezultacie otrzymamy (w tym przypadku) <b>g³êbok¹ kopiê</b>
obiektu klasy B (bêdzie on mia³ teraz jako element referencjê do nowej
tablicy
liczb ca³kowitych ze skopiowanymi z orygina³u elementami).<br>
<br>
Co by siê jadnak sta³o, gdyby w klasie B, tablica arr by³a
zadeklarowana jako final:<br>
<br>
<b>private final int[] arr = { 1, 2, 3 };</b><br>
<br>
Oczywiœcie, wyst¹pi³by b³¹d w kompilacji, bowiem pole arr nie mo¿e
byæ modyfikowane
po inicjacji (bo jest final) i przypisanie copy.arr = (int[])
arr.clone()
jest syntaktycznie b³êdne.<br>
<br>
Zauwa¿my: nie chodzi tylko o przekopiowanie elementów tablicy, ale
stworzenie
tablicy nowej i przypisanie referencji arr (w klonie) odniesienia do
tej
nowej tablicy. Zatem nawet gdybyœmy zrezygnowali z u¿ycia clone wobect
tablicy arr i zapisywali kod "bezpoœrednio", to:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; B copy = (B) super.clone();<br>
&nbsp; &nbsp; &nbsp;for (int i=0; i&lt;arr.length; i++) copy.arr[i] =
arr[i];<br>
<br>
&nbsp;nic nam nie daje (bo arr i copy.arr oznacza ten sam
obiekt-tablicê), a z kolei takie rozwi¹zanie:<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C copy = (C) super.clone();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int[] newArr = new int[arr.length]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i=0; i&lt;arr.length; i++)
newArr[i] = arr[i];<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy.arr = newArr; <br>
<br>
jest niedopuszczalne, bo modyfikujemu zainicjowane finalne pole arr.<br>
<br>
Zatem nawet w prostych przypadkach mechanizm klonowania w Javie
jest bardzo
problematyczny. Jeœli uwzglêdnimy do tego fakt, ¿e w z³o¿onych
hierarchiach
dziedziczenia musimy opieraæ siê na klonowaniu obiektów nadklas (które
np.
mo¿e byæ zabronione) i na rekursywnym wo³aniu clone po polach
obiektowych
(co te¿ mo¿e byæ w ich klasach zabronione) oraz dodamy uci¹¿liw¹ i
nonsensown¹
koniecznoœc obs³ugi wyj¹tku CloneNotSupportedException, to ³atwo
dojdziemy
do wniosku, ¿e: <br>
<b><br>
</b><div class="important"><b>mechanizm klonowania w Javie
jest&nbsp; skomplikowany, Ÿle zdefiniowany i niespójny.</b></div><br>
<br>
<b>
Nie nale¿y zatem go u¿ywaæ</b> (byæ mo¿e za wyj¹tkiem zastosowania
dobrze zdefiniowanych,
ju¿ istniej¹cych w niektórych klasach, metod clone, np. dla tablic lub
dla
obiektów takich klas jak Date, Dimension, Rectangle, Vector).<br>
<br>
Alternatyw¹ jest budowanie w³asnych konstruktorów kopiuj¹cych lub
statycznych metod fabrycznych.<br>
<br>
<b><!----><a name="ind.4.10"></a>Konstruktor kopiuj¹cy</b> ma jako
parametr referencjê do obiektu swojej klasy i inicjuje nowotworzony
obiekt wartoœciami obiektu-argumentu<!---->.<br>
<br>
<div class="notel">Czasami metody fabryczne s¹ nazywane krótko <b>fabrykami
(factory)</b>, ale najczêœciej pojêcie <b>factory</b> stosowane jest
wobec klas, które dostarczaj¹ zestawu metod, z których ka¿da
fabrykuje (tworzy i inicjuje) obiekt innej klasy, ukrywaj¹c przed
u¿ytkownikiem
niektóre zawi³oœci u¿ycia konstruktorów tych klas (te klasy s¹ zwykle
logicznie
powi¹zane, np. poprzez&nbsp; implementacjê tego samego interfejsu).</div>
Statyczna
<!----><a name="ind.4.11"></a><b>metoda fabryczna</b> (<i><b>ang.
factory method</b></i>) tworzy i inicjuje nowy obiekt klasy oraz zwraca
referencjê do niego<!---->. Zwykle metody fabryczne maj¹ nazwê <b>getInstance</b>
, najczêsciej pozwalaj¹ zwracaæ - zale¿ne od parametru - obiekty
ró¿nych klas
(w szczególnoœci podklas jakiejœ klasy abstrakcyjnej lub klas
implementujacych
jakiœ interfejs). W naszym przypadku statyczna metoda fabryczna bêdzie
mia³a
jako parametr referencjê do obiektu orygina³u i bêdzie zwracaæ
referencjê
do obiektu-kopii.<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<div class="important">Metody fabryczne oraz fabryki - to wzorce
projektowe z zestawu 23 wzorców projektiowych GOF.</div><br>
Zobacz opis wzorca Factory w dalszych wyk³adach.<br>
&nbsp; &nbsp; <br>
<br>
<br>
Przyk³ad konstruktora kopiujacego i statycznej metody fabrycznej
pokazano na wydruku.<br>
<pre>class E  {

  private final int[] arr = {1, 2, 3};

  public E() { }

  <b>// statyczna metoda fabryczna</b>
  public static E getInstance(E orgObj) {
    // nowy obiekt
    E newInst = new E();
    // skopiowanie zawartoœci tablicy
    // - wugodna metoda arraycopy (zob. dokumentacje) &nbsp;
    System.arraycopy(orgObj.arr, 0, newInst.arr, 0, orgObj.arr.length);
    // zwrot wyniku &nbsp;
    return newInst;
  }

  <b>// konstruktor kopiuj¹cy</b>
  public E( E orgObj ) {
    for (int i=0; i&lt;orgObj.arr.length; i++) arr[i] = orgObj.arr[i];
  }

  public int[] get() { return arr; }
  public void set(int i, int val) { arr[i] = val; }

}

class Cloning5 {

  static void show(String nam, int[] arr) {
    System.out.println(nam);
    for (int i=0; i&lt;arr.length; i++) System.out.print(" " + arr[i]);
    System.out.println("");
  }

  public static void main(String[] args) {
    E x = new E();
    E x1 = new E(x);
    show("x", x.get());
    show("x1 - nowy obiekt kopia x" , x1.get());
    x.set(1, 10);
    show("x1 - g³êboka kopia, jest niezale¿nym obiektem!", x1.get());
    show("x jest teraz", x.get());
    E x2 = E.getInstance(x);
    x.set(2, 11);
    show("x2 - g³êboka kopia, jest niezale¿nym obiektem!", x2.get());
    show("a x jest teraz", x.get());
  }


}
</pre>Program wyprowadzi w³aœciwe (spodziewane) wyniki:<br>
<div class="listing100"><br>
x<br>
&nbsp;1 2 3<br>
x1 - nowy obiekt kopia x<br>
&nbsp;1 2 3<br>
x1 - g³êboka kopia, jest niezale¿nym obiektem!<br>
&nbsp;1 2 3<br>
x jest teraz<br>
&nbsp;1 10 3<br>
x2 - g³êboka kopia, jest niezale¿nym obiektem!<br>
&nbsp;1 10 3<br>
a x jest teraz<br>
&nbsp;1 10 11<br>
</div><br>
<br>
<b>
Warto te¿ podkreœliæ, ¿e argumenty konstruktorów kopiuj¹cych lub
kopiuj¹cych
statycznych metod fabrycznych mo¿emy formu³owaæ w kategoriach
interfejsów,
umo¿liwiaj¹c w ten sposób tworzenie obiektów naszej klasy,
zawieraj¹cych
dane z obiektów innej klasy w inny sposób implementuj¹cej podany
interfejs.<br>
<br>
Bardzo dobitnym przyk³adem tego jest JCF przyk³adowo konstruktory
klas implementuj¹cych
kolekcje (ArrayList, HashSet, TreeSet itp.), w których typem parametru
jest
Collection.</b><br>
<br>
No dobrze, ale co zrobiæ gdy chcemy uzyskaæ kopiê obiektu klasy,
która ani
nie implementuje metody klonowania, ani nie dostarcza konstruktora
kopiuj¹cego
czy fabrycznych metod &nbsp;kopiuj¹cych? Jest jeszcze jedno
rozwi¹zanie: <br>
<ul> <li>jeœli
klasa jest serializowalna, to mo¿na stworzyæ kopiê jej obiektu za
pomoc¹
serializacji i deserializacji (zapisu stanu obiektu do strumienia -
zwykle
pamiêciowego - z nastêpuj¹cym odczytaniem tego obiektu). </li> <li>jeœli
klasa spe³nia protokó³ Java Beans - to mo¿na u¿yæ XMLEncodera i
XMLDecodera na strumieniach pamiêciowych.</li>
</ul>Jeœli przyjrzymy siê jeszcze raz uwa¿nie ostatniemu kodowi
programu, to zauwa¿ymy
w klasie E metodê int[] get(), która zwraca referencjê do pola
deklaruj¹cego
tablicê liczb ca³kowitych. Jak wiemy, te tablice dla orygina³u i kopii
bêd¹
zawiera³y te same dane, ale&nbsp; bêd¹ ró¿nymi obiektami, dziêki czemu
zmiany
danych w kopii nie bêd¹ dotyczyæ zmian w oryginale i odwrotnie. <br>
Metoda get()
<b>eksponuje te tablice na zewn¹trz</b> klasy i przez to umo¿liwia
dokonywanie zmian
danych-elementów tablic spoza klasy E. Powstaje pytanie czy to dobrze?
A
przynajmniej - czy zawsze bêdzie to po¿¹dane, a jeœli nie - to jak
mo¿na
wykluczyæ tak¹ mo¿liwoœæ?<br>
<br>
<br>
<a name="Wzorce1.10"></a><h2>4.6. Niezmiennoœæ obiektów</h2> W Javie
(ale równie¿ w innych œrodowiskach
programowania obiektowego) bardzo wa¿n¹ rolê spe³nia koncepcja
niezmiennoœci
obiektów.<br>
<br>
<div class="def"><!----><a name="ind.4.12"></a>Obiekt jest
niezmienny (<i><b>ang. immutable</b></i>), jeœli po utworzeniu
obiektu jego stan, okreœlany przez elementy stanowi¹ce o treœci obiektu
w
kontekstach jego zewnêtrznego wykorzystania,&nbsp; nie mo¿e byæ
zmieniony<!----></div>
<br>
<br>
Oczywiœcie, nie zawsze bêdziemy chcieli, by obiekty naszych klas by³y
niezmienne.
Ale czêsto okazuje siê to u¿yteczne, a nawet niezbêdne.<br>
<br>
WyobraŸmy sobie np. ¿e mamy jakieœ pude³ka opisywane przez wymiary
oraz zawartoœæ.<br>
Wymiary (szerokoœæ, wysokoœæ) bêd¹ obiektami klasy Dimension:<br>
<br>
<pre>class Dimension {
  public int width;
  public int height;
  public Dimension(int w, int h) {
    width = w;
    height = h;
  }
}
</pre>
<br>
Pude³ka bêd¹ opisywane przez wymiary i &nbsp;opis zawartoœci:<br>
<br>
<pre>class Box {
  Dimension dim;
  String cont;

  public Box(Dimension d, String c) {
    dim = d;
    cont = c;
  }

  public void show() {
    System.out.println("Pude³ko: " + dim.width + "x" + dim.height +
                       " Zawartoœæ: " + cont);
  }
}
</pre>
<br>
Mo¿emy teraz utworzyæ jakiœ standardowy wymiar:<br>
<br>
Dimension d = new Dimension(50,50);<br>
<br>
i tworzyæ pude³ka na p³yty:<br>
<br>
Box b1 = new Box(d, "P³yty 1");<br>
Box b2 = new Box(d, "P³yty 2");<br>
...<br>
Box b10 = new Box(d, "P³yty 10");<br>
<br>
Nastêpnie przychodzi pora na pude³ko na ksi¹¿ki. Szerokoœæ pude³ka
na ksi¹¿ki
jest o 20 cm wiêksza. Niew¹tpliwie odczujemy nieprzepart¹ chêæ, by
zapisac
to w ten sposób:<br>
<br>
d.width += 20;<br>
Box bk = new Box(d, "Ksi¹¿ki");<br>
<br>
i - niestety - pope³nimy b³¹d, co pokazuje poni¿szy fragment
programu i wydruk jego dzia³ania:<br>
<pre>  public static void main(String[] args) {
    // Wymiary pude³ka na p³yty
    Dimension d = new Dimension(50, 50);
    // ... tworzymy pude³ka na p³yty
    // ...
    Box b10 = new Box(d, "P³yty 10");
    b10.show();
    // pude³ko na ksi¹¿ki bêdzie szersze o 20 cm
    d.width += 20;
    Box bk = new Box(d, "Ksi¹zki");
    bk.show();
    System.out.println("Co siê sta³o z pude³kiem na p³yty?");
    b10.show();
  }
</pre><div
 class="listing100">Pude³ko: 50x50 Zawartoœæ: P³yty 10<br>
Pude³ko: 70x50 Zawartoœæ: Ksi¹zki<br>
Co siê sta³o z pude³kiem na p³yty?<br>
Pude³ko: 70x50 Zawartoœæ: P³yty 10</div>
<br>
<br>
Pude³ka na p³yty (ju¿ po ich utworzeniu) zmieni³y swoje rozmiary! Sta³o
siê
tak dlatego, i¿ obiekt klasy Dimension nie jest niezmienny, a poniewa¿
stanowi
pole (element) obiektu klasy Box, to zmiana wymiaru d ( zwiêkszenie
szerokoœci
pude³ka) powoduje zmiany we wszystkich ju¿ utworzonych i
wykorzystuj¹cych
ten obiekt pude³kach.<br>
<br>
 Nasza klasa Dimension - przynajmniej w tym przyk³adzie, po to by
uniemo¿liwiæ
pope³nianie takich b³êdów - powinna byæ zatem niezmienna (<i><b>immutable</b></i>).
<br>
<br>
Ogólnie, aby klasa by³a niezmienna (co oznacza niezmiennoœæ jej
obiektów) musz¹ byæ spe³nione nastêpuj¹ce warunki:<br>
<ul> <li>klasa nie mo¿e byæ dziedziczona (gdy¿ poprzez
przedefiniowanie lub
dostarczenie nowych metod w podklasie moglibyœmy uczyniæ jej obiekty
zmiennymi); specyfikator <b>final</b> u¿yty w deklaracji klasy (np.
final public class Dimension) zabrania jej dziedziczenia,</li> <li>nieprywatne
pola klasy (jeœli s¹) powinny byæ finalne,</li> <li>obiektowe pola
klasy powinny byæ prywatne i niezmienne po ich pierwszej
efektywnej inicjacji (to ostatnie niekoniecznie oznacza, ¿e pola musz¹
byæ
finalne: np. w niezmiennej klasie String pola nie s¹ finalne, ale po
inicjacji,
która - jak np w przypadku pola hashcode jest efektywnie od³o¿ona do
momentu
u¿ycia metody hashCode() - nie s¹ zmieniane w klasie String i nie mog¹
byæ
zmienione z zewn¹trz),</li> <li>klasa nie powinna udostêpniaæ metod
uzyskiwania referencji do pól,
zawieraj¹cych odniesienia do obiektów, które nie s¹ niezmienne (np. do
tablic).</li>
</ul> Warto podkreœliæ, ¿e ostatnie wymaganie dotyczy równie¿ kodowania
konstruktora, a tak¿e niekoniecznie oznacza, ¿e klasa nie mo¿e
udostêpniaæ
danych dostêpnych poprzez pola obiektowe (np. ca³ej tablicy), tyle
tylko,
¿e takie udostêpnienie nie mo¿e umo¿liwiaæ zmian wartoœci tych danych w
obiekcie
klasy.<br>
<br>
Zobaczmy to na schemacie.<br>
<br>
<table style="background-color: rgb(228, 229, 224);" border="1"
 cellpadding="2" cellspacing="2" width="100%"> <tbody> <tr> <td
 valign="top"> <div align="center"><b>Niezmienna tablica - jak tworzyæ
klasy niezmienne?</b><br>
 </div> <br>
class Tablica { &nbsp;// powinno byæ: final class Tablica<br>
 <br>
&nbsp; private final int[] tab; &nbsp; // dobrze: pole prywatne i
finalne<br>
 <br>
&nbsp; // &nbsp;Nieprawid³owy sposób kodowania konstruktora<br>
&nbsp; // &nbsp;Po stworzeniu obiektu &nbsp;zewn¹trzne zmiany elementów
przekazanej&nbsp; tabArg<br>
&nbsp; // &nbsp;bêd¹ zmieniaæ elementy tab (czyli stan tego obiektu)<br>
<br>
&nbsp; public Tablica(int[] tabArg) {<br>
&nbsp;&nbsp;&nbsp; &nbsp;tab = tabArg;<br>
&nbsp; }<br>
 <br>
 <br>
&nbsp; // Prawid³owy sposób kodowania konstruktora<br>
&nbsp; // Tworzymy kopie (nowy obiekt) przekazanej tablicy<br>
&nbsp; // PóŸniejsze zmiany w tabArg nie bêd¹ mia³y wp³ywu na tab<br>
 <br>
&nbsp; public Tablica(int[] tabArg) {<br>
&nbsp;&nbsp;&nbsp; tablica = (int[]) tabArg.clone();<br>
&nbsp; }<br>
 <br>
 <br>
&nbsp; // Nieprawid³owy sposób kodowania - udostêpnia na zewn¹trz
referencjê do tablicy<br>
&nbsp; // Jej elementy mog¹ byæ zewnêtrznie zmieniane<br>
 <br>
&nbsp; public int[] getTab()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
return tab; }<br>
 <br>
 <br>
&nbsp; // Prawid³owy sposób kodowania<br>
&nbsp; // --- nie udostêpniamy referencji do tablicy<br>
 <br>
&nbsp; public int getTab(int n)&nbsp; { return tab[n]; }<br>
 <br>
&nbsp; // Jeœli chcemy udostêpniæ ca³¹ tablicê<br>
&nbsp; // --- skopiujmy j¹, by nikt nie mógl zmieniæ elementów orygina³u<br>
<br>
&nbsp; public int[] getTab()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
return (int[]) tab.clone(); }<br>
 <br>
}<br>
 <br>
Uwaga: bardzo czêsto w sytuacjach takich jak przedstawiona wy¿ej klasa
Tablica
bêdziemy chcieli zachowaæ zewnêtrzn¹ niezmiennoœæ obiektów, daj¹c
jednoczeœnie
u¿ytkownikowi&nbsp; mo¿liwoœæ dokonywania zmian wy³¹cznie za pomoc¹
metod naszej
klasy. W tym przypadku - wszystkie przedstawione na schemacie regu³y
dalej
maj¹&nbsp; zastosowanie, ale dodatkowo udostêpniamy metodê zmiany
elementów tablicy
np. void set(int indeks, int wartoœæ)).<br>
 </td> </tr> </tbody>
</table><br>
<br>
<u><b>
Niezmiennoœæ obiektów pozwala na:</b></u><br>
<ul> <li>unikanie b³êdów przy przekazywaniu argumentów (np. jeœli
przekazujemy argument
typu String, to mamy pewnoœæ, ¿e metoda nie zmieni przekazanego napisu,
bo
klasa String jest niezmienna),</li> <li>
bezproblemowe wspó³dzielenie obiektów w programach wielow¹tkowych
(poniewa¿
niezmiennoœæ obiektów wyklucza mo¿liwoœci powstawania niespójnych
stanów,
gdy na obiekcie operuje kilka w¹tków jednoczeœnie, zatem unikamy
narzutu synchronizacji ), </li> <li>
spójne&nbsp; przechowywanie referencji w strukturach danych (np. klucze
w tablicach
asocjacyjnych - mapach (takich jak np. Hashtable) powinny byæ obiektami
niezmiennymi,
bowiem zmiana klucza po zapisaniu go do tablicy prowadzi do
niespójnoœci danych,</li>
</ul><br>
<hr style="width: 100%; height: 2px;"><a name="Wzorce1.11"></a><h2>5. Wzorce GoF - klasyfikacja</h2>
W ksi¹¿ce&nbsp;“Design Patterns: Abstraction and Reuse of Object
Oriented-Design” opisano trzy klasy wzorców projektowych:<br>
<br>
<u><!----><a name="ind.5.2"></a>konstrukcyjne</u>:<br>
tworzenie obiektów, w tym: delegowanie procesu tworzenia do innych klas
(wa¿ne
ze wzglêdu na zmniejszanie wspó³zaleznoœci w kodzie), kontrola nad
sposobem
tworzenia obiektów<!----><br>
<br>
<u><!----><a name="ind.5.3"></a>strukturalne:</u><br>
zarz¹dzanie struktur¹ obiektów i strukturami z³o¿onymi z obiektów<!----><br>
<br>
<u><!----><a name="ind.5.4"></a>behawioralne:</u><br>
zachowanie obiektów i komunikacja miêdzy nimi<!----><br>
<br>
S¹ to:<br>
<ul> <li>Wzorce konstrukcyjne<br>
 <ul> <li>Factory</li> <li>Factory
method</li> <li>Abstract factory</li> <li>Singleton</li> <li>Builder</li>
<li>Prototype</li> </ul> </li> <li>Wzorce strukturalne<br>
 <ul> <li>Adapter</li>
<li>Bridge</li> <li>Composite</li> <li>Decorator</li> <li>Facade</li>
<li>Flyweight</li> <li>Proxy</li> </ul> </li> <li>Wzorce
&nbsp;behawioralne<br>
 <ul> <li>Chain of responsibility</li> <li>Command</li>
<li>Interpreter</li> <li>Iterator</li> <li>Mediator</li> <li>Memento</li>
<li>Observer</li> <li>State</li> <li>Strategy</li> <li>Template</li>
<li>Visitor</li> </ul> </li>
</ul><br>
W poni¿szej tabeli pokazano zastosowania poszczególnych wzorców.<br>
<br>
<table border="1" cellpadding="3" cellspacing="0"> <tbody> <tr> <th>Nazwa
wzorca</th> <th align="center">Kategoria</th> <th align="center">Zastosowanie</th>
<th align="center">Czêsto u¿ywane z</th> <th align="center">Pokrewne do</th>
</tr>
<!-- Frequently used patterns have a lime background --><tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Abstract
Factory</td> <td style="background-color: rgb(215, 220, 233);"
 bgcolor="#ffffcc">Konstrukcyjne</td> <td>Uzyskiwanie instancji</td> <td>Factory
Method<br>
Prototype<br>
Singleton + Facade</td> <td>Factory Method<br>
Prototype<br>
Singleton</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Adapter</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strukturalne</td>
<td>Dostosowanie interfejsu</td> <td align="center">-</td> <td>Bridge<br>
Decorator<br>
Proxy</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Command</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Separowanie akcji<br>
 </td> <td>Composite</td> <td>Composite<br>
Memento<br>
Prototype</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Composite</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strukturalne</td>
<td>Strukturalna kompozycja/dekompozycja obiektów-systemów</td> <td
 align="center">-</td> <td>Decorator<br>
Iterator<br>
Visitor</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Decorator</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strukturalne</td>
<td>³atwe uzupe³nianie o dodatkowe w³aœciwoœci/ funkcjonalnoœæ<br>
 </td>
<td align="center">-</td> <td>Object Adapter<br>
Composite<br>
Strategy</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Facade</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strukturalne</td>
<td>U³atwienia dostêpu</td> <td>Singleton Abstract Factory</td> <td>Abstract
Factory<br>
Mediator</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Flyweight</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strukturalne</td>
<td>Wspó³dzielenie zasobów = ograniczanie wymagañ pamiêciowych<br>
 </td>
<td align="center">-</td> <td>Singleton<br>
State<br>
Strategy<br>
 Shareable</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Iterator</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Nawigacja<br>
 <br>
 </td> <td align="center">-</td> <td>Composite<br>
Factory Method<br>
Memento</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Observer</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td><br>
Komunikacja, uniezale¿nienie fragmentów kodu<br>
 <br>
 </td> <td
 align="center">-</td> <td>Mediator<br>
Singleton</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Proxy</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strukturalne</td>
<td>Kontrolowanie dostêpu<br>
 </td> <td align="center">-</td> <td>Adapter<br>
Decorator</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Singleton</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Konstrukcyjne</td>
<td>Kontrolowanie dostêpu</td> <td align="center">-</td> <td>Abstract
Factory<br>
Builder<br>
Prototype</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">State</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Zmiany stanów obiektu<br>
 </td> <td>Flyweight</td> <td>Flyweight<br>
Singleton</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strategy</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Implementacja algorytmu</td> <td align="center">-</td> <td>Flyweight<br>
State<br>
Template Method</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Template
Method</td> <td style="background-color: rgb(215, 220, 233);"
 bgcolor="#ffffcc">Behawioralne</td> <td>Implementacja algorytmu<br>
 </td>
<td align="center">-</td> <td>Strategy</td> </tr>
<!-- Moderately use patterns have a yellow background --><tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Bridge</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Strukturalne</td>
<td>Implementacja</td> <td align="center">-</td> <td>Abstract Factory<br>
Class Adaptor</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Builder</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Konstrukcyjne</td>
<td>Tworzenie struktur</td> <td align="center">-</td> <td>Abstract
Factory<br>
Composite</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Chain
of Responsibility</td> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Organizacja przep³ywu zadañ</td> <td align="center">-</td> <td>Composite</td>
</tr> <tr> <td style="background-color: rgb(215, 220, 233);"
 bgcolor="#ffffcc">Factory Method</td> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Konstrukcyjne</td>
<td>Tworzenie obiektów</td> <td>Template Method</td> <td>Abstract
Factory<br>
Template Method<br>
Prototype</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Mediator</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Interakcja miêdzy obiektami<br>
 </td> <td align="center">-</td> <td>Facade<br>
Observer</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Prototype</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Konstrukcyjne</td>
<td>Tworzenie obiektów</td> <td align="center">-</td> <td>Prototype<br>
Composite<br>
Decorator</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Visitor</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>"Double-dispatching" (zob. nastêpne wyk³ady)<br>
 </td> <td
 align="center">Composite<br>
 </td> <td>Composite<br>
Visitor</td> </tr>
<!-- Seldom used patterns have a red background --><tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Interpreter</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Organizacja zadañ<br>
 </td> <td align="center">-</td> <td>Composite<br>
Flyweight<br>
Iterator<br>
Visitor</td> </tr> <tr> <td
 style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Memento</td>
<td style="background-color: rgb(215, 220, 233);" bgcolor="#ffffcc">Behawioralne</td>
<td>Zarz¹dzanie obiektami</td> <td align="center">-</td> <td>Command<br>
Iterator</td> </tr> </tbody>
</table>¯ród³o: na podstawie <strong></strong>David Corner wg GoF i
Craig Larman,&nbsp; ObjectSpace
<br>
<hr style="width: 100%; height: 2px;"><br>
</body></html>