<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="Uniwersalne techniki programowania">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2010">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Java i bazy danych (JDBC)</title>
</head>
<body>
<br>
<br>
<div align="Center">
<h1>Java i bazy danych (JDBC)</h1>
</div>
<br>

</div>
<hr>
<span style="font-style: italic;">Java jest doskona≥ym úrodowiskiem programowania dostÍpu do baz danych.
Przyjrzymy siÍ wiÍc mechanizmom umoøliwiajπcym pisanie takich programÛw.</span><i> </i>
<hr>

<a name="PrgBd.1"></a><h2>1. Przyk≥adowa baza danych</h2>

<br>
Schemat przyk≥adowej bazy danych ksiπøek (moøe czÍúÊ BD ksiÍgarni internetowej) przedstawia poniøszy rysunek.<br>
<br>
<img src="images/bd1.jpg" alt="r" border="1" height="207" width="630">
<br>
<br>
Baza sk≥ada siÍ z trzech powiπzanych tabel (AUTOR, POZYCJE, WYDAWCA). Pola
ID (identyfikatory) sπ kluczami g≥Ûwnymi w tabelach AUTOR i WYDAWCA,
w tabeli POZYCJE odnoszπ sie do nich klucze zewnÍtrzne (obce) AUTID i WYDID. Pole
ISBN jest kluczem g≥ownym tabeli POZYCJE. Podobnej bazy bÍdziemy uøywac
w przyk≥adowych programach tego rozdzia≥u.<br>
<br>
Poniøej przedstawiono plik wsadowy z instrukcjami dla MySQL, ktÛre tworzπ
przyk≥πdowπ bazÍ. Na tej podstawie moøna siÍ zorientowaÊ jak ta baza wyglπda.<br>
<br>
<pre>create database if not exists ksidb;
use ksidb;
drop table if exists AUTOR; 
drop table if exists WYDAWCA; 
drop table if exists POZYCJE;

create table AUTOR (
        AUTID integer not null AUTO_INCREMENT,
        NAME varchar(255) not null,
        PRIMARY KEY(AUTID)
        ) ENGINE=INNODB;

create table WYDAWCA (
        WYDID integer not null AUTO_INCREMENT,
        NAME varchar(255) not null,
        PRIMARY KEY(WYDID)
        ) ENGINE=INNODB;



load data infile '../BazySql/ksidb/AUTOR.TXT' replace into table AUTOR;
load data infile '../BazySql/ksidb/WYDAWCA.TXT' replace into table WYDAWCA;

create table POZYCJE (
        ISBN char(13) not null,
        AUTID integer not null,
        TYTUL varchar(255) not null,
        WYDID integer not null,
        ROK integer not null,
        CENA real,
        PRIMARY KEY(ISBN),

        INDEX(AUTID),
        FOREIGN KEY(AUTID) REFERENCES AUTOR(AUTID),

        INDEX(WYDID),
        FOREIGN KEY(WYDID) REFERENCES WYDAWCA(WYDID)


        ) ENGINE=INNODB;

load data infile '../BazySql/ksidb/POZYCJE.TXT' replace into table POZYCJE;
</pre>
<br>
Podobny skrypt dla Derby w trybie Embedded ( uruchamianu przez <span style="font-weight: bold; font-style: italic;">ij &nbsp;nazwa_skryptu</span>)<br><br>
<pre>connect 'jdbc:derby:ksidb;create=true';

drop table POZYCJE;
drop table AUTOR;
drop table WYDAWCA;


create table AUTOR (
        AUTID integer not null generated by default as identity,
        NAME varchar(255) not null,
        PRIMARY KEY(AUTID)
        );

create table WYDAWCA (
        WYDID integer not null generated by default as identity,
        NAME varchar(255) not null,
        PRIMARY KEY(WYDID)
        );


CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'AUTOR','AUTOR.TXT',null,null,null,0);
CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'WYDAWCA','WYDAWCA.TXT',null,null,null,0);

create table POZYCJE (
        ISBN char(13) not null,
        AUTID integer not null,
        TYTUL varchar(255) not null,
        WYDID integer not null,
        ROK integer not null,
        CENA real,
        PRIMARY KEY(ISBN),
        FOREIGN KEY(AUTID) REFERENCES AUTOR(AUTID),
        FOREIGN KEY(WYDID) REFERENCES WYDAWCA(WYDID)
        );

CALL SYSCS_UTIL.SYSCS_IMPORT_TABLE (null,'POZYCJE','POZYCJE.TXT',null,null,null,0);
</pre>
<br>

<a name="PrgBd.2"></a><h2>2. Dlaczego Java?</h2>

<br>
Zazwyczaj "powaøne" RDBMS nie dostarczajπ gotowych (zadowalajπcych) rozwiπzaÒ&nbsp;
w zakresie graficznych interfejsÛw dostÍpu do&nbsp; baz danych lub nieco bardziej
zaawansowanych úrodkÛw przetwarzania danych na styku klient ñ serwer bazodanowy.<br>
<br>
Zamiast tego udostÍpniane sπ programistyczne interfejsy (API), dziÍki ktÛrym moøna takie problemy rozwiπzywaÊ.<br>
Kaødy RDBMS ma zdefiniowane dla rÛønych jÍzykÛw programowania odpowiednie
interfejsy programistyczne dostÍpu do BD (C, C++, Cobol, PL/I etc; nie wspomnÍ
juø o Visual Basicu czy jÍzykach specyficznych dla danego RDBMS).<br>
<br>
Sπ to jednak biblioteki dynamiczne, skompilowane (i zlinkowane) dla konkretnych
platform sprzÍtowych i systemowych. Kaøde takie API rÛøni siÍ w teø w zaleønoúci
od RDBMS.<br>
<br>
<b>Programistyczny interfejs dostÍpu do baz danych z poziomu Javy <br>
JDBC (Java Database Connectivity API):<br>
</b>
<ul>
  <li>jest niezaleøny od maszyny bazodanowej (RDBMS)</li>
  <li>jest niezaleøny od platformy sprzÍtowej</li>
  <li>jest niezaleøny od systemu operacyjnego</li>
</ul>
Jest zatem jednolity i uniwersalny, a do tego ≥atwy w uøyciu i aktualny (np.
umoøliwia dzia≥ania, wykorzystujπce nowe konstrukcje SQL ñ przewijalne tabele
wynikowe czy typy danych SQL3 ñ oraz programowanie z uwzglÍdnieniem wymagaÒ
úrodowisk rozproszonych).<br>
<br>
<div class="notec">Wszystko co chcielibyúmy robiÊ z dowolnymi relacyjnymi bazami danych z
poziomu programÛw uøytkowych ñ moøemy zrobiÊ w Javie, w jej duchu i konwencji,
majπc jednoczeúnie do dyspozycji przebogate úrodowisko Javy.<br>
<br>
Znajπc JavÍ moøemy szybko i ≥atwo tworzyÊ aplikacje bazodanowe, ktÛre wykraczajπ
poza samπ interakcjÍ z RDBMS i mogπ w≥πczaÊ wszystko co Java ma do zaoferowania
(programowanie sieciowe, rozproszone, multimedialne itp.) </div><br>
<br>

<a name="PrgBd.3"></a><h2>3. JDBC</h2>

JDBC&nbsp; jest zestawem klas i interfejsÛw, umoøliwiajπcych:<br>
<ol>
  <li>Po≥πczenie z bazπ danych</li>
  <li>Wykonywanie instrukcji SQL na bazie danych</li>
  <li>Otrzymywanie i przetwarzanie wynikÛw instrukcji SQL (np. tabel wynikowych)</li>
</ol>
&nbsp;<br>
Wersja JDBC 1.0 dostarcza podstawowych úrodkÛw dzia≥ania na BD.<br>
Wersje JDBC 2.0 i - aktualna JDBC 4.0 dajπ dodatkowe moøliwoúci&nbsp; np. <br>
<ul>
  <li>przewijalne i modyfikowalne tabele wynikowe, </li>
  <li>bezpoúrednie modyfikowanie tabel wynikowych za pomoc metod klasy Statement</li>
  <li>wsadowe przetwarzanie instrukcji SQL</li>
  <li>obs≥ugÍ typÛw danych SQL3</li>
  <li>wspomaganie&nbsp; JNDI (Java Naming and Directory Services) ñ czyli moøliwoúÊ
katalogowania i prowadzenia nazw ürÛde≥ danych na poziomie logicznym (podobnie
jak to jest w hierarchicznym systemie plikowym)&nbsp; </li>
  <li>pooling po≥πczeÒ (przechowywanie puli po≥πczeÒ w pamiÍci w celu ew. ponownego uøycia i przyspieszenia transakcji)</li>
  <li>transakcje rozproszone (przesy≥anie danych w sieci do takich klientÛw jak np. przeglπdarki lub laptopy)</li>
  <li>dostÍp do praktycznie kaødej formy tabularyzowanych danych (w tym arkuszy kalkulacyjnych i zwyk≥ych plikÛw),</li><li>obs≥ugÍ typu XML.</li>
</ul>
JDBC pozwala na dzia≥anie w architekturze dwu- i trzy-warstwowej.<br>
<br>
Architektura dwuwarstwowa<br>
<br>
<img src="images/arch1.jpg" alt="r" border="1" height="239" width="526">
<br>
<br>
èrÛd≥o: JDBC User's Guide. Javasoft<br>
<br>
Architektura trzywarstwowa<br>
<br>
<img src="images/arch2.jpg" alt="r" border="1" height="387" width="607">
<br>
<br>
èrÛd≥o: JDBC User's Guide. Javasoft<br>
<br>
<div class="important">Zalety warstwy poúredniej: efektywnoúÊ, kontrola, bezpieczeÒstwo, u≥atwienie
utrzymywania i rozwoju systemu, moøliwoúci integracji z innymi podsystemami
(middleware).</div><br>
<br>
<br>

<a name="PrgBd.4"></a><h2>4. Sterowniki JDBC</h2>

Aby po≥πczyÊ siÍ z bazπ danych i mÛc wykonywaÊ na niej operacje naleøy skorzystaÊ
ze specjalnego sterownika, ktÛry t≥umaczy odwo≥ania z poziomu Javy na odwo≥ania
w≥aúciwe dla danego RDBMS.<br>
<br>
Istniejπ 4 typy sterownikÛw.<br>
<br>
<p style="margin-bottom: 0cm;"><br>
</p>
<table border="1" bordercolor="#000000" cellpadding="1" cellspacing="0" width="553">
<col width="181"><col width="196"><col width="167"><tbody><tr valign="top"><td width="181"><p style="page-break-after: avoid;">Typ sterownika</p></td><td width="196"><p>Wyjaúnienia</p></td><td width="167"><p>Zastosowanie</p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;">1 - JDBC-ODBC
			bridge </p><p style="margin-bottom: 0cm;">+
			sterownik ODBC </p><p style="margin-bottom: 0cm;"><br>
</p><p><br>
</p></td><td width="196"><p style="margin-bottom: 0cm;">DostÍp
			do BD przez ODBC.</p><p style="margin-bottom: 0cm;">JDBC-ODBC
			bridge komunikuje siÍ ze sterownikiem ODBC a ten z bazπ danych.</p><p>Natywny kod
			ODBC musi byÊ za≥adowany po stronie klienta.</p></td><td width="167"><p style="margin-bottom: 0cm;">Wszelkie BD spe≥niajπce
			protokÛ≥ ODBC.</p><p>Kiedy nie
			ma problemÛw z ≥adowaniem natywnego kodu po stronie klienta
			</p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;">2 -
			Native-API</p><p style="margin-bottom: 0cm;">
			    partly-Java driver</p><p><br>
</p></td><td width="196"><p>Sterownik
			JDBC t≥umaczy odwo≥ania na natywny kod konkretnego API klienta
			danego RDBMS.</p></td><td width="167"><p>Sterowniki
			sπ specyficzne dla RDBMS dostarczane przez firmy  np.
			Oracle, Sybase, IBM DB2 (UDB) etc. </p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;">3 - JDBC-Net </p><p style="margin-bottom: 0cm;">
			     pure Java driver</p><p><br>
</p></td><td width="196"><p>Tylko
			kod javowy. Odwo≥ania t≥umaczone sπ na uniwersalny, niezaleøny od
			RDBMS, protokÛ≥ sieciowy, a nastÍpnie przez serwer na kody
			specyficzne dla RDBMS . </p></td><td width="167"><p>Najbardziej
			elastyczne rozwiπzanie, ale  w przypadku uøycia w Internecie
			wymaga, by sterownik/serwer zapewnia≥y odpowiedni poziom
			bezpieczeÒstwa </p></td></tr><tr valign="top"><td width="181"><p style="margin-bottom: 0cm;">4 - Native-protocol
			</p><p style="margin-bottom: 0cm;">
			    pure Java driver</p><p><br>
</p></td><td width="196"><p style="margin-bottom: 0cm;">Tylko kod javowy.</p><p>Sterownik
			t≥umaczy odwo≥ania na specyficzny dla danego RDBMS protokÛ≥
			sieciowy</p></td><td width="167"><p style="margin-bottom: 0cm;">Pozwala
			na b. efektywnπ, bo bezpoúredniπ komunikacjÍ klient-serwer
			bazodanowy. Doskona≥e w intranecie.</p><p style="margin-bottom: 0cm;">G≥Ûwnym
			ürÛd≥em sπ producenci RDBMS np. Oracle, Sybase, Informix,
			IBM DB2, Inprise InterBase, Microsoft SQL Server</p><p><br>
</p></td></tr></tbody>
</table>
<br>
<br>

<a name="PrgBd.5"></a><h2>5. £πczenie z bazπ danych</h2>

<br>
Po≥πczenie z bazπ danych wymaga dwÛch krokÛw:<br>
<ul>
  <li>za≥adowania sterownika JDBC,</li>
  <li>zaøπdania od sterownika&nbsp; po≥πczenia i ew. uzyskania go w postaci obiektu typu Connection.</li>
</ul>
Za≥adowanie sterownika odbywa siÍ za pomocπ wywo≥ania statycznej metody klasy
Class o nazwie forName i z argumentem ñ nazwa klasy (sterownika). OgÛlnie
metoda ta zwraca obiekt-klasÍ o podanej nazwie. Jeúli klasa ta nie jest za≥adowana
do JVM, nastÍpuje jej za≥adowanie. Klasy-sterowniki sπ tak napisane, øe przy
ich ≥adowaniu rejestrujπ siÍ jako obiekty typu Driver. <br>
Zwykle obiekt ten (klasa) nie interesuje nas (dlatego w wywo≥aniu pomijamy zwracany rezultat).&nbsp; <br>
<br>
Przyk≥ady:<br>
<br>
&nbsp; Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");<br>
&nbsp; Class.forName("postgresql.Driver"); <br>
&nbsp; Class.forName("oracle.jdbc.driver.OracleDriver");<br>
&nbsp; Class.forName("com.mysql.jdbc.Driver");<br>
<br>
<br>
Nad za≥adowanymi sterownikami kontrolÍ sprawuje DriverManager (nazwa klasy).<br>
Prowadzi on listÍ zarejestrowanych sterownikÛw.<br>
Statyczna metoda <b>getConnection</b> z klasy DriverManager pozwala na uzyskanie po≥πczenia z bazπ, ktÛrej URL podajemy jako argument metody.<br>
DriverManager przeglπda listÍ zarejestrowanych sterownikÛw i wybiera ten, ktÛry moøe po≥πczyÊ siÍ z podanπ bazπ.<br>
Po po≥πczeniu z bazπ&nbsp; zwracany jest obiekt typu Connection, ktÛry reprezentuje po≥πczenie.<br>
<br>
<div class="syntax"><br>
<b>Connection con = DriverManager.getConnection(dbUrl, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
userID, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
password);</b><br>
<br>
lub (jeúli dopuszczalne jest "domyúlne" po≥πczenie ñ bez podania nazwy uøytkownika i has≥a)<br>
<br>
<b>Connection con = DriverManager.getConnection(dbUrl);</b><br>
<br>
Wszystkie argumenty metody getConnection sπ typu String.<br>
<br>
Forma lokatorÛw (urli) zaleøna jest od sterownika i konkretnej bazy danych np.<br>
<br>
// ürÛd≥o danych ODBC o nazwie ksidb<br>
String dbUrl = "jdbc:odbc:ksidb" <br>
<br>
// ≥πczenie z Oraclem z dodatkowymi specyfikacjami<br>
String dbUrl = "jdbc:oracle:thin:user/password@( description=(address_list=(
address=(protocol=tcp) (host=dbmachine)(port=1521)))(source_route=yes) (connect_data=(sid=ksidb)))";<br>
<br>
// MySQL:<br>
<b>String dbUrl = "jdbc:mysql://localhost/ksidb";</b><br>
</div><br>
<br>
<br>
Uwaga: klasa sterownika powinna byÊ dostÍpna dla odwolaÒ z naszego programu.
Odpowiedni JAR moøna np. umieúciÊ w katalogu jre/lib/ext.<br>
<br>
<br>
W trakcie ≥adowania klasy sterownika i przy prÛbie po≥πczenia mogπ powstaÊ wyjπtki, ktÛre musimy obs≥uøyÊ. <br>
<br>
<pre>....
 String driverName = <b>"com.mysql.jdbc.Driver"</b>;
 String url = "<b>jdbc:mysql://localhost/ksidb</b>";
 String uid = "jakis";
 String pwd = "haslo";
 Connection con;

 try {
     Class.forName(driverName);
     con = DriverManager.getConnection(url, uid, pwd);
    } catch (ClassNotFoundException  exc)  {  // brak klasy sterownika
        System.out.println("Brak klasy sterownika");
        System.out.println(exc);
        System.exit(1);
    } catch(SQLException exc) {  // nieudane po≥πczenie
       System.out.println("Nieudane po≥πczenie z " + url);
       System.out.println(exc);
       System.exit(1);
}

.....

</pre>
<br>
Moøemy teø przechwyciÊ oba wyjπtki w jednej klauzuli catch(Exception exc) ...<br>
<br>
Innym sposobem uzyskania po≥aczenie jest wykorzystaie serwisÛw JNDI oraz
tzw. ürÛde≥ danych - zapoznamy sie z nim w rozdziale "Aplikacje WEB".<br><br><br>
Sterowniki
spe≥niajπce specyfikacjÍ JDBC 4.0 (jeúli odpowiednie JARy spe≥niajπ
protokÛl Service Provider) mogπ byÊ odnajdywane bez jawnego za≥adowania
klasy.<br>
Np. jeúli nasza aplikacja ma dostÍp do pliku derby.jar (jest
na úcieøce dostÍpu klas), to uzyskaÊ po≥aczenie moøemy &nbsp;proúciej:<br><br>
<pre>Connection con = DriverManager.getConnection("jdbc:derby:ksidb"); </pre>
Dzieje siÍ tak dlatego, øe w&nbsp;derby.jar w katalogu
META-INF/services znajduje siÍ plik java.sql.Driver, zawierajπcy nazwÍ
klasy sterowanika.<br><br>
Przy tej okazji - parÍ s≥Ûw o Derby.<br>
Derby jest &nbsp;niewielkim i wygodnym w uøyciu SZBD, ca≥kowicie napisanym w Javie, dostarczanym w dystrybucji Javy 6.<br>
Moøe dzia≥aÊ w dwÛch trybach:<br>
<ul><li>embedded - SZBD dzia≥a w tej samej maszynie wirtualnej co nasza aplikacja i nie wymaga dzia≥ania serwera,</li><li>klient-serwer (wymaga startu serwera Derby)</li></ul><br>
Bardzo waønπ kwestiπ jest ustalenie systemowej w≥aúciwoúci Javy <span style="font-weight: bold; font-style: italic;">derby.system.home</span>,
wskazujπcej na katalog, w ktÛrym zajdujπ siÍ bazy danych. Jesli tej
w≥aúciwoúci nie ustalimy, to zostanie przyjÍty bieøπcy katalog lub
katalog podany bezpoúrednio przy specyfikacji URLa bazy danych.<br>
W≥aúciwoúÊ derby.system.home moøemy okreúliÊ&nbsp; podajπc opcjÍ <span style="font-weight: bold;">-Dderby.system.home=<span style="font-style: italic;">nazwa_katalogu</span></span> przy starcie JVM (czy to nazej aplikacji, czy serwera Derby czy teø CLI, ktÛry w Derby nazywa siÍ <span style="font-weight: bold;">ij</span>.<br><br>
Za≥Ûømy, øe:<br>
JAVA_HOME wskazuje na katalog instalacyjny Javy i katalog %JAVA_HOME%/bin jest naúcieøce PATH<br>
DERBY_HOME - katalog instalacyjny Derby,<br>
DERBY_JARS
- zawiera nazwy niezbÍdnych bibliotek JAR z
katalogu&nbsp;%DERBY_HOME%/lib, w szczegÛlnoúci: (rozdzielone
srednikami):<br>
%DERBY_HOME%/lib/derby.jar<br>
%DERBY_HOME%/lib/derbynet.jar<br>
%DERBY_HOME%/lib/derbyclient.jar<br>
%DERBY_HOME%/lib/derbytools.jar <br><br><br>
Start CLI w trybie embedded &nbsp;ze skryptem tworzπcym bazÍ danych ksidb w katalogu D:\DerbyDbs<br>
<pre>java -Dderby.system.home=D:/DerbyDbs -cp "%DERBY_JARS" -Dij.protocol=jdbc:derby: 
org.apache.derby.tools.ij <span style="font-style: italic;">nazwa_skryptu</span></pre><br>
Start aplikacji App w trybie embedded &nbsp;Derby (dostÍp do bd ksidb umieszczonej w katalogu D:\DerbyDbs):<br>
<pre>java -Dderby.system.home=D:/DerbyDbs -cp %DERBY_HOME%/derby.jar App

// dostÍp do ksidb w programie:
Connection con = DriverManager.getConnection("jdbc:derby:ksidb");</pre><br>
Start serwera Derby (z ustaleniem derby.system.home):<br>
<pre>java -Dderby.system.home=D:/DerbyDbs -cp "%DERBY_JARS" org.apache.derby.drda.NetworkServerControl start</pre><br>
DostÍp do bazy danych za pomocπ protoko≥u sieciowego (po starcie serwera):<br>
<pre>  String driverName = "org.apache.derby.jdbc.ClientDriver";
  String url = "jdbc:derby://localhost/ksidb";
  try {
      Class.forName(driverName).newInstance();
      Connection con = DriverManager.getConnection(url);
      // ...
  }

lub jeúli dostÍpnym JARem jest tylko derbyclient.jar:

try {&nbsp;
     Connection con = DriverManager.getConnection(jdbc:derby://localhost/ksidb);
// ...
}</pre>DostÍp
w trybie embedded do bazy danych&nbsp; umieszczonej w katalogu
D:\DerbyDbs (niezaleønie od tego czy w≥aúciwoúÊ derby.system.home
zosta≥a ustalona &nbsp;czy nie):<br>
<pre>Connection con = DriverManager.getConnection(jdbc:derby:D:/DerbyDbs/ksidb);</pre><br>
Po uzyskaniu po≥πczenia otrzymany obiekt Connection wykorzystujemy do operacji
na bazie danych za poúrednictwem innych obiektÛw, ktÛry uzyskamy od obiektu
Connection.<br>
Pokazuje to poniøszy rysunek.<br>
<br>
<img src="images/schemat1.jpg" alt="r" border="1" height="311" width="553">
<br>
<br>
Po zakoÒczeniu operacji
na bazie danych warto zwolniÊ uzyskane zasoby (takie jak Statement) oraz&nbsp;
po≥πczenie, wywo≥ujπc odpowiednie&nbsp; metody close() na rzecz obiektÛw reprezentujπcych
zasoby/ po≥πczenie.<br>
Nie zawsze jest to obowiπzkowe, bo zwykle zasoby sπ zwalniane automatycznie
przy zakoÒczeniu programu, ale naleøy do dobrej praktyki programistycznej,
mogπ siÍ bowiem zdarzyÊ takie sytuacje, kiedy zasoby nie zostanπ automatycznie
zwolnione.
<br>
<p style="margin-bottom: 0cm;"></p>
<br>

<a name="PrgBd.6"></a><h2>6. Uzyskiwanie metainformacji o bazie danych (przyk≥ad)</h2>

<br>
<pre> Connection con;
<b> DatabaseMetaData md;  // metadane</b>

 // ... uzyskane po≥πczenie
// reprezentuje obiekt con

// uzyskanie metadanych
<b> md = con.getMetaData();  </b>

 // odpytywanie metadanych o rÛøne
 // informacje
 md.getDatabaseProductName();
 md.getDatabaseProductVersion();
 md.getDriverName();
 md.getURL();
 md.getUserName();
 md.supportsAlterTableWithAddColumn();
 md.supportsAlterTableWithDropColumn();
 md.supportsANSI92FullSQL();
 md.supportsBatchUpdates();
 md.supportsMixedCaseIdentifiers();
 md.supportsMultipleTransactions();
 md.supportsPositionedDelete();
 md.supportsPositionedUpdate();
 md.supportsSchemasInDataManipulation();
 md.supportsTransactions();
 md.supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
 md.supportsResultSetType(ResultSet.TYPE_SCROLL_SENSITIVE);
 md.insertsAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE);
 md.updatesAreDetected(ResultSet.TYPE_SCROLL_INSENSITIVE);

</pre>
Przyk≥adowe wyniki:<br>
<div class="listing100"><br>
DatabaseProductName: ACCESS<br>
DatabaseProductVersion: 3.5 Jet<br>
DriverName: JDBC-ODBC Bridge (ODBCJT32.DLL)<br>
URL: jdbc:odbc:ksidb<br>
UserName: admin<br>
supportsAlterTableWithAddColumn: true<br>
supportsAlterTableWithDropColumn: true<br>
supportsANSI92FullSQL: false<br>
supportsBatchUpdates: true<br>
supportsMixedCaseIdentifiers: true<br>
supportsMultipleTransactions: true<br>
supportsPositionedDelete: false<br>
supportsPositionedUpdate: false<br>
supportsSchemasInDataManipulation: false<br>
supportsTransactions: true<br>
ResultSet&nbsp; TYPE_SCROLL_INSENSITIVE :true<br>
ResultSet&nbsp; TYPE_SCROLL_SENSITIVE :false<br>
insertsAreDetected :false<br>
updatesAreDetected :false<br>
<br>
DatabaseProductName: MySQL<br>
DatabaseProductVersion: 3.23.33-debug<br>
DriverName: Mark Matthews' MySQL Driver<br>
URL: jdbc:mysql:///test<br>
UserName: Admin<br>
supportsAlterTableWithAddColumn: true<br>
supportsAlterTableWithDropColumn: true<br>
supportsANSI92FullSQL: false<br>
supportsBatchUpdates: false<br>
supportsMixedCaseIdentifiers: false<br>
supportsMultipleTransactions: true<br>
supportsPositionedDelete: false<br>
supportsPositionedUpdate: false<br>
supportsSchemasInDataManipulation: false<br>
supportsTransactions: false<br>
ResultSet&nbsp; TYPE_SCROLL_INSENSITIVE :true<br>
ResultSet&nbsp; TYPE_SCROLL_SENSITIVE :false<br>
insertsAreDetected :false<br>
updatesAreDetected :false<br>
</div><br>
<br>
<br>
Interfejs DatabaseMetaData zawiera rÛwnieø metody umoøliwiajπce uzyskanie informacji o:<br>
<ul>
  <li>podtrzymywanych przez RDBMS typach danych</li>
  <li>zestawie tabel w bazie danych.</li>
</ul>
<br>
<br>

<a name="PrgBd.7"></a><h2>7. Wykonywanie instrukcji SQL</h2>

<br>
Do wykonywanie instrukcji SQL s≥uøy obiekt typu: <br>
<br>
&nbsp;&nbsp;&nbsp; <b>Statement&nbsp;&nbsp; (oznacza instrukcje SQL)</b><br>
<br>
a takøe obiekty typu interfejsÛw pochodnych: <br>
<br>
&nbsp;&nbsp;&nbsp; <b>PreparedStatement (prekompilowane instrukcje SQL)<br>
<br>
&nbsp;&nbsp;&nbsp; CallableStatement (przechowywane procedury)</b><br>
<br>
Uzyskujemy je od obiektu typu Connection za pomocπ odwo≥aÒ&nbsp; (odpowiednio):
createStatement(...), prepareStatement(...) i prepareCall(...)<br>
<br>
Poniøszy schemat obrazuje sposÛb pos≥ugiwania siÍ tymi interfejsami.<br>
<br>
<img src="images/statemet.jpg" alt="r" border="1" height="457" width="682">
<br>
<br>
RÛønice pomiÍdzy w/w metodami sπ nastÍpujπce.<br>
<br>
<table border="1" bordercolor="#000000" cellpadding="1" cellspacing="0" width="614">
<tbody><tr valign="top"><td width="202"><p style="margin-bottom: 0cm;"><font size="4"><b>          Argumenty
			metod</b></font></p><p style="margin-bottom: 0cm;"><br>
</p><p style="margin-bottom: 0cm;"><br>
</p><p><font size="4"><b>Metody</b></font></p></td><td width="203"><p style="page-break-after: avoid;" align="center"><font size="4"><b>SELECT...</b></font></p></td><td width="202"><p style="margin-bottom: 0cm;"><font size="4"><b>CREATE TABLE...</b></font></p><p style="margin-bottom: 0cm;"><font size="4"><b>DROP TABLE...</b></font></p><p style="margin-bottom: 0cm;"><font size="4"><b>INSERT...</b></font></p><p style="margin-bottom: 0cm;"><font size="4"><b>UPDATE...</b></font></p><p><font size="4"><b>DELETE...</b></font></p></td></tr><tr valign="top"><td width="202"><p><font size="4"><b>executeQuery(...)</b></font></p></td><td width="203"><p><font face="Times New Roman CE, serif"><font size="4"><b>zwraca tabelÍ wynikowπ</b></font></font></p></td><td width="202"><p><font size="4"><b>-</b></font></p></td></tr><tr valign="top"><td width="202"><p><font size="4"><b>executeUpdate(...)</b></font></p></td><td width="203"><p><font size="4"><b>-</b></font></p></td><td width="202"><p><font face="Times New Roman CE, serif"><font size="4"><b>zwraca
			liczbÍ zmodyfikowanych rekordÛw lub ñ1 (np. dla
			CREATE...)</b></font></font></p></td></tr><tr valign="top"><td width="202"><p><font size="4"><b>execute(...)</b></font></p></td><td colspan="2" width="406"><p><font size="2"><b><font size="4"><font face="Times New Roman CE, serif">wykonuje
			dowolnπ instrukcjÍ SQL i zwraca wartoúÊ boolean (true ñ
			jeúli powsta≥a tabela wynikowa, false ñ jeúli nie;
			prawdziwy wynik ñ tabelÍ wynikowπ lub liczbÍ
			zmodyfikowanych rekordÛw uzyskujemy za pomocπ dodatkowego
			odwo≥ania do obiektu S</font>tatement )</font></b></font></p></td></tr></tbody>
</table>
<p style="margin-bottom: 0cm;"><br>
</p>
Ten sam obiekt typu Statement moøe byÊ wielokrotnie uøywany do wykonania rÛønych instrukcji SQL np.<br>
<br>
<pre>Statement stmt;
...
String[] creTab = { "CREATE TABLE  A (ID INTEGER, NAME CHAR(30))",
                                "CREATE TABLE  B (ID INTEGER, ADR CHAR(30))",
                             };
...
for (int i = 0; i &lt;&nbsp;creTab.length; i++) {
      stmt.executeUpdate(creTab[i]);
}
stmt.executeUpdate("INSERT INTO A VALUES(1, 'Pies')");
stmt.executeUpdate("INSERT INTO B VALUES(1, 'Buda')");
....

</pre>
<br>

<a name="PrgBd.8"></a><h2>8. Obs≥uga wyjπtkÛw SQLException</h2>

<br>
ZarÛwno createStatement() jak i metody executeUpdate(...), executeQuery(...)
i execute(...) mogπ generowaÊ wyjπtki typu SQLException.<br>
Wyjπtki te sygnalizujπ b≥Ídy, wykrywane albo przez sam sterownik (np. brak
jakiegoú trybu dzia≥ania) , albo przez RDBMS (np. b≥Ídy sk≥adniowe w SQL
lub prÛba naruszenia ograniczeÒ ñ jednoznacznoúci, spÛjnoúci referencyjnej
itp.).<br>
<br>
<b>Wyjπtki te musimy obs≥ugiwaÊ.</b><br>
A&nbsp;w trakcie obs≥ugi moøemy uzyskaÊ wiele cennych informacji o przyczynie b≥Ídu.<br>
<br>
Na przyk≥ad:<br>
<pre>Connection con;
Statement stmt;
try {
     Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
     con = DriverManager.getConnection("jdbc:odbc:ksidb");
     stmt = con.createStatement();
   } catch (Exception exc)  {
     System.out.println(exc);
     System.exit(1);
   }

   String crestmt = "CREATE TABLE WYDAWCA ( " +
                    "    ID  INTEGER,      " +
                    "    NAME VARCHAR(120), " +
                    "    CONSTRAINT WYDPK PRIMARY KEY(ID) )";
   try  {
     stmt.executeUpdate(crestmt);
     System.out.println("Table created.");
   } catch (SQLException exc)  {
<b>     // rÛøne informacje, ktÛre moøna uzyskaÊ o wyjπtku SQLException</b>
     System.out.println("SQL except.: " + exc.getMessage());  // komunikat
     System.out.println("SQL state  : " + exc.getSQLState()); // kod standardowy
     System.out.println("Vendor errc: " + exc.getErrorCode()); //&nbsp;kod zaleøny od RDBMS
     System.exit(1);
   } finally {       // klauzula finally wykona siÍ zawsze
      try {          // wykorzystujemy to do prawid≥owego zwolnienia zasobÛw
        stmt.close();
        con.close();
      } catch(SQLException exc) {
        System.out.println(exc);
        System.exit(1);
      }
   }

</pre>
<br>
<br>

<a name="PrgBd.9"></a><h2>9. Instrukcja SQL SELECT, tabele wynikowe, ResultSet i kursory</h2>

W wyniku wykonania instrukcji SELECT powstaje tabela wynikowa. <br>
Jest ona w Javie dostÍpna poprzez obiekt typu ResultSet.<br>
<br>
<img src="images/ResultSet.jpg" alt="r" border="1" height="424" width="643">
<br>
<br>
<br>
Przy czym:<br>
<ul>
  <li>ResultSet moøemy przeglπdaÊ za pomocπ kursora,</li>
  <li>kursor inicjalnie jest ustawiony przed pierwszym rekordem tabeli wynikowej,</li>
  <li>w zaleønoúci od typu ResultSet moøemy przemieszczaÊ kursor tylko w
kierunku od poczπtku tabeli wynikowej do koÒca (typ: ResultSet.TYPE_FORWAD_ONLY)
lub&nbsp; w obu kierunkach (typy ResultSet.TYPE_SCROLL_INSENSITIVE lub ResultSet.TYPE_SCROLL_SENSITIVE).</li>
  <li>interfejs ResultSet zawiera metody przemieszczajπce kursor, z ktÛrych korzystamy przy przeglπdaniu tabeli wynikowej. </li>
  <li>metody przemieszczajπce kursor zwracajπ wartoúÊ logicznπ false, gdy
øπdane przemieszczenie kursora nie jest moøliwe np. polecenie przejúcia do
nastÍpnego rekordu wyprowadza nas poza tabelÍ,</li>
  <li>jeúli kursor ustawiony jest na jakimú rekordzie tabeli wynikowej,
to moøemy pobraÊ wartoúci jego pÛl za pomocπ odpowiednich metod interfejsu
ResultSet; metody te zapewniajπ automatyczne przekszta≥cenie typÛw SQL do
odpowiadajπcych im typÛw Javy</li>
</ul>

<a name="PrgBd.10"></a><h2>10. Przemieszczanie kursora</h2>

W kontekúcie:<br>
<br>
<b>ResultSet rs = stmt.executeQuery(query);</b><br>
<br>
<p style="margin-bottom: 0cm;"><br>
</p>
<table border="1" bordercolor="#000000" cellpadding="1" cellspacing="0" width="614">
<col width="125"><col width="215"><col width="130"><col width="134"><tbody><tr valign="top"><td width="125">Odwo≥anie</td><td width="215">Ustawia kursor</td><td colspan="2" width="266">Typ
			ResultSet</td></tr><tr valign="top"><td width="125"><br>
</td><td width="215"><br>
</td><td width="130">nieprzewijalny</td><td width="134">przewijalny</td></tr><tr valign="top"><td width="125">rs.beforeFirst();</td><td width="215">Przed pierwszym rekordem</td><td width="130">NIE</td><td width="134">TAK</td></tr><tr valign="top"><td width="125">rs.first();</td><td width="215">Na pierwszym rekordzie</td><td width="130">NIE</td><td width="134">TAK</td></tr><tr valign="top"><td width="125">rs.next();</td><td width="215">Na
			nastÍpnym rekordzie</td><td width="130">TAK</td><td width="134">TAK</td></tr><tr valign="top"><td width="125">rs.previous();</td><td width="215">Na poprzednim rekordzie</td><td width="130">NIE</td><td width="134">TAK</td></tr><tr valign="top"><td width="125">rs.last();</td><td width="215">Na ostatnim rekordzie</td><td width="130">NIE</td><td width="134">TAK</td></tr><tr valign="top"><td width="125">rs.afterLast();</td><td width="215">Za ostatnim rekordem</td><td width="130">NIE</td><td width="134">TAK</td></tr><tr valign="top"><td width="125">rs.absolute(n);</td><td width="215">Na n-tym rekordzie</td><td width="130">NIE</td><td width="134">TAK</td></tr><tr valign="top"><td width="125">rs.relative(n);</td><td width="215">Na
			rekordzie oddalonym o n miejsc od bieøπcego (jeúli n &lt; 0 ñ

			to do poczπtku)</td><td width="130">NIE</td><td width="134">TAK</td></tr></tbody>
</table>
<p style="margin-bottom: 0cm;"><br>
</p>
Przyk≥ad:<br>
ile rekordÛw zawiera tabela wynikowa?<br>
<br>
<pre>int count = 0;
while (rs.next()) count++;</pre>
<br>
lub:<br>
<br>
<pre>rs.last();
int count = rs.getRow() // numer bieøπcego rekordu</pre>
<br>
Uwaga: dzia≥anie na ResultSet nie oznacza, øe wszystkie rekordy tabeli wynikowej
sπ "úciπgane" z RDBMS. Jest zwykle úciπgana jakaú rozsπdna porcja, gdy kursor
zbliøa siÍ do pozycji od ktÛrej te rekordy mogπ byÊ potrzebne.<br>
Dlatego drugi sposÛb (dostÍpny tylko dla przewijalnych&nbsp; tabel wynikowych) jest bardziej efektywny od pierwszego<br>
<br>
Oczywiúcie, ResultSet przeglπdamy zwykle po to by pobieraÊ wartoúci pÛl poszczegÛlnych
rekordÛw i wykonywaÊ na nich jakieú operacje (choÊby raportowania).<br>
<br>

<a name="PrgBd.11"></a><h2>11. OdpowiednioúÊ typÛw danych SQL i Javy. Pobieranie wartoúci pÛl</h2>

Typy danych zapisane w BD rÛøniπ siÍ od typÛw danych Javy.<br>
Aby sprawnie dzia≥aÊ na wartoúciach pÛl poszczegÛlnych rekordÛw trzeba wiedzieÊ
w jaki sposÛb typy SQL sπ odzwierciedlane w typy Javy.<br>
<br>
<table border="1" cellspacing="1" width="526">
<tbody><tr><td valign="middle" width="29%"><p align="center">Standardowy typ SQL </p></td><td valign="top" width="35%"><p align="center">Podstawowy typ Javy </p></td><td valign="top" width="35%"><p align="center">Obiektowy typ Javy</p></td></tr><tr><td valign="middle" width="29%"><code></code><p>CHAR </p></td><td valign="top" width="35%"><code></code><p>String </p></td><td valign="top" width="35%"><code></code><p>String </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>VARCHAR </p></td><td w="" idth="35%" valign="top"><code></code><p>String </p></td><td valign="top" width="35%"><code></code><p>String </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>LONGVARCHAR </p></td><td valign="top" width="35%"><code></code><p>String </p></td><td valign="top" width="35%"><code></code><p>String </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>NUMERIC </p></td><td valign="top" width="35%"><code></code><p>java.math.BigDecimal </p></td><td valign="top" width="35%"><code></code><p>j
ava.math.BigDecimal </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>DECIMAL </p></td><td valign="top" width="35%"><code></code><p>java.math.BigDecimal </p></td><td valign="top" width="35%"><code></code><p>java.math.BigDecimal </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>BIT </p></td><td valign="top" width="35%"><code></code><p>boolean </p></td><td valign="top" width="35%"><code></code><p>Boolean </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>TINYINT
</p></td><td valign="top" width="35%"><code></code><p>byte </p></td><td valign="top" width="35%"><code></code><p>Integer </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>SMALLINT </p></td><td valign="top" width="35%"><code></code><p>short </p></td><td valign="top" width="35%"><code></code><p>Integer </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>INTEGER </p></td><td valign="top" width="35%"><code></code><p>int </p></td><td valign="top" width="35%"><code></code><p>Integer
</p></td></tr><tr><td valign="middle" width="29%"><code></code><p>BIGINT </p></td><td valign="top" width="35%"><code></code><p>long </p></td><td valign="top" width="35%"><code></code><p>Long </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>REAL </p></td><td valign="top" width="35%"><code></code><p>float </p></td><td valign="top" width="35%"><code></code><p>Float </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>FLOAT </p></td><td valign="top" width="35%"><code></code><p>doub
le </p></td><td valign="top" width="35%"><code></code><p>Double </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>DOUBLE </p></td><td valign="top" width="35%"><code></code><p>double </p></td><td valign="top" width="35%"><code></code><p>Double </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>BINARY </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>VARBINARY </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>LONGVARBINARY </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td><td valign="top" width="35%"><code></code><p>byte[] </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>DATE </p></td><td valign="top" width="35%"><code></code><p>java.sql.Date </p></td><td valign="top" width="35%"><code></code><p>java.sql.Date </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>TIME </p></td><td valign="top" width="35%"><code></code><p>java.sql.Time </p></td><td valign="top" width="35%"><code></code><p>java.sql.Time </p></td></tr><tr><td valign="middle" width="29%"><code></code><p>TIMESTAMP </p></td><td valign="top" width="35%"><code></code><p>java.sql.Timestamp </p></td><td valign="top" width="35%"><code></code><p>java.sql.Timestamp </p></td></tr><tr><td valign="Midd
le" width="29%"><p>CLOB </p></td><td valign="top" width="35%"><code></code><p>java.sql.Clob </p></td><td valign="top" width="35%"><code></code><p>java.sql.Clob </p></td></tr><tr><td valign="middle" width="29%"><p>BLOB </p></td><td valign="top" width="35%"><code></code><p>java.sql.Blob </p></td><td valign="top" width="35%"><code></code><p>java.sql.Blob </p></td></tr><tr><td valign="middle" width="29%"><p>ARRAY </p></td><td valign="top" width="35%"><code></code><p>java.sql.Array </p></td><td valign="top" width="35%"><cod e=""></cod><p>java.sql.Array </p></td></tr><tr><td valign="middle" width="29%"><p>STRUCT </p></td><td valign="top" width="35%"><code></code><p>java.sql.Struct </p></td><td valign="top" width="35%"><code></code><p>java.sql.Struct </p></td></tr><tr><td valign="middle" width="29%"><p>REF </p></td><td valign="top" width="35%"><code></code><p>java.sql.Ref </p></td><td valign="top" width="35%"><code></code><p>java.sql.Ref </p></td></tr></tbody>
</table>
<br>
<br>
Ta informacja jest waøna, jeúli chcemy tworzyÊ nieco bardziej elastyczne
aplikacje (np. uniwersalne edytory tabel bazodanowych).<br>
<br>
&nbsp;Do pobierania wartoúci kolumn tabeli wynikowej s≥uøπ metody getTTT(...)
interfejsu ResultSet, ktÛre dokonujπ automatycznej konwersji&nbsp; pomiÍdzy SQL-owym
typem pola, a typem Javy TTT (TTT ñ oznacza tu jakiú typ np. int lub String).<br>
<br>
Najprostszy szablon:<br>
<br>
<img src="images/rsGet.jpg" alt="r" border="1" height="145" width="554">
<br>
<br>
Moøliwoúci uøycie metod getTTT(...) wobec okreúlonych typÛw SQL wyjaúnia nastÍpujπca rysunek.<br>
<br>
<img src="images/types.jpg" alt="r" border="1" height="642" width="765">
<br>
<br>
Przyk≥ad:<br>
<br>
<pre>String sel = "select tytul, cena from pozycje where cena &gt; 40";
   try  {
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      while (rs.next())  {                     //  moøna teø uøyÊ:
         String tytul = rs.getString(3);       //   rs.getString("tytul");
         float cena  = rs.getFloat(6);         //   rs.getFloat("cena");
         float usd = cena/4;
         System.out.println("Tytul: " + tytul);
         System.out.println("Cena : " + cena + " PLN");
         System.out.println("USD  : " + usd + " USD");
         System.out.println("-----------------");
      }
      rs.close();
      stmt.close();
      con.close();
   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }

</pre>
Uwaga: naleøy zamykaÊ ResultSet po wykorzystaniu (rs.close()), aby na pewno zwolniÊ zasoby.<br>
ResultSet jest zamykany automatycznie, gdy zamykamy Statement (stmt.close())
lub gdy ten sam obiekt typu Statment&nbsp; wykorzystywany jest ponownie do wykonania
innej instrukcji SQL (ew. powstaje wtedy nowy ResultSet).<br>
<br>
<img src="images/rsTyp.jpg" alt="r1" border="1" height="409" width="646">
<br>
<br>
<br>

<a name="PrgBd.12"></a><h2>12. Modyfikowalny ResultSet</h2>

Jeøeli sterownik JDBC dopuszcza modyfikowalny ResultSet (typ: ResultSet.TYPE_CONCUR_UPDATABLE),
to moøemy uøyÊ wobec obiektu typu ResultSet metod updateTTT(...), updateRow(),
insertRow()&nbsp; i deleteRow(...).<br>
Pozwalajπ one na: dodawanie, modyfikowanie i usuwanie rekordÛw bez bezpoúredniego
uøycia instrukcji SQL, operujπc na obiekcie typu ResultSet.<br>
<br>
Przed wywo≥aniem tych metod naleøy ustawiÊ kursor, tak by wskazywa≥ odpowiedni rekord. <br>
<pre>// Np. usuwanie rekordu 5
ResultSet rs;
...
rs.absolute(5);
rs.deleteRow();

</pre>
Metoda updateRow() s≥uøy zarÛwno do wpisywania jak i modyfikowania rekordÛw.&nbsp;
Przy wpisywaniu ustawiamy kursor na specjalnym "rekordzie" ñ nowym wierszu,
za pomocπ metody moveToInsertRow().<br>
Ustalenie wartoúci pÛl (w nowym lub modyfikowanym) rekordzie odbywa siÍ za
pomocπ metod updateTTT(...) (gdzie TTT ñ javowy typ pola) z dwoma argumentami:
oznaczenie kolumny (indeks lub nazwa) i wpisywana wartoúÊ.<br>
<br>
<img src="images/rsMod.jpg" alt="r" border="1" height="467" width="644">
<br>
<br>
<br>

<a name="PrgBd.13"></a><h2>13. Metainformacje o tabeli wynikowej</h2>

Specjalny obiekt typu <b>ResultSetMetaData</b> dostarcza informacji o kolumnach tabeli wynikowej. Obiekt ten uzyskujemy od obiektu ResultSet za pomocπ metody getMetaData():<br>
<br>
<div class="syntax"><br>
&nbsp;&nbsp;&nbsp; ResultSet rs ... <br>
&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp; ResultSetMetaData rsmd =&nbsp; rs.getMetaData();<br>
</div><br>
<br>
a nastÍpnie uøywamy metod interfejsu ResultSetMetaData by otrzymaÊ konkretne informacje.<br>
Przyk≥ad <br>
( mamy otwarte po≥aczenie Connection con i uøywamy dodatkowej metody <br>
&nbsp; void say(String s)&nbsp; { System.out.print(s); }&nbsp; )<br>
<br>
<pre> String sel ="SELECT AUTOR.ID, AUTOR.AUTOR, POZYCJE.TYTUL,"
                   "WYDAWCA.NAME AS WYDAWCA " +
                   "FROM POZYCJE,AUTOR, WYDAWCA " +
                   "WHERE WYDAWCA.ID = POZYCJE.WYDID " +
                   "AND AUTOR.ID = POZYCJE.AUTID " +
                   "ORDER BY AUTOR ASC;";
   try  {
      Statement stmt = con.createStatement();
      ResultSet rs = stmt.executeQuery(sel);
      ResultSetMetaData rsmd = rs.getMetaData();
      int cc = rsmd.getColumnCount();               // liczba kolumn
     for (int i = 1; i &lt;= cc; i++)  {               // i-ta kolumna:
        say('\n'+ rsmd.getColumnName(i));           // - nazwa
        say(" " + rsmd.getColumnDisplaySize(i));    // - szerokoúÊ
        say(" " + rsmd.getColumnClassName(i));      // - klasa Javy
        say(" " + rsmd.getColumnType(i));           // - typ SQL
        say(" " + rsmd.getColumnTypeName(i));       // - typ RDBMS
      }
      stmt.close();
      con.close();

   } catch (SQLException exc)  {
     System.out.println(exc.getMessage());
   }

</pre>
Uwaga:<br>
typ SQL ñ sta≥a int z java.sql.Types<br>

klasa Javy ñ jakiej klasy obiekt zwrÛci&nbsp; getObject() uøyty wobec tej kolumny ResultSet<br>
<br>
Moøliwy wynik:<br>
<div class="listing100"><br>
ID 11 java.lang.Integer 4 LONG<br>
AUTOR 255 java.lang.String 12 TEXT<br>
TYTUL 255 java.lang.String 12 TEXT<br>
WYDAWCA 120 java.lang.String 12 TEXT<br>
</div><br>
<br>
<br>

<a name="PrgBd.14"></a><h2>14. Instrukcje prekompilowane</h2>

Prekompilowane instrukcje SQL sπ przed wykonaniem wysy≥ane do RDBMS i podlegajπ
tam prekompilacji, swoistemu przygotowaniu, ktÛre nastÍpnie przyspiesza ich
wielokrotne uøycie (wykonanie).<br>
Oczywiúcie nie ma sensu wykonywaÊ tej samej instrukcji wielokrotnie. Dlatego
w instrukcjach prekompilowanych uøywane sπ znaki ? jako symbole parametrÛw.
Przy kaødym wykonaniu w miejsce znakÛw ? podstawia siÍ odpowiednie wartoúci.<br>
Instrukcje prekompilowane w Javie reprezentowane sπ jako obiekty typu PreparedStatement. <br>
Tworzymy instrukcjÍ prekompilowanπ za pomocπ metody prepareStatement (zamiast
createStatement), podajπc jako argument odpowiedniπ instrukcjÍ SQL (z parametrami
?). Zwykle instrukcje takie wykonujemy w pÍtli ustalajπc wartoúci parametrÛw
za pomocπ metod set... interfejsu PrepareStatement .<br>
<br>
Jeúli TTT i XXX oznaczajπ (rÛøny) typ Javy (np. int, String, float, etc)
to (przyk≥adowe) wykonanie instrukcji prekompilowanej moøna przedstawiÊ schematycznie
w nastÍpujπcy sposÛb:<br>
<br>
<img src="images/prep.jpg" alt="r" border="1" height="329" width="606">
<br>
<br>
<br>
Przyk≥ad:<br>
<pre>Connection con;
PreparedStatement stmt;
...
  String[] wyd =  { "PWN", "PWE", "Czytelnik", "Amber", "HELION",
                            "MIKOM" };
  int beginKey = 10,
  try  {
     stmt = con.prepareStatement("INSERT INTO WYDAWCA VALUES(?,?)");
     for (int i=0; i &lt; wyd.length; i++)   {
       stmt.setInt(1, beginKey + i);
       stmt.setString(2, wyd[i]);
       stmt.executeUpdate();     //         Uwaga: inna forma executeUpdate()
 }
     con.close();
   } catch(SQLException exc)  {
      System.out.println(exc);
   }

</pre>
<br>

<a name="PrgBd.15"></a><h2>15. Obs≥uga transakcji</h2>

<b>Transakcja</b> to grupa instrukcji, traktowanych jako ca≥oúÊ: jeøeli ktÛraú
z nich nie zostanie wykonana ñ nie mogπ byÊ wykonane inne; np. przelew z
konta na konto)<br>
<br>
Sterowniki JDBC zwykle uøywajπ domyúlnie trybu autoCommit (wykonanie kaødej
instrukcji INSERT, DELETE, UPDATE powoduje zmiany w bazie danych; transakcjπ
jest jedna instrukcja).<br>
<br>
<img src="images/commit.jpg" alt="r" border="1" height="306" width="631">
<br>
<br>
<br>

<a name="PrgBd.16"></a><h2>16. Zastosowanie architektury "Model-View-Controller" przy tworzeniu graficznych interfejsÛw BD za pomocπ komponentÛw Swingu</h2>

<br>
Java wyjπtkowo dobrze nadaje siÍ do tworzenia graficznych interfejsÛw uøytkownika
dostÍpu do baz danych. SzczegÛlnπ rolÍ odgrywajπ tu komponenty Swingu ze
wzglÍdu na ich elastycznoúÊ, atrakcyjnoúÊ graficznπ, niezaleøny od platformy
i konfigurowalny wyglπd oraz realizacjÍ koncepcji MVC.<br>
SzczegÛlnie atrakcyjnym (w kontekúcie interakcji z bazπ danych) komponentem Swingu jest tabela (klasa JTable).<br>
<br>
 Zobaczymy teraz przyk≥ad realizacji modelu danych tabeli dla przedstawienia
tabeli wynikowej instrukcji SELECT (i nie tylko ñ praktycznie kaødego ResultSetu).<br>
KomÛrki tabeli bÍdπ edytowalne, a ich edycja ma powodowaÊ zmiany w tabelach BD.<br>
<br>
<pre>// Model danych dla&nbsp;tabeli pokazujπcej dowolny ResultSet

import java.util.*;
import java.sql.*;
import javax.swing.*;
import javax.swing.table.*;
import javax.swing.event.*;

public class DbTable extends AbstractTableModel  {
    private Connection con;
    private ResultSet rs;
    private String[]  columnNames;
    private int[]  columnTypes;
    private boolean[] readOnly;
    private String tableName = "";
    private List  rows;
    private ResultSetMetaData   md;
    private boolean editable = false;

public DbTable(Connection conn, String query, ResultSet resultSet, boolean ed)  {
   rs = resultSet;
   editable = ed;
   con = conn;
   tableName = getTableName(query);
   try {
     md = rs.getMetaData();
     int cc =  md.getColumnCount();
     columnNames = new String[cc];
     columnTypes = new int[cc];
     readOnly = new boolean[cc];
     for(int col = 0; col &lt; cc; col++) {
       columnNames[col] = md.getColumnName(col+1);
       columnTypes[col] = md.getColumnType(col+1);
       readOnly[col] = md.isReadOnly(col+1);
     }

     rows = new ArrayList();
     while (rs.next()) {
        List row = new ArrayList();
        for (int i = 1; i &lt;= getColumnCount(); i++) {
          row.add(rs.getObject(i));
        }
        rows.add(row);
     }
     rs.close();
     fireTableChanged(null); // Nowa tabela
   } catch (SQLException ex) {
            System.out.println(ex.getMessage());
     }
}

// Niedoskonala wersja
private String getTableName(String q)  {
   if (q == null || q.equals("")) return "";
   StringTokenizer st = new StringTokenizer(q);
   while (st.hasMoreTokens())  {
     String w = st.nextToken();
     w = w.toUpperCase();
     if (w.equals("FROM")) {
         String t = st.nextToken();
         if (t.indexOf(',') == -1) return t;
         break;
     }
   }
   return "";
}

// Obowiπzkowe metody interfejsu TableModel
public String getColumnName(int column) {
    if (columnNames[column] != null) return columnNames[column];
     else return "";
}

public Class getColumnClass(int column) {
   String type;
   Class c = null;
   try {
     type = md.getColumnClassName(column+1);
     c = Class.forName(type);
     }
     catch (Exception e) {
       return super.getColumnClass(column);
   }
   return c;
}

public boolean isCellEditable(int row, int column) {
    if (!editable) return false;
    if (tableName.equals("")) return false;
    return !readOnly[column];
}

public int getColumnCount() {
   return columnNames.length;
}

public int getRowCount() {
   return rows.size();
}

public Object getValueAt(int r, int c) {
    List row = (List)rows.get(r);
    return row.get(c);
}

 public String dbValue(int col, Object value) {
    int type;
    if (value == null) return "null";
    type = columnTypes[col];

    switch(type) {
        case Types.CHAR:
        case Types.VARCHAR:
        case Types.LONGVARCHAR:
             return "\'"+value.toString()+"\'";
        case Types.BIT:
            return ((Boolean)value).booleanValue() ? "1" : "0";
        default:
            return value.toString();
        }
}


 public void setValueAt(Object value, int r, int c) {
    List row = (List) rows.get(r);
    String oldval = row.get(c).toString();
    if (oldval.equals(value.toString())) return;
    String colName = getColumnName(c);
    String query = " update " + tableName +
                   " set " + colName + " = " + dbValue(c, value) +
                   " where ";
    for(int j = 0; j &lt; getColumnCount(); j++) {
      colName = getColumnName(j);
      if (colName.equals("")) continue;
      if (j != 0)  query += " and ";
      query += colName +" = "+  dbValue(j, getValueAt(r, j));
    }
    query +=  ";";
    try {
       Statement s = con.createStatement();
       int updCount = s.executeUpdate(query);
       row.set(c, value);
       System.out.println("Zmieniono rekordÛw: " + updCount);
    } catch (SQLException e) {
        System.out.println(query);
        System.out.println(e.getMessage());
   }
 }


}

</pre>
Srworzymy rÛwnieø prosty garficzny interfejs do wydawania zleceÒ SQL oraz oglπdania wynikÛw w postaci tabeli.<br>
Przyk≥adowe okno tego programiku wyglπda tak:<br>
<br>
<img src="images/ksidb1.jpg" alt="r" border="1" height="478" width="608">
<br>
<br>
a&nbsp; jego kod &nbsp;pokazano poniøej:<br>
<br>
<pre>// Testowy interfejs SQL

import java.sql.*;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;

public class TestSQL extends JFrame implements ActionListener {

   private Connection con = null;
   private Statement stmt;
   private ResultSet rs = null;
   private String query;
   private JTable table = new JTable();
   private JTextArea ta = new JTextArea(3,40);
   private DefaultListModel history = new DefaultListModel();
   private JList hlis = new JList(history);
   private JWindow wh = new JWindow();


   public TestSQL(String URL, String driver, String user,
                         String passwd) {
        super("Baza danych ksiπøki");
        setDefaultCloseOperation(3);

        try {
           Class.forName(driver);
           con = DriverManager.getConnection(URL);
           stmt = con.createStatement();
        } catch (Exception exc)  {
           System.out.println(exc.getMessage());
           System.exit(1);
        }

        JScrollPane scrollpane = new JScrollPane(table);
        scrollpane.setPreferredSize(new Dimension(600, 400));
        JPanel p = new JPanel();
        p.setLayout(new BorderLayout());
        ta.setLineWrap(true);

        JScrollPane tsp = new JScrollPane(ta);
        p.add(tsp, "Center");
        JButton b = new JButton("Execute");
        b.setMnemonic('E');
        b.addActionListener(this);

        p.add(b, "East");
        p.setBorder(BorderFactory.createLineBorder(Color.blue));
        getContentPane().add(scrollpane, "Center");
        getContentPane().add(p, "South");

        createHistoryList();

        pack();
        setVisible(true);
    }

   public void actionPerformed(ActionEvent e)  {
      String new_query = ta.getText();
      if (new_query.equals(query)) return;
      query = new_query;
      if (!history.contains(query)) history.addElement(query);
      execute(query);
   }

   void execute(String query)  {
      try  {
        rs = stmt.executeQuery(query);
        DbTable dbt = new DbTable(con, query, rs, true);
        table.setModel(dbt);
      } catch(SQLException exc)  {
         System.out.println(exc.getMessage());
      }
   }

  void createHistoryList()  {

    ta.addMouseListener(new MouseAdapter()  {
        public void mouseReleased(MouseEvent e)  {
          if (e.isPopupTrigger())  {
             wh.pack();
             wh.show();
          }
        }
    });

    hlis.addMouseListener(new MouseAdapter()  {
        public void mouseClicked(MouseEvent e)  {
          if (e.getClickCount() == 2)   {
             String s = (String) hlis.getSelectedValue();
             if (s != null) ta.setText(s);
             wh.setVisible(false);
          }
        }
    });

    JScrollPane hsp = new JScrollPane(hlis);
    hsp.setPreferredSize(new Dimension(200, 300));
    JPanel hp = new JPanel(new BorderLayout());
    hp.setBorder(BorderFactory.createLoweredBevelBorder());
    hp.add(hsp, "Center");
    JPanel bhp = new JPanel();

    ActionListener hlHandler = new ActionListener()  {
      public void actionPerformed(ActionEvent e)  {
          String cmd = e.getActionCommand();
          if (cmd.equals("Cancel")) wh.setVisible(false);
          else if (cmd.equals("Clear all")) history.clear();
          else  {
            int index = hlis.getSelectedIndex();
            if (index == -1) return;
            if (cmd.equals("Clear")) history.remove(index);
            else if (cmd.equals("Execute"))  {
              String new_query = (String) hlis.getSelectedValue();
              if (new_query.equals(query)) return;
              query = new_query;
              wh.setVisible(false);
              execute(query);
              ta.setText(query);
            }
          }
      }
    };

    JButton  b = new JButton("Cancel");
    b.addActionListener(hlHandler);
    bhp.add(b);
    b = new JButton("Clear");
    b.addActionListener(hlHandler);
    bhp.add(b);
    b = new JButton("Clear all");
    b.addActionListener(hlHandler);
    bhp.add(b);
    b = new JButton("Execute");
    b.addActionListener(hlHandler);
    bhp.add(b);
    hp.add(bhp, "South");

    wh.getContentPane().add(hp);
    ta.addMouseListener(new MouseAdapter()  {
       public void mouseReleased(MouseEvent e)  {
          if (e.isPopupTrigger())  {
            wh.setLocation( getX()+10, getY()+50);
            wh.pack();
            wh.show();
          }
       }
     });
  }


  public static void main(String[] args) {
    String driverName = "com.mysql.jdbc.Driver";
    String url = "jdbc:mysql:///ksidb";
    String uid = "pies";
    String pwd = "kuba";
    new TestSQL(url, driverName, uid, pwd);
  }
}
</pre>
<br>

</body>
</html>