<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="Uniwersalne techniki programowania">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2010">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Strumienie</title>
</head>
<body>
<br>
<br>
<div align="Center">
<h1>Strumienie we-wy</h1>
</div>
<br>

</div>
<br>


<hr>
<br>
<span style="font-style: italic;"> Programowanie aplikacji niemal zawsze wymaga wykonywania operacji wejúcia-wyjúcia. W Javie nie jest to banalne, choÊby
ze wzglÍdu na bardzo duøπ liczbÍ klas, ktÛre temu s≥uøπ. Tu poznamy prawie
wszystkie te klasy, ale przede wszystkim koncepcje, leøπce u podstaw konstrukcji
niezwykle bogatego w moøliwoúci, ale jednoczeúnie doúÊ zawik≥anego úrodowiska&nbsp;
programowania wejúcia-wyjúcia w Javie.</span>
<hr>

<a name="Strumienie.1"></a><h2>1. OgÛlny obraz: pojÍcie strumienia i pakietu we-wy Javy</h2>


Java dostarcza dwÛch podstawowych pakietÛw (z podpakietami), s≥uøπcych do przeprowadzania operacji wejúcia-wyjúcia:<br>
<ul>
  <li>java.io &nbsp; </li>
  <li>java.nio</li>
</ul>
Pakiet java.io zawiera przede wszystkim klasy, ktÛre pozwalajπ operowaÊ na <b>strumieniach</b> danych.<br>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
  <tbody>
    <tr>
      <td bgcolor="#ccffff" valign="top"><br>
      <div align="center"><b>StrumieÒ danych jest pojÍciem abstrakcyjnym, logicznym.</b> <br>
      </div>
      <br>
Oznacza ciπg danych, w≥aúnie ÑstrumieÒî, do ktÛrego dane mogπ byÊ dodawane i z ktÛrego dane mogπ byÊ pobierane.<br>
      <br>
Przy czym:

      <ul>
<li>strumieÒ zwiπzany jest ze ürÛd≥em lub odbiornikiem danych</li><li>
ürÛd≥o lub odbiornik mogπ byÊ dowolne: plik, pamiÍÊ, URL, gniazdo, potok ...</li><li>
strumieÒ s≥uøy do zapisywania-odczytywania informacji - dowolnych danych</li><li>
program:</li><ul><li>
kojarzy strumieÒ z zewnÍtrznym ürÛd≥em/odbiornikiem,</li><li>
otwiera strumieÒ,</li><li>
dodaje lub pobiera dane ze strumienia,</li><li>
zamyka strumieÒ.</li></ul><li>przy
czytaniu lub zapisie danych z/do strumienia mogπ byÊ wykonywane
dodatkowe operacje (np. buforowanie, kodowanie-dekodowanie,
kompresja-dekompresja)</li>
        <li>w Javie dostarczono klas,
reprezentujπcych&nbsp; strumienie. Hierarchia tych klas pozwala na
programowanie w sposÛb abstrahujπcy od konkretnych ürÛde≥ i odbiornikÛw.<br>
        </li>

      </ul>
      <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
Klasy reprezentujπce strumienie (inaczej: klasy strumieniowe) omÛwimy najpierw,
sπ one bowiem podstawowym úrodkiem programowania operacji wejúcia-wyjúcia
w Javie.<br>
<br>
W pakiecie java.nio ("Java new input-output", w skrÛcie <b>NIO</b>) wprowadzono dodatkowe úrodki wejúcia-wyjúcia, takie jak <b>kana≥y</b>, <b>bufory</b> i <b>selektory</b>
. Mimo nazwy ("new input-output") úrodki te nie zastÍpujπ klas strumieniowych.
S≥uøπ przede wszystkim do zapewnienia wysokiej efektywnoúci i elastycznoúci
programÛw, ktÛre w bardzo duøym stopniu obciπøone sπ operacjami wejúcia-wyjúcia.
W szczegÛlnoúci dotyczy to serwerÛw, ktÛre muszπ rÛwnolegle obs≥ugiwaÊ ogromnπ
liczbÍ po≥πczeÒ sieciowych. Elementom nowych klas wejúciowo-wyjúciowych przyjrzymy
siÍ w przysz≥ym semestrze, przy okazji omaiwania&nbsp; zasad programowania klient-serwer.&nbsp;
&nbsp; <br>
<br>
OprÛcz tego Java dostarcza klas reprezentujπcych inne od strumieni obiekty operacji wejúcia-wyjúcia.<br>
Do klas tych naleøy np. klasa File&nbsp;z pakietu java.io - opisujπca pliki i
katalogi, a takøe - w pakiecie java.net - klasy reprezentujπce obiekty "sieciowe",
takie jak URL czy gniazdo (socket), mogπce stanowiÊ ürÛd≥o lub odbiornik
danych w sieci (w szczegÛlnoúci w Internecie). <br>
Obiekty tych klas nie stanowiπ strumieni. Do operowania na nich strumienie
(lub kana≥y) sπ jednak potrzebne i moøemy je uzyskaÊ albo przez uøycie odpowiednich
konstruktorÛw lub metod.<br>
<br>
<br>



<a name="Strumienie.2"></a><h2>2. Klasy strumieniowe</h2>


 

Na strumieniach moøemy wykonywaÊ dwie podstawowe operacje: odczytywanie
danych i zapisywanie danych. Z tego punktu widzenia moøemy mÛwiÊ o strumieniach
wejúciowych i wyjúciowych. I odpowiednio do tego ñ Java wprowadza dwie roz≥πczne
hierarchie klas strumieniowych: <b>klasy strumieni wejúciowych</b> i<b> klasy strumieni wyjúciowych</b>.<br>
<br>
Dalej, pobranie/zapis danych moøe dotyczyÊ okreúlonych&nbsp; atomistycznych (minimalnie
rozrÛønialnych w trakcie operacji) Ñporcji danychî. Okazuje siÍ, øe nie sπ
to tylko bajty. W Javie ñ ze wzglÍdu na przyjÍcie standardu kodowania znakÛw
(Unikod) ñ wyrÛønia siÍ rÛwnieø inny Ñatom danychî ñ znak Unikodu, z≥oøony
z dwÛch bajtÛw. Wobec tego powstajπ kolejne dwie roz≥πczne hierarchie klas
strumieniowych: <b>klasy strumieni&nbsp; bajtowych</b> (Ñatomemî operacji we-wy jest bajt) oraz <b>klasy strumieni znakowych</b> (Ñatomemî sπ znaki Unikodu ñ 2 bajty).<br>
<br>
<div class="important">Przy przetwarzaniu tekstÛw naleøy korzystaÊ ze strumieni znakowych ze wzglÍdu
na to, iø w trakcie czytania/pisania wykonywane sπ odpowiednie operacje kodowania/dekodowania
ze wzglÍdu na stronÍ kodowπ w≥aúciwπ dla ürÛd≥a/odbiornika</div><br>
<br>
Zatem mamy aø cztery hierarchie klas strumieniowych.<br>
<br>
Poczπtkowe nadklasy tych hierarchii pokazuje poniøsza tabela.<br>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td><br>
</td><td>Wejúcie</td><td>Wyjúcie</td></tr><tr><td>Strumienie bajtowe</td><td><b>InputStream</b></td><td><b>OutputStream</b></td></tr><tr><td>Strumienie znakowe</td><td><b>Reader</b></td><td><b>Writer</b></td></tr></tbody>
</table>
<br>
Sπ to klasy abstrakcyjne, zatem bezpoúrednio nie moøna tworzyÊ obiektÛw tych klas. <br>
Dostarczajπ one&nbsp; natomiast podstaw dla wszystkich innych klas strumieniowych
oraz paru ogÛlnych uøytecznych (choÊ&nbsp; bardzo podstawowych)&nbsp; metod. Metody
te umoøliwiajπ m.in.
<ul>
  <li>czytanie - <b>read</b>(..)&nbsp; (bajtÛw, znakÛw) - rÛøne wersje tej (przeciπøonej)
metody&nbsp; pozwalajπ na przeczytanie jednego bajtu ze strumienia bajtowego lub
znaku ze strumienia znakowego albo ca≥ej porcji bajtÛw/znakÛw, &nbsp; </li>
  <li>zapisywanie (<b>write</b>(...)) (bajtÛw/znakÛw) - rÛøne wersje tej
(przeciπøonej) metody pozwalajπ zapisywac pojedyÒcze bajty/znaki lub tablice
bajtÛw/znakÛw, a w przypadku strumieni znakowych rÛwnieø napisy (obiekty
klasy String),</li>
  <li>pozycjonowanie strumieni (metody <b>skip(..)</b>, <b>mark(..)</b>, <b>reset()</b>
) - kaødy strumieÒ moøe byÊ traktowany jako sekwencja bajtÛw/znakÛw, czytanie
i zapisywanie zawsze dotyczy bieøπcej pozycji tej sekwencji; po wykonaniu
operacji czytania lub zapisu bieøπca pozycja zwiÍksza siÍ o jeden; metody
pozycjonowania pozwalajπ zmieniaÊ bieøπcπ pozycjÍ.</li>
  <li>zamykanie strumieni (metoda <b>close</b>()) - strumieÒ zawsze naleøy zamknπÊ po zakoÒczeniu operacji na nim.</li>
</ul>
&nbsp; <br>
Metody te sπ zazwyczaj odpowiednio przedefiniowane w klasach dziedziczπcych;
polimorfizm zapewnia ich oszczÍdne i w≥aúciwe uøycie. <br>
<br>
DziÍki temu moøemy np. opracowaÊ ogÛlnπ klasÍ udostÍpniajπcπ rudymentarne kopiowanie strumieni.<br>
<br>
<pre>import java.io.*;

class Stream {

  static void copy(InputStream in, OutputStream  out) throws IOException {
    int c;
    while ((c = in.read()) != -1) out.write(c);
  }

  static void copy(Reader in, Writer out) throws IOException {
    int c;
    while ((c = in.read()) != -1) out.write(c);
  }
}

</pre>
Uwaga: metoda read() zwraca liczbÍ ca≥kowitπ, reprezentujπcπ kolejny znak
ze strumienia znakowego (lub bajt ze strumienia bajtowego) albo wartoúÊ -1
gdy czytanie siÍga poza koniec pliku.<br>
<br>
Moøemy teraz uøyÊ&nbsp; metody copy wobec dowolnych strumieni z
odpowiednich konkretnych klas hierarchii klas strumieniowych, np. <br>
<br>
&nbsp;&nbsp;&nbsp; Stream.copy(input, output);<br>
<br>
W≥aúnie! Po to by kopiowanie mia≥o sens input musi oznaczaÊ konkretne ürÛd≥o danych , a output ñ konkretny odbiornik danych.<br>
<br>
StrumieÒ abstrakcyjny (w ktÛrymú momencie) musi byÊ zwiπzany z konkretnym ürÛdlem bπdü odbiornikiem.<br>
<br>
W Javie jest to moøliwe g≥Ûwnie (ale nie tylko) dziÍki wprowadzeniu na kolejnych
szczeblach dziedziczenia&nbsp; omawianych czterech hierarchii (we-wy, bajty-znaki)
konkretnych klas oznaczajπcych rÛøne rodzaje ürÛd≥a/odbiornika danych. Moøna
by je nazwaÊ <b>klasami przedmiotowymi</b>, bowiem majπ one&nbsp; ustalone Ñprzedmiotyî operacji - konkretne rodzaje ürÛd≥a bπdü odbiornika. <br>
<br>



<a name="Strumienie.3"></a><h2>3. Strumieniowe klasy przedmiotowe. Wiπzanie strumieni ze ürÛd≥em/odbiornikiem</h2>



èrÛd≥a bπdü odbiorniki danych mogπ byÊ rÛønorodne. StrumieÒ moøe byÊ zwiπzany
np. z plikiem, z pamiÍciπ operacyjnπ,&nbsp; z potokiem, z URLem, z gniazdkiem
(socket)....<br>
Klasy przedmiotowe wprowadzono dla wygody operowania na konkretnych rodzajach ørÛde≥ i odbiornikÛw.<br>
<br>
<div align="center"><b>Klasy przedmiotowe<br>
<br>
</b><br>
</div>
<table border="1" cellpadding="5" width="100%" align="Center">
<tbody><tr><th>èrÛd≥o/odbiornik</th><th>Strumienie znakowe</th><th>Strumienie bajtowe</th></tr><tr><td rowspan="2"><b>PamiÍÊ</b></td><td><b>CharArrayReader,</b><br>
<b>CharArrayWriter</b></td><td><b>ByteArrayInputStream,</b><br>
<b>ByteArrayOutputStream</b></td></tr><tr><td><b>StringReader,</b><br>
<b>StringWriter</b></td><td><b>StringBufferInputStream</b></td></tr><tr><td><b>Potok</b></td><td><b>PipedReader,</b><br>
<b>PipedWriter</b></td><td><b>PipedInputStream,</b><br>
<b>PipedOutputStream</b></td></tr><tr><td><b>Plik</b></td><td><b>FileReader,</b><br>
<b>FileWriter</b></td><td><b>FileInputStream,</b><br>
<b>FileOutputStream</b></td></tr></tbody>
</table>
<div align="left">
<center></center>
<br>
Teraz juø moøemy uøyÊ przyk≥adowej (pokazanej poprzednio) klasy Stream&nbsp; np.do
kopiowania plikÛw tekstowych i do zapisu zawartoúci ≥aÒcucha znakowego do
pliku </div>
<br>
<pre>class StreamCopy1 {
  static public void main(String[] args)  {
    try {
      FileReader in1 = new FileReader("plik0.txt");
      FileWriter out1 = new FileWriter("plik1.txt");
      Stream.copy(in1, out1);
      in1.close();
      out1.close();

      String msg = "Ala ma kota";
      StringReader in2 = new StringReader(msg);
      FileWriter out2 = new FileWriter("plik2.txt");
      Stream.copy(in2, out2);
      in2.close();
      out2.close();
    } catch(IOException exc) {
      exc.printStackTrace();
    }

  }
}
</pre>
Komentarze:<br>
<ul>
  <li>jednπ z wersji konstruktorÛw klas strumieniowych zwiπzanych z plikami
sπ konstruktory, w ktÛrych podajemy jako argument nazwÍ pliku (moøna takøe
utworzyÊ strumieÒ plikowy podajπc jako argument konstruktora referenecjÍ
do obiektu klasy File), </li>
  <li>przy tworzeniu obiektÛw klas strumieniowych, zwiπzanych z plikami,
odpowiednie pliki sπ otwierane; strumienie wejúciowe sπ otwierane "tylko
do odczytu", strumienie wyjúciowe "tylko do zapisu".</li><li>strumienie
wyjúciowe mogπ byÊ otwarte w trybie dopisywania (naleøy uøyÊ konstruktora
z drugim argumentem "append mode" = true); w takim przypadku dane bÍdo dopisywane
do koÒca strumienia, <br>
  </li>

  <li>przy operacjach na strumieniach moøe powstaÊ wyjπtek klasy IOException
oznaczajπcy b≥πd operacji (np. odczytu lub zapisu), a takøe wyjπtki klas
pochodnych FileNotFoundException (brak&nbsp; pliku) oraz EOFException (w trakcie
operacji czytania lub pozycjonowania osiπgniÍto koniec pliku),</li>
  <li>przy obs≥udze wyjπtkÛw wejúcia-wyjúcia stosujemy metodÍ printStackTrace(),
ktÛra wyprowadza dok≥adne informacje o przyczynie i miejscu wystπpienia wyjπtku.</li>
</ul>
Uøycie klas przedmiotowych nie jest jedynym sposobem zwiπzania logicznego strumienia z fizycznym ürÛd≥em lub odbiornikiem.<br>
Inne klasy (spoza pakietu java.io, np. klasy sieciowe) mogπ dostarczaÊ metod,
ktÛre zwracajπ jako wynik referencjÍ do abstrakcyjnego strumienia zwiπzanego
z konkretnym ürÛd≥em odbiornikiem (np. plikiem w Sieci).<br>
<br>



<a name="Strumienie.4"></a><h2>4. Klasy przetwarzajπce (przekszta≥acanie danych w trakcie operacji na strumieniach)</h2>



Przy wykonywaniu operacji we-wy mogπ byÊ dokonywane przekszta≥cenia danych.<br>
Java oferuje nam wiele klas wyspecjalizowanych w konkretnych rodzajach automatycznego
przetwarzania strumieni. Klasy te implementujπ okreúlone rodzaje przetwarzania
strumieni, niezaleønie od rodzaju ürÛd≥a/odbiornika <br>
<br>
<table border="1" cellpadding="5" width="100%">
<tbody><tr><th>Rodzaj przetwarzania&nbsp;</th><th>Strumienie znakowe</th><th>Strumienie bajtowe</th></tr><tr><td>Buforowanie</td><td>BufferedReader,
<br>
BufferedWriter</td><td>BufferedInputStream,
<br>
BufferedOutputStream</td></tr><tr><td>Filtrowanie</td><td>FilterReader,
<br>
FilterWriter</td><td>FilterInputStream,
<br>
FilterOutputStream</td></tr><tr><td>Konwersja: bajty-znaki</td><td>InputStreamReader,
<br>
OutputStreamWriter</td><td>&nbsp;</td></tr><tr><td>Konkatenacja</td><td>&nbsp;</td><td>SequenceInputStream</td></tr><tr><td>Serializacja obiektÛw</td><td>&nbsp;</td><td>ObjectInputStream,
<br>
ObjectOutputStream</td></tr><tr><td>Konwersje danych</td><td>&nbsp;</td><td>DataInputStream,
<br>
DataOutputStream</td></tr><tr><td>Zliczanie wierszy</td><td>LineNumberReader</td><td>LineNumberInputStream</td></tr><tr><td>Podglπdanie</td><td>PushbackReader</td><td>PushbackInputStream</td></tr><tr><td>Drukowanie</td><td>PrintWriter</td><td>PrintStream</td></tr></tbody>
</table>
<center></center>
<p>Komentarze:</p>
<ul>
<li>
Buforowanie ogranicza liczbÍ fizycznych odwo≥aÒ do urzπdzeÒ zewnÍtrznych.</li><li>
Klasy Filter... sπ klasami abstrakcyjnymi, definiujπcymi interfejs dla
rzeczywistych filtrÛw. Filtrami sπ np.:</li><ul><li>
DataInputStream i DataOutputStream,</li><li>
BufferedInputStream i BufferedOutputStream,</li><li>
LineNumberInputStream,</li><li>
PushbackInputStream,</li><li>
PrintStream,</li></ul>
</ul>
<blockquote>
Moøna tworzyÊ w≥asne filtry.</blockquote>
  <ul>
<li>
Konwersje bajty-znaki</li><ul><li>
InputStreamReader czyta bajty ze strumienia definiowanego przez InputStream
(strumieÒ bajtowy) i zamienia je na znaki (16 bitowe), uøywajπc domyúlnej
lub podanej strony kodowej,</li><li>
OutputStreamWriter wykonuje przy zapisie konwersjÍ odwrotnπ.</li></ul><li>
Konkatenacja strumieni wejúciowych pozwala po≥πczyÊ strumienie i traktowaÊ
je jak jeden strumieÒ.</li><li>
Serializacja s≥uøy do "utrwalania" obiektÛw po to, by odtworzyÊ je w innym
kontekúcie (przy ponownym uruchomieniu programu lub w innym miejscu (np.
programie dzia≥ajπcym w innym miejscu sieci po przekazaniu "utrwalonego"
obiektu przez socket),</li><li> DataInputStream i DataOutputStream pozwalajπ
czytaÊ/pisaÊ dane typÛw pierwotnych (np. liczby rzeczywiste) w postaci binarnej.
Strumienie sπ tutaj strumieniami binarnymi, w zwiπzku z tym koniec strumienia
rozpoznaje siÍ jako wyjπtek EOFException.</li>
<li>
LineNumber... zlicza wiersze strumienia przy czytaniu (i pozwala w kaødym
momencie uzyskaÊ informacjÍ o numerze wiersza).</li><li>
PushBack.. pozwala podglπdnπÊ nastÍpny znak/bajt w strumieniu bez "wyciπgania" tego znaku/bajtu.</li><li>
 Klasy Print...&nbsp; zawierajπ wygodne metody wyjúcia (np. println). Niekoniecznie
oznacza to drukowanie fizyczne, czÍsto wykorzystywane jest w powiπzaniu z
innymi strumieniami po to by ≥atwo wyprowadzaÊ informacje.</li>
  </ul>
Konstruktory klas przetwarzajπcych majπ jako argument referencjÍ do obiektÛw
podstawowych klas abstrakcyjnych hierarchii dziedziczenia (InputSteram, OutputSteram,
Reader, Writer).<br>
Dlatego przetwarzanie (automatyczna transformacja) danych jest logicznie
oderwana od fizycznego strumienia, stanowi swoistπ na niego nak≥adkÍ.<br>
  <br>
Zatem zastosowanie klas przetwarzajπcych wymaga:<br>
  <ul>
    <li>stworzenia obiektu zwiπzanego z fizycznym ürÛd≥em/odbiornikiem</li>
    <li>stworzenie obiektu odpowiedniej klasy przetwarzajπcej, "na≥oøonego" na fizyczny strumieÒ.</li>
  </ul>
Przyk≥ady tego zobaczymy za chwilÍ. Przedtem jednak - dla lepszej orientacji
w gπszczu klas strumieniowych - warto przedstawiÊ ich hierarchie dziedziczenia.<br>

  

<a name="Strumienie.5"></a><h2>5. Hierarchie dziedziczenia klas strumieniowych</h2>



  <br>
Na poniøszych rysunkach pokazano hierarchiÍ klas znakowych i strumieniowych.
<br>
Zaciemnione elementy oznaczajπ klasy przedmiotowe (zwiπzane z konkretnym
ürÛd≥em/odbiornikiem), jasne - klasy przetwarzajπce (realizujπce okreúlone
rodzaje orzetwarzania).<br>
  <br>
  <p><b>Klasy dla strumieni bajtowych</b>
</p>
  <p><img style="border: 1px solid ; width: 458px; height: 199px;" src="images/bsclass.gif" alt="r"></p>
  <p><img style="border: 1px solid ; width: 459px; height: 142px;" src="images/bsclass2.gif" alt="r"></p>
  <p>ØrÛd≥o: Java Tutorial, Sun Microsystems 2002
<br>
&nbsp;
</p>
  <p><b>Klasy dla strumieni znakowych</b>
</p>
  <p><img style="border: 1px solid ; width: 462px; height: 170px;" src="images/csclass.gif" alt="r"></p>
  <p><img style="border: 1px solid ; width: 462px; height: 198px;" src="images/csclass2.gif" alt="r"></p>
ØrÛd≥o: Java Tutorial, Sun Microsystems 2002<br>
  <br>
  <br>

  

<a name="Strumienie.6"></a><h2>6. Buforowanie</h2>



Buforowanie ogranicza liczbÍ fizycznych odwo≥aÒ do urzπdzeÒ zewnÍtrznych,
dziÍki temu, øe fizyczny odczyt lub zapis dotyczy ca≥ych porcji danych, gromadzonych
w buforze (wydzielonym obszarze pamiÍci). Jedno fizyczne odwo≥anie wczytuje
dane ze strumienia do bufora lub zapisuje zawartoúÊ bufora do strumienia.
W naszym programie operacje czytania lub pisania dotyczπ w wiÍkszoúci bufora
(dopÛki sπ w nim dane lub dopÛki jest miejsce na dane) i tylko niekiedy&nbsp;
powodujπ fizyczny odczyt&nbsp;(gdy bufor jest pusty) lub zapis (gdy bufor jest
pe≥ny).<br>
  <br>
Np. przy czytaniu duøych plikÛw tekstowych naleøy unikaÊ bezpoúredniego czytania
za pomocπ klasy FileReader. To samo dotyczy zapisu.<br>
Zastosowanie klasy BufferedReader (czy BufferedWriter) powinno przynieúÊ poprawÍ efektywnoúci dzia≥ania programu.<br>
Ale klasa BufferedReader (BufferedWriter) jest klasπ przetwarzajπcπ, a wobec tego w jej konstruktorze
nie moøemy bezpoúrednio podaÊ fizycznego ürÛd≥a danych. <br>
  <br>
Np. przy czytaniu plikÛw ürÛd≥o to podajemy przy konstrukcji obiektu typu FileReader, a po to, øeby
uzyskaÊ buforowanie, "opakowujemy" FileReadera BufferedReaderem. <br>
  <br>
Wyglπda to mniej wiÍcej tak: <br>
  <pre>FileReader fr = new FileReader("plik.txt");   // tu powstaje zwiπzek
                                              // z fizycznym ürÛd≥em

BufferedReader br = new BufferedReader(fr);    // tu dodajemy "opakowanie"
                                               // umoøliwiajπce buforowanie
// czytamy wiersz po wierszu
String line;
while  ((line = br.readLine()) != null) {      // kolejny wiersz pliku:
                                               // metoda readLine zwraca wiersz
                                               // lub null jeúli koniec pliku
   // ... tu coú robimy z odczytanym wierszem
}
</pre>
Uwagi.<br>
  <ul>
    <li>
w konstruktorach klas Buffered... moøemy podaÊ rozmiar bufora. Domyúlny rozmiar jest wystarczajπcy dla codziennych zastosowaÒ.</li>
    <li>w klasie BufferedReader zdefiniowano wygodnπ metodÍ readLine(), umoøliwiajπca czytanie pliku tekstwoego wiersz po wierszu. </li>
  </ul>


Przyk≥ad buforowania: program, czytajπcy plik tekstowy i zapisujπcy jego zawartoúc do innego pliku wraz z numerami wierszy.<br>
  <br>
  <pre>import java.io.*;

class Lines {
	
  public static void main(String args[]) {
    try {
      FileReader fr = new FileReader(args[0]);
      LineNumberReader lr = new LineNumberReader(fr);
      BufferedWriter bw = new BufferedWriter(
                              new FileWriter(args[1]));

      String line;
      while  ((line = lr.readLine()) != null) {
        bw.write( lr.getLineNumber() + " " + line);
        bw.newLine();
      }
      lr.close();
      bw.close();
    } catch(IOException exc) {
        System.out.println(exc.toString());
        System.exit(1);
   }

  }
}
</pre>
Komentarze:<br>
  <ul>
    <li>klasa LineNumberReader dziedziczy klasÍ BufferedReader, dajπc moøliwoúÊ
prostego uzyskiwania informacji o numerze bieøπcego wiersza (metoda getLineNumner(),</li>
    <li>zastosowanie metody newLine() z klasy BufferedWriter pozwala w niezaleøny
od platformy systemowej sposÛb zapisywaÊ separatory wierszy,</li>
    <li>przy zamkniÍciu wyjúciowego strumienia buforowanego zawartoúÊ bufora
jest zapisywana do strumienia; istnieje teø metoda <b>void flush( )</b>, zapisujπce
dane ktÛre pozosta≥yw buforze a nie zosta≥y jeszcze zapisane w miejscu przeznaczenia;
takie "rÍczne" oprÛønianie bufora jest czasem przydatne. <br>
      <br>
    </li>
  </ul>

  

<a name="Strumienie.7"></a><h2>7. Strumienie binarne</h2>



Klasy przetwarzajπce DataInputStream i&nbsp; DataOutputStream s≥uøπ do odczytu/zapisu
danych typÛw pierwotnych&nbsp;w postaci binarnej (oraz ≥aÒcuchÛw znakowych).
  <br>
  <br>
Metody tych klas majπ postaÊ:<br>
  <br>
  <b>typ readTyp( )&nbsp;&nbsp; <br>
void writeTyp(typ arg)<br>
  </b><br>
gdzie typ odpowiada nazwie ktÛregoú z typÛw pierwotnych<br>
Mamy wiÍc np. metody readInt(),&nbsp; readDouble() itp.<br>
  <br>
Dane typu String mogπ byÊ zapisywane/czytane do/z strumieni binarnych za pomocπ metod writeUTF i readUTF.<br>
  <br>
Dla przyk≥adu, stwÛrzmy klasÍ Obs, ktÛrej obiekty reprezentujπ obserwacje.
Kaøda obserwacaja ma nazwÍ oraz odpowiadajπcy jej ciπg (tablicÍ) liczb rzeczywistych.
Moøe to byÊ np. MAX_TEMPERATURA z 12 liczbami, pokazujπcymi maksymalnπ temperaturÍ
w 12 miesiπcach roku. <br>
W klasie tej zdefiniujemy takøe dwie metody, sluøπce do zapisu obserwacji
w postaci binarnej do strumienia i odczytywania binarnych strumieni obserwacji.<br>
  <br>
  <pre>import java.io.*;

class Obs {
  String name;
  double[] data;

  public Obs() {}

  public Obs(String nam, double[] dat) {
    name = nam;
    data = dat;
  }

  public void writeTo(DataOutputStream dout)
         throws IOException  {
    dout.writeUTF(name);
    dout.writeInt(data.length);
    for (int i=0; i&lt;data.length; i++) dout.writeDouble(data[i]);
  }

  public Obs readFrom(DataInputStream din)
         throws IOException {
    name = din.readUTF();
    int n = din.readInt();
    data = new double[n];
    for (int i=0; i&lt;n; i++) data[i] = din.readDouble();
    return this;
  }

  public void show() {
    System.out.println(name);
    for (int i=0; i&lt;data.length; i++) System.out.print(data[i] + " ");
    System.out.println("");
  }
}
</pre>
ZwrÛÊmy uwagÍ, øe przyjÍliúmy nastÍpujπcy format zapisu obserwacji w pliku binarnym:<br>
nazwa<br>
liczba_elementÛw_tablicy<br>
dane_tablicy.<br>
  <br>
DziÍki temu, metoda readFrom bez k≥opotu moøe odczytywaÊ dowolne obserwacje
z dowolnych plikÛw binarnych, pod warunkiem, øe pliki te majπ podany format.<br>
&nbsp;<br>
  <br>
Przyk≥ad wykorzystania klasy: tworzymy dwie obserwacje, pokazujemy jak wyglπdajπ
(show) zapisujemy je do pliku (writeTo(out)), po czym z tego samego pliku
odczytujemy dane do innych (ad hoc tworzonych) obiektÛw-obserwacji i jednoczeúnie
pokazujemy odczytane dane na konsoli (new Obs().readFrom(in).show()).<br>
  <br>
  <pre>class BinDat {
	
  public static void main(String args[]) {
    double[] a = { 1, 2, 3, 4 };
    double[] b = { 7, 8, 9, 10 };

    Obs obsA = new Obs("Dane A", a);
    Obs obsB = new Obs("Dane B", b);

    obsA.show();
    obsB.show();

    try {
      DataOutputStream out = new DataOutputStream(
                                 new FileOutputStream("dane")
                                 );
      obsA.writeTo(out);
      obsB.writeTo(out);
      out.close();

      DataInputStream in = new DataInputStream(
                                 new FileInputStream("dane")
                                 );
      new Obs().readFrom(in).show();
      new Obs().readFrom(in).show();
      in.close();
      } catch (IOException exc) {
        exc.printStackTrace();
        System.exit(1);
        }


  }
}
</pre>
  <br>
  <br>
  <br>

  

<a name="Strumienie.8"></a><h2>8. Kodowanie</h2>



Java pos≥uguje siÍ znakami w formacie Unicode. Sπ to - ogÛlnie - wielkoúci 16-bitowe. <br>
årodowiska natywne (np. Windows) najczÍúciej zapisujπ teksty jako sekwencje bajtÛw (z przyjÍtπ stronπ kodowπ). <br>
Jak pogodziÊ najczÍúciej bajtowy charakter plikÛw natywnych ze znakowymi strumieniami? <br>
OtÛø strumienie znakowe potrafiπ - niewidocznie dla nas -&nbsp; przekszta≥caÊ
bajtowe ürÛd≥a w znaki Unikodu i odwrotnie. "Pod pokrywkπ" tego procesu znajdujπ
siÍ dwie klasy: <b>InputStreamReader</b> i <b>OutputStreamWriter</b>, ktÛre dokonujπ w≥aúciwych konwersji w trakcie czytania/pisania. <br>
  <br>
Klasy te moøemy wykorzystaÊ rÛwnieø samodzielnie. <br>
Jeúli w konstruktorach tych klas nie podamy strony kodowej - przy konwersjach zostanie przyjÍta domyúlna strona kodowa. <br>
Aby siÍ dowiedzieÊ, jakie jest domyúlne kodowanie moøna uøyÊ nastÍpujπcego programiku:<br>
  <br>
  <pre>public class DefaultEncoding {
      public static void main(String args[])
      {
        String p = System.getProperty("file.encoding");
        System.out.println(p);
      }  &nbsp;
}

</pre>
  <p>W zaleønoúci od ustawieÒ na danej platformie otrzymamy rÛøne wyniki.
Np. ibm-852 lub Cp852 (Latin 2) albo Cp1252 (Windows Western Europe / Latin-1).
</p>
Inna wersja konstruktorÛw pozwala na podanie stron kodowych, ktÛre bÍdπ uøywane do kodownia i dekodowania bajty-znaki .
<br>
Napiszmy program wykonujπcy konwersje plikÛw z-do dowolnych (dopuszczalnych
przez JavÍ) formatÛw kodowania.
<br>
Dopuszczalne symbole kodowania moøna znaleüÊ na stronach java.sun.com.
<br>
  <br>
  <pre>import java.io.*;

class Convert {

  public static void main(String[] args) {

    if (args.length != 4) {
      System.out.println("Syntax: in in_enc out out_enc");
      System.exit(1);
    }

    String infile  = args[0],     // plik wejúciowy
           in_enc  = args[1],     // wejúciowa strona kodowa
           outfile = args[2],     // plik wyjúciowy
           out_enc = args[3];     // wyjúciowa strona kodowa

    try {
       FileInputStream fis = new FileInputStream(infile);
       BufferedReader in = new BufferedReader(new InputStreamReader(fis, in_enc));
       FileOutputStream fos = new FileOutputStream(outfile);
       BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, out_enc));
       String line;
       while ((line = in.readLine()) != null) {
         out.write(line);
         out.newLine();
       }
       in.close();
       out.close();
    } catch (IOException e) {
        System.err.println(e);
        System.exit(1);
    }

  }
}
</pre>
  <br>
  <p>Przyk≥adowe wykorzystanie do konwersji pliku zle.htm (zapisanego w Windows
1250) na plik dobrze.htm ( ISO-8859-2):
</p>
&nbsp;&nbsp;&nbsp; &nbsp;java Convert zle.htm Cp1250 dobrze.htm ISO8859_2
<br>
  <br>
  O innych sposobach kodowania i dekodowania danych wejúciowo-wyjúciowych
- zob. punkt dotyczπcy "nowego wejúcia-wyjúcia" (java.nio).<br>

  

<a name="Strumienie.9"></a><h2>9. Serializacja obiektÛw</h2>



  Obiekty&nbsp; tworzone przez program&nbsp; rezydujπ w pamiÍci operacyjnej, w przestrzeni adresowej procesu.<br>
Sπ zatem nietrwa≥e, bo kiedy program koÒczy dzia≥anie wszystko co znajduje
siÍ w jego przestrzeni adresowej ulega wyczyszczeniu i nie moøe byÊ odtworzone.<br>
  <br>
  <b>Serializacja</b> (szeregowanie) pozwala na <b>utrwalaniu</b> obiektÛw. <br>
W Javie polega ona na <b>zapisywaniu obiektÛw do strumienia</b>.

  <p>
</p>


  <table bgcolor="#ccffff" border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td><br>
        <div align="center">Podstawowe zastosowania serializacji:

<br>
        </div>
        <ul>
          <li>komunikacja pomiÍdzy obiektami/aplikacjami poprzez gniazdka (sockets),</li>
          <li>
zachowanie obiektu (jego stanu i w≥aúciwoúci) do pÛüniejszego odtworzenia i wykorzystania
przez tÍ samπ lub innπ aplikacjÍ.</li>
        </ul>
        <br>
</td></tr></tbody>
  </table>
  <br>
Do zapisywania/odczytywania obiektÛw s≥uøπ klasy <b>ObjectOutputStream</b>
oraz <b>ObjectInputStream,</b> ktÛre naleøπ do strumieniowych klas przetwarzajπcych.<br>
  <br>
<div class="syntax"><br>
Metoda klasy ObjectInputStream:<br>
  <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>void writeObject(Object o)</b>&nbsp; zapisuje obiekt o do strumienia<br>
  <br>
Metoda klasy ObjectInputStream:<br>
  <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<b>Object readObjectO</b> &nbsp; odczytuje obiekt ze strumienia i zwraca referencjÍ do niego<br>
</div> &nbsp;&nbsp;&nbsp; <br>
  <br>
  <p></p><div class="important">Do strumieni mogπ byÊ zapisywane tylko <b>serializowalne</b> obiekty.<br>
Obiekt jest serializowalny jeúli jego klasa implementuje interfejs Serializable</div>
Prawie wszystkie klasy standardowych pakietÛw Javy implementujπ ten interfejs.<br>
RÛwnieø tablice (ktÛre sπ obiektami specjalnych klas definiowanych w trakcie kompilacji) sπ serializowalne.<br>
  <br>
Zatem bez problemu moøemy utrwalaÊ obiekty wiÍkszoúci klas standardowych Javy oraz tablice.<br>

  Przyk≥ad: program zapisuje do strumienia obiekty - datÍ, tablicÍ opisÛw
i odpowiadajπcπ kaødemu opisowi temperaturÍ. NastÍpnie odczytuje te obiekty
ze strumienia i odtwarza je.<br>
  <br>
  <pre>import java.io.*;
import java.util.*;

class Serial {
	
  public static void main(String args[]) {

    Date data = new Date();
    int[] temperatura = { 25,&nbsp;19 , 22};
    String[] opis = { "dzieÒ", "noc", "woda" };

    // Zapis
    try {

      ObjectOutputStream out = new ObjectOutputStream(
                                 new FileOutputStream("test.ser")
                                 );
      out.writeObject(data);
      out.writeObject(opis);
      out.writeObject(temperatura);
      out.close();
    } catch(IOException exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    // Odtworzenie (zazwyczaj w innym programie)
    try {
      ObjectInputStream in = new ObjectInputStream(
                                 new FileInputStream("test.ser")
                                );
      Date odczytData = (Date) in.readObject();
      String[] odczytOpis = (String[]) in.readObject();
      int[] odczytTemp = (int[]) in.readObject();
      in.close();
      System.out.println(String.valueOf(odczytData));
      for (int i=0; i&lt;odczytOpis.length; i++)
          System.out.println(odczytOpis[i] + " " + odczytTemp[i]);

    } catch(IOException exc) {
        exc.printStackTrace();
        System.exit(1);
    } catch(ClassNotFoundException exc) {
        System.out.println("Nie moøna odnaleüÊ klasy obiektu");
        System.exit(1);
    }

  }

}
</pre>
Przyk≥adowy wydruk programu.<br>
<div class="listing100"><br>
Wed Jan 15 18:30:17 CET 2003<br>
dzieÒ 25<br>
noc 19<br>
woda 22<br>
</div><br>
  <br>
Metoda readObject() pobiera ze strumienia zapisane charakterystyki obiektu
(w tym rÛwnieø oznaczenie klasy do ktÛrej naleøy zapisany obiekt) - na ich
podstawie tworzy nowy obiekt tej klasy i inicjuje go odczytanymi wartoúciami.
Wynikiem jest referencja formalnego typu Object wskazujπca na nowoutworzony
obiekt, ktÛry jest identyczny z zapisanym.&nbsp; <br>
Poniewaø wynikiem jest Object, nalezy&nbsp; wykonaÊ odpowiedniπ konwersjÍ
zawÍøajπcπ do w≥aúciwego typu (referencji do konkretnej podklasy klasy Object,
tej mianowicie, ktÛrej egzemplarzem faktycznie jest odczytany obiekt). <br>
 Moøe siÍ teø okazaÊ, øe w strumieniu zapisano obiekt klasy, ktÛra nie jest
dostÍpna przy odczytywaniu (np. zosta≥a usuniÍta). Wtedy przy tworzeniu obiektu
z odczytanych danych powstanie wyjπtek ClassNotFoundException, ktÛry musimy
obslugiwaÊ.<br>
  <br>
A jak serializowaÊ obiekty w≥asnych klas?<br>
Odpowiedü juø znamy: klasa winna implementowaÊ interfejs Serializable.<br>
  <br>
<div class="notel">Takie interfejsy (bez metod) nazywane sπ interfejsami znacznikowymi. Ich
jedynπ funkcjπ jest umoøliwienie sprawdzenia typu np. za pomocπ operatora
instanceof. Metoda writeObject to w≥asnie robi, gdy podejmuje decyzje o zapisie:
jeúli jej argument x jest typu Serializable (x instanceof Serializable ma
wartoúc true), to obiekt jest zapisywany do strumienia, w przeciwnym razie
- nie</div>Rzecz nie jest trudna, bowiem interfejs ten jest pusty - nie musimy
wiÍc implementowaÊ øadnych jego metod, wystarczy tylko wskazaÊ, øe nasza
klasa implementuje interfesj Serializable.<br>
  <br>
Zobaczmy to na przykladzie nieco bardziej praktycznego zastosowania serializacji.<br>
Przypomnijmy sobie klasÍ TravelSearcher z poprzedniego semestru. Sluøy≥a
ona do zgromadzenia w tablicy obiektÛw klasy Travel, opisujπcych destynacje
(napis, np. Cypr) i ceny podrÛøy (liczba ca≥kowita, np. 1500) oraz dostarcza≥a
metody wyszukiwania informacji o cenie na podstawie podanej destynacji.<br>
Klasa Travel jest bardzo prosta:<br>
  <pre>public class Travel&nbsp;... {

   private String dest; // destynacja podrÛzy
   private int price;   // cena

   public Travel(String s, int p) {
     dest = s;
     price = p;
   }

   public String getDest() { return dest; }
   public int getPrice() { return price; }
   public String toString() { return dest + ", cena: " + price; }

}
</pre>
  <br>
Schemat klasy TravelSearcher przedstawiono poniøej:<br>
  <pre>public class TravelSearcher ... {

  private Travel[] travel;            // tablica podrÛøy
  private int lastIndex = -1;         // indeks ostatnio zapisanej
  private final int MAX_COUNT = 5;    // max rozmiar tablicy
  private boolean sorted = false;     // czy jest posortowana

  // Konstruktor: tworzy tablicÍ
  public TravelSearcher() {
    travel = new Travel[MAX_COUNT];
  }

  // Metoda add dodaje nowy element do tablicy
  // jeøeli przekrozcono zakres
  // - zg≥aszany jest wyjπtek w≥asnej klasy NoSpaceForTravelException
  public void add(Travel t) throws NoSpaceForTravelException {
    try {
      lastIndex++;
      travel[lastIndex] = t;
    } catch (ArrayIndexOutOfBoundsException exc) {
        lastIndex--;
        throw new NoSpaceForTravelException("Brakuje miejsca dla dodania podrÛøy");
    }
    sorted = false;
  }

  // Jaki jest ostatni zapisany indeks
  public int getLastIndex() { return lastIndex; }


  // Wyszukiwanie podrÛøy na podstawie podanego celu (destynacji)
  public Travel search(String dest) {
    if (!sorted) sortByDest();
    // ... wyszukiwanie binarne
  }

  // Sortowanie - aby moøna by≥o stosowaÊ wyszukiwanie binarne
  private void sortByDest() {
    // ... sortowanie
    sorted = true;
  }

  public String toString() {
    // zwraca spis podrÛøy z tablicy travel (destynacji i cen)
  }

}
</pre>
  <br>
Wyobraümy sobie, øe w innej klasie dostarczamy jakiú interfejs uøytkownika,
umoøliwiajπcy wprowadzanie informacji o podrÛøach i na tej podstawie tworzenie
obiektÛw klasy Travel oraz wpisywanie ich do tablicy w klasie TravelSearcher.<br>
Informacje podawane sπ na bieøπco (w jakichú oknach dialogowych) i zapisywane
j dodawane do tablicy travel w klasie TravelSearcher.<br>
W trakcie dzialania tego programu moøemy zapewniÊ wyszuskiwanie informacji
o wpisanych podrÛøach. Ale gdy program zakoÒczy dzia≥anie - obiekt klasy
TravelSearcher, a co za tym idzie cala tablica informacji o podrÛøach - zniknπ.<br>
Moøemy temu zaradziÊ zapewniajπc zapis informacji do pliku. Jeúli zastosujemy
zwyk≥e strumienie (np. znakowe), to - oczywiúcie - w doúÊ prosty sposÛb moøemy
zapisaÊ do pliku listÍ podrÛøy i wprowadziÊ jπ znowu przy ponownym uruchomieniu
aplikacji.<br>
  <br>
Duøo proúciej jednak bÍdzie zapisaÊ &nbsp;do strumienia obiekt klasy TravelSearcher.<br>
Dodatkowo zyskamy ca≥kowite odtworzenie stanu aplikacji (obiektu TravelSearcher)
zapamiÍtanego przy poprzednim jej uruchomieniu. A ten stan, to nie tylko
tablica wycieczek, ale rÛwnieø istotne dla dzialania aplikacji wartoúci indeksu
ostatniego zapisanego elementu tablicy oraz zmiennej <i><b>sorted</b></i> pokazujπcej czy tablica jest posortowana.<br>
  <br>
Zatem naleøy zagwarantowaÊ serializowalnoúÊ obiektÛw klasy TravelSearcher
oraz - w g≥Ûwnej aplikacji (okreúlajπcej interfejs uøytkownika) zapewniÊ
ich serializacjÍ poprzez uøycie metody writeObject oraz odtwarzanie - za
pomoca metody readObject.<br>
  <br>
Napiszemy wiÍc na pewno:<br>
  <br>
<div class="notec"><b>public class TravelSearcher implements Serializable {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ...<br>
}</b></div><br>
  <br>
Czy to wystarczy? ZwrÛÊmy uwagÍ, øe polem klasy TravelSearcher jest tablica
referencji do obiektÛw klasy Travel. Tablice - jak widzieliúmy poprzednio
- zapisujπ siÍ do strumieni obiektowych bez k≥opotu. A co z obiektami klasy
Travel, na ktÛre wskazujπ elementy tablicy?<br>
  <br>
SzczÍúliwie:<br>
  <br>
<div class="important"><b>Przy serializacji zapisywany i odtwarzany jest pe≥ny stan obiektu (w tym - rekursywnie - obiektÛw
sk≥adowych). </b></div>
  <p>Ale nie sπ&nbsp; zapisywane <b>stany</b> obiektÛw sk≥adowych, ktÛre naleøπ do
klas <b>nieserializowalnych</b>. Bo choÊ pola, odpowiadajπce tym obiektom sπ zapisywane, to przy odtwarzaniu, takie obiekty sπ tworzone
za pomocπ konstruktorÛw bezparametrowych z ich klas i nie ma øadnej innej inicjacji ich elementÛw. </p>
  <p>Musimy zatem zapewniÊ rÛwnieø serializacjÍ obiektÛw klasy Travel:<br>
</p><div class="notec"><b>public class Travel implements Serializable {<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ...<br>
}</b></div><br>
  
  <p><br>
  </p>
Po tych poprawkach, klas TravelSearcher i Travel moøemy uøyÊ w przykladowej
aplikacji, stanowiπcej interfejs uøytkownika do wprowadzania, wyszukiwania,
zapisywania i lstowania podrÛøy.<br>
  <p>Argumentem aplikacji jest plik "kartoteka", ktÛry zawiera lub bÍdzie
zawiera≥ utrwalony obiekt klasy TravelSearcher. Jeøeli taki plik juø istnieje,
to informacje o wycieczkach sπ z niego odtwarzana za pomoca deserializacji
utrwalonego obiektu. Uøytkownik ma do wyboru rÛøne tryby dzia≥ania (np. wprowadzanie nowych
danych, ich wyszukiwanie i - oczywiúcie - utrwalenie.<br>
  </p>
Pokazuje to poniøszy program.<br>
Przy okazji warto zwrÛciÊ uwagÍ na sposoby oprogramowania dialogow wyboru
(zastosowane tu postaci metod z klasy JOptionPane bÍdπ wyjaúnione w nastÍpnych
wyk≥adach; juø teraz moøna jednak samodzielnie zapoznaÊ siÍ z nimi na podstawie
dokumentacji).
  <p></p>
  <pre>import java.io.*;
import java.util.*;
import javax.swing.*;

public class TravelApp {

  private String travFileName;
  private TravelSearcher travels;
  private boolean dataSaved = false;

  public TravelApp(String[] tfn) {
    try {
      travFileName = tfn[0];
      ObjectInputStream in = new ObjectInputStream(
                                 new FileInputStream(travFileName)
                             );
      travels = (TravelSearcher) in.readObject();
      in.close();

    } catch(ArrayIndexOutOfBoundsException exc) {
        showMsg("Syntax: java TravelApp plik_kartoteki");
        System.exit(1);

    } catch(FileNotFoundException exc) {
        showMsg("Nowa kartoteka!!!");
        travels = new TravelSearcher();

    } catch(IOException exc) {
        exc.printStackTrace();
        System.exit(2);

    } catch(ClassNotFoundException exc) {
       showMsg("Brak klasy dostÍpu do klasy TravelSearcher");
       System.exit(3);
    }

    String[] modes = { "Wprowadzanie", "Szukanie", "Zapis", "Pokaz", "Koniec" };
    while (true) {
      switch ( select("Wybierz tryb dzia≥ania", modes)) {
        case 'W' : inputData(); break;
        case 'S' : searchData(); break;
        case 'Z' : saveData(); break;
        case 'P' : showData(); break;
        case 'K' : finish(); break;
        default : break;
      }
    }
  }

  private char select(String msg, String[] modes) {
    int sel = JOptionPane.showOptionDialog(null, msg,
                         "Travel App", 0, JOptionPane.QUESTION_MESSAGE,
                          null, modes, modes[1]);
    if (sel == JOptionPane.CLOSED_OPTION) return 0;
    return modes[sel].charAt(0);
  }

  public void inputData() {
    String data = "";
    String msg = "Wprowadü dane";
    while((data = ask(msg, data)) != null) {
      StringTokenizer st = new StringTokenizer(data);
      try {
        String dest = st.nextToken();
        int price = Integer.parseInt(st.nextToken());
        travels.add(new Travel(dest, price));
        dataSaved = false;
      } catch(NoSpaceForTravelException exc) {
          showMsg(exc.getMessage());
          return;
      } catch(Exception exc) {
          msg = "Dane wadliwe - popraw";
          continue;
      }

      msg = "Wprowadü dane";
      data = "";
    }
  }

  public void searchData() {
    if (travels.getLastIndex() &gt;= 0) {
      String dest = "";
      String msg = "Podaj miejsce podrÛøy";
      while((dest = ask(msg, "")) != null) {
        Travel t = travels.search(dest);
        String info = (t == null ? "Nie ma takiej podrÛøy!" : t.toString() );
        showMsg(info);
      }
    }
    else showMsg("Nie ma øadnych danych do przeszukiwania!");
  }

  public void saveData() {
    ObjectOutputStream out = null;
    try {
      out = new ObjectOutputStream(
                new FileOutputStream(travFileName)
                );
      out.writeObject(travels);
    } catch(IOException exc) {
        showMsg(exc.getMessage());
    } finally {
        try { out.close(); } catch (Exception exc) {}
    }
    dataSaved = true;
  }

  public void showData() {
    System.out.println("Dane\n" + travels);
  }

  public void finish() {
    while (!dataSaved) {
      char ans = select("Czy zapisaÊ dane?", new String[] { "Tak", "Nie" } );
      if (ans == 'T')  saveData();
      else if (ans == 'N') break;
    }
    System.exit(0);
  }

  private void showMsg(String msg) {
    JOptionPane.showMessageDialog(null, msg);
  }

  private String ask(String msg, String initVal) {
    return JOptionPane.showInputDialog(null, msg, initVal);
  }

  public static void main(String[] args) {
    new TravelApp(args);
  }

}
</pre>
  <p><b><br>
  </b>Na koniec warto powiedzieÊ, øe:<b><br>
  </b></p>
  <ul>
    <li>przy serializacji <b>nie</b> sπ zapisywane <b>pola statyczne</b> oraz pola deklarowane
ze specyfikatorem
<b>transient</b>; specyfikatora transient uøywamy wiÍc wobec elementÛw informacji o obiekcie, ktÛrych nie chcemy poddawaÊ utrwaleniu.</li>
    <li>pe≥niejszπ kontrolÍ nad sposobem serializacji moøemy zyskaÊ definiujπc
odpowiednie metody w klasie obiektu serializowanegoo, metody te winny mieÊ
nastÍpujπce sygnatury:</li>
  </ul>


  <pre> private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException;
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException
 </pre>
  <ul>
    <li>calkowitπ kontrolÍ nad formatem i sposobem serializacji zyskujemy
poprzez implementacjÍ w klasie interfejsu Externalizable i dostarczenie metod
writeExternal i  readExternal</li>
  </ul>
  <br>
  

<a name="Strumienie.10"></a><h2>10. Potoki</h2>

<div class="def">Potoki s≥uøπ do przesy≥ania danych pomiÍdzy rÛwnolegle dzia≥ajπcymi wπtkami.</div><br>
<br>
Wπtek produkujπcy dane zapisuje je do potoku wyjúciowego (<b>PipedWriter</b> lub <b>PipedOutputStream</b>).<br>
Potok ten za pomocπ konstruktorÛw potokowych klas wejúciowych (<b>PipedReader</b> i <b>PipedInputStream</b>) moøna przy≥πczyÊ do strumienia wejúciowego, z ktÛrego inny watek bÍdzie czyta≥ dane.<br>
  <br>
Niech na przyklad obiekt-wπtek klasy DataPutter produkuje jakieú dane i umieszcza
je w strumieniu wyjúciowym, do ktÛrego referencjÍ otrzymuje konstruktor.<br>
  <br>
  <pre>class DataPutter extends Thread {

  OutputStream out;

  public DataPutter(OutputStream o) {
    out = o;
  }

  public void run() {
    try {
      for (char c = 'a'; c &lt;= 'z'; c++) out.write(c);
      out.close();
    } catch(IOException exc) { return; }

  }
}
</pre>
  <br>
a obiekt-wπtek klasy DataGetter, odczytuje jakieú dane ze strumienia i wypisuje je na konsoli.<br>
  <br>
  <pre>class DataGetter extends Thread {

  InputStream in;

  public DataGetter(InputStream i) {
    in = i;
  }

  public void run() {
    try {
      int c;
      while ((c = in.read()) != -1) System.out.println((char) c);
    } catch(IOException exc) { return; }
  }
}
</pre>
  <br>
Za pomocπ potoku moøemy po≥πczyÊ wyjúciowy strumieÒ, do ktÛrego pisze DataPutter
z wejúciowym strumieniem czytanym przez DataGetter.<br>
  <br>
W tym celu zwiπøemy strumieÒ wyjúciowy, do ktÛrego ma pisaÊ DataPutter z potokiem:
  <pre>PipedOutputStream pout = new PipedOutputStream();
</pre>
i potok ten po≥πczymy ze strumieniem wejúciowym, z ktÛrego bÍdzie czyta≥ DataGetter.&nbsp; <br>
  <br>
  <pre>    <b>PipedInputStream pin = new PipedInputStream(pout);</b></pre>
  <br>
Po uruchomieniu obu watkÛw:<br>
  <br>
  <pre>class Main {
  public static void main(String[] args) throws IOException {
    PipedOutputStream pout = new PipedOutputStream();
    PipedInputStream pin = new PipedInputStream(pout);
    new DataPutter(pout).start();
    new DataGetter(pin).start();
  }
}
</pre>
uzyskamy oczekiwany wynik: produkowanie przez jeden z nich danych i przesylanie ich potokiem do drugiego wπtku.<br>
Uwaga: przy pisaniu/czytaniu znakÛw Unikodu naleøy stosowaÊ klasy PipeWriter i&nbsp; PipeReader.<br>
  <br>
Podstawowπ zaletπ potokÛw jest to, iø umoøliwiajπ one uproszczenie komunikacji
pomiÍdzy wπtkami. Wπtek zapisuje dane do potoku i o nic wiÍej nie musi dbaÊ.
Inny wπtek czyta dane z potoku za pomocπ zwyklego read(), na ktÛrym - ew.
jest blokowany, jeúli danych jeszcze nie ma. Nie musimy martwiÊ siÍ o synchronizacjÍ
i koordynacjÍ dzialania wπtkÛw. Samo pisanie i czytanie danych za pomocπ
potokÛw takπ synchronizacjÍ i koordynacje juø zapewnia.&nbsp; <br>
  <br>
Przyk≥ad-zadanie:<br>
Wπtek-Autor pisze teksty, skladajπc losowo wybrane s≥owa w wiersze o losowo
wybranej liczbie s≥Ûw. Wiersze te pobiera wπtek-Duplikator i rozdysponowuje
je do wielu wπtkÛw-przepisywaczy (TxtWriter), Kaødy z przepisywaczy rÛwnolegle&nbsp;
wypisuje tekst Autora w przydzielonynym mu miejscu (nazwiemy je SpaceToWrite).&nbsp;
  <br>
  <br>
Poniøej pokazano moøliwe rozwiπzanie. Klasy sπ bardzo szczegÛ≥owo komentowane,
zatem dodatkowy opis programu ograniczymy do minimum.<br>
  <br>
Klasa Author zzapewnie generowanie tekstÛw autora. Sπ one tworzone w wπtku
g≥Ûwnym programu, zatem nie dostarczyliúmy tu metody run().<br>
  <br>
  <pre>import java.io.*;
import java.util.*;

public class Author {

  private int linesToWrite;    // ile wierszy ma napisac autor
  String[] words;              // z jakich slÛw siÍ bÍdπ sk≥adaÊ
  private Writer out;          // strumieÒ do ktÛrego zapisuje teksty
  static final int N = 5;      // maksymalna liczba s≥Ûw w wierszu

  public Author(int l, String[] words, Writer w) {
    linesToWrite = l;
    this.words = words;
    out = w;
    try {
      write();                  // wywo≥anie pisania
    } catch(IOException exc) {
        System.out.println(exc.toString());
    } catch(InterruptedException exc) {}
  }

  // Metoda pisania przez autora
  public void write() throws IOException,
                             InterruptedException {
    Random rand = new Random();
    for (int i=0; i &lt; linesToWrite; i++) {

      // Kaødy wiersz sk≥ada siÍ z losowo wybranej nw liczby s≥Ûw
      int nw = rand.nextInt(N) + 1;
      String line = "";

      for (int k=0; k&lt;nw; k++) {   // s≥owa sπ losowane z tablicy words
        int wordNum = rand.nextInt(words.length);
        line += words[wordNum] + " ";
      }
      out.write(line);
      out.write('\n');
      Thread.sleep((rand.nextInt(3) + 1) * 1000);  // autor myúi nad
    }                                              // nastÍpnym wierszem :-)
    out.write("Koniec pracy\n");
    out.close();
    System.out.println("Autor skoÒczy≥ pisaÊ");
  }
}&nbsp;</pre>
Kaødy z przepisywaczy (klasa TxtWriter)&nbsp;stanowi odrÍbny wπtek, czyta teksty
ze strumienia&nbsp; wypisuje je w miejscu okreúlonym przez przekazany konstruktorowi
obiekt SpaceToWrite. Generalnie moøe to byÊ cokolwiek, na czym bÍdzie widaÊ
tekst. Jak zobaczymy dalej - w tym programie zastosujemy wielowierszowe pola
edycyjne umieszczone w jednym oknie (po jednym polu dla kaødego z przepisywaczy).<br>
  <br>
  <pre>import java.io.*;

public class TxtWriter extends Thread {  // Klasa przepisywacza

  private LineNumberReader in;   // strumieÒ skπd czyta
  private SpaceToWrite spw;      // miejsce gdzie pisze

  public TxtWriter(String name,      // nazwa przepisywacza
                   Reader in_,       // z jakiego strumeinia czyta
                   SpaceToWrite spw_ // gdzie pisze
                   )
  {
    super(name);
    in = new LineNumberReader(in_);  // filtrowanie strumienia
                                     // by mieÊ numery wierszy
    spw = spw_;
  }

  // Kod wπtku przepisywacza
  // czyta wiersze ze strumienia wejúciowego
  // i zapisuje je w miejscu oznaczanym spw (SpaceToWrite)
  // dopÛki nie nadszedl sygna≥ o koÒcu pracy (tekst "Koniec pracy")
  public void run() {
    spw.writeLine(" *** " + getName() + " rozpoczπ≥ pracÍ" + " ***");
    spw.writeLine("---&gt; czekam na teksty !");
    String txt;
    try {
      txt = in.readLine();
      while(!txt.equals("Koniec pracy")) {
        spw.writeLine(in.getLineNumber() + " " + txt);
        txt = in.readLine();
      }
      in.close();
      spw.writeLine("**** " + getName() + " skoÒczy≥ pracÍ");
    } catch(IOException exc) {
        spw.writeLine("****" + getName() + " - zakonczenie na skutek bledu");
        exc.printStackTrace();
        return;
    }
  }
}
</pre>
  <br>
Wπtki przepisywaczy tworzy i uruchamia Duplikator. Poúredniczy on rownieø
w przekazywaniu tekstÛw od autora do przepisywaczy i czyni to w≥aúnie za
pomocπ potokÛw.<br>
  <br>
  <pre>import java.io.*;

public class Duplicator extends Thread {

  PipedReader fromAuthor;    // potok od autora
  PipedWriter[] toWriters;   // potoki do przepisywaczy

  public Duplicator(PipedReader pr,       // potok od autora
                    SpaceToWrite[] space  // na czym piszπ pzrepisywacze?
                    ) throws IOException {
    fromAuthor = pr;

    int numOfWriters = space.length;      // tylu jest przepisywaczy
                                          // ile miejsc na ktÛrych piszπ

    // Tworzymy tablicÍ potokÛw do przepisywaczy
    toWriters = new PipedWriter[numOfWriters];

    for (int i = 0; i &lt; numOfWriters; i++) { // dla kaødego przepisywacza

      // tworzymy potok do niego
      toWriters[i] = new PipedWriter();

      // tworzymy przepisywacza
      // podajπc: nazwÍ, z jakiego potoku ma czytaÊ, miejsce gdzie ma pisaÊ
      TxtWriter tw = new TxtWriter("TxtWriter " + (i+1),
                                   new PipedReader( toWriters[i]), // po≥πczenie!
                                   space[i]);

      // uruchamiamy wπtek przepisywacza
      tw.start();
    }
  }

  // Kod wykonywany w wπtku Duplikatora
  public void run() {
    try {
      // Buforowanie potoku od autora
      BufferedReader in = new BufferedReader(fromAuthor);

      // czytanie wierszy z potoku od autora
      // i zapisywanie ich do potokÛw, czytanych przez przepisywaczy
      while (true) {
        String line = in.readLine();
        for (int i = 0; i &lt; toWriters.length; i++) {
          toWriters[i].write(line);
          toWriters[i].write('\n');
        }
        if (line.equals("Koniec pracy")) break;
      }
    } catch (IOException exc) { return; }
    System.out.println("Duplikator zakoÒczy≥ dzia≥anie");
  }

}
</pre>
  <br>
G≥Ûwna klasa aplikacji organizuje ca≥y ten "proceder".<br>
  <br>
  <pre>import java.io.*;

class PipesShow {

  PipedWriter authorWrites = new PipedWriter(); // potok, do ktÛrego pisze autor
  PipedReader duplicatorReads;                  // potok, z ktorego czyta duplikator

  Duplicator dup;

  PipesShow(int numLines, int numWriters) {

    // kaødy przepisywacz na swojπ przestrzeÒ pisania
    SpaceToWrite[] writeSpace = new SpaceToWrite[numWriters];
    for (int i=0; i &lt; writeSpace.length; i++)
      writeSpace[i] = new SpaceToWrite(20, 30); // 20 wierszy, 30 kolumn

    try {
      // Po≥πczenie potoku do ktorego pisze autor
      // z nowoutworzonym potokiem, z ktÛrego bÍdzie czyta≥ duplikator
      duplicatorReads = new PipedReader(authorWrites);

      // utworzenie duplikatora (on z kolei stworzy i uruchomi przepisywaczy)
      dup = new Duplicator(duplicatorReads, // skπd bÍdzie czyta≥
                           writeSpace);     // przetstrzeÒ pisania dla przepisywaczy

      // start wπtku duplikatora
      dup.start();

    } catch (IOException exc) {
        System.out.println("Nie moøna stworzyÊ duplikatora");
        exc.printStackTrace();
        System.exit(1);
    }

    SpaceToWrite.show(numWriters); // pokazanie ogÛlnej przestrzeni pisania
                                   // grupujπcej przestrzenie pisania
                                   // kaødego przepisywacza

    // Teraz autor bÍdzie pisa≥!
    // Utworzenie obiektu klasy Autor powoduje rozpoczÍcie przez niego pisania

    String words[] = { "Ala", "ma", "kota", "i", "psa" };

    Author autor = new Author(numLines,      // ile wierszy ma napisaÊ
                              words,         // z jakich s≥Ûw sk≥adaÊ teksty
                              authorWrites); // Dokπd je zapisywaÊ
  }

  public static void main(String args[]) {
    int numLin = 0; // ile wierszy ma napisaÊ autor
    int numWri = 0; // ilu jest przepisywaczy
    try {
      numLin = Integer.parseInt(args[0]);
      numWri = Integer.parseInt(args[1]);
    } catch(Exception exc) {
        System.out.println("Syntax: java  PipesShow numLines numWri");
        System.exit(1);
    }
    new PipesShow(numLin, numWri);
  }
}
</pre>
  <br>
No i w koÒcu przestrzeÒ przepisywania. Uprzedzajπc nieco wyk≥ady o graficznych
interfejscah uøytkownika zastosujemy tu proste elementy AWT. Jeøeli w tej
chwili bÍdzie to niezrozumia≥e - proszÍ siÍ nie martwiÊ (dziÍki klasie SpaceToWrite
odseparowaliúmy wyglπd aplikacji od jej funkcjonalnoúci, zatem z punktu widzenia
eksperymentowania z potokami nie ma wiÍkszego znaczenia jakπ postaÊ ma ta
klasa).<br>
  <br>
  <pre>// Klasa, okreúlajπca przestrzenie
// na ktÛrych piszπ przepisywacze
// oraz grupujπca te przestrzenie w oknie.
// Kaødy przepisywacz wypisuje tekst
// do wielowierszowego pola edycyjnego (TextArea z pakietu AWT)
// do czego s≥uøy mu metoda writeLine.
// Wszystkie przestrzenie grupowane sπ w oknie frame.

import java.awt.*;
import java.awt.event.*;

public class SpaceToWrite extends TextArea {

  private static Frame frame = new Frame("Write space");

  // Konstruktor: tworzy nowπ przetrzeÒ pisania dla jednego przepisywacza
  public SpaceToWrite(int rows, int cols) {
    super(rows, cols);  // utworzenie TextArea  - z podanπ liczbπ wierszy, kolumn
    frame.add(this);    // dodanie TextArea do okna
  }

  // Metoda dopisujπca nowy wiersz do textarea
  public void writeLine(String s) {
    this.append(s + '\n');
  }

  // Metoda ustalajπca u≥oøenie pÛl edycyjnych w oknie
  // rozmiar okna (pack daje rozmiar taki jak akurat potrzreba)
  // i pokazujπca okno
  public static void show(int numWriters) {
    frame.setLayout(new GridLayout(0, numWriters));
    frame.pack();
    frame.show();

    // Umoøliwienie zakoÒczenia aplikacji poprzez zamkniÍcie okna
    frame.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        frame.dispose();
        System.exit(1);
      }
    });
  }
</pre>
  <br>
Wynik dzialania ca≥ego programu pokazuje poniøszy rysunek:<br>
  <img src="images/pipesSample.jpg" alt="r" height="345" width="698">
  <br>
  <br>
  <b><font color="#cc0000">Dla przeúledzenia rÛwnoleglej pracy przepisywaczy
proszÍ skompilowaÊ i uruchomiÊ ten program na w≥asnym komputerze (program
znajduje siÍ w katalogu PipesTest).</font></b><br>
  <br>
  <br>
  <br>
  

<a name="Strumienie.11"></a><h2>11. Obiekty plikowe</h2>


Klasa File oznacza obiekty plikowe (pliki i katalogi). Jej metody umoøliwiajπ
m.in. uzyskiwanie informacji o plikach i katalogach, jak rÛwnieø wykonywanie
dzia≥aÒ na systemie plikowym.<br>
&nbsp;<br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr><td rowspan="1" colspan="2" bgcolor="#ffffcc" valign="top"><div align="center"><b>Wybrane metody klasy File</b><br>
</div></td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>canRead()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy plik moøe byÊ czytany?</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>canWrite()<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Czy plik moøe byÊ zapisywany?</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>createNewFile()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tworzy nowy plik</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>static&nbsp;File</code></font></td><td>createTempFile(String&nbsp;prefix,
               String&nbsp;suffix)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tworzy nowy plik tymczasowy z nazwπ wg wzorca</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>static&nbsp;File</code></font></td><td>createTempFile(String&nbsp;prefix,
               String&nbsp;suffix,
               File&nbsp;directory)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tworzy nowy plik tymczasowy z nazwπ wg wzorca w podanym katalogu</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>delete()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usuwa plik lub katalog</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;void</code></font></td><td>deleteOnExit()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zaznacza plik do usuniÍcia po zakoÒczeniu programu.</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>exists()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy plik/katalog istnieje?</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;String</code></font></td><td>getName()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nazwa pliku lub katalogu</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;String</code></font></td><td>getParent()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Katalog nadrzÍdny</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;String</code></font></td><td>getPath()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; åcieøka</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>isDirectory()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy to katalog?</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>isFile()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy plik?</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>isHidden()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czy ukryty?</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;long</code></font></td><td>lastModified()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Czas ostatniej modyfikacji</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;long</code></font></td><td>length()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rozmiar</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;String[]</code></font></td><td>list()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lista nazw plikÛw i katalogÛw w katalogu</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;String[]</code></font></td><td>list(FilenameFilter&nbsp;filter)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lista nazw plikÛw wg wzorca; zob wyk≥ad 3</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;File[]</code></font></td><td>listFiles()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lista plikÛw i katalogÛw</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;File[]</code></font></td><td>listFiles(FileFilter&nbsp;filter)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Lista plikÛw i katalogÛw<br>
</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;File[]</code></font></td><td>listFiles(FilenameFilter&nbsp;filter)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Lista plikÛw i katalogÛw</td>
</tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>static&nbsp;File[]</code></font></td><td>listRoots()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lista dostÍpnych "rootÛw" w systemie plikowym</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>mkdir()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tworzy katalog</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>mkdirs()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tworzy katalog i ew. niezbÍdne (niestniejπce) katalogi nadrzÍdne</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>renameTo(File&nbsp;dest)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renames the file denoted by this abstract pathname.</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>setLastModified(long&nbsp;time)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ustala czas ostatniej modyfikacji</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;boolean</code></font></td><td>setReadOnly()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zaznacza jako tylko od odczytu</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;URI</code></font></td><td>toURI()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tworzy obiekt
klasy URI (Uniform Resource Identifier), reprezentujπcy ten obiekt
plikowy&nbsp;</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><font size="-1"><code>&nbsp;URL</code></font></td><td>toURL()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Tworzy obiekt klasy URL (Uniform Resource Locator), reprezentujπcy ten obiekt plikowy&nbsp;</td></tr></tbody>
  </table>
  <br>
  <br>
  <br>
  

<a name="Strumienie.12"></a><h2>12. Pliki o dostÍpie swobodnym</h2>



  Klasa RandomAccessFile definiuje pliki o dostÍpie swobodnym, ktÛre mogπ
byÊ otwarte z trybie "czytania" lub "czytania i pisania".&nbsp; Swobodny dostÍp
oznacza dostÍp do dowolnego bajtu danych bez potrzeby sekwencyjnego przetwarzania
pliku od poczπtku.&nbsp; <br>
  <br>
<div class="syntax">Konstruktory klasy majπ nastÍpujπcπ postaÊ:<br>
  <br>
&nbsp;&nbsp;&nbsp; <b>RandomAccessFile(String filename, String mode)<br>
&nbsp;&nbsp;&nbsp; RandomAccessFile(File file, String mode)<br>
  </b>
  <br>
&nbsp;&nbsp;&nbsp; gdzie <i><b>mode</b></i> oznacza jeden z nastÍpujπcych trybÛw otwarcia <br>
  <ul>
    <li>
"r" &nbsp;- plik tylko do odczytu, </li>
    <li>
"rw" - plik do odczytu i zapisu,</li>
    <li>
"rws", "rwd" - jak "rw", ale z wymuszeniem synchronicznego zapisu kaødej zmiany na dysk.</li>
  </ul>
</div> <br>
  <br>
Pliki o dostÍpie swobodnym mogπ byÊ traktowane jako ciπgi bajtÛw. Bieøπcy
bajt &nbsp;do odczytu lub miejsce do zapisu okreúla specjalny wskaünik <b>pozycji w pliku</b>
 (filePointer). PozycjÍ tÍ moøemy zmieniaÊ za pomoca metod seek() i skip().
Jest takøe zmieniana przy kaødej operacji czytania lub pisania.<br>
Do czytania/pisania s≥uøy wiele metod read... i write... , ktÛre pozwalajπ
operowaÊ&nbsp; na rÛønych rodzaajch danych odczytywanych z i zapisywanych do
pliku (np. readDouble, readLine, writeInt itp.),<br>
  <br>
<div class="important">Pliki o dostÍpie swobodnym nie sπ strumieniami. Klasa RandomAccessFile nie naleøy wiÍc do hierarchii klas strumieniowych</div><br>
  <br>
  

<a name="Strumienie.13"></a><h2>13. Archiwizacja, kompresja i dekompresja</h2>


Pakiet java.util.zip dostarcza klas umoøliwiajπcych kompresjÍ i dekompresjÍ
danych.<br>

Naleøπ do nich klasy pokazane w tabeli.<br>
  <br>
Tabela. Wybrane klasy pakietu java.util.zip<br>
  <br>
  <table border="1" width="100%">
<tbody><tr><th>Klasa</th><th>FunkcjonalnoúÊ</th></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Deflater</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Kompresja dowolnyc danych z uøyciem biblioteki ZLIB (dzia≥anie na danych w
    pamiÍci np. Stringach)</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Inflater</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">Kompresja dowolnyc danych z uøyciem biblioteki ZLIB
    (dzia≥anie na danych w pamiÍci np. Stringach)</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    DeflaterOutputStream</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Strumieniowa klasa przetwarzajπca: pozwala na kompresjÍ danych&nbsp; (wg
    protoko≥u ZLIB) w trakcie zapisu dotsrumienia wyjúciowego.</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    InflaterInputStream</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Strumieniowa klasa przetwarzajπca; pozwala na dekompresjÍ danych w trakcie
    odczytu.</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    GZIPInputStream</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">Strumieniowa klasa przetwarzajπca: dekompresja w trakcie
    odczytywania plikÛw w formacie GZIP.</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    GZIPOutputStream</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">Strumieniowa klasa przetwarzajπca: kompresja w trakcie
    zapisu do&nbsp; plikÛw w formacie GZIP.</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    ZipInputStream</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Jak poprzednie klasy, ale czytanie i rozpakowywanie plikÛw ZIP</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    ZipOutputStream</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">Jak poprzednie klasy, ale kompresja danych i zapis do
    plikÛw ZIP</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    ZipEntry</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Reprezentuje element ("wejúcie") w pliku ZIP</td></tr><tr><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    ZipFile</td><td style="font-size: 13px; color: rgb(0, 0, 0); font-family: verdana,sans-serif;">
    Klasa pozwalajπca czytaÊ "wejúcia" elementy z pliku ZIP w dowolnym porzπdku.</td></tr></tbody>
  </table>


  <p>Zastosowanie narzÍdzi kompresji - dekompresji rozpatrzymy na przyk≥adzie
 przetwarzania plikÛw ZIP. Zauwaømy, øe wraz ze spakowanπ zawartoúciπ plikÛw,
archiwum ZIP zawiera elementy opisujπce kaødy plik (tzw. "wejúcia" - entry).
WiÍcej informacji nt kompresji i dekompresji, a wsczegÛlnoúci formatÛw ZLIB,
ZIP i GZIP&nbsp; moøna znaleüÊ w ogÛlniedostÍpnych materia≥ach w Internecie.<br>
</p>


Aby skompresowaÊ (spakowaÊ) dane i zapisaÊ je do pliku ZIP trzeba wykonaÊ
nastÍpujπce kroki.<br>
  <br>
  <b>* </b>Na≥oøyÊ na strumieÒ wyjúciowy zwiπzany z &nbsp;nowotworzonym archiwum obiekt klasy

              przetwarzajπcej ZipOutputStream:<br>
  <br>
&nbsp;&nbsp;&nbsp; ZipOutputStreame zip = new ZipOutputStream(<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; new BufferedInputStream(<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new FileInputStream("nazwa.zip")<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;}<br>
&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; );<br>
  <br>
  <b>* </b>Dla kaødego pliku wejúciowego (ktÛry ma podlegaÊ kompresji) utworzyÊ "entry" w pliku ZIP: <br>
  <br>
&nbsp;&nbsp;&nbsp; ZipEntry entry = new ZipEntry(nazwa);<br>
  <br>
  <b>* </b>ZapisaÊ "entry":<br>
  <br>
&nbsp;&nbsp;&nbsp; zip.putNextEntry(entry);<br>
  <br>
  <b>* </b>ZapisaÊ do strumienia zip zawartoúÊ pliku wejúciowego.<br>
  <br>
  <b>* </b>ZamknπÊ bieøπce "entry" (kolejne putNextEntry robi to automatycznie):<br>
  <br>
&nbsp;&nbsp;&nbsp; zip.closeEntry();<br>
  <br>
  <br>
Przy rozpakowaniu archiwum moøemy uøyÊ klasy ZipFile lub ZipInputSteram.
W tym ostatnim przypadku kolejnoúÊ dzia≥aÒ jest nastÍpujπca.<br>
  <br>
  <b>* </b>Stworzenie rozpakowujπcego strumienia wejúciowego: <br>
  <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ZipInputStream&nbsp; zis = new&nbsp; ZipInputStream(<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;
&nbsp;&nbsp; &nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
new BufferedInputStream(<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; new
FileInputSTream("nazwa.zip")<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; )<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp; );<br>
  <br>
  <b>*</b> Przetwarzanie (rozpakownaie) elementÛw archiwum:<br>
&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp; ZipEntry entry; // element archiwum (spakowany plik lub katalog)<br>
  <br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // DopÛki sπ w w archiwum elementy<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // Pobieramy je i przetwarzamy<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; while((entry = zis.getNextEntry()) != null) {<br>
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; String ename = entry.getName(); // nazwa elementu archiwum<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;...<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>
  <br>
  <b>*</b> W powyøszej pÍtli dla kaødego elementu (pliku) archiwum tworzymy
strumieÒ wyjúciowy (do zapisu)/ o nazwie takiej samej jak w archiwum (ename)<br>
  <br>
  <b>*</b> I dalej w tej pÍtli czytamy dane ze strumeinia zis (metoda read()
zwrÛci -1 gdy przeczytamy dany element - plik - z archiwum) i zapisujemy
je do strumienia wyjúciowego (reprezentujπcego rozpakowany plik).<br>
  <br>
Dla przyk≥adu stworzymy klasÍ ZipArch, ktÛra bÍdzie pozwalaÊ na archiwizowanie
w formacie zip plikÛe i (rekursywnie) katalogÛw oraz na rozpakowywanie takich
archiwÛw.<br>
  <br>
  <pre>class ZipArch {

  // rozmiar bufora dla plikÛw
  static final int BUF_SIZE = 4096;

  // Znak separatora katalogu ("\" lub "/" - zaleønie od platformy)
  static final private String fileSep = System.getProperty("file.separator");

  private String zipFileName;  // archiwum ZIP

  // konstruktor; argument - nazwa archiwum (tworzonego lub rozpakowywanego)
  public ZipArch(String fileName) {
    zipFileName = fileName;
  }

  private boolean verbose = true; // czy pokazywaÊ postÍpy?
  public void setVerbose(boolean b) { verbose = b; }
  public boolean isVerbose() { return verbose; }

  // Metoda rozpakowuje archiwum o nazwie zipFileName
  public void unzip() throws IOException, ZipException {
    // ...
  } &nbsp;

  // Metoda kompresujπca: argument - plik lub katalog do spakowania
  public void zip(String srcFileName) throws IOException, ZipException {
    // ...
   }
</pre>
  <br>
W prezentowanej dalej metodzie unzip ciekawe jest odtwarzanie struktury katalogowej zapisanej w archiwum.<br>
  <br>
  <pre>  public void unzip() throws IOException, ZipException {

    // ZbiÛr createdDirs przechowuje utworzone przy rozpakowywaniu katalogi,
    // tak by szybko stwierdziÊ czy juø katalog utworzyliúmy
    // i nie prÛbowaÊ go tworzyÊ jeszcze raz (zob. zbiory w rozdz.o kolekcjach)
    Set createdDirs = new HashSet();

    // Utworzenie wejúciowego strumienia zwiπzanego z plikiem ZIP
    FileInputStream fis = new FileInputStream(zipFileName);

    // Na≥oøenie na ten strumieÒ przetwarzania w postaci
    // - najpierw buforowania, nastÍpnie - dekompresji
    ZipInputStream  zis = new  ZipInputStream(
                            new BufferedInputStream(fis));

    ZipEntry entry; // element archiwum (spakowany plik lub katalog)

    // DopÛki sπ w w archiwum elementy
    // Pobieramy je i przetwarzamy
    while((entry = zis.getNextEntry()) != null) {

      String ename = entry.getName(); // nazwa elementu archiwum
                                      // np. \windows\bum.txt
      // Gdy wπczona opcja pokazywania postÍpÛw (zob. pole verbose)
      if (verbose) System.out.println("Inflating " + ename);

      // Tworzenie ew. pustych katalogÛw zapisanych w ZIPie
      // Tylko dla pustego katalogu entry.isDirectory() bÍdzie true
      // Nazwa kaødego innego elementu archiwum bÍdzie mia≥a postaÊ
      // [d:][\katalog1\katalog2\...\]plik
      if (entry.isDirectory()) {
        new File(ename).mkdirs(); // tworzymy pusty (z nadkatalogami)
        continue;                 // z pustego nie ma co rozpakowaÊ!
      }

      // Jeøeli archiwum zawiera (niepuste) katalogi,
      // to musimy je utworzyÊ przed rozpakowaniem plikÛw

      int p = ename.lastIndexOf(fileSep); // ostatni znak "/" lub "\"
      if (p != -1) {     // czy "entry" jest plikiem w katalogu?

        // Nazwa katalogu
        String dirName = ename.substring(0,p+1);

        // Jeúli go jeszcze nie utworzyliúmy ...
        if (!createdDirs.contains(dirName)) {

          createdDirs.add(dirName);       // rejestrujemy, øe utworzony!
          File dir = new File(dirName);
          boolean created = dir.mkdirs(); // tworzymy (wraz z nadkatalogami)

          if (!created) {                 // nie uda≥o siÍ utworzyÊ
            int rc = JOptionPane.showConfirmDialog(null,
                       "Katalog " + dirName + " juø istnieje." +
                       "KontynuowaÊ?");
            if (rc != 0)  { // niezgoda na kontynuacjÍ programu
              throw
              new IOException("Unable to create directory "+ dirName);
             }
           }
         }
     }  // Koniec tworzenia ew. niezbÍdnego katalogu

     // Teraz dla kaødego elementu (pliku) archiwum tworzymy
     // buforowany strumieÒ wyjúciowy (do zapisu)
     // o nazwie takiej samej jak w archiwum (ename)

     BufferedOutputStream out = new BufferedOutputStream(
                                  new FileOutputStream(ename), // plik out
                                  BUF_SIZE                // rozmiar bufora
                                 );

      byte data[] = new byte[BUF_SIZE]; // tablica. do wczytywania danych
      int count;                        // liczba przeczytanych bajtÛw
      while ((count = zis.read(data, 0, BUF_SIZE)) != -1) {
        out.write(data, 0, count);
      }
      out.close();
    }
    zis.close();
  }  // Koniec metody unzip
</pre>
Natomiast w kodzie metody zip interesujπce moøe byÊ zarÛwno rekursywne archiwizowanie
struktur katalogowych, jak i sposÛb na pozbywanie siÍ w archiwizowanej strukturze
katalogu g≥Ûwnego dysku. <br>
  <pre>  public void zip(String srcFileName) throws IOException, ZipException {

    // StrumieÒ wyjúciowy archiuwm ZIP
    // na zapisywany plik ZIP na≥oøone jest buforowanie,
    // a nastÍpnie kompresja (strumieÒ przetwarzajπcy ZipOutputStream)
    ZipOutputStream zos = new ZipOutputStream(
                             new BufferedOutputStream(
                                new FileOutputStream(zipFileName),
                                BUF_SIZE
                                )
                             );
     // Ze wzglÍdu na ew. rekurencyjne wchodzenie w podkatalogi ørÛd≥a
     // wywo≥ujemy wewnÍtrznπ metodÍ doZip
     // z argumentami plik (lub katalog) do archiwizacji,
     //               zip-strumieÒ wyjúciowy
     doZip(new File(srcFileName), zos);
     zos.close();
  }

  // Metoda rekurencyjnie archiwizuje pliki podane jako fileToZip
  // do archiwum, do ktÛrego przy≥πczony jest strumieÒ zos
  private void doZip(File fileToZip, ZipOutputStream zos)
                     throws IOException, ZipException
  {
    if (fileToZip.isDirectory()) {  // Jeøeli archiwizacja ma dotyczyÊ katalogu

      File[] listToZip = fileToZip.listFiles(); // lista obiektÛw plikowych

      for (int i=0; i&lt;listToZip.length; i++) {
        doZip(listToZip[i], zos);  // dla kaødego obiektu plikowego w tym
      }                            // katalogu wolamy rekurencyjnie doZip

    }
    else {  // jezeli to plik - zipujemy!

      String fname = fileToZip.toString();   // nazwa pliku

      // czy przypadkiem nie ma postaci d:\plik_lub_katalog
      // w tym przypadku w nazwie elementu ("wejúcia") archiwum
      // pominiemy literowe oznaczenie dysku, dwukropek i separator
      int colon = fname.indexOf(":") + 1;
      if (colon!= 0) fname = fname.substring(colon); // bez "d:"
      if (fname.charAt(0) == fileSep.charAt(0)) { // zdjπÊ ew. separator
        fname = fname.substring(1);
      }

      // Tworzymy nowe "wejúcie" - opisujπce nowy element archiwum
      ZipEntry entry = new ZipEntry(fname);
      // i zapisujemy to "wejúcie"
      zos.putNextEntry(entry);

      // informacja o postÍpach kompresji
      if (verbose) System.out.println("Deflating " + entry);

      // Czytamy plik i zapisujemy jego zawartoúÊ
      // w skompresowanej postaci "pod" otwartym "wejúciem" entry
      BufferedInputStream in = new BufferedInputStream(
                                    new FileInputStream(fileToZip),
                                    BUF_SIZE
                                   );
      byte data[] = new byte[BUF_SIZE]; // tablica. do wczytywania danych
      int count;                        // liczba przeczytanych bajtÛw

      while ((count = in.read(data)) != -1) { // czytanie i zapis z kompresjπ
            zos.write(data, 0, count);
      }
      in.close(); // zamkniÍcie pliku wejúciowego

      zos.closeEntry(); // zamkniÍcie elementu (koniec zapisu elementu)
    }
  }

</pre>
Przedstawiony kod klasy ZipArch&nbsp; moøna ≥atwo dostosowaÊ do rÛønych potrzeb i opcji dzia≥ania.<br>
  <br>
Zauwaømy na koniec, øe rÛwnieø pliki JAR (ktÛre s≥uøπ w Javie do zapisywania
klas w strukturach pakietÛw oraz innych zasobÛw - np. plikÛw graficznych
czy düwiÍkowych) sπ tak naprawdÍ archiwami ZIP. Istotna rÛønica w stosunku
do plikÛ ZIP polega na tym, øe JAR zawiera specjalny plik tzw. <b>manifest</b>
, w ktÛrym dostarcza siÍ informacji potzrebnych do w≥asciwej interpretacji
zawartoúci archiwum (np. ktÛra z klas zaiera metodÍ main, jaka jest stosowana
polityka bezpieczeÒstwa itp.).<br>
Pakiet <b>java.util.jar</b> zawiera klasy do&nbsp; manipulowania zawartoúciπ plikÛw
JAR (m.in. dajπce moøliwoúÊ dynamicznego ≥adowania zapisanych tam klas i
ich "wykonywania").<br>
  <br>

<a name="Strumienie.14"></a><h2>14. Skaner i formator</h2>

<!---->W
wyk≥adzie "Podstawy programowania w jÍzyku Java" poznaliúmy juø doúÊ
szczegÛ≥owo zastosowania skanera i fotmatora. Teraz wiÍc tylko krÛtkie
przypomneinie.<br><br>
<div class="def">Klasa java.util.Scanner pozwala na ≥atwy,
elastyczny i o bardzo duøych
moøliwoúciach rozbiÛr informacji zawierajπcej napisy i dane typÛw
prostych.
<br>
</div> <b><br>
Moøliwoúci</b>:<br>
 <br>
<ul><li>dzia≥a na Stringach, plikach (File),
strumieniach, kana≥ach,</li><li>do parsowania uøywa
wyraøeÒ regularnych (w tym prostych separatorÛw, ale rÛwnieø dowolnych
z≥oøonych wyraøeÒ),</li><li>≥atwo rozbija teksty na
wiersze,</li><li>umie wyrÛøniÊ i skonwertowaÊ dane typÛw
prostych (a takøe BigDecimal),</li><li>pozwala na
rozbiÛr, polegajπcy nie tylko na wyrÛønianie symboli
rozdzielonych separatorami, ale rÛwnieø na wyrÛønianie symboli
pasujπcych
do podanego wyraøenia regularnego (metoda findInText(...), metoda
skip(...)),</li><li>sposÛb rozbioru moøna zmieniaÊ w
trakcie skanowania tekstu, m.in.
stosujπc rozliczne metody next...(), w tym takie, ktÛre pozwalajπ
podawaÊ
rÛøne wyraøenia regularne.</li><li>pozwala na
zlokalizowany rozbiÛr danych.<br>
 </li></ul> <br>
Przyk≥ad.<br>
 <br>
<pre>import java.util.*;

class Employee {
 String name;
 double salary;

 Employee(String n, double s) {
   name = n; salary = s;
 }

 public double getSalary() { return salary; }

 public String toString() { return name + " " + salary; }

}

public class Skaner1 {

 String s1 = "1 2 3";
 String s2 = "Jan Kowalski/1200\nA. Grabowski/1500";


 public Skaner1() {
   Scanner scan1 = new Scanner(s1);
   int suma = 0;
   while (scan1.hasNextInt()) suma += scan1.nextInt();
   System.out.println("Suma = " + suma);

   List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
   Scanner scan2 = new Scanner(s2);
   while (scan2.hasNextLine()) {
     Scanner scan3 = new Scanner(scan2.nextLine()).useDelimiter("/");
     String name = scan3.next();
     double salary = scan3.nextDouble();
     list.add(new Employee(name, salary));
   }

   double value = 0;
   for (Employee emp : list) {
     value += emp.getSalary();
     System.out.println(emp);
   }
   System.out.println("Suma zarobkÛw: " + value);
 }

 public static void main(String[] args) {
   Skaner1 skaner1 = new Skaner1();
 }

}
</pre>
<br>
Wynik dzia≥ania programu:<br>
<div class="listing100">Suma = 6<br>
Jan Kowalski 1200.0<br>
A. Grabowski 1500.0<br>
Suma zarobkÛw: 2700.0<br>
</div><br>
<div class="def">Klasa java.utill.Formatter zapewnia moøliwoúci formatowania danych.</div><!---->
<br>
Tworzπc formator (za pomocπ wywo≥ania konstruktora) moøemy
okreúliÊ: <br>
<br>
<ul><li>destynacjÍ formatowanych danych, ktÛrπ
moøe byÊ:</li></ul><blockquote> <blockquote>File, String,
OutputStream, obiekty klas implementujπcych interfejs Appendable, czyli:</blockquote>
</blockquote>
<ul><ul><ul><li>BufferedWriter,
CharArrayWriter, CharBuffer, FileWriter, FilterWriter,
LogStream, OutputStreamWriter, PipedWriter, PrintStream, PrintWriter,
StringBuffer,
StringBuilder (szybsza wersja StringBuffer, bo niesynchronizowana),
StringWriter,
Writer <br>
 <br>
 <br>
 </li></ul></ul><li>lokalizacjÍ (Locale), wp≥ywajπcπ na reprezentacjÍ liczb i dat,</li></ul><ul><li>stronÍ kodowπ (do kodowania napisÛw) -
dla strumieni, plikÛw i StringÛw</li></ul>&nbsp;<br>
Uwaga: formatory dla destynacji implementujπcyh interfejs Closeable
(m.in.
pliki, strumienie) powinny byÊ po uøyciu zamykane lub wymiatane
(close() flush()),
co powoduje zamkniÍcie lub wymiecenie buforÛw tych destynacji.<br>
<br>
Formatowanie polega na wywo≥aniu jednej z dwÛch wersji metody format
(na rzecz fornatora):<br>
 <br>
<span style="font-weight: bold;">&nbsp;Formatter
format(Locale l, String format, Object... args) </span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>
&nbsp;<span style="font-weight: bold;">Formatter
format(String format, Object... args)</span> <br>
 <br>
£aÒcuch formatu zawiera dowolne ciπgi znakÛw oraz specjalne symbole
formatujπce
(podobne jak w printf w jezyku C). Dalej nastÍpujπ dane do "wstawienia"
w ≥aÒcuch formatu
w miejscu symboli formatu i do sformatowania pod≥ug tych symboli
(zmienna
liczba argumentÛw). Wszystko dzia≥a podobnie jak printf. DziÍki
autoboxingowi
nie ma problemu z formatowaniem danych typÛw prostych.<br>
 <br>
Ciekawe w≥aúciwoúci formatora to m.in.:<br>
<ul><li>w symbolach formatu moøna uøywaÊ indeksÛw,
odnoszπcych siÍ do podanych
danych, w ten sposÛb moøna np. przestawiaÊ dane miejscami lub powielaÊ
je
(powtarzaÊ indeksy).</li><li>rozbudowane moøliwoúci
formatowania czasu i dat.</li></ul>Dla uproszczenia dostÍpne sπ:
<ul><li>statyczne metody <b>format</b> w
klasie String,</li><li>metody <b>format i printf</b>
(dzia≥ajπce tak samo) w klasach PrintStream i PrintWriter,</li></ul><br>
  
</body></html>
</body>
</html>