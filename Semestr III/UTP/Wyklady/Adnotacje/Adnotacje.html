<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1250"> <meta name="author" content="Krzysztof Barteczko"> <meta name="description" content="Uniwersalne techniki programowania"> <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2010"> <link rel="stylesheet" type="text/css" href="../STYLE/common.css"> <title>Metadane i adnotacje</title></head>
<body><br>
<br>
<div align="center"><h1>Metadane i adnotacje</h1>
</div><br>
<hr><i></i><span style="font-style: italic;">Kolejny
dynamiczny aspekt Javy - to adnotacje. Pozwalaj¹ one na swoistym
metapoziomie kszta³towaæ semantykê aplikacji i&nbsp;znacz¹co
upraszczaj¹ wykorzystanie ró¿nych technologii programistycznych.<br>
 </span>
<hr>
<a name="Adnotacje.1"></a><h2>1. Wprowadzenie</h2>
<br>
<div class="def"><b><!---->Metadane</b> to dane opisuj¹ce dane. W
przypadku programowania chodzi
o takie metadane, które opisuj¹ i uzupe³niaj¹ kod Ÿród³owy w znaczeniu
semantycznym<!----></div><br>
<br>
Coraz czêœciej metadane s¹ obecne w jêzykach programowania.<br>
W Javie czêœciowo wystêpowa³y ju¿ wczeœniej - w samym œrodowisku
(dokumentacyjne np. @author),
a czêœciowo jako zewnêtrzne uzupe³nienia (np. XDoclet, JBoss AOP).<br>
W C# nazywaj¹ siê (nieco nieszczêœliwie) atrybutami.<br>
<br>
Java 5 rozszerza i standaryzuje zastosowanie metadanych na
platformie Javy poprzez <b>mechanizm<!----> <a name="ind.3.2"></a>adnotacji</b><!---->.<br>
<br>
<b>Zastosowania</b> (bardzo ró¿norodne), m.in.
<ul><li>do celów poprawy niezawodnoœci programowania (np. @override),</li><li>do
generacji dodatkowych kodów programu (uzupe³niaj¹cych klas),</li><li>do
okreœlania sposobu funkcjonowaniu programu w fazie wykonania (mo¿na
krótko zapisaæ ró¿ne rzeczy). </li><li>do celów konfiguracyjnych,</li><li>do
generowania pomocniczych plików (np. ró¿nych deskryptorów itp.)</li></ul>
<div class="important">Mechanizm adnotacji jest najwa¿niejszym
praktycznie uzupe³nieniem Javy
w wersji 5, choæby dlatego, ¿e ju¿ teraz kolejne wersje du¿ych
platform,
takich jak J2EE, a tak¿e pakiety narzêdziowe , takie jak JDBC 4.0,
intensywnie u¿ywaj¹
adnotacji.<br>
</div><br>
<br>
<b>Zalety adnotacji</b>:
<ul><li>zastosowanie adnotacji mo¿e znacznie u³atwiæ pisanie i
wdra¿anie aplikacji,
szczególnie du¿ych; kody mog¹ byæ wielokrotnie mniejsze, pracoch³onnoœæ
znacz¹co
ograniczona itp.</li></ul>
<br>
<b>Wady</b>:
<ul><li>pojawiaj¹ siê jakby nowe elementy sk³adniowo-semantyczne;
poniewa¿
ka¿dy mo¿e definiowaæ w³asne adnotacje, to istnieje niebezpieczeñstwo,
¿e
pojawi siê mnóstwo "dialektów" Javy - czyli standard Javy + wymyœlne,
niestandardowe
adnotacje,</li><li>adnotacje pozwalaj¹ upraszczaæ wiele rzeczy,
zapisywaæ niejako symbolicznie
jednym s³owem, to co bez nich wymaga³o byæ mo¿e dziesi¹tek linii kodu;
ale
tych zapisów (notacji i ich znaczeñ) trzeba siê te¿ uczyæ (dla ró¿nych
œrodowisk
za ka¿dym razem od nowa) i mieæ œwiadomoœæ, do czego tego tak naprawdê
te
skróty prowadz¹ (co robi¹),</li><li>na razie nie ma dobrej koncepcji
sprawdzania b³êdowi na poziomie metadanych.</li></ul><br><br>
<br>
<a name="Adnotacje.2"></a><h2>2. Rodzaje adnotacji</h2>
<span style="font-weight: normal;">Mo¿na wyró¿niæ nastêpuj¹ce rodzaje
adnotacji:</span><br>
<ul><li><b>adnotacje wbudowane w Javê</b></li><ul><li>regularne</li><li>metaadnotacje</li></ul></ul>
<ul><li><b>adnotacje u¿ytkownika</b> (tworzone przez u¿ytkownika)</li><ul><li>stosowane
na etapie kompilacji (przetwarzane przez narzêdzia)</li><li>stosowane w
fazie wykonania (za pomoc¹ mechanizmów refleksji)</li></ul></ul>
<br>
<u>Adnotacje mog¹ byœ stosowane wobec</u>:<br>
<ul><li>pakietów</li><li>
klas</li><li>
interfejsów</li><li>
pól</li><li>
konstruktorowi</li><li>
metod</li><li>
zmiennych lokalnych</li><li>
innych adnotacji</li></ul>
<br>
Mo¿na wyraŸnie zaznaczyæ do czego odnosi siê nowodefiniowana
adnotacja za pomoc¹ metaadnotacji <b>@Target </b>(wtedy inne jej
zastosowanie bêdzie wykryte jako b³¹d w fazie kompilacji).<b><br>
<br>
</b><div class="notec"><b>Mo¿liwe znaczenia (wartoœci)
metaadnotacji @Target</b><br>
<br>
ANNOTATION_TYPE - dana adnotacja adnotuje inn¹,<br>
PACKAGE - dotyczy pakietu,<br>
TYPE - klas i interfejsów<br>
METHOD - metod<br>
CONSTRUCTOR - konstruktorów<br>
FIELD - pól<br>
PARAMETER - parametrów<br>
LOCAL_VARIABLE - zmiennych lokalnych<br>
</div><br>
<br>
Przyk³ad (fragment) definicji adnotacji o nazwie Test, która mo¿e
dotyczyæ tylko metod:<br>
<br>
@Target(ElementType.METHOD)<br>
public @interface Test <br>
<br>
Uwagi: <br>
<ol><li>adnotacja nie oznaczona znacznikiem @Target ma zastosowanie
wszêdzie.</li><li>aby okreœliæ kilka mo¿liwych zastosowañ piszemy
@Target({ a, b, c }
), gdzie a, b, c to elementy w postaci <span style="font-weight: bold; font-style: italic;">ElementType.rodzaj,</span>
a rodzaj to jeden
z PACKAGE, METHOD, FIELD itp.</li></ol>
<br>
Si³a adnotacji polega na tym, ¿e mog¹ one byæ przetwarzane: <br>
<ul><li>przez narzêdzia do generacji (i ew. równoczesnej kompilacji)
kodu (wtedy potrzebne s¹ tylko w fazie kompilacji), </li><li>
albo przez mechanizmy refleksji &nbsp;- wtedy powinny byæ zapisane w
klasie wykonywalnej
i dostêpne dla tych mechanizmów w fazie wykonania programu,</li><li>
albo przez narzêdzia przetwarzania "binarnej" postaci klas
(umo¿liwiaj¹ce
m.in. ró¿ne iniekcje, zmiany, usuwanie kodu binarnego) - wtedy powinny
byæ
zapisane w klasie, ale nie musz¹ byæ dostêpne dla mechanizmów refleksji.</li></ul>
<br>
<!----><!---->Odpowiadaj¹ temu trzy polityki utrzymywania
adnotacji, specyfikowane przez metaadnotacjê @<b>Retention</b>.<br>
<br>
<div class="notec"><br>
<div style="text-align: center;">Polityki utrzymywania adnotacji<br>
</div><br>
RetentionPolicy.SOURCE - tylko w ¿ródle,<br>
RetentionPolicy.CLASS - w klasie skompilowanej, ale niedostêpne w fazie
wykonania,<br>
RetentionPolicy.RUNTIME - dostêpne w fazie wykonania.<br>
</div><br>
<br>
Przyk³ad:<br>
@Retention(RetentionPolicy.SOURCE) &nbsp; // utrzymanie tylko w kodzie
adnotacji AdapterFor<br>
public interface @AdapterFor &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; // zostanie przetworzona przez narzêdzia w fazie<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // kompilacji<br>
<br>
Wœrod metaadnotacji dostêpne s¹ jeszcze:<br>
<br>
<b>@Documented</b> &nbsp;- mowi o tym, ¿e dokumentacja dzia³ania
adnotacji ma byæ w³¹czona do dokumentacji wszystkich oznaczanych przez
ni¹ elementów<br>
<br>
<b>@Inherited</b> - mówi o tym, ¿e oznaczana przez ni¹ adnotacja
(zaznaczaj¹ca klasy) ma byæ dziedziczona przez podklasy zaznaczonych
klas.<br>
<br>
<br>
Zestaw regularnych, wbudowanych w Javê adnotacji jest na razie bardzo
niewielki i obejmuje:<br>
<br>
@Deprecated - zaznacza dowolny element jako spadkowy
("przestarza³y"),<br>
<br>
@SupressWarnings - blokuje ostrze¿enia (podanego typu) ze strony
kompilatora,<br>
<br>
@Override - stosowana &nbsp;wobec metod, oznacza intencjê
programisty przedefiniowania
metody z nadklasy, dziêki czemu jest mo¿liwoœæ sprawdzenia w fazie
kompilacji
czy programista nie pope³ni³ b³êdu,<br>
<br>
Ta ostatnia adnotacja jest b. u¿yteczna i nale¿y j¹ stosowaæ.<br>
Dziêki temu unikniemy b³êdów niewykrywalnych nie tylko w fazie
kompilacji, ale równie¿ czasem w fazie wykonania.<br>
<br>
Np.<br>
<br>
class Push extends JButton {<br>
<br>
&nbsp;&nbsp;&nbsp; public Dimension getPrefferedSize() { ... }<br>
<br>
}<br>
<br>
Tutaj nast¹pi³a pomy³ka w nazwie metody - wobec czego pojawia siê
nowa metoda
(nigdy nie wo³ana), a w³aœciwa (getPreferredSize()) nie jest
przedefiniowana.
B³êdu nie ma &nbsp;ani w kompilacji ani w fazie wykonania (oprócz - byæ
mo¿e
nie zawsze, nie od razu, nie w ka¿dych okolicznoœciach - widocznych
niew³aœciwych
rozmiarów przycisku).<br>
<br>
Gdy napiszemy:<br>
<br>
class Push extends JButton {<br>
<br>
&nbsp; @Override&nbsp; public Dimension getPrefferedSize() { ... }<br>
<br>
}&nbsp;<br>
<br>
to kompilator wykryje b³¹d i powiadomi nas o tym.<br>
<br>
<br>
<div class="syntax">Jak widaæ, sk³adnia zastosowania adnotacji jest
bardzo prosta.<br>
Adnotacje zaczynaj¹ sie znakiem @.<br>
Adnotacje poprzedzaj¹ inne kwalifikatory elementów (klas, metod, pól).<br>
</div><br>
<a name="Adnotacje.3"></a><h2>3. Definiowanie adnotacji</h2>
Adnotacje s¹ definiowane jako swego rodzaju interfejsy, za pomoc¹ s³owa
@<b>interface</b><br>
Wewn¹trz takiego interfejsu dostarcza siê deklaracji danych, które
adnotacja mo¿e zawieraæ.<br>
<br>
<div class="syntax"><br>
[ew. kwalifikacja dostêpu]&nbsp; @<b>interface</b> NazwaAdnotacji {<br>
&nbsp; &nbsp; deklaracja1<br>
&nbsp; &nbsp; deklaracja2<br>
&nbsp; &nbsp; &nbsp;. . .<br>
&nbsp;&nbsp; &nbsp;deklaracjaN<br>
}<br>
</div><br>
<br>
Ka¿da deklaracja ma postaæ:<br>
<br>
<div class="syntax"> &nbsp;typ nazwaDanej();</div><br>
<br>
albo <br>
<br>
<div class="syntax">typ nazwaDanej() <b>default</b>
wartoœæ_domyœlna;</div><br>
<br>
<br>
Przy zastosowaniu adnotacji mo¿emy podaæ konkretne dane:<br>
<br>
@NazwaAdnotacji(nazwaDanej1=wartoœæ1, nazwaDanej2=wartoœæ2, . . .)<br>
<br>
Typy danych w adnotacji mog¹ byæ nastêpuj¹ce:<br>
<br>
<ul><li>typy proste (int, short, long, byte, char, double, float,
boolean),</li><li>
String,</li><li>
typ referencyjny, reprezentowany przez Class, w tym tak¿e w wersji
sparametryzowanej,</li><li>
enum.</li><li>
adnotacja,</li><li>
tablica (w/w elementów).</li></ul>
<br>
Przyk³ad:<br>
<pre>public @interface Opis {<br>&nbsp; &nbsp; String text() default "Brak opisu";<br>&nbsp; &nbsp; int version() default 1;<br>}<br><br><br>// i zastosowanie np. do opisu klasy:<br><br>@Opis(text="Klasa warzyw", version=2)<br>public class Warzywa { ... }<br><br><br><br></pre><br>
Mo¿na te¿ tak:<br>
<br>
@Opis(version=5, text="Klasa warzyw")<br>
<br>
albo:<br>
<br>
@Opis(text="Klasa warzyw")<br>
<br>
tu pominiête dane przyjm¹ wartoœci domyœlne,<br>
w szczególnoœci:<br>
<br>
<div class="notec"><br>
@Opis <br>
oznacza to samo co<br>
<br>
@Opis()<br>
i co<br>
<br>
@Opis(text="Brak opisu", version=1)<br>
</div><br>
<br>
Mamy te¿ szczególny przypadek, kiedy mo¿na pomin¹æ nazwê danych i znak
=. Mianowicie:<br>
<br>
public @interface JakaœAdnotacja {<br>
&nbsp; &nbsp;jakiœTyp value()<br>
}<br>
<br>
<br>
Wtedy mo¿na pisaæ np. tak (jeœli jakiœTyp to int):<br>
<br>
@JakaœAdnotacja(111)<br>
<br>
nadaj¹c danej oznaczanej przez value wartoœæ 111.<br>
<br>
<br>
Dane konkretnych adnotacji mog¹ byæ uzyskiwane od nich (w fazie
wykonania
lub kompilacji) poprzez odwo³ania do "metod" interfejsu definiuj¹cego
adnotacjê
<br>
(np. jeœli annot - jest uzyskan¹ metodami refleksji lub przez
narzêdzia przetwarzania
w fazie kompilacji adnotacj¹ @Opis, to mo¿emy wo³aæ:<br>
<br>
String op = annot.txt();<br>
int v = annot.version();<br>
<br>
<a name="Adnotacje.4"></a><h2>4. Przetwarzanie adnotacji w fazie wykonania</h2>
Aby przetwarzaæ - i odpowiednio stosowaæ - adnotacje w fazie wykonania,
nale¿y:<br>
<br>
<ul><li>ustaliæ rodzaj adnotacji przez
@Retention(RetentionPolicy.RUNTIME),</li><li>u¿yæ metod refleksji do
uzyskania informacji które elementy i za pomoc¹ jakich adnotacji s¹
zaznaczane,</li><li>od uzyskanych adnotacji dowiedzieæ siê ew.
dodatkowych informacji,
zapisanych w nich jako dane; po czym na podstawie adnotacji i tych
danych
dynamicznie wytworzyæ i wykonaæ odpowiedni kod.</li></ul>
Dla ka¿dego elementu programu (uzyskanego dynamicznie): Class, Method,
Field
itp. mo¿emy u¿yæ metod, które zwracaj¹ informacjê o adnotacjach
zastosowanych
wobec tego elementu.<br>
<br>
<table summary="" border="1" cellpadding="3" cellspacing="0" width="100%"> <tbody> <tr class="TableRowColor" bgcolor="white"> <td align="right" valign="top" width="1%"> <table summary="" border="0" cellpadding="0" cellspacing="0"> <tbody> <tr align="right" valign="">
<td nowrap="nowrap">&lt;T extends Annotation&gt; <br>
T</td> </tr> </tbody> </table> </td> <td>getAnnotation(Class&lt;T&gt;&nbsp;annotationType)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca adnotacjê
podanego typu, albu null, jeœli element nie jest oznaczony adnotacj¹.</td>
</tr> <tr class="TableRowColor" bgcolor="white"> <td align="right" valign="top" width="1%">&nbsp;Annotation[]</td> <td>getAnnotations()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca wszystkie
adnotacje dla tego elementu</td> </tr> <tr class="TableRowColor" bgcolor="white"> <td align="right" valign="top" width="1%">&nbsp;Annotation[]</td>
<td>getDeclaredAnnotations()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca wszystkie
adnotacje bezpoœrednio zastosowane (z pominieciem dziedziczonych)</td> </tr>
<tr class="TableRowColor" bgcolor="white"> <td align="right" valign="top" width="1%">&nbsp;boolean</td> <td>isAnnotationPresent(Class&lt;?
extends Annotation&gt;&nbsp;annotationType)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca true,
jeœli wobec elementu zastosowano adnotacjê podanego typu.</td> </tr> </tbody>
</table><br>
Co to jest typ adnotacji?<br>
Nic innego jak nazwa interfejsu który j¹ definiuje. Np. dla adnotacji,
zdefiniowanej jako:<br>
<br>
public @interface Opis { ... }<br>
<br>
typem jest:<br>
<br>
Opis.class<br>
albo<br>
Class.forName("Opis");<br>
<br>
Uwagi: <br>
<ul><li>przy zastosowaniu nazwanych pakietów nazwy interfejsów
adnotacji musz¹ byæ kwalifikowane nazw¹ pakietu,</li><li>wszystkie
adnotacje (jako interfejsy) rozszerzaj¹ interfejs Annotation,
wobec czego mog¹ byæ traktowane jako Annotation i dlatego takie s¹
wyniki
w/w metod; zwróæmy uwagê, ¿e dziêki parametryzacji nie musimy stosowaæ
konwersji
zawê¿aj¹cych.</li></ul>
<br>
<b>Przyk³ad.</b><br>
<br>
Stworzymy i zastosujemy adnotacjê, dziêki której w prosty sposób w
kodzie
Ÿród³owym bêdziemy ustalaæ do jakich kontenerów maj¹ byæ wk³adane
wybrane
komponenty GUI.<br>
Adnotacjê nazwiemy Loc (od locate).<br>
<br>
<pre>import java.lang.annotation.*;<br>import java.awt.*;<br><br>@Target(ElementType.FIELD)             // do oznaczania pól<br>@Retention(RetentionPolicy.RUNTIME)    // faza wykonania<br><br>public @interface Loc {<br>   String to();<br>}<br></pre>
<br>
Adnotacja ma jedn¹ "dan¹", swoisty atrybut, o nazwie<span style="font-weight: bold; font-style: italic;"> to</span>, który
bêdzie reprezentowa³
za ka¿dym razem nazwê zmiennej oznaczaj¹cej kontener do którego dany
komponent
(oznaczony t¹ adnotacj¹)&nbsp; ma byæ dodany.<br>
<br>
A oto jej zastosowanie:<br>
<br>
<pre>import java.awt.*;<br>import java.awt.event.*;<br>import javax.swing.*;<br>import java.lang.reflect.*;<br><br>public class Annot0 extends JFrame {<br><br>  JComponent cp = (JComponent) getContentPane();<br><br>  @Loc(to="cp") JPanel p1 = new JPanel();<br>  @Loc(to="cp") JPanel p2 = new JPanel();<br><br>  @Loc(to="p1") JButton b1 = new JButton("Przycisk 1");<br>  @Loc(to="p1") JButton b2 = new JButton("Przycisk 2");<br>  @Loc(to="p2") JButton b3 = new JButton("Przycisk 3");<br>  @Loc(to="p2") JButton b4 = new JButton("Przycisk 4");<br>  @Loc(to="p2") JButton b5 = new JButton("Przycisk 5");<br><br>  public Annot0() {<br>    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);<br>    cp.setLayout(new BoxLayout(cp, BoxLayout.Y_AXIS));<br>    try {<br>      locateComponents();   // metoda ta zajmie siê wk³adaniem do kontenerow<br>    } catch(Exception exc) {<br>        exc.printStackTrace();<br>    }<br>    pack();<br>    show();<br>  }<br>//....<br>}<br></pre>
<br>
<br>
Metoda locateComponents() nie jest trudna do napisania, jeœli tylko
choæ trochê w³adamy metodami refleksji:<br>
<br>
<pre>  private void locateComponents() throws Exception {<br>    Class klasa =  getClass();<br>    for (Field f : klasa.getDeclaredFields()) {   // po polach klasy<br>      Loc annot = f.getAnnotation(Loc.class);     // dla f uzyskaæ anotacjê Loc<br>      if (annot == null) continue;                // nie ma - nastêpne pole<br>      System.out.println(annot);                  // zobaczmy jak wygl¹da<br>      String contName = annot.to();               // od adnotacji: nazwa kontenera<br>      Field contField = klasa.getDeclaredField(contName);  // pole, ktore go deklaruje<br>      Object container = contField.get(this);  // sam obiekt-kontener<br>      Method m = container.getClass().getMethod("add", Component.class); // metoda add<br>      m.invoke(container, f.get(this)); // i jej wywo³anie - dodajemy komponent<br>    }<br>}<br></pre>Mo¿na
powiedzieæ, ¿e ten sposób programowania, szczególnie w du¿ych
projektach
mo¿e byæ bardzo u¿yteczny, bowiem ³atwo pozwala zmieniaæ u³o¿enie
komponentów.<br>
Sama metoda locateComponents() mo¿e byæ nieco zmodyfikowana, tak by
mog³a
znaleŸæ siê w jakiejœ klasie narzêdziowej i byæ zastosowana wobec
dowolnych
klas o podobnej j.w. konstrukcji.<br>
<br>
<a name="Adnotacje.5"></a><h2>5. Przetwarzanie adnotacji w fazie kompilacji</h2>
Niew¹tpliwie mo¿liwoœæ przetwarzania adnotacji &nbsp;w fazie kompilacji
&nbsp;jest najbardziej ekscytuj¹ca. <br>
Umo¿liwia np. generowanie dodatkowych klas czy niezbêdnych plików
zewnêtrznych.<br>
<br>
Do takiego przetwarzania powo³ane s¹ odpowiednie dodatkowe
narzêdzia. <br>
<br>
Nale¿y do nich procesory&nbsp;adnotacji.<br>Sposób
ich definiowania i u¿ycia by³ doœæ prosty w Javie w wersji 5, ale
wymaga³ uzycia dodatkowego narzêdzia (apt). W wersji 6 Javy
infrastrukturê przetwarzania adnotacji zintegrowano z kompilatorem,
jednoczesnie dostarczaj¹c rozbudowanego API do dzia³ania na elementach
kodu Ÿród³owego. Tutaj&nbsp;sposób definiowania i u¿ycia procesorów adnotacj w Javie w wersji 5. <br>Sposób postêpowania obowi¹zuj¹cy od
wersji Java 6 przedstawiony jest w ksi¹¿ace K. Barteczko. Java. Uniwersalne techniki programowania, PWN 2015.<br>
<span style="font-weight: bold;"></span><br>W Javie 5 do przetwarzania danotacji wykorzystywane jese narzêdzie zwane "Annotation Processing Tool" (apt).<br>
<br>
Sk¹d apt ma wiedzieæ, jak nale¿y przetwarzaæ nasze adnotacje?<br>
<!----><!---->
Oto¿ musimy mu to sami powiedzieæ, dostarczaj¹c tzw. procesora
adnotacji.<br>
<br>
<div class="syntax"><br>
Procesor adnotacji definiujemy implementuj¹c we w³asnej klasie
interfejs <b>AnnotationProcessor</b> i dostarczaj¹c definicji jedynej
jego metody public void process()<br>
<br>
Apt uzyskuje dostêp do naszego procesora za pomoc¹ metody
getProcessorFor(...)
z klasy, któr¹ te¿ musimy zdefiniowaæ i która stanowi fabrykê
procesorów
- implementacjê interfejsu <b>AnnotationProcessorFactory</b>.<br>
<br>
Podczas wywo³ania tej metodzie przekazywane jest œrodowisko
dzia³ania dla procesora - <b>AnnotationProcessorEnvironment</b>. Z
tego œrodowiska nasz procesor mo¿e odczytaæ wszystkie niezbêdne
informacje
o strukturze kodu Ÿród³owego oraz sposobach tworzenia i generowania
nowych
plików, a tak¿e raportowania b³êdów i ostrze¿eñ.<br>
<br>
Apt u¿ywa naszego procesora, który np. produkuje dodatkowe pliki,
po czym wykonuje wszystkie niezbêdna kompilacje.<br>
<br>
Uwaga: konieczne s¹ importy pakietów z tools.jar - zob. przyk³adowy
kod Ÿród³owy.<br>
</div><br>
<br>
Jako przyk³ad rozpatrzmy prosty sposób zapisu klas typu JavaBeans.<br>
Na podstawie tych bardzo uproszczonych zapisów bêd¹ mog³y byæ
generowane
"prawdziwe" du¿e klasy JavaBeans. Przyk³ad jest raczej ilustracyjny i
do
dalszego znacz¹cego rozszerzania i modyfikowania.<br>
<br>
Umówimy siê, ¿e na podstawie zapisu:<br>
<br>
<b>@BeanTemplate class <i>NazwaBeana</i>Template {</b><br>
&nbsp; &nbsp; &nbsp; &nbsp;typ1 nazwa1;<br>
&nbsp; &nbsp; &nbsp; &nbsp;typ2 nazwa2;<br>
&nbsp; &nbsp; &nbsp; &nbsp;....<br>
&nbsp; &nbsp; &nbsp; &nbsp;tyoN nazwaN;<br>
}<br>
<br>
ma byæ wygenerowana klasa JavaBean o nazwie NazwaBeana, zawieraj¹ce
w³aœciwe
deklaracje pól (podanych) oraz odpowiednie dla nich settery i gettery.<br>
<br>
Musimy wiêc mieæ adnotacjê @BeanTemplate:<br>
<pre>import java.lang.annotation.*;<br><br>@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.SOURCE)<br>public @interface BeanTemplate {<br>}<br></pre>&nbsp;
<br>
&nbsp;i odpowiedni procesor, dostarczany przez nasz¹ implementacjê
fabryki procesorow adnotacji:<br>
<br>
<pre>import com.sun.mirror.apt.*;<br>import com.sun.mirror.declaration.*;<br>import com.sun.mirror.type.*;<br>import com.sun.mirror.util.*;<br><br>import java.beans.*;<br>import java.io.*;<br>import java.util.*;<br><br><br>public class BeanTemplateAnnotationFactory<br>       implements AnnotationProcessorFactory<br>{<br><br>   // Typ adnotacji<br>   private final String annoType = "BeanTemplate";<br><br>   public Collection&lt;String&gt; supportedAnnotationTypes() {<br>      return Arrays.asList(annoType);<br>   }<br><br>   public Collection&lt;String&gt; supportedOptions() {<br>      return Arrays.asList(new String[0]);<br>   }<br><br>   public AnnotationProcessor   <b>// wa¿na metoda getProcessorFor</b>
          getProcessorFor(Set&lt;AnnotationTypeDeclaration&gt; atds,
                          final <b>AnnotationProcessorEnvironment env</b>)<br>   {<br>      return new AnnotationProcessor() { <b>// procesor - w klasie wewnêtrznej</b>

        <b>public void process() {</b>
          // deklaracje markowane adnotacj¹ annoType (teraz "BeanTemplate")
          Collection&lt;Declaration&gt; dcls =
             env.getDeclarationsAnnotatedWith(
                (AnnotationTypeDeclaration) env.getTypeDeclaration(annoType));

          for (Declaration d : dcls) {&nbsp;
             if (d instanceof ClassDeclaration) {  <b>// je¿eli klasa</b>
               ClassDeclaration cdcl = (ClassDeclaration) d;
               String name = cdcl.getSimpleName();
               if (!name.endsWith("Template")) {
                  <b>// od env uzyskujemy œrodki raportowania b³êdów, ostrze¿eñ, info.</b>
                  env.getMessager().printWarning("Wadliwa nazwa klasy bean template");
                  continue;
               }
               String qname = cdcl.getQualifiedName();
               env.getMessager().printNotice(qname);
               qname = qname.substring(0, qname.lastIndexOf("Template"));
               name = name.substring(0, name.lastIndexOf("Template"));
               try {
                 <b>// od env uzyskamy plik i skojarzony z nim PrintWriter</b>
                 PrintWriter out = env.getFiler().createSourceFile(qname);
                 // generujemy œwie¿y kod na podstawie info o zaznaczonej klasie
                 out.println("public class " + name + " {" );
                 Collection&lt;FieldDeclaration&gt; fdcl = cdcl.getFields();
                 for (FieldDeclaration f : fdcl) {
                   String fname = f.getSimpleName();
                   String mname = Character.toUpperCase(fname.charAt(0)) +
                                  fname.substring(1);
                   String ftype = f.getType().toString();
                   out.println("  private " + ftype + " " + fname + ";");
                   out.println("  public " + ftype + " get" +  mname +
                               "() { return " + fname + "; }");
                   out.println("  public void set" +  mname +
                               "(" + ftype + " v) { " + fname + " = v; }");
                 }
                 out.println("}");
                 out.close();
               } catch(IOException exc) { exc.printStackTrace(); }
             }
             else  // jeœli nie byla klasa, to ktoœ siê pomyli³ i zazn. interfejs
               env.getMessager().printWarning("Adnotacja dotyczy interfejsu");
          }
        }
      };
   }



}</pre>
<br>
Po skompilowaniu tej fabryki umieszczamy wynik kompilacji w
katalogu, w
którym znajduj¹ siê&nbsp; inne pliki Ÿród³owe. Np. takie przyk³adowe
zastosowanie:<br>
<br>
Uproszczona definicja beana:<br>
<pre>import java.awt.*;<br>@BeanTemplate public class Bean1Template {<br>  String txt;<br>  Color color;<br>}<br></pre>Poniewa¿,
zgodnie z umow¹ ma z tego powstaæ prawdziwa klasa JavaBean, to
plik j¹ wykorzystuj¹cy bêdzie siê odwo³ywa³ do Bean1, a nie
Bean1Template:<br>
<br>
<pre>import java.awt.*;<br>public class Annot1 {<br><br><br>  public Annot1() {<br>    Bean1 b = new Bean1();<br>    b.setTxt("Pies");<br>    b.setColor(Color.BLUE);<br><br>    System.out.println(b.getTxt() + "\n" + b.getColor());<br><br>  }<br><br>  public static void main(String[] args) {<br>     new Annot1();<br>  }<br><br>}<br></pre>
<br>
Aby to wszystko ze sob¹ pola¹czyæ, musimy wywo³aæ apt, podaj¹c mu
lokalizacjê fabryki procesorow:<br>
<br>
<pre>apt -factory BeanTemplateAnnotationFactory *.java<br></pre>
<br>
APT nie tylko przeprowadzi analizê adnotacji i odpowiednie ich
substytucje,
nie tylko skorzysta z naszego procesora i pozwoli mu zapisaæ nowy plik
Ÿród³owy,
ale równie¿ wywo³a normalny kompilator javy, aby wszystko z³o¿y³ do
kupy.<br>
<br>
W efekcie uzyskamy nowowygenerowany plik Ÿród³owy (który
"zastêpuje" uproszczony "template"):<br>
<pre>public class Bean1 {<br>  private java.awt.Color color;<br>  public java.awt.Color getColor() { return color; }<br>  public void setColor(java.awt.Color v) { color = v; }<br>  private java.lang.String txt;<br>  public java.lang.String getTxt() { return txt; }<br>  public void setTxt(java.lang.String v) { txt = v; }<br>}<br></pre>a
w wyniku kompilacji wszystkiego razem dzia³aj¹cy plik Annot1.class,
który wyprodukuje napis:<br>
<br>
Pies<br>
java.awt.Color[r=0,g=0,b=255]<br><br><br>
<a style="font-weight: bold;" href="mm/w3p1/w3p1.html" target="_blank">Zobacz multimedialn¹
prezentacjê u¿ycia APT</a><a href="mm/w3p1/w3p1.html"><img style="border: 0px solid ; width: 100px; height: 80px;" alt="r" src="../STYLE/video2.gif"></a><br><br>
Podany przyk³ad jest prosty, a
tak¿e trochê dyskusyjny. Ale dobrze pokazuje
potencjalnie olbrzymie mo¿liwoœci tkwi¹ce w przetwarzaniu adnotacji w
fazie kompilacji.<br><br>
<br>
<a name="Adnotacje.6"></a><h2>6. Adnotacje a transformowanie kodu binarnego</h2>
<br>
Polityka utrzymywania adnotacji oznaczana przez metaadnotacjê
@Retention jako RetentionPolicy.CLASS utrzymuje adnotacjê w klasie
(kodzie binarnym), ale nie udostêpnia jej mechanizmom refleksji.<br>
<br>
Taki typ adnotacji mo¿e byæ wykorzystywany przez ró¿ne narzêdzia
modyfikacji kodu binarnego klas. Nale¿¹ do nich takie narzêdzia jak:<br>
<ul><li>Javassist,</li><li>BCEL.</li></ul>
<br>
<span style="font-weight: bold;">Javassist</span> pozwala na bardzo
³atwe transformowanie kodu binarnego klas, polegaj¹ce m.in na:<br>
<ul><li>zastêpowaniu metod i konstruktorów.</li><li>dodawanie kodu na
pocz¹tku lub w koñcu cia³a metod lub konstruktorów.</li></ul>
Modyfikacje s¹ ³atwe, poniewa¿ mo¿emy zapisaæ je w naturalnym jêzyku
Javy.<br>
Javassist ma pewne ograniczenia. <br>
Znacznie potê¿niejszym narzêdziem jest BCEL (Byte Code Engineering
Library), który pozwala robiæ praktycznie wszystko, ale wymaga
zapisów w postaci podobnej do bajtkodu.<br>
<br>
Zobacz wiêcej o:<br>
<span style="font-weight: bold;">Javassist</span> - <a href="http://jboss.com/products/javassist">http://jboss.com/products/javassist</a><br>
<span style="font-weight: bold;">BCEL</span> - <a href="http://jakarta.apache.org/bcel/">http://jakarta.apache.org/bcel/</a>
<hr></body></html>