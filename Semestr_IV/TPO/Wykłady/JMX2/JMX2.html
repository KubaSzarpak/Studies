<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1250"> 
    <meta name="author" content="Bart³omiej Starosta"> 
    <meta name="description" content="opis"> 
    <meta name="copyright" content="(c) Bart³omiej Starosta PJWSTK 2010"> 
    <link rel="stylesheet" type="text/css" href="../STYLE/common.css"> 
    <STYLE TYPE="text/css">
      DL.args       {   margin-left: 5%;     }   
      DFN           {   font-style: italic;  }
      DFN.def       {   font-weight: bold;   }
      VAR           {   font-family: monospace; }
      PRE.syntax    { 
                        background-color: inherit;
                        font-size: 100%;
                        border: 0px;
                        padding: 0px;
                        margin-left: 0%; 
                        margin-top: 0.5em; 
                        margin-bottom: 0.5em; 
                    }
   </STYLE>
   <title>JMX 2</title>
</head>
<body>
<div align="center">
  <a name="JMX2"></a><h1>JMX - Czeœæ 2</h1>
  <h1>Przegl¹d technologii</h1>
</div>
<hr>
<br>
<i> 
    <P>
    JMX to skrót od <EM>Java Management Extensions</EM>.
    Z jednej strony jest to technologia programowania rozproszonego,
    z drugiej - metodologia projektowania aplikacji w taki sposób, 
    aby mo¿na by³o je kontrolowaæ i ³atwo nimi zarz¹dzaæ ju¿ na poziomie poszczególnych obiektów, 
    równie¿ zdalnie, przy u¿yciu rozmaitych protoko³ów komunikacyjnych.
    Ponadto JMX umo¿liwia nadzorowanie zasobów maszyny wirtualnej Javy.
    </P>
    <P>
    Wa¿n¹ zalet¹ tej technologii jest prostota i wyj¹tkowa ³atwoœæ w u¿yciu. 
    Nie wymaga ona du¿ej iloœci dodatkowego kodu do uzyskania gotowego rozwi¹zania. 
    Jest przy tym uniwersalna i skalowalna - 
    mo¿na j¹ stosowaæ we wszelkiego rodzaju aplikacjach: 
    od urz¹dzeñ mobilnych po wielkie serwery korporacyjne.
    Ze wzglêdu na swe mo¿liwoœci staje siê coraz bardziej popularna na œwiecie i 
    wielu dostawców oprogramowania biznesowego w³¹cza j¹ do swoich 
    <A HREF="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/jmxadoption.jsp">produktów</A>
    (np. IBM WebSphere, JBoss, BEA WebLogic, Tomcat).
    </P>
    W tym wyk³adzie omówimy wa¿ne pojêcia i techniki oraz przedstawimy implementacjê dynamicznego m-ziarna.
</i>
  
<BR><HR><a name="JMX2.1"></a><H2><A NAME="PRZEGLAD">1. W skrócie</A></H2>
<P>
<DFN CLASS=def>Java Management Extensions (JMX)</DFN> 
to architektura, zbiór API oraz zestaw us³ug
przeznaczonych do zarz¹dzania i monitorowania aplikacji, zasobów i maszyny wirtualnej.
Specyfikacja sk³ada siê z dwóch czêœci:
<UL>
<LI>
<DFN CLASS=def>Java Management Extensions (JMX) API Specification (JSR 3)</DFN> -
jest to podstawowy zestaw API definiuj¹cy tê technologiê (zawiera pakiety 
<CODE>javax.management</CODE> i wszystkie jego podpakiety z wyj¹tkiem wymienionych poni¿ej.
JDK 5 implementuje j¹ w wersji 1.2 natomiast JDK 6 implementuje wersjê 1.4.
</LI>
<LI>
<DFN CLASS=def>Java Management Extensions (JMX) Remote API Specification (JSR 160)</DFN> -
definiuje sposób zdalnego dostêpu klientów do agentów. 
JDK 5 implementuje <STRONG>obowi¹zkowe</STRONG> pakiety wersji 1.0 tej specyfikacji:
<CODE>javax.management.remote</CODE> i <CODE>javax.management.remote.rmi</CODE>
(pakiety <STRONG>opcjonalne</STRONG> nie zosta³y zaimplementowane).
JDK 6 implementuje wersjê 1.4 tej czêœci specyfikacji.
</LI>
<LI>
Dodatkowo - w maszynie wirtualnej firmy Sun - pakiet <CODE>com.sun.jmx</CODE> wraz z podpakietami 
zawiera prywatne API wspieraj¹ce oficjaln¹, publiczn¹ czêœæ implementacji.
</LI>    
</UL>
Obecnie trwaj¹ prace nad wersj¹ 2.0 JMX API opisan¹ w JSR 255.
Implementacja tej specyfikacji pierwotnie mia³a byæ w³¹czona do JDK 7, 
jednak ostatecznie wcielenie nowego JMX odroczono do JDK 8.
</P>
<P>

</P>
<P>
W wyk³adzie omawiamy wy³¹cznie te elementy specyfikacji, 
które wchodz¹ w sk³ad JDK 5-7.
Pomijamy opcjonalne pakiety <DFN>JMX Remote API</DFN>, które 
umo¿liwiaj¹ stosowanie w³asnych protoko³ów komunikacyjnych w dostêpie do agentów.
Specyfikacja JMX okreœla standardowy sposób komunikacji pomiêdzy klientem a agentem 
oparty o protokó³ <DFN>RMI</DFN> (<DFN>Remote Method Invocation</DFN>).
</P>
<P>
Oprócz implementacji odniesienia (<DFN>reference implementation</DFN>) specyfikacji JMX 
zawartej w JDK 5-7 dostêpne s¹ równie¿ komercyjne lub otwarte (<DFN>open-source</DFN>) produkty 
oparte na tej specyfikacji.
</P>

<H3>1.1. Przeznaczenie</H3>
<P>
JMX u³atwia przede wszystkim tworzenie narzêdzi administracyjnych.
Typowe zastosowania tej technologii to:
<UL>
<LI>modyfikowanie konfiguracji dzia³aj¹cej aplikacji</LI>
<LI>gromadzenie danych statystycznych dotycz¹cych zachowania siê dzia³aj¹cej aplikacji</LI>
<LI>
umo¿liwienie aplikacjom wysy³ania sygna³ów powiadamiaj¹cych o zmianach stanów 
lub te¿ o wyj¹tkowych zdarzeniach i b³êdach
</LI>
<LI>
monitorowanie zasobów JVM
</LI>
</UL>
Powy¿sze operacje mog¹ byæ wykonywane zdalnie, 
poprzez do³¹czenie siê do dzia³aj¹cego serwera m-ziaren.
</P>
<P>
Dziêki elastycznemu podejœciu do realizacji zdalnego dostêpu opartemu na idei
<A HREF="#ADACON"><DFN>³¹czników</DFN> i <DFN>adapterów</DFN>,</A>
aplikacje klienckie nie musz¹ byæ implementowane wy³¹cznie w Javie.
Pozwala to na wykorzystanie istniej¹cego oprogramowania zarz¹dzaj¹cego,
pos³uguj¹cego siê w³asnym protoko³em do specyfikowania ¿¹dañ
(wystarczy w tym celu zaprojektowaæ odpowiedni adapter).
</P>
<P>
Z drugiej strony, pole zastosowañ JMX nie ogranicza siê wy³¹cznie do monitorowania obiektów Javy.
Mog¹ to byæ dowolne zasoby daj¹ce siê w takie obiekty opakowaæ 
(np. poprzez wykorzystanie technologii <DFN>JNI</DFN>).
</P>

<H3>1.2. Zalety</H3>
<P>
Korzyœci p³yn¹ce ze stosowania JMX:
<UL>
<LI>Traktowanie zasobów jako obiektów.</LI>
<LI>
Przezroczystoœæ sieciowa - dostêp do zdalnego zasobu (ulokowanego na innej JVM) 
jest identyczny jak do zasobu lokalnego.
</LI>
<LI>
Bardzo niskie koszta dodatkowe w stosunku do uzyskiwanych mo¿liwoœci.
Do zainstalowania agenta JMX potrzebna jest minimalna iloœæ dodatkowego kodu.
Do nadzorowania maszyny wirtualnej nie jest w ogóle konieczny dodatkowy kod.
</LI>
<LI>
Skalowalnoœæ - identyczne podejœcie obowi¹zuje niezale¿nie od skali problemu.
Specyfikacja JMX mo¿e byæ implementowana na niemal¿e wszystkich urz¹dzeniach,
dla których istniej¹ implementacje maszyn wirtualnych Javy.
</LI>
<LI>
Mo¿liwoœæ definiowania w³asnych <DFN>³¹czników</DFN> - 
protoko³ów komunikacyjnych klient-agent
(u¿yteczne w nietypowych sytuacjach, np. zwiêkszone wymogi bezpieczeñstwa).
</LI>
<LI>
Mo¿liwoœæ tworzenia <DFN>adapterów</DFN>  czyli 
mapowania rozkazów istniej¹cych protoko³ów (np. <VAR>SNMP</VAR> albo <VAR>HTTP</VAR>) 
na polecenia zrozumia³e dla agenta JMX.
Pozwala to na kontrolowanie aplikacji (agenta JMX) za pomoc¹ klienta,
który nie jest napisany w Javie; 
mo¿na równie¿ wykorzystaæ w tym celu istniej¹ce i sprawdzone oprogramowanie.
</LI>
</UL>
</P>
<BR><HR><a name="JMX2.2"></a><H2><A NAME="ARCH">2. Architektura</A></H2>
<P>
Architektura JMX sk³ada siê z trzech warstw:
<OL>
<LI>
warstwa <DFN CLASS=def>narzêdziowa</DFN> (ang. <DFN>instrumentation level</DFN>) -
obejmuje zasoby, które s¹ kontrolowane przez obiekty Javy zwane <DFN>m-ziarnami</DFN>
</LI>
<LI>
warstwa <DFN CLASS=def>agenta</DFN> (ang. <DFN>agent level</DFN>), 
który sk³ada siê z <DFN>m-serwera</DFN> przechowuj¹cego <DFN>m-ziarna</DFN>
oraz dodatkowych us³ug wspomagaj¹cych
</LI>
<LI>
warstwa <DFN CLASS=def>zarz¹dcy</DFN> (ang. <DFN>manager level</DFN>) czyli aplikacji klienckiej
</LI>
</OL>
</P>
<CENTER><IMG SRC="images/arch.gif"></CENTER>
<H3>2.1 Warstwa narzêdziowa</H3>
<P>
W warstwie narzêdziowej mo¿na wyró¿niæ nastêpuj¹ce elementy:
<UL>
<LI>
<DFN>m-ziarna</DFN> - reprezentuj¹ zasoby
</LI>
<LI>
<DFN>sygna³y</DFN> - s³u¿¹ do przekazywania informacji o zachodz¹cych zdarzeniach do klientów
</LI>
<LI>
<DFN>metadane</DFN> - s¹ to obiekty specjalnych klas (opisanych dalej) przechowuj¹ce informacje
o w³aœciwoœciach m-ziaren (atrybuty, operacje, sygna³y)
</LI>
</UL>
</P>
<P>
S¹ cztery rodzaje m-ziaren (opisane ni¿ej).
Programista projektuje klasê m-ziarna zgodnie z jednym z wzorców. 
Do zdefiniowania jego w³aœciwoœci mo¿e siê pos³u¿yæ (a w niektórych przypadkach musi)
klasami metadanych.
Obiekt m-ziarna mo¿e byæ nastêpnie utworzony i zarejestrowany w m-serwerze przez agenta
lub klienta.
</P>

<H3>2.2. Warstwa agenta</H3>
<P>
Zadaniem agenta jest przygotowanie m-serwera i ewentualnie utworzenie m-ziaren.
Oprócz m-serwera w warstwie agenta mo¿na wyró¿niæ cztery rodzaje us³ug dodatkowych:
<UL>
<LI><DFN>Dynamic Class Loader</DFN> - ³aduje klasy i tworzy obiekty</LI>
<LI>
<DFN>Monitor</DFN> - obserwuje wartoœci liczbowych lub napisowych atrybutów w m-ziarnach i 
powiadamia inne obiekty o zachodz¹cych zmianach.
</LI>
<LI><DFN>Timer</DFN> - mechanizm szeregowania oraz cykliczne powiadamianie o zdarzeniach</LI>
<LI><DFN>Relation service</DFN> - definiowanie i utrzymywanie zwi¹zków (relacji) pomiêdzy m-ziarnami</LI>
</UL>
</P>

<H3>2.3. Warstwa zarz¹dcy</H3>
<P>
Aplikacja klienta po nawi¹zaniu po³¹czenia z agentem uzyskuje dostêp do zasobów 
reprezentowanych przez m-ziarna za poœrednictwem m-serwera.
Klient mo¿e wtedy:
<UL>
<LI>odczytywaæ i modyfikowaæ wartoœci atrybutów</LI>
<LI>wykonywaæ operacje</LI>
<LI>odbieraæ emitowane sygna³y</LI>
<LI>tworzyæ i rejestrowaæ nowe m-ziarna na zdalnym m-serwerze</LI>
<LI>wyszukiwaæ m-ziarna w m-serwerze na podstawie ich nazw lub wartoœci atrybutów</LI>
</UL>

<H3><A NAME="ADACON">2.4. Adaptery i ³¹czniki</A></H3>
<P>
Klient uzyskuje dostêp do agenta za poœrednictwem <DFN>³¹czników</DFN> i/lub <DFN>adapterów</DFN>.
</P>
<P>
<DIV CLASS=def>
    <DFN CLASS=def>Adapter</DFN> (ang. <DFN>adaptor</DFN>)
    protoko³u pozwala wydawaæ agentowi polecenia w jêzyku tego protoko³u.
</DIV>
</P>
<P>
Dziêki temu mo¿emy komunikowaæ siê z agentem w ró¿nych jêzykach,
co z kolei zwiêksza mo¿liwoœci tworzenia aplikacji klienckich.
Ka¿dy agent mo¿e mieæ dowoln¹ liczbê adapterów.
Standardowa maszyna wirtualna (JVM) nie dostarcza ¿adnego adaptera.
</P>
<P>
Aplikacje klienckie wymagaj¹ce poœrednictwa adaptera w dostêpie do agenta 
s¹ z regu³y uzale¿nione od tego protoko³u (np. przegl¹darka WWW)
i dlatego nie mog¹ pos³ugiwaæ siê bezpoœrednio zdaln¹ reprezentacj¹ m-serwera 
(<CODE>MBeanServerConnection</CODE>) w dostêpie do zasobów,
co jest normalnym sposobem dostêpu do niego.
Zamiast tego wysy³aj¹ rozkazy, które s¹ mapowane przez adapter na jêzyk agenta.
</P>
<P>
<DIV CLASS=def>
<DFN CLASS=def>£¹cznik</DFN> (ang. <DFN>connector</DFN>) s³u¿y do po³¹czenia agenta z klientem.
Sk³ada siê z <DFN CLASS=def>serwera po³¹czeñ</DFN> (ang. <DFN>connector server</DFN>) 
po stronie agenta oraz <DFN CLASS=def>klienta po³¹czenia</DFN> (ang. <DFN>connector client</DFN>)
po stronie klienta.
</DIV>
</P>
<P>
Serwer po³¹czeñ nas³uchuje zg³oszeñ klientów.
Klient nawi¹zuje po³¹czenie z serwerem po³¹czeñ zawartym w agencie.
</P>
<P>
Mo¿liwe s¹ ró¿ne implementacje ³¹czników, oparte na ró¿nych protoko³ach sieciowych 
(szyfrowanie po³¹czeñ). Agent mo¿e mieæ dowolnie wiele ³¹czników.
JVM zawiera standardowy ³¹cznik oparty na protokole <DFN>RMI</DFN>,
który musi byæ obecny w ka¿dej implementacji JMX.
</P>
<DIV CLASS=important>
Aby agent by³ dostêpny z zewn¹trz, musi mieæ przynajmniej jeden ³¹cznik lub adapter.
</DIV>

<BR><HR><a name="JMX2.3"></a><H2><A NAME="HELPER">3. Klasy pomocnicze</A></H2>
<P>
Dla porz¹dku podamy teraz podstawowe informacje o znanych ju¿ klasach, które s¹ niezbêdne do korzystania z JMX.
</P>
<H3>3.1 Klasa <CODE>ObjectName</CODE></H3>
<P>
Obiekty tej klasy s¹ nazwami m-ziaren.
Stanowi¹ one swego rodzaju adresy, które pozwalaj¹ zidentyfikowaæ i odnaleŸæ m-ziarno.
Opakowuj¹ one nazwy m-ziaren w postaci napisów czytelnych dla cz³owieka,
które przekazuje siê konstruktorowi.
</P>
<P>
Najprostszy z konstruktorów wygl¹da tak:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
ObjectName(String domain, String key, String value)
</PRE>
gdzie:
<DL CLASS=args>
  <DT><CODE>domain</CODE></DT>
    <DD>jest <DFN>nazw¹ dziedziny</DFN></DD>
  <DT><CODE>key</CODE></DT>
    <DD>jest kluczem</DD>
  <DT><CODE>value</CODE></DT>
    <DD>jest jego wartoœci¹</DD>
</DL>
</DIV>
</P>
<P>

Zarówno <DFN>nazwa dziedziny</DFN> jak i wszystkie elementy <DFN>klucz</DFN> i <DFN>wartoœæ</DFN>
s¹ dowolnymi napisami.
Pozwalaj¹ one parametryzowaæ nazwy m-ziaren.
Podstawowym elementem nazwy jest dziedzina.
Mo¿na przyj¹æ domyœln¹ dziedzinê zwracan¹ przez metodê <CODE>getDefaultDomain()</CODE> m-serwera.
Klucz mo¿e byæ jak¹œ informacj¹ o m-ziarnie, a wartoœæ z nim skojarzona - dodatkowym parametrem.
</P>
<P>
Liczba par <VAR>klucz=wartoœæ</VAR> w nazwie mo¿e byæ dowolna, 
ale trzeba wtedy u¿yæ jednego z poni¿szych konstruktorów:
<pre>
ObjectName(String domain, Hashtable table) 
ObjectName(String name) 
</pre>
W pierwszym przypadku oprócz dziedziny przekazujemy tablicê mieszaj¹c¹ z asocjacjami
<VAR>klucz=wartoœæ</VAR>.
Drugi konstruktor pobiera napis z³o¿ony z:
<OL>
<LI><DFN>nazwy dziedziny</DFN></LI>
<LI>dwukropka</LI>
<LI>zestawu par <VAR>klucz=wartoœæ</VAR> oddzielonych przecinkami</LI>
</OL>
Kolejnoœæ par na liœcie nie jest istotna.
Na przyk³ad:
<PRE CLASS=sample>
pl.edu.pjwstk.JMX:type=Dynamic,creator=Client
pl.edu.pjwstk.JMX:creator=Agent,type=Dynamic
</PRE>
</P>
<P>
Napisy przekazywane do konstruktorów mog¹ zawieraæ specjalne metaznaki.
Utworzony obiekt bêdzie wtedy wzorcem nazwy s³u¿¹cym do wyszukiwania nazw w m-serwerze
(<A HREF="#SEARCH">patrz dalej</A>).
</P>

<H3>3.2. Klasa <CODE>Attribute</CODE></H3>
<P>
Klasa <CODE>Attribute</CODE> przechowuje informacje o atrybucie 
i jest u¿ywana do pobierania i zapisywania wartoœci atrybutów.
Obiekt reprezentuj¹cy atrybut tworzymy konstruktorem:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
<B>Attribute</B>(String name, Object value) 
</PRE>
<DL CLASS=args>
  <DT><CODE>name</CODE></DT>
    <DD>jest nazw¹ atrybutu (nie mo¿e byæ <CODE>null</CODE>)</DD>
  <DT><CODE>value</CODE></DT>
    <DD>jest wartoœci¹ atrybutu - musi byæ takiego typu jak zosta³ zadeklarowany atrybut</DD>
</DL>
</DIV>
</P>
<P>

Zgodnie z konwencj¹, nazwa atrybutu zaczyna siê du¿¹ liter¹ 
(o ile pole klasy, któremu ten atrybut odpowiada zaczyna siê ma³¹).
</P>
<P>
Inna klas¹, zwi¹zan¹ z powy¿sz¹, a u¿ywan¹ w dalszej czêœci jest <CODE>AttributeList</CODE>.
Jest to podklasa klasy <CODE>ArrayList</CODE> przystosowana do przechowywania obiektów typu
<CODE>Attribute</CODE>.
</P>

<BR><HR><a name="JMX2.4"></a><H2><A NAME="METADATA">4. Metadane</A></H2>
<P>
Informacje o m-ziarnach przechowuj¹ klasy <DFN CLASS=def>metadanych</DFN> (ang. <DFN>metadata</DFN>).
Opisuj¹ one atrybuty, operacje, sygna³y i konstruktory. 
Agent JMX u¿ywa ich do analizy m-ziarna pod k¹tem jego w³aœciwoœci.
S¹ one równie¿ bardzo u¿yteczne dla klientów, 
którzy mog¹ w ten sposób poznaæ charakterystyki zasobów reprezentowanych przez m-ziarna
i prezentowaæ je w postaci graficznej.
</P>
<P>
Poni¿sza tabelka prezentuje klasy metadanych 
(pochodz¹ one z pakietu <CODE>javax.management</CODE>):
<DIV CLASS=syntax STYLE="padding:0px;">
<TABLE border="1" cellpadding="5" width="100%" STYLE="color:inherit;">
<TBODY>
<TR>
<TD><CODE><B>MBeanInfo</B></CODE></TD>
<TD>Przechowuje informacje o atrybutach, operacjach, sygna³ach i konstruktorach m-ziarna.</TD>
</TR>
<TR>
<TD><CODE><B>MBeanFeatureInfo</B></CODE></TD>
<TD>Jest to nadklasa dla poni¿szych klas:</TD>
</TR>
<TR>
<TD><CODE><B>MBeanAttributeInfo</B></CODE></TD>
<TD>Reprezentuje atrybuty.</TD>
</TR>
<TR>
<TD><CODE><B>MBeanConstructorInfo</B></CODE></TD>
<TD>Reprezentuje konstruktory (sygnatury).</TD>
</TR>
<TR>
<TD><CODE><B>MBeanOperationInfo</B></CODE></TD>
<TD>Reprezentuje metody (sygnatury).</TD>
</TR>
<TR>
<TD><CODE><B>MBeanParameterInfo</B></CODE></TD>
<TD>Reprezentuje parametry metod.</TD>
</TR>
<TR>
<TD><CODE><B>MBeanNotificationInfo</B></CODE></TD>
<TD>Reprezentuje sygna³y.</TD>
</TR>
</TBODY>
</TABLE>
</DIV>
</P>
<P>
Sygnatury s¹ napisami reprezentuj¹cymi typy.
W wiêkszoœci przypadków s¹ to kwalifikowane nazwy klas.
Szczegó³owy opis formatu zawiera dokumentacja klasy <CODE>Class</CODE>.
</P>
<H3>4.1. <CODE>MBeanInfo</CODE></H3>
<P>
Jest to podstawowa klasa metadanych.
Wykorzystywana do specyfikowania pewnych typów m-ziaren, opisanych ni¿ej.
Obiekt tej klasy tworzymy konstruktorem:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
<B>MBeanInfo</B>(String className,
          String description,
          MBeanAttributeInfo[] attributes,
          MBeanConstructorInfo[] constructors,
          MBeanOperationInfo[] operations,
          MBeanNotificationInfo[] notifications)
</PRE>
gdzie:
<DL CLASS=args>
  <DT><CODE>className</CODE></DT>
    <DD>jest nazw¹ klasy reprezentowanego m-ziarna</DD>
  <DT><CODE>description</CODE></DT>
    <DD>opcjonalny opis przeznaczony dla u¿ytkownika</DD>
  <DT><CODE>attributes</CODE></DT>
    <DD>lista atrybutów</DD>
  <DT><CODE>constructors</CODE></DT>
    <DD>lista publicznych konstruktorów</DD>
  <DT><CODE>operations</CODE></DT>
    <DD>lista operacji, czyli udostêpnianych metod</DD>
  <DT><CODE>notifications</CODE></DT>
    <DD>lista emitowanych sygna³ów</DD>
</DL>
Wszystkie listy mog¹ byæ d³ugoœci 0 albo <CODE>null</CODE>.
</DIV>
</P>
<H3>4.2. <A NAME="MBeanOperationInfo"><CODE>MBeanOperationInfo</CODE></A></H3>
<P>
Ta klasa reprezentuje operacje, czyli metody jakie mo¿na wywo³ywaæ z m-ziarna.
Obiekt tej klasy zawiera - oprócz opisu metody - informacje o typie wyniku i sygnaturze. 
Ciekaw¹ cech¹ jest dodatkowa informacja o wp³ywie wywo³ania reprezentowanej metody na m-ziarno.
Zwraca j¹ metoda (klasy <CODE>MBeanOperationInfo</CODE>) <CODE>getImpact()</CODE> 
w postaci jednej ze sta³ych: 
<UL>
<LI><CODE>ACTION</CODE> - mo¿e zmodyfikowaæ m-ziarno poprzez przypisanie na jakiœ atrybut</LI>
<LI><CODE>INFO</CODE> - nie modyfikuje m-ziarna, jedynie zwraca informacjê</LI>
<LI><CODE>ACTION_INFO</CODE> - po³¹czenie obu powy¿szych: modyfikacja i zwrócenie wartoœci</LI>
<LI><CODE>UNKNOWN</CODE> - zachowanie jest nieznane</LI>
</UL>
</P>
<H3>4.3. <CODE>MBeanNotificationInfo</CODE></H3>
<P>
Obiekty tej klasy s¹ czasem potrzebne przy wysy³aniu sygna³ów (patrz dalej).
Tworzymy je konstruktorem:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
<B>MBeanNotificationInfo</B>(String[] notifTypes, String name, String description)
</PRE>
<DL CLASS=args>
  <DT><CODE>notifTypes</CODE></DT>
    <DD>
       tablica z typami sygna³ów (nie s¹ to typy Javy - patrz ni¿ej) 
       emitowanych przez to m-ziarno
    </DD>
  <DT><CODE>name</CODE></DT>
    <DD>kwalifikowana nazwa klasy tego sygna³u</DD>
  <DT><CODE>description</CODE></DT>
    <DD>opis sygna³u nios¹cy informacjê dla u¿ytkownika</DD>
</DL>
</DIV>
</P>
<BR><HR><a name="JMX2.5"></a><H2><A NAME="NOTIF">5. Sygna³y</A></H2>
<P>
Model powiadamiania o zdarzeniach sk³ada siê z poni¿szych elementów
(wszystkie klasy i interfejsy pochodz¹ z pakietu <CODE>javax.management</CODE>):
<DIV CLASS=syntax STYLE="padding:0px;">
<TABLE border="1" cellpadding="5" width="100%" STYLE="color:inherit;">
<TBODY>
<TR>
<TD><CODE><B>Notification</B></CODE></TD>
<TD>Ogólna klasa sygna³ów.</TD>
</TR>
<TR>
<TD><CODE><B>NotificationListener</B></CODE></TD>
<TD>Interfejs nas³uchu sygna³ów. Implementuj¹ go obiekty chc¹ce odbieraæ sygna³y.</TD>
</TR>
<TR>
<TD><CODE><B>NotificationFilter</B></CODE></TD>
<TD>
Interfejs pozwalaj¹cy na filtrowanie sygna³ów. 
Pozwala ograniczyæ iloœæ odbieranych sygna³ów.
</TD>
</TR>
<TR>
<TD><CODE><B>NotificationBroadcaster</B></CODE></TD>
<TD>
Interfejs implementowany przez m-ziarna wysy³aj¹ce sygna³y.
Deklaruje metody pozwalaj¹ce dodawaæ i usuwaæ s³uchaczy.
</TD>
</TR>
<TR>
<TD><CODE><B>NotificationEmitter</B></CODE></TD>
<TD>
Interfejs rozszerzaj¹cy <CODE>NotificationBroadcaster</CODE> 
z dodatkow¹ metod¹ do usuwania s³uchaczy
</TD>
</TR>
</TBODY>
</TABLE>
</DIV>
</P>
<H3>5.1. Typy sygna³ów</H3>
<P>
Ka¿dy sygna³ ma typ, który jest napisem (nie myliæ z typem wyznaczonym przez klasê sygna³u).
Typ jest okreœlony przez wysy³aj¹cego sygna³ i zawiera jego opis.
Sk³ada siê on z elementów oddzielonych kropkami.
Na przyk³ad <VAR>"dostawcaXYZ.zasóbABC.sygna³007"</VAR>.
Nazwy typów zaczynaj¹ce siê od <VAR>"JMX."</VAR> s¹ zarezerwowane dla sygna³ów generowanych przez 
infrastrukturê JMX.
Typ podaje siê jako pierwszy argument ka¿dego konstruktora klasy <CODE>Notification</CODE>.
</P>

<H3>5.2. Sygna³y</H3>
<P>
Klasa <CODE>Notification</CODE> - podobnie jak klasy zdarzeniowe Swinga - 
dziedziczy z <CODE>java.util.EventObject</CODE>, zatem ma podobne cechy.
Jej podklasy reprezentuj¹ szczególne rodzaje sygna³ów.
Na przyk³ad - opisana wy¿ej - klasa <CODE>AttributeChangeNotification</CODE> 
dziedziczy z <CODE>Notification</CODE> i
reprezentuje sygna³y zwi¹zane z modyfikacj¹ jakiegoœ atrybutu.
</P>
<P>
Sygna³ zawiera w sobie nastêpuj¹ce informacje:
<UL>
<LI><DFN CLASS=def>typ zdarzenia</DFN> - omówiony wy¿ej</LI>
<LI><DFN CLASS=def>numer</DFN> - kolejny numer zdarzenia</LI>
<LI><DFN CLASS=def>czas emisji</DFN> - kiedy zosta³ wygenerowany</LI>
<LI><DFN CLASS=def>wiadomoœæ</DFN> - napis objaœniaj¹cy zdarzenie</LI>
<LI><DFN CLASS=def>dane u¿ytkownika</DFN> - dowolny obiekt przekazywany s³uchaczom</LI>
</UL>
</P>
<P>
Dane te mog¹ byæ przekazane jako argumenty konstruktora lub 
ustalone odpowiednimi setterami klasy <CODE>Notification</CODE>.
</P>

<H3>5.3. Emisja sygna³ów</H3>
<P>
M-ziarna chc¹ce wysy³aæ sygna³y musz¹ implementowaæ interfejs 
<CODE>NotificationBroadcaster</CODE> lub - obecnie zalecany - 
jego podinterfejs <CODE>NotificationEmitter</CODE>.
Deklaruje on nastêpuj¹ce metody:
</P>
<P>
<DIV CLASS=syntax STYLE="padding:0px;">
<TABLE border="1" cellpadding="5" width="100%" STYLE="color:inherit;">
<TBODY>
<TR>
<TD>
<PRE CLASS=syntax>
void <B>addNotificationListener</B>(NotificationListener listener, 
                             NotificationFilter filter, 
                             Object handback) 
</PRE>
</TD>
<TD>
Dodaje s³uchacza <CODE>listener</CODE> do tego m-ziarna.
Argument <CODE>filter</CODE> s³u¿y do filtrowania sygna³ów.
Obiekt <CODE>handback</CODE> bêdzie wysy³any s³uchaczowi razem z sygna³em.
</TD>
</TR>
<TR>
<TD>
<PRE CLASS=syntax>
MBeanNotificationInfo[] <B>getNotificationInfo</B>() 
</PRE>
</TD>
<TD>
Zwraca tablicê z opisem sygna³ów emitowanych przez to m-ziarno
</TD>
</TR>
<TR>
<TD>
<PRE CLASS=syntax>
void <B>removeNotificationListener</B>(NotificationListener listener) 
</PRE>
</TD>
<TD>
Usuwa s³uchacza <CODE>listener</CODE>.
</TD>
</TR>
<TR>
<TD>
<PRE CLASS=syntax>
void <B>removeNotificationListener</B>(NotificationListener listener, 
                                NotificationFilter filter, 
                                Object handback) 
</PRE>
</TD>
<TD>
Usuwa s³uchacza <CODE>listener</CODE>.<BR>
Argumenty <CODE>filter</CODE> i <CODE>handback</CODE> oznaczaj¹ obiekty 
u¿yte podczas dodawania s³uchacza.
</TD>
</TR>
</TBODY>
</TABLE>
</DIV>
</P>
<P>
Pierwsze trzy metody s¹ odziedziczone z nadinterfejsu <CODE>NotificationBroadcaster</CODE>.
Zamiast implementowaæ te interfejsy mo¿na odziedziczyæ klasê 
<CODE>NotificationBroadcasterSupport</CODE> jak to zrobiliœmy w przyk³adzie.
</P>
<DIV CLASS=notel>
To oznacza, ¿e mo¿na pos³u¿yæ siê domyœln¹ implementacj¹ tej metody z klasy  
<CODE>NotificationBroadcasterSupport</CODE>, która zwraca tablicê d³ugoœci 0
(zatem nie zawiera ona ¿adnych informacji).
</DIV>
<P>
Metoda <CODE>getNotificationInfo()</CODE> powinna zwracaæ informacjê o wszystkich sygna³ach
emitowanych przez m-ziarno, aczkolwiek dopuszczalne jest wysy³anie sygna³ów nie uwzglêdnionych
w tej tablicy.
<DIV CLASS=important>
Dziedzicz¹c klasê <CODE>NotificationBroadcasterSupport</CODE> nale¿y przedefiniowaæ tê metodê.
</DIV>
</P>
<P>
Metoda <CODE>addNotificationListener()</CODE> rejestruje s³uchacza sygna³ów emitowanych przez to
m-ziarno. 
Obiekt <CODE>handback</CODE> przekazany jako argument powinien byæ przechowywany i 
odsy³any w nie zmienionej postaci s³uchaczowi razem z sygna³em.
U³atwia on identyfikacjê zdarzenia co mo¿e byæ przydatne przy jego przetwarzaniu.
S³uchacz mo¿e byæ rejestrowany wielokrotnie z ró¿nymi obiektami identyfikuj¹cymi <CODE>handback</CODE> -
w takim przypadku bêdzie on otrzymywa³ sygna³y osobno dla ka¿dego takiego obiektu.
Druga, rozszerzona wersja metody <CODE>removeNotificationListener()</CODE> s³u¿y w³aœnie do
usuniêcia nas³uchu dla konkretnego obiektu identyfikuj¹cego.<BR>
Przed wys³aniem sygna³u do s³uchacza m-ziarno sprawdza, czy zezwala na to dostarczony filtr
<CODE>filter</CODE>.
Jeœli ten nie protestuje, to wywo³ywana jest metoda obs³ugi sygna³u z obiektu s³uchacza.
Zarówno filtr jak i obiekt identyfikuj¹cy (dwa ostatnie argumenty) mog¹ byæ <CODE>null</CODE>.
</P>

<H3>5.4. Nas³uch sygna³ów</H3>
<P>
S³uchacz sygna³ów implementuje - opisany wy¿ej - interfejs <CODE>NotificationListener</CODE> 
deklaruj¹cy metodê <CODE>handleNotification()</CODE> wywo³ywan¹ przez m-ziarno emituj¹ce sygna³.
Wystarcza on do odbierania wszystkich sygna³ów pochodz¹cych od dowolnego m-ziarna.
Do odró¿niania sygna³ów pochodz¹cych z ró¿nych Ÿróde³ s³u¿y napis okreœlaj¹cy typ sygna³u.
</P>

<H3>5.5. Filtrowanie sygna³ów</H3>
<P>
Interfejs <CODE>NotificationFilter</CODE> definiuje filtr sygna³ów.
Jego metoda:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
boolean <B>isNotificationEnabled</B>(Notification notification) 
</PRE>
</DIV>
</P>
<P>
jest wywo³ywana przed emisj¹ sygna³u do s³uchacza, który zg³osi³ ten filtr podczas rejestracji.
Jeœli jej wynik bêdzie <CODE>true</CODE>, to sygna³ zostanie wys³any.
Oczywiœcie, interfejs ten mo¿e byæ implementowany w klasie s³uchacza.
</P>
<H3>5.6. Sygna³y zmiany atrybutów</H3>
<P>
Klasa <CODE>AttributeChangeNotification</CODE> - wstêpnie opisana wy¿ej - 
reprezentuje specyficzne sygna³y wysy³ane w celu powiadomienia s³uchaczy, 
¿e zosta³a zmieniona wartoœæ atrybutu.
Powinna ona byæ u¿ywana zamiast <CODE>Notification</CODE> do tworzenia tego rodzaju sygna³ów.
Typem tego zdarzenia jest zawsze "<VAR>jmx.attribute.change</VAR>", 
który to napis jest wartoœci¹ statycznego pola <CODE>AttributeChangeNotification.ATTRIBUTE_CHANGE</CODE>.
</P>
<P>
S³uchacze tych sygna³ów, jak równie¿ m-ziarna emituj¹ce je implementuj¹ zwyk³e interfejsy
<CODE>NotificationListener</CODE> i <CODE>NotificationEmitter</CODE>.
Natomiast do filtrowania takich sygna³ów mo¿na u¿yæ dedykowanej klasy 
<CODE>AttributeChangeNotificationFilter</CODE>, która implementuje interfejs 
<CODE>NotificationFilter</CODE> i dostarcza kilku u¿ytecznych metod s³u¿¹cych do dodawania
i usuwania atrybutów, które maj¹ byæ filtrowane.
</P>

<BR><HR><a name="JMX2.6"></a><H2><A NAME="TYPY">6. Typy m-ziaren</A></H2>
<P>
W ogólnym przypadku mo¿emy mieæ 4 typy m-ziaren:
<UL type="i">
<LI>
<DFN CLASS=def>standardowe</DFN> (ang. <DFN>standard mbean</DFN>) - 
najprostsze w u¿yciu,
</LI>
<LI>
<DFN CLASS=def>dynamiczne</DFN> (ang. <DFN>dynamic mbean</DFN>) - 
implementuj¹ce interfejs <CODE>javax.management.DynamicMBean</CODE>
</LI>
<LI>
<DFN CLASS=def>otwarte</DFN> (ang. <DFN>open mbean</DFN>) - 
pakiet <CODE>javax.management.openmbean</CODE>
</LI>
<LI>
<DFN CLASS=def>modelowe</DFN> (ang. <DFN>model mbean</DFN>) - 
pakiet <CODE>javax.management.modelmbean</CODE>
</LI>
</UL>
</P>
<P>
Ró¿ni¹ siê one budow¹ i sposobem tworzenia.
M-ziarna standardowe definiuj¹ swoje w³aœciwoœci statycznie - w kodzie Ÿród³owym.
Zatem s¹ one znane ju¿ na etapie kompilacji a agent poznaje je metodami introspekcji.
Pozosta³e m-ziarna okreœlaj¹ swoje w³aœciwoœci dynamicznie, 
za pomoc¹ metody zwracaj¹cej ich opis (m.in. atrybuty i sygnatury operacji) 
w obiekcie metadanych.
Dziêki temu mog¹ zmieniaæ siê w czasie i dostosowywaæ te w³aœciwoœci do
zmieniaj¹cych siê potrzeb.
</P>
<P>
M-ziarna otwarte i modelowe s¹ szczególnymi rodzajami m-ziaren dynamicznych.
Pierwsze z nich pos³uguj¹ siê ograniczonym zbiorem typów.
Drugie implementuj¹ specjalne interfejsy, 
które pozwalaj¹ konfigurowaæ ich charakterystyki na ¿¹danie -
s¹ przez to proste w u¿yciu.
</P>
<P>
Mimo tych ró¿nic, 
sposób pos³ugiwania siê dynamicznymi m-ziarnami jest identyczny jak w przypadku standardowym.
Inny jest tylko sposób definiowania i zakres zastosowañ.
</P>
<P>
Standardowe m-ziarna s¹ stosowane w sytuacjach, kiedy nadzorowane zasoby 
s¹ dobrze zdefiniowane i nie zmieniaj¹ siê w czasie.
Jeœli zasoby, które chcemy kontrolowaæ podlegaj¹ zmianom lub te¿ 
nie mog¹ byæ w pe³ni okreœlone na etapie kompilacji
nale¿y stosowaæ m-ziarna dynamiczne.
Jeœli m-ziarno ma byæ kontrolowane przez aplikacjê nie napisan¹ w Javie 
nale¿y stosowaæ typ otwarty, 
ze wzglêdu na stosowany w nich zestaw standardowych, uniwersalnych typów 
(atrybutów czy te¿ jako argumenty operacji).
</P>

<H3>6.1. M-ziarna standardowe</H3>

<P>
M-ziarna <DFN>standardowe</DFN> tworzy siê wed³ug okreœlonych wzorców nazewniczych.
Nadzorowany zasób (atrybuty) jest udostêpniany poprzez metody o ustalonych nazwach 
i sygnaturze (<DFN>settery</DFN> i <DFN>gettery</DFN>).
Owe metody, wraz z metodami definiuj¹cymi operacje m-ziarna musz¹ byæ zadeklarowane w
interfejsie implementowanym przez m-ziarno (m-interfejsie).
Interfejs ten reprezentuje m-ziarno na zewn¹trz i pozwala wywnioskowaæ 
(na podstawie analizy nazw i sygnatur zadeklarowanych metod)
jakich atrybutów i operacji dostarcza m-ziarno.
</P>
<P>
Œcis³y zwi¹zek pomiêdzy nazw¹ interfejsu sterowania i nazw¹ klasy m-ziarna (przyrostek <VAR>MBean</VAR>)
mo¿e zostaæ anulowany poprzez wykorzystanie klasy <CODE>javax.management.StandardMBean</CODE>.
Pozwala ona utworzyæ m-ziarno na podstawie dostarczonego interfejsu i jego implementacji.
Poniewa¿ nie musi byæ miêdzy nimi ¿adnych zwi¹zków nazewniczych, 
mo¿e to byæ bardzo u¿yteczne rozwi¹zanie w sytuacji, 
kiedy mamy ju¿ gotowe klasy i interfejsy i nie mo¿emy zmieniæ ich nazw.
</P>
<H3>6.2. <A NAME="TYPYDYN">M-ziarna dynamiczne</A></H3>
<P>
M-ziarna dynamiczne mog¹ definiowaæ swoje w³aœciwoœci w trakcie dzia³ania.
Dziêki temu maj¹ znacznie szersze pole zastosowañ ni¿ m-ziarna standardowe.
</P>
<P>
<DIV CLASS=def>
<DFN CLASS=def>M-ziarno dynamiczne</DFN> to obiekt klasy implementuj¹cej interfejs
<CODE>javax.management.DynamicMBean</CODE>.
</DIV>
</P>
<P>
Oto metody tego interfejsu:
<DIV CLASS=syntax STYLE="padding:0px;">
<TABLE border="1" cellpadding="5" width="100%" STYLE="color:inherit;">
<TBODY>
<TR>
<TD><PRE CLASS=syntax>Object <B>getAttribute</B>(String attribute)</PRE></TD>
<TD>Zwraca wartoœæ atrybutu o nazwie <CODE>attribute</CODE>.</TD>
</TR>
<TR>
<TD><PRE CLASS=syntax>AttributeList <B>getAttributes</B>(String[] attributes)</PRE></TD>
<TD>Zwraca wartoœci podanych atrybutów.</TD>
</TR>
<TR>
<TD><PRE CLASS=syntax>MBeanInfo <B>getMBeanInfo</B>()</PRE></TD>
<TD>Zwraca informacje o atrybutach i operacjach m-ziarna</TD>
</TR>
<TR>
<TD>
<PRE CLASS=syntax>
Object <B>invoke</B>(String actionName, 
              Object[] params, 
              String[] signature)
</PRE>
</TD>
<TD>
Wywo³uje metodê o nazwie <CODE>actionName</CODE> i sygnaturze 
(nazwach typów parametrów) <CODE>signature</CODE>  z argumentami <CODE>params</CODE>
</TD>
</TR>
<TR>
<TD><PRE CLASS=syntax>void <B>setAttribute</B>(Attribute attribute)</PRE></TD>
<TD>
Ustala wartoœæ atrybutu. 
Jego nazwa i nowa wartoœæ s¹ przekazane w argumencie <CODE>attribute</CODE>.
</TD>
</TR>
<TR>
<TD><PRE CLASS=syntax>AttributeList <B>setAttributes</B>(AttributeList attributes)</PRE></TD>
<TD>Ustala wartoœci podanych atrybutów.</TD>
</TR>
</TBODY>
</TABLE>
</DIV>
</P>
<DIV CLASS=notel>
Niestety - w ogólnym przypadku -  nie istniej¹ mechanizmy rozg³aszaj¹ce zmianê interfejsu do
zainteresowanych klientów.
Co prawda, m-ziarno mo¿e wygenerowaæ sygna³ informuj¹cy o zmianie, 
ale trzeba wtedy wzi¹æ pod uwagê sytuacjê, 
kiedy zachodzi ona podczas wykonywania metody ze starego interfejsu.
</DIV>

<P>
Metoda <CODE>getMBeanInfo</CODE> zwraca <A HREF="#METADATA">opisany wy¿ej</A> 
obiekt typu <CODE>MBeanInfo</CODE>.
To ona definiuje w³aœciwoœci dynamicznego m-ziarna (atrybuty i operacje), 
a nie zestaw akcesorów (settery i gettery) i metod jak w przypadku standardowych m-ziaren.
W trakcie dzia³ania programu te w³aœciwoœci mog¹ siê zmieniaæ poniewa¿ nie s¹ 
zaszyte na sta³e w kodzie.
Dziêki temu takie m-ziarna mog¹ dostosowywaæ siê do zmieniaj¹cych siê okolicznoœci.
</P>
<P>
Metody <CODE>getAttribute()</CODE> i <CODE>getAttributes()</CODE> pobieraj¹ 
nazwy atrybutów i zwracaj¹ ich wartoœci.
Podobnie, metody <CODE>setAttribute()</CODE> i <CODE>setAttributes()</CODE> 
ustalaj¹ wartoœci atrybutów. Druga z nich zwraca listê atrybutów, dla których operacja siê powiod³a.
</P>
<P>
Metoda <CODE>invoke()</CODE> wywo³uje podan¹ metodê z m-ziarna.
Sygnatura przekazana jako argument pozwala na odró¿nienie metod przeci¹¿onych
(aczkolwiek nie jest to zalecane).
Wynik zwracany jest na typie <CODE>Object</CODE>, 
jednak wo³aj¹cy mo¿e poznaæ deklarowany typ wyniku analizuj¹c obiekt <CODE>MBeanInfo</CODE>
zwracany przez <CODE>getMBeanInfo()</CODE>.
Wywo³ywanie w ten sposób akcesorów (<CODE>get..</CODE>, <CODE>set...</CODE>) jest zabronione.
</P>
<P>
Sposób pos³ugiwania siê m-ziarnami dynamicznymi zobaczymy na 
<A HREF="#DYNAMIC">przyk³adzie</A> w dalszej czêœci.
</P>

<H3>6.3. M-ziarna otwarte</H3>
<P>
Jeœli m-ziarno posiada atrybut typu, który nie jest dostêpny po stronie klienta
(nie ma takiej klasy), to pojawiaj¹ siê pewne problemy.
Jeœli klient jest aplikacj¹ napisan¹ w Javie, to mo¿na tak¹ klasê serializowaæ.
Ale jeœli jest on przegl¹dark¹ WWW (po³¹czon¹ protoko³em HTTP z agentem poprzez odpowiedni adapter), 
to nie bêdzie wiedzia³ jak wizualizowaæ elementy  danego typu. 
Aby unikn¹æ tego rodzaju trudnoœci zdefiniowano m-ziarna,
które pos³uguj¹ siê zestawem typów ograniczonym do najprostszych, uniwersalnych typów,
które ³atwo mo¿na zinterpretowaæ w ka¿dych warunkach.
</P>
<P>
<DIV CLASS=def>
<DFN CLASS=def>M-ziarna otwarte</DFN> (ang. <DFN>open mbeans</DFN>) s¹ to 
dynamiczne m-ziarna pos³uguj¹ce siê ograniczonym, œciœle okreœlonym  zestawem typów
atrybutów, parametrów i wartoœci zwracanych przez metody.
</DIV>
</P>
<P>
Takie ograniczenie ma na celu zwiêkszenie przenoœnoœci oprogramowania -
umo¿liwia implementacjê klienta w innym jêzyku ni¿ Java.
U³atwia równie¿ prezentacjê m-ziarna potencjalnemu u¿ytkownikowi przy pomocy klas metadanych - 
opisywane typy s¹ samoobjaœniaj¹ce.
</P>
<P>
Typy, które mo¿na stosowaæ w m-ziarnach otwartych  s¹ opisane w poni¿szej tabelce.
<DIV CLASS=syntax STYLE="padding:0px;">
<TABLE border="1" cellpadding="5" width="100%" STYLE="color:inherit;">
<CAPTION><STRONG>Proste typy danych</STRONG></CAPTION>
<TBODY>
<TR>
<TD>
<CODE>Void</CODE>, <CODE>Boolean</CODE>, <CODE>Byte</CODE>, <CODE>Character</CODE>,
<CODE>String</CODE>, <CODE>Short</CODE>, <CODE>Integer</CODE>, <CODE>Long</CODE>,
<CODE>Float</CODE>, <CODE>Double</CODE>
</TD>
<TD>Standardowe klasy opakowuj¹ce typy pierwotne z pakietu <CODE>java.lang</CODE></TD>
</TR>
<TR>
<TD><CODE>BigDecimal</CODE>, <CODE>BigInteger</CODE></TD>
<TD>Klasy reprezentuj¹ce du¿e liczby z pakietu <CODE>java.math</CODE></TD>
</TR>
<TR>
<TD><CODE>java.util.Date</CODE></TD>
<TD>Reprezentacja dat</TD>
</TR>
<TR>
<TD><CODE>javax.management.ObjectName</CODE></TD>
<TD>Nazwy obiektów JMX (m-ziaren)</TD>
</TR>
<TR>
<TD><CODE>javax.management.openmbean.CompositeData</CODE></TD>
<TD>
Interfejs reprezentuj¹cy typy z³o¿one w postaci tablicy mieszaj¹cej 
kojarz¹cej nazwy elementów (jako napisy) z ich wartoœciami, 
które mog¹ byæ obiektami typów wymienionych w tej tabelce.
</TD>
</TR>
<TR>
<TD><CODE>javax.management.openmbean.TabularData</CODE></TD>
<TD>Reprezentuje tablice z³o¿one z elementów typu <CODE>CompositeData</CODE></TD>
</TR>
</TBODY>
</TABLE>
</DIV>
</P>
<P>
Interfejsy <CODE>CompositeData</CODE> i <CODE>TabularData</CODE> zosta³y zaimplementowane w
klasach pomocniczych: <CODE>CompositeDataSupport</CODE> i <CODE>TabularDataSupport</CODE>,
których nale¿y u¿ywaæ w praktyce.
</P>
<P>
Otwarte m-ziarna s¹ równie¿ dynamicznymi m-ziarnami, 
zatem musz¹ implementowaæ interfejs <CODE>DynamicMbean</CODE> i - w zwi¹zku z tym -
definiowaæ swój opis dynamicznie poprzez obiekt typu <CODE>MBeanInfo</CODE>
zwracany przez metodê <CODE>getMBeanInfo()</CODE>.
Rzeczywistym typem zwracanym przez tê metodê musi byæ jednak obiekt klasy
<CODE>OpenMBeanInfoSupport</CODE>, która dziedziczy z <CODE>MBeanInfo</CODE> 
i implementuje interfejs <CODE>OpenMBeanInfo</CODE>.
</P>
<P>
Tak naprawdê, to w³aœnie typ obiektu zwracanego przez metodê <CODE>getMBeanInfo()</CODE>
(<CODE>OpenMBeanInfo</CODE> lub <CODE>MBeanInfo</CODE>) rozstrzyga, 
czy dane dynamiczne m-ziarno jest otwarte, czy nie.
</P>
<DIV CLASS=notel>
Opis zawarty w klasach metadanych musi byæ wystarczaj¹cy do zaprezentowania ziarna 
u¿ytkownikowi za poœrednictwem GUI.
</DIV>
<P>
Inne klasy metadanych (<CODE>MBean...Info</CODE>) s¹ równie¿ odziedziczone w podobny sposób 
(maj¹ wyspecjalizowane wersje) i nale¿y ich u¿ywaæ w kontekœcie m-ziaren otwartych.
Na przyk³ad, klasie <CODE>MBeanAttributeInfo</CODE> odpowiada interfejs
<CODE>OpenMBeanAttributeInfo</CODE> zaimplementowany w klasie 
<CODE>OpenMBeanAttributeInfoSupport</CODE> 
</P>
<P>
Oprócz opisanych wy¿ej wymagañ, m-ziarna otwarte musz¹ zagwarantowaæ pe³ny opis swoich operacji.
Zatem metoda <CODE>OpenMBeanOperationInfo.getImpact()</CODE> 
(opisuj¹ca wp³yw operacji na m-ziarno, tak jak 
<A HREF="#MBeanOperationInfo"><CODE>MBeanOperationInfo.getImpact()</CODE></A>)
w przypadku zwyk³ych m-ziaren nie mo¿e zwracaæ wartoœci <CODE>UNKNOWN</CODE>.
</P>

<H3>6.4. M-ziarna modelowe</H3>
<P>
M-ziarna modelowe s¹ najogólniejszym typem m-ziaren.
Jednoczeœnie - z punktu widzenia kodu programu - s¹ one najprostsze w u¿yciu.
Z drugiej jednak strony maj¹ najbardziej z³o¿on¹ budowê i w³aœciwoœci,
a co za tym idzie wymagaj¹ wiêkszego nak³adu pracy na zapoznanie siê ze sposobem ich stosowania.
Z tego powodu nie bêdziemy ich tu prezentowaæ szczegó³owo a zamieœcimy jedynie pobie¿ny opis.
Klasy i interfejsy u¿ywane przez m-ziarna modelowe s¹ zawarte w pakiecie
<CODE>javax.management.modelmbean</CODE>.
</P>
<P>
Podstawow¹ ró¿nic¹ w stosunku do poprzednio omawianych typów m-ziaren jest fakt, ¿e 
<DIV CLASS=important>
klas m-ziaren modelowych nie projektujemy samodzielnie.
</DIV>
</P>
<P>
Do utworzenia obiektu m-ziarna modelowego korzystamy z klasy <CODE>RequiredModelMBean</CODE>,
któr¹ musi zawieraæ ka¿da implementacja specyfikacji JMX.
</P>
<P>
Proces tworzenia reprezentacji jakiegoœ zasobu w postaci m-ziarna modelowego
polega na utworzeniu obiektu klasy <CODE>RequiredModelMBean</CODE>,
skonfigurowaniu jego w³aœciwoœci (atrybuty, operacje, sygna³y) i zarejestrowaniu w m-serwerze.
W wielu typowych przypadkach wymaga to zaledwie kilku wierszy kodu (!).
</P>
<P>
W³aœciwoœci m-ziaren modelowych s¹ definiowane przy u¿yciu wyspecjalizowanych klas metadanych
bêd¹cych podklasami standardowych klas metadanych opisanych <A HREF="#METADATA">wczeœniej</A>.
Najwa¿niejsz¹ z nich jest klasa <CODE>ModelMBeanInfoSupport</CODE>, 
która zawiera wszystkie informacje definiuj¹ce modelowe m-ziarno 
(wykorzystuje ona pozosta³e klasy metadanych zawarte w pakiecie <CODE>javax.management.modelmbean</CODE>
zaczynaj¹ce siê od przedrostka <CODE>Model...</CODE>).
</P>
<P>
Zatem aby utworzyæ m-ziarno modelowe musimy najpierw stworzyæ opisuj¹cy go obiekt klasy
metadanych <CODE>ModelMBeanInfoSupport</CODE> przekazuj¹c jego konstruktorowi informacje o
atrybutach, operacjach, sygna³ach i konstruktorach projektowanego m-ziarna.
Nastêpnie tworzymy obiekt klasy <CODE>RequiredModelMBean</CODE> przekazuj¹c konstruktorowi
obiekt metadanych.
Dalsze operacje przebiegaj¹ tak jak w przypadku innych typów m-ziaren -
trzeba je najpierw zarejestrowaæ a potem mo¿na u¿ywaæ.
</P>
<BR><HR><a name="JMX2.7"></a><H2><A NAME="SECURITY">7. Bezpieczeñstwo</A></H2>
<DIV CLASS=notel>
Ze wzglêdów bezpieczeñstwa
na platformie <DFN>Win32</DFN> monitorowanie lokalnej JVM mo¿liwe jest tylko pod warunkiem,
¿e domyœlny katalog tymczasowy (zmienna <SAMP>TEMP</SAMP>) znajduje siê w systemie plików NTFS
(a nie FAT).
</DIV>
<P>
Po³¹czenia sieciowe nawi¹zywane przez JMX czêsto wymagaj¹ zapewnienia bezpieczeñstwa.
£¹cznik RMI zawarty w maszynie wirtualnej korzysta z
autoryzacji has³ami z u¿yciem protoko³u <DFN>SSL</DFN>, która jest domyœlnie w³¹czona.
Tê autoryzacjê mo¿na wy³¹czyæ nadaj¹c wartoœci <CODE>false</CODE> 
w³aœciwoœciom systemowym:
<SAMP>com.sun.management.jmxremote.ssl=false</SAMP> i
<SAMP>com.sun.management.jmxremote.authenticate=false</SAMP>
podczas uruchamiania JVM agenta.
</P>
<P>
Jeœli jednak chcemy skorzystaæ z autoryzacji, to musimy przygotowaæ plik z has³ami i
ewentualnie skonfigurowaæ SSL.
Opisane ni¿ej czynnoœci dotycz¹ domyœlnego ³¹cznika RMI. 
W przypadku korzystania z w³asnego ³¹cznika o autoryzacjê musimy zadbaæ sami.
</P>

<H3>7.1. Has³a</H3>
<P>
<DIV CLASS=notel>
<VAR>JRE_HOME</VAR> oznacza katalog zawieraj¹cy <DFN>runtime</DFN> Javy - 
ten, z którego jest uruchamiana maszyna wirtualna.<BR>
Mo¿e to byæ katalog <SAMP><VAR>JDK_HOME</VAR>/jre</SAMP> lub
<SAMP>C:\Program&nbsp;Files\Java\jre1.6.0</SAMP>
</DIV>
Has³a przechowywane s¹ w pliku tekstowym.
W systemach z jednym u¿ytkownikiem jest to plik 
<SAMP><VAR>JRE_HOME</VAR>/lib/management/jmxremote.password</SAMP>.
W systemach wielodostêpnych plik ten przechowuje siê w katalogu domowym u¿ytkownika,
a jego po³o¿enie podaje siê maszynie wirtualnej ustalaj¹c w³aœciwoœæ
(najlepiej podczas uruchamiania JVM):
</P>
<P>
<DIV CLASS=syntax>
<PRE CLASS=syntax>
com.sun.management.jmxremote.password.file=<VAR>plik_hase³</VAR>
</PRE>
</DIV>
</P>
<P>
<DIV CLASS=notel>
B³êdy autoryzacji mog¹ byæ spowodowane niew³aœciwymi uprawnieniami pliku z has³ami
(na przyk³ad mo¿na w nim pisaæ).
</DIV>
Wzorzec pliku z has³ami znajduje siê w 
<SAMP><VAR>JRE_HOME</VAR>/lib/management/jmxremote.password.template</SAMP>.
Zale¿nie od systemu, nadajemy mu nazwê <SAMP>jmxremote.password</SAMP> lub kopiujemy
do katalogu domowego i nadajemy prawa tylko do odczytu (bardzo wa¿ne!).
Plik hase³ kojarzy tzw. <DFN>role</DFN> - czyli nazwy u¿ytkowników - z ich has³ami.
Na koñcu tego pliku, za instrukcj¹ u¿ycia, znajduj¹ siê dwie linie 
okreœlaj¹ce domyœlne role i ich has³a (w oryginale s¹ one zakomentowane).
<PRE CLASS=sample>
monitorRole QED
controlRole R&D
</PRE>
Mo¿emy nadaæ nowe has³a istniej¹cym rolom (<CODE>monitorRole</CODE>, <CODE>controlRole</CODE>) 
i/lub dodaæ nowe role.
</P>
<P>
Definicje ról, czyli zakres nadanych im uprawnieñ, mieszcz¹ siê w pliku
<SAMP><VAR>JRE_HOME</VAR>/lib/management/jmxremote.access</SAMP>.
Oto jego istotny fragment:
<PRE CLASS=sample>
monitorRole  readonly
controlRole  readwrite
</PRE>
Za nazwami ról (u¿ytkowników) wystêpuj¹ s³owa kluczowe okreœlaj¹ce zakres uprawnieñ im przys³uguj¹cy.
<UL>
<LI><CODE>readonly</CODE> - zezwala na odczytywanie atrybutów</LI>
<LI><CODE>readwrite</CODE> - zezwala na zapis, odczyt i wykonywanie operacji</LI>
</UL>
Mo¿na dodaæ w³asne role i okreœliæ ich uprawnienia,
które mog¹ byæ wy³¹cznie tych dwóch typów.
Ich has³a nale¿y wtedy zdefiniowaæ w pliku z has³ami.
</P>
<P>
Zatem chc¹c u¿ywaæ hase³ dla autoryzacji u¿ytkowników korzystaj¹cych z m-ziaren naszej maszyny wirtualnej
musimy:
<UL>
<LI>
odkomentowaæ linie w pliku z has³ami, które definiuj¹ domyœlne role 
lub zdefiniowaæ w³asne
</LI>
<LI>
zmieniæ nazwê tego pliku lub skopiowaæ do katalogu domowego nadaj¹c mu odpowiednie uprawnienia
</LI>
</UL>
Od teraz mo¿emy zrezygnowaæ z opcji uruchomieniowej JVM, która wy³¹cza³a autoryzacjê:
<SAMP>-Dcom.sun.management.jmxremote.authenticate=false</SAMP>.
Jeœli jednak plik z has³ami znajduje siê w nietypowej lokalizacji to nale¿y j¹ okreœliæ opcj¹
<SAMP>-Dcom.sun.management.jmxremote.password.file=<VAR>plik_hase³</VAR></SAMP>.
</P>
<H3>7.2. SSL</H3>
<P>
Aby korzystaæ z protoko³u SSL nale¿y przygotowaæ klucze i certyfikat 
(np. przy pomocy programu <SAMP>keytool</SAMP> wchodz¹cego w sk³ad JDK)
oraz skonfigurowaæ kilka w³aœciwoœci JVM.
Szczegó³y s¹ opisane w dokumentach:
<A HREF="http://java.sun.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html#CustomizingStores"><SAMP><VAR>JDK_HOME</VAR>/docs/guide/security/jsse/JSSERefGuide.html#CustomizingStores</SAMP></A>
oraz 
<A HREF="http://java.sun.com/javase/6/docs/technotes/tools/windows/keytool.html#EXAMPLES"><SAMP><VAR>JDK_HOME</VAR>/docs/technotes/tools/windows/keytool.html#EXAMPLES</SAMP>.</A>
</P>
<H3>7.3. Autoryzacja klientów</H3>
<P>
Lokalny klient ³¹cz¹cy siê z agentem JMX przy pomocy aplikacji <SAMP>jconsole</SAMP> 
jest autoryzowany na podstawie uprawnieñ zawartych w systemie plików.
Jeœli jednak jest to klient zdalny, to musi podaæ nazwê u¿ytkownika i has³o w zak³adce 
<VAR>Remote</VAR> okna dialogowego wyboru po³¹czenia.
Nazw¹ u¿ytkownika jest tu nazwa roli zdefiniowana w pliku z rolami serwera.
Odpowiadaj¹cej jej has³o (które musimy podaæ) 
jest okreœlone równie¿ w odpowiednim pliku hase³ na serwerze.
</P>
<P>
Jeœli chcemy po³¹czyæ siê z agentem JMX programowo, 
musimy przekazaæ nazwê roli i has³o podczas nawi¹zywania po³¹czenia z m-serwerem.
W tym celu, do po³¹czenia z serwerem wykorzystujemy dwuargumentow¹ 
(zamiast zwyk³ej, jednoargumentowej) wersjê statycznej metody z klasy <CODE>JMXConnectorFactory</CODE>:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
JMXConnectorFactory.connect(JMXServiceURL serviceURL, Map environment) 
</PRE>
</DIV>
</P>
<P>
Pierwszym argumentem jest jak zwykle url serwera, 
natomiast drugi s³u¿y do przekazania œrodowiska zawieraj¹cego w naszym przypadku dane
umo¿liwiaj¹ce autoryzacjê.
Te dane to para, której pierwszym elementem jest napis <CODE>"jmx.remote.credentials"</CODE>
a drugim - dwuelementowa tablica napisów zawieraj¹ca nazwê roli (jako pierwszy element)
i has³o (jako drugi).
Zatem jako drugi argument powy¿szej metody przekazujemy mapê z dodan¹ par¹:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
new HashMap().put("jmx.remote.credentials", new String[] { "controlRole" , "R&D" });
</PRE>
</DIV>
</P>
<P>
Oto gotowy fragment kodu, s³u¿¹cy do nawi¹zania po³¹czenia z agentem
(pomijamy obs³ugê wyj¹tków):
<PRE CLASS=sample><B>
 Map env = new HashMap();
 String[] credentials = new String[] { "controlRole" , "R&D" };
 env.put("jmx.remote.credentials", credentials);
</B>
 JMXServiceURL jmxurl = new JMXServiceURL(url);
 JMXConnector jmxcon = JMXConnectorFactory.connect(jmxurl, <B>env</B>);  <I>// przekazanie œrodowiska!</I>
 MBeanServerConnection server = jmxcon.getMBeanServerConnection();
</PRE>
Wyt³uszczon¹ czcionk¹ zaznaczone zosta³y nowe elementy,
nieobecne w przypadku braku autoryzacji.
</P>

<BR><HR><a name="JMX2.8"></a><H2><A NAME="DYNAMIC">8. Przyk³ad dynamicznego m-ziarna</A></H2>
<P>
Zapoznajmy siê teraz z tworzeniem m-ziaren dynamicznych.
Klasa <CODE>Dynamic</CODE> reprezentuje m-ziarna, które udostêpniaj¹ dwa atrybuty: <VAR>"Message"</VAR> (rw) i <VAR>"Changes"</VAR> (ro)
oraz operacjê <CODE>reset()</CODE>.
Tym razem jednak mamy do czynienia z m-ziarnem dynamicznym,
zatem informacja o jego w³aœciwoœciach jest zwracana przez okreœlon¹ metodê, 
a nie wywnioskowana z nazw metod interfejsu, który implementuje.
</P>
<P>
Klasa <CODE>Dynamic</CODE> dziedziczy <CODE>NotificationBroadcasterSupport</CODE> aby móc
wysy³aæ sygna³y na skutek wykonania operacji <CODE>reset()</CODE> (jak w poprzednim przyk³adzie).
Aby byæ m-ziarnem dynamicznym implementuje <A HREF="#TYPYDYN">opisany wy¿ej</A> interfejs <CODE>DynamicMBean</CODE>.
Wymaga on dostarczenia definicji metod pozwalaj¹cych na zapis i odczyt atrybutów 
oraz wykonywanie operacji m-ziarna.
Ponadto potrzebna bêdzie wspomniana wczeœniej metoda <CODE>getMBeanInfo()</CODE> 
opisuj¹ca w³aœciwoœci m-ziarna.
</P>
<P>
Prezentacjê klasy <CODE>Dynamic</CODE> zaczniemy od atrybutów i akcesorów.
</P>
<pre>
import java.util.Iterator;
import javax.management.*;

public class Dynamic
    extends NotificationBroadcasterSupport
    implements DynamicMBean {
    
<I>
    /**
     * Atrybut read-write (jest getter i setter)
     */</I>
    private String <B>message</B> = "Dynamic";
    
<I>
    /**
     * Atrybut read-only (jest tylko getter)
     */</I>
    private int <B>changes</B> = 0;
    
<I>
    /**
     * Kolejny numer sygna³u wysy³anego po reset()
     */</I>
    private long <B>resets</B> = 0;

<I>
    /*
     * Inne metody publiczne:
     */
</I>
    public String <B>getMessage</B>(){
        return message;
    }

    public void <B>setMessage</B>(String newMessage){
        message = newMessage;
        changes++;
    }

    public int <B>getChanges</B>(){
        return changes;
    }

    public int <B>reset</B>(){
        AttributeChangeNotification notification =
            new AttributeChangeNotification(
                        this,
                        ++resets,
                        System.currentTimeMillis(),
                        "Zresetowano m-ziarno klasy Dynamic",
                        "Changes",
                        "Integer",
                        changes,
                        0
            );
        notification.setUserData("Poprzednia wartoœæ atrybutu Message = \\\\\\\\"" + message + "\\\\\\\\"");
        message = "Dynamic";
        int oldValue = changes;
        changes = 0;
<I>        // wywo³ujemy metodê odziedziczon¹ </I>
        sendNotification(notification);   
        return oldValue;
    }
</pre>
<P>
Powy¿szy kod ró¿ni siê od odpowiadaj¹cego mu fragmentu z klasy <CODE>AnotherStandard</CODE>
wy³¹cznie domyœlnym napisem  <CODE>message</CODE> (tu: <CODE>"Dynamic"</CODE>) 
oraz sposobem wys³ania sygna³u w³aœciwym dla przypadku dziedziczenia klasy 
<CODE>NotificationBroadcasterSupport</CODE>.
</P>
<P>
Drugi fragment zawiera implementacje metod interfejsu <CODE>DynamicMBean</CODE>.
Dla uproszczenia pomijamy sprawdzanie poprawnoœci argumentów (czy nie s¹ null).
</P>
<P>
Do pobrania wartoœci atrybutu s³u¿y metoda <CODE>getAttribute(String)</CODE>, 
która pobiera jego nazwê jako argument i zwraca wartoœæ jako wynik.
Do nadania atrybutowi nowej wartoœci s³u¿y metoda <CODE>setAttribute(Attribute)</CODE>, 
która pobiera jako argument obiekt zawieraj¹cy nazwê i now¹ wartoœæ atrybutu.
Obie metody zg³aszaj¹ wyj¹tek <CODE>AttributeNotFoundException</CODE> jeœli atrybut o podanej
nazwie nie istnieje, b¹dŸ nast¹pi³a próba modyfikacji atrybutu tylko-do-odczytu.
Metoda <CODE>getAttributes(String[])</CODE> pobiera jako argument tablicê z nazwami atrybutów
i zwraca jako wynik listê <CODE>AttributeList</CODE> tych atrybutów, 
dla których uda³o siê pobraæ wartoœci (zatem ignorujemy ewentualne b³êdy, 
które mog³y powstaæ w czasie dostêpu do pewnych atrybutów
jak równie¿ wyj¹tki powstaj¹ce przy próbie dostêpu do nieistniej¹cego atrybutu).
Podobnie metoda <CODE>setAttributes(AttributeList)</CODE> pobiera listê atrybutów wraz z wartoœciami
i zwraca now¹ listê zawieraj¹c¹ atrybuty, 
którym uda³o siê zmieniæ wartoœci wraz z ich nowymi wartoœciami.
</P>
<pre>
<I>
    /**
     * Zwraca wartoœæ atrybutu o nazwie attribute 
     */</I>
    public Object <B>getAttribute</B>(String attribute) throws AttributeNotFoundException {

        if (attribute.equals("Message")) {
            return getMessage();
        } 
        else if (attribute.equals("Changes")) {
            return getChanges();
        }
<I>        // Nie ma takiego atrybutu</I>
        throw new AttributeNotFoundException("Nie ma takiego atrybutu: " + attribute);
    }    
    
<I>
    /**
     * Zwraca wartoœci atrybutów z tablicy attributes
     */</I>
    public AttributeList <B>getAttributes</B>(String[] attributes) {

        AttributeList results = new AttributeList();
        
        for(String attr : attributes){
            try {        
                Object value = getAttribute(attr);     
<I>                // Dodajemy, jeœli nie by³o wyj¹tku</I>
                results.add(new Attribute(attr, value));
            } catch (Exception e) {
<I>                // Nie przekazujemy wyj¹tków wo³aj¹cemu</I>
            }
        }
<I>        // Na wynikowej liœcie znajduj¹ siê te wartoœci, które uda³o siê pobraæ</I>
        return results;
    }
    
<I>
    /**
     * Ustala wartoœæ atrybutu o nazwie attribute 
     */</I>
    public void <B>setAttribute</B>(Attribute attribute) 
                throws AttributeNotFoundException, InvalidAttributeValueException {

        String name = attribute.getName();
        Object value = attribute.getValue();

        if (name.equals("Message")) {
<I>            // Czy mo¿na dokonaæ przypisania wartoœci atrybutu?</I>
            if (String.class.isAssignableFrom(value.getClass()))
                setMessage((String) value);
            else
                throw new InvalidAttributeValueException("Z³y typ wartoœci atrybutu");
        }
<I>        // Próba modyfikacji atrybutu read-only</I>
        else if (name.equals("Changes")) {
            throw new AttributeNotFoundException("Atrybut tylko do odczytu");
        }
        else 
            throw new AttributeNotFoundException("Nieznany atrybut: " + name);
    }
    
<I>
    /**
     * Ustala wartoœci atrybutów z listy attributes
     */</I>
    public AttributeList <B>setAttributes</B>(AttributeList attributes) {

        AttributeList results = new AttributeList();

        for (Iterator i = attributes.iterator(); i.hasNext();) {
            Attribute attr = (Attribute) i.next();
            try {
                setAttribute(attr);
<I>                // Jeœli siê uda³o to dodajemy do wynikowej listy</I>
                results.add(attr);
            } catch(Exception e) {
<I>                // Nie przekazujemy wyj¹tków wo³aj¹cemu</I>
            }
        }
        return results;
    }
</pre>
<P>
<DIV CLASS=notel>
Jeœli typy nie bêd¹ zgodne to maszyna wirtualna zg³osi wyj¹tek <CODE>ClassCastException</CODE>.
</DIV>
Metoda <CODE>setAttribute()</CODE> musi sprawdziæ, 
czy przekazana nowa wartoœæ atrybutu mo¿e zostaæ przypisana do tego atrybutu -
czyli czy typy tych obiektów s¹ zgodne (w czasie wykonania).
S³u¿y do tego metoda <CODE>isAssignableFrom(Class&lt;?&gt; cls)</CODE> z klasy <CODE>Class</CODE>.
Jeœli typy nie s¹ zgodne, to metoda musi zg³osiæ wyj¹tek <CODE>InvalidAttributeValueException</CODE>.
</P>
<P>
Aby wykonaæ operacjê m-ziarna wywo³ujemy ogóln¹ metodê <CODE>invoke(...)</CODE> 
przekazuj¹c jej tablice z argumentami i sygnatur¹.
Ta ostatnia s³u¿y do rozró¿nienia przeci¹¿onych wariantów metod.
Jeœli ¿¹dano wykonania nieistniej¹cej operacji, to nale¿y zg³osiæ wyj¹tek
<CODE>NoSuchMethodException</CODE> opakowany w <CODE>ReflectionException</CODE>.
</P>
<pre>
<I>
    /**
     * Wywo³uje metodê o nazwie operationName i sygnaturze signature
     * przekazuj¹c parametry params i zwracaj¹c wynik
     */</I>
    public Object <B>invoke</B>(String operationName, Object params[], String signature[])
                  throws ReflectionException {

        if (operationName.equals("reset"))
            return reset();
        else 
<I>            // Nieznana operacja</I>
            throw new ReflectionException(new NoSuchMethodException(operationName));
    }
    
<I>
    /**
     * Zwraca informacje o m-ziarnie
     */</I>
    public MBeanInfo <B>getMBeanInfo</B>() {
        return mBeanInfo;
    }
</pre>
<P>
Metoda <CODE>getMBeanInfo()</CODE> zwraca informacjê o m-ziarnie zaszyt¹ w obiekcie 
klasy <CODE>MBeanInfo</CODE>.
Mo¿e ona zmieniaæ tê informacjê w trakcie dzia³ania programu, 
zmieniaj¹c tym samym w³aœciwoœci m-ziarna (atrybuty, operacje).
Nasza implementacja zwraca obiekt <CODE>mBeanInfo</CODE> przygotowany w konstruktorze, 
poniewa¿ nie planujemy modyfikacji w³aœciwoœci m-ziarna.
</P>
<P>
Tak jak poprzednio, musimy dostarczyæ implementacji metody <CODE>getNotificationInfo()</CODE>
interfejsu <CODE>NotificationBroadcaster</CODE>, 
poniewa¿ jej implementacja odziedziczona z klasy <CODE>NotificationBroadcasterSupport</CODE>
jest pusta, a w zwi¹zku z tym nieadekwatna do rzeczywistego stanu.
Zwraca ona informacjê o sygna³ach emitowanych przez to m-ziarno.
Kod tej metody jest podobny w wiêkszoœci prostych przypadków.
Zmianie ulega jedynie komunikat bêd¹cy ostatnim argumentem konstruktora.
</P>
<pre>
    public MBeanNotificationInfo[] <B>getNotificationInfo</B>() {
        return new MBeanNotificationInfo[] {
            new MBeanNotificationInfo(
                new String[] {AttributeChangeNotification.ATTRIBUTE_CHANGE},
                AttributeChangeNotification.class.getName(),
                "Sygna³ emitowany po wywo³aniu reset()"
            )
        };
    }

<I>
    /**
     * Informacja o dynamicznym m-ziarnie
     */</I>
    MBeanInfo <B>mBeanInfo</B>;

<I>
    /**
     * Publiczny konstruktor
     */</I>
    public <B>Dynamic</B>(){
<B>        mBeanInfo = buildMBeanInfo();</B>
    }
    
<I>
    /**
     * Tworzy informacjê o m-ziarnie zawart¹ w MBeanInfo
     */</I>
    private MBeanInfo <B>buildMBeanInfo</B>() {

        MBeanAttributeInfo[] attributes = {
            new MBeanAttributeInfo("Message", 
                                   "java.lang.String", 
                                   "Komunikat", 
                                   true, 
                                   true, 
                                   false),
            new MBeanAttributeInfo("Changes", 
                                   "java.lang.Integer", 
                                   "Licznik zmian komunikatu", 
                                   true, 
                                   false, 
                                   false)
        };

        MBeanConstructorInfo[] constructors = {
            new MBeanConstructorInfo("Konstruktor", getClass().getConstructors()[0])
        };

        MBeanOperationInfo[] operations = {
            new MBeanOperationInfo("reset", 
                                   "Resetuje m-ziarno", 
                                   new MBeanParameterInfo[0], 
                                   "java.lang.Integer", 
                                   MBeanOperationInfo.ACTION)
        };

        MBeanNotificationInfo[] notifications = {
            new MBeanNotificationInfo(
                new String[] {AttributeChangeNotification.ATTRIBUTE_CHANGE},
                AttributeChangeNotification.class.getName(),
                "Sygna³ emitowany po wywo³aniu reset()")
        };

        return new MBeanInfo(this.getClass().getName(),
                             "Przyk³ad dynamicznego m-ziarna",
                             attributes,
                             constructors,
                             operations,
                             notifications);
    }
}
</pre>
<P>
Metoda <CODE>buildMBeanInfo()</CODE> buduje informacjê o m-ziarnie zawart¹ w obiekcie
klasy <CODE>MBeanInfo</CODE>.
Sk³ada siê ona z tablic wyliczaj¹cych jego atrybuty, konstruktory, operacje i sygna³y.
Warto zauwa¿yæ, ¿e w sk³ad <CODE>MBeanInfo</CODE> wchodzi tablica obiektów 
<CODE>MBeanNotificationInfo</CODE> opisuj¹cych sygna³y, 
która w poprzednim przypadku (m-ziarno standardowe) by³a zwracana
przez dedykowan¹ metodê (<CODE>getNotificationInfo()</CODE>).
</P>
<P>
Jak widaæ przygotowanie dynamicznego m-ziarna wymaga³o wiêkszego zachodu 
ni¿ w przypadku m-ziarna standardowego.
Jego zalet¹ jest mo¿liwoœæ modyfikacji w³aœciwoœci m-ziarna w czasie wykonania programu.
Jest ona na tyle istotna, ¿e warta dodatkowych nak³adów.
</P>
<P>
Jak siê oka¿e, sposób pos³ugiwania siê takim m-ziarnem - zarówno z poziomu agenta jak i klienta -
jest taki sam jak w przypadku standardowym.
Zatem te typy ziaren ró¿ni¹ siê jedynie sposobem przygotowania kodu
(no i oczywiœcie mo¿liwoœciami).
</P>
<BR><HR><a name="JMX2.9"></a><H2><A NAME="RMICONN">9. Stosowanie ³¹cznika RMI</A></H2>
<P>
Uruchamiaj¹c poprzednie przyk³adowe programy korzystaj¹ce z technologii JMX 
musieliœmy podawaæ specjalny zestaw opcji maszynie wirtualnej.
Powodowa³y one m.in. zainstalowanie ³¹cznika, poprzez który aplikacje klienckie
mog³y ³¹czyæ siê z m-serwerem zawartym w maszynie wirtualnej.
</P>
<DIV CLASS=notel>
Opisywane tu klasy i interfejsy, podobnie jak inne zwi¹zane z sieciowym aspektem JMX,
znajduj¹ siê w pakiecie <CODE>javax.management.remote</CODE>.
</DIV>
<P>
Uaktywnianie w ten sposób warstwy JMX jest k³opotliwe i nie zawsze wykonalne
(np. jeœli chcemy pod³¹czyæ siê do ju¿ dzia³aj¹cej JVM).
Oczywiœcie istnieje inny - bardziej uniwersalny - sposób wykonania tego zadania.
Polega on na utworzeniu obiektu, który bêdzie serwerem dla nadchodz¹cych po³¹czeñ i
uruchomieniu go odpowiedni¹ metod¹.
</P>
<P>
Tym serwerem jest obiekt klasy <CODE>JMXConnectorServer</CODE>.
Koñcówka klienta - tak jak we wczeœniej opisanym przypadku - 
jest reprezentowana przez obiekt typu <CODE>JMXConnector</CODE> 
zwracany przez statyczn¹ metodê <CODE>JMXConnectorFactory.connect(..)</CODE>.
</P>
<P>
Aby uzyskaæ serwer po³¹czeñ nale¿y wywo³aæ statyczn¹ (i jedyn¹) metodê klasy 
<CODE>JMXConnectorServerFactory</CODE>:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
JMXConnectorServer <B>newJMXConnectorServer</B>(JMXServiceURL serviceURL, Map environment, MBeanServer mbeanServer)
</PRE>
Argumenty:
<DL CLASS=args>
  <DT><CODE>serviceURL</CODE></DT>
    <DD>adres serwera po³¹czeñ</DD>
  <DT><CODE>environment</CODE></DT>
    <DD>œrodowisko - przewa¿nie <CODE>null</CODE></DD>
  <DT><CODE>mbeanServer</CODE></DT>
    <DD>serwer m-ziaren, dla którego tworzymy ³¹cznika</DD>
</DL>
</DIV>
</P>
<P>
Serwer jest gotowy do u¿ytku po wydaniu mu polecenia <CODE>start()</CODE>.
Po zakoñczeniu pracy nale¿y go zdeaktywowaæ poleceniem <CODE>stop()</CODE>.
</P>
<P>
Nastêpuj¹cy (standardowy) kod powoduje utworzenie ³¹cznika i uruchomienie go, 
a nastêpnie zatrzymanie - po wykonaniu zadania, kiedy nie jest ju¿ potrzebny.
<pre>
<I>// Utworzenie m-serwera, na przyk³ad:</I>
MBeanServer mbs = MBeanServerFactory.createMBeanServer();
<I>/*
 * Utworzenie URLa dla tego serwisu w zwyk³y sposób:
 *            <VAR>host</VAR> jest nazw¹ hosta
 *            <VAR>port</VAR> jest numerem portu 
 *            <VAR>name</VAR> jest jak¹œ nazw¹ - identyfikatorem
 */</I>
String url = "service:jmx:rmi:///jndi/rmi://<VAR>host</VAR>:<VAR>port</VAR>/<VAR>name</VAR>";
JMXServiceURL jmxurl = new JMXServiceURL(url);
JMXConnectorServer cs = <B>JMXConnectorServerFactory.newJMXConnectorServer</B>(jmxurl, null, mbs);

<I>// Uruchomienie serwera po³¹czeñ</I>
cs.start();
<I>/* 
 * Obs³uga zg³oszeñ klientów ...
 */</I>
<I>// Zatrzymanie serwera po³¹czeñ</I>
cs.stop();
</pre>
<P>
£¹cznik jest zainstalowany na maszynie <CODE>host</CODE> i numerze portu <CODE>port</CODE>.
pod nazw¹ <CODE>name</CODE>.
Te trzy elementy wchodz¹ w sk³ad URLa (a w tym przypadku nawet ca³kowicie go determinuj¹),
który bêdzie lokalizowa³ serwer po³¹czeñ w sieci.
Klient bêdzie go u¿ywa³ do odnalezienia serwera w trakcie nawi¹zywania po³¹czenia.
</P>
Po wywo³aniu <CODE>stop()</CODE> ³¹cznik jest nieaktywny i nie mo¿e zostaæ ponownie uruchomiony.
</P>
<P>
Powy¿sze rozwi¹zanie jest bardziej elastyczne ni¿ poprzednie:
pozwala zainstalowaæ ³¹cznik na ju¿ dzia³aj¹cej maszynie wirtualnej,
jak równie¿ zakoñczyæ go w dowolnej chwili zwalniaj¹c port.
Dziêki temu wyœmienicie nadaje siê do tworzenia tymczasowych po³¹czeñ.
Ponadto, mo¿emy w ten sposób zainstalowaæ wiele ³¹czników na ró¿nych portach 
(z ew. obs³ug¹ ró¿nych protoko³ów  dostêpu do m-serwera).
</P>
<P>
Uci¹¿liwoœci¹ tego rozwi¹zania jest koniecznoœæ uruchomienia rejestru RMI
(jako zewnêtrznego programu <SAMP>rmiregistry</SAMP>  lub poprzez wywo³anie metody 
<DIV CLASS=notel>
Przypomnienie: 
rejestr RMI przechowuje obiekty Javy, które mog¹ byæ udostêpniane innym JVM.
</DIV>
<DIV CLASS=syntax>
<PRE CLASS=syntax>
java.rmi.registry.LocateRegistry.<DFN>createRegistry</DFN>(int port)
</PRE>
</DIV>
</P>
<P>
<DIV CLASS=important>
Rejestr RMI musi byæ uruchomiony przed utworzeniem ³¹cznika.
</DIV>
</P>
<P>
Z punktu widzenia klienta dostêp do tak utworzonego ³¹cznika jest taki sam jak 
we wczeœniej opisanym przypadku.
Kod agenta równie¿ nie ulega innym zmianom (poza tworzeniem i uruchamianiem serwera ³¹cznika).
</P>

<BR><HR><a name="JMX2.10"></a><H2><A NAME="SEARCH">10. Wyszukiwanie m-ziaren w m-serwerze</A></H2>
<P>
Poni¿sze metody interfejsu <CODE>MBeanServerConnection</CODE>
zwracaj¹ zbiór nazw m-ziaren (pierwsza) lub zbiór m-ziaren (druga) 
zarejestrowanych w m-serwerze:
<DIV CLASS=syntax>
<PRE CLASS=syntax>
Set <B>queryNames</B>(ObjectName name, QueryExp query) 
Set <B>queryMBeans</B>(ObjectName name, QueryExp query) 
</PRE>
Argumenty:
<DL CLASS=args>
  <DT><CODE>name</CODE></DT>
    <DD>jest wzorcem</DD> 
  <DT><CODE>query</CODE></DT>
    <DD>jest wyra¿eniem relacyjnym</DD> 
</DL>
</DIV>
</P>
<P>
Argumenty pozwalaj¹ na zdefiniowanie filtra ograniczaj¹cego wynikowy zbiór
do interesuj¹cych nas elementów.
Jeœli oba argumenty bêd¹ równe <CODE>null</CODE>, 
to zwrócone zostan¹ wszystkie zarejestrowane m-ziarna.
</P>
<P>
W najprostszym przypadku filtrowanie mo¿na oprzeæ na obiekcie <CODE>name</CODE> 
(typu <CODE>ObjectName</CODE>) przekazanym jako pierwszy argument 
(drugim argumentem jest wtedy <CODE>null</CODE>).
Okreœla on wzorzec, do którego bêd¹ dopasowane nazwy m-ziaren.
W wynikowym zbiorze znajd¹ siê tylko te, które pasuj¹ do wzorca.
Napis przekazany konstruktorowi <CODE>ObjectName</CODE> musi mieæ 
<A HREF="../JMX1/JMX1.html#MNAME">postaæ opisan¹ w poprzednim wyk³adzie</A>, 
ale mo¿e dodatkowo zawieraæ specjalne metaznaki <CODE>*</CODE> i <CODE>?</CODE>, 
których znaczenie jest nastêpuj¹ce:
<DIV CLASS=notel>
Przypomnienie: obiekt klasy <CODE>ObjectName</CODE> tworzymy przekazuj¹c konstruktorowi
napis sk³adaj¹cy siê z nazwy domeny i listy z³o¿onej z dowolnej liczby (równie¿ 0)
par <VAR>klucz=wartoœæ</VAR> oddzielonych przecinkami:
<STRONG><CODE>"domena:key1=value1,key2=value2"</CODE></STRONG>.
</DIV>
<DIV CLASS=def>
<DL CLASS=args>
  <DT><CODE><STRONG>?</STRONG></CODE> (<EM>pytajnik</EM>) - </DT>
    <DD>w nazwie domeny oznacza jeden znak</DD>
  <DT><CODE><STRONG>*</STRONG></CODE> (<EM>gwiazdka</EM>) - </DT>
    <DD> w nazwie domeny oznacza zero lub wiêcej znaków,<BR>
         na liœcie w³aœciwoœci oznacza dowoln¹ liczbê par <VAR>klucz=wartoœæ</VAR>
    </DD>
</DL>
</DIV>
</P>
<P>
Kolejnoœæ wystêpowania par w nazwie nie jest istotna, 
zatem umiejscowienie gwiazdki we wzorcu równie¿ nie ma wp³ywu na dopasowanie.
Efekt bêdzie niezale¿ny od jej po³o¿enia - na pocz¹tku listy, w œrodku czy na koñcu.
</P>
<P>
Przyk³ady:
<UL>
<LI><CODE>"*:*"</CODE> jest wzorcem, do którego pasuj¹ wszystkie nazwy m-ziaren</LI>
<LI><CODE>"MojaDomena:*"</CODE> jest wzorcem okreœlaj¹cym wszystkie m-ziarna w domenie <CODE>MojaDomena</CODE></LI>
<LI>
<CODE>"*ojaDomena:type=MojeZiarno,*"</CODE> jest wzorcem, do którego pasuj¹ te m-ziarna, których:
<OL>
<LI>
nazwa domeny koñczy siê na <CODE>ojaDomena</CODE>, 
czyli np. <CODE>MojaDomena</CODE> lub <CODE>TwojaDomena</CODE>
</LI>
<LI>
z kluczem <CODE>type</CODE> maj¹ skojarzon¹ wartoœæ <CODE>MojeZiarno</CODE>;
mog¹ mieæ równie¿ inne pary <VAR>klucz=wartoœæ</VAR>
</LI>
</OL>
</LI>
</UL>
</P>
<P>
Jak widaæ, obiekty typu <CODE>ObjectName</CODE> mog¹ byæ nazwami 
nie tylko pojedynczych m-ziaren, ale równie¿ - dziêki u¿yciu metaznaków - 
mog¹ specyfikowaæ grupy m-ziaren, których nazwy pasuj¹ do wzorca.
</P>
<P>
Bardziej z³o¿one wyszukiwanie mo¿na wyspecyfikowaæ korzystaj¹c z drugiego argumentu.
Obiekty tego typu uzyskuje siê statycznymi metodami klasy <CODE>Query</CODE> 
z pakietu <CODE>javax.management</CODE>.
Pozwalaj¹ one budowaæ wyra¿enia logiczne w oparciu o klucze i odpowiadaj¹ce im wartoœci
zaszyte w nazwach m-ziaren.
Wiêcej na ten temat w dokumentacji klasy <CODE>Query</CODE>.
</P>

<BR><HR><a name="JMX2.11"></a><H2>11. Rozwój JMX</H2>

<P>
Implementacja specyfikacji JMX zosta³a w³¹czona po raz pierwszy do JDK 5.0.
W wersji JDK 6 pojawi³o siê kilka usprawnieñ, jednak prawdziwa rewolucja szykowa³a siê w wersji 7,
w postaci implementacji JMX API 2.0, opisywanej dokumentem JSR 255.
Z powodu ró¿nych ograniczeñ zdecydowano siê prze³o¿yæ wdro¿enie nowej wersji JMX do JDK 8.
</P>    
    
<P>
Najwa¿niejsze dodatki wprowadzone w JDK 6 to:
<UL>
<LI>
Wsparcie dla synchronizatorów pakietu <CODE>java.util.concurrent</CODE>.
W szczególnoœci mx-ziarno <CODE>ThreadMXBean</CODE> podaje informacje nie tylko o standardowych synchronizatorach typu <CODE>Object</CODE>,
na które mo¿e oczekiwaæ w¹tek, ale równie¿ uwzglêdnia obiekty typu 
<CODE>java.util.concurrent.locks.AbstractOwnableSynchronizer</CODE>.
</LI>    
<LI>
Oficjalne wsparcie dla <SAMP>jconsole</SAMP> (w JDK 5 by³ to eksperymentalny dodatek).
Pojawi³o siê równie¿ kilka mniej istotnych zmian w interfejsie, wsparcie dla wtyczek, 
oraz dynamiczne przy³¹czanie - implementacja Attach API 
(dziêki czemu nie trzeba uruchamiaæ nadzorowanej aplikacji ze specjalnymi opcjami aby umo¿liwiæ jej lokalne monitorowanie).
</LI>    
<LI>
Wsparcie dla typów sparametryzowanych.
</LI>    
</UL>
</P>    
<P>
Specyfikacja JSR 255 jest nakierowana przede wszystkim na pe³ne wykorzystanie typów sparametryzowanych oraz adnotacji.
</P>

<BR><HR><a name="JMX2.12"></a><H2>12. Æwiczenia</H2>
<P>
Stworzyæ "prawdziwie" dynamiczne m-ziarno, t.j. takie, do którego mo¿na dodawaæ i usuwaæ atrybuty w czasie wykonania.
<H3>Wskazówka</H3>
Wzorowaæ siê na <A HREF="#DYNAMIC">przyk³adzie dynamicznego m-ziarna.</A>
Wykorzystaæ mapê kojarz¹c¹ nazwy atrybutów z ich wartoœciami (i ew. typami).
Dodawaæ i usuwaæ nowe atrybuty do/z tej mapy.
</P>    

<BR><HR><a name="JMX2.13"></a><H2>7. Dokumentacja, literatura, aplikacje</H2>

<VAR>JDK_HOME</VAR> oznacza katalog instalacji JDK 6.

<H3>Elektroniczna</H3>
<P>
Dokumentacja podstawowa:
</P>
<UL>
  <LI>
    Witryna <A HREF="http://java.sun.com/products/JavaManagement">java.sun.com/products/JavaManagement</A> - strona domowa JMX.
  </LI>
  <LI>Specyfikacja API - pakiety:
    <UL type="i">
      <LI>
         <CODE>javax.management</CODE> wraz z podpakietami
      </LI>
      <LI>
        <CODE>java.lang.management</CODE>
      </LI>
    </UL>
  </LI>
  <LI>
    Dokument <A HREF="http://java.sun.com/javase/6/docs/technotes/guides/management/">java.sun.com/javase/6/docs/technotes/guides/management/</A>
    (wersja lokalna: JDK_HOME/docs/technotes/guide/management/index.html)
    wprowadza w koncepcje nadzorowania i zarz¹dzania dla jêzyka Java.
  </LI>
  <LI>
    Dokument <A HREF="http://java.sun.com/javase/6/docs/technotes/guides/jmx/index.html">java.sun.com/javase/6/docs/technotes/guides/jmx/index.html</A>
    (wersja lokalna JDK_HOME/docs/technotes/guide/jmx/index.html)
    zawiera odnoœniki do specyfikacji i tutoriala wraz z przyk³adami.
  </LI>
  <LI>
    W¹tek w Java Tutorial poœwiêcony JMX: <A HREF="http://java.sun.com/docs/books/tutorial/jmx/">java.sun.com/docs/books/tutorial/jmx/</A>.
  </LI>
</UL>

<H3>Papierowa</H3>
<P>
Po polsku:
<UL>
  <LI>
   artyku³: "JMX - Zdalne zarz¹dzanie aplikacjami i maszyn¹ wirtualn¹ Javy", Bart³omiej Starosta, Software Developer's Journal, 06.2006, str. 54-63.   
  </LI>
  <LI>
   ksi¹¿ka: "JMX. Zarz¹dzanie aplikacjami w jêzyku Java", Bart³omiej Starosta, PJWSTK 2006.
  </LI>
</UL>
Dostêpnych jest równie¿ <A HREF="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/books.jsp">kilka ksi¹¿ek</A> w jêzyku angielskim.
</P>

<H3>Oprogramowanie</H3>
<P>
Przyk³adowe programy znajduj¹ siê w katalogach:
<UL>
  <LI>
   <SAMP><VAR>JDK_HOME</VAR>/demo/management/</SAMP>   
  </LI>
  <LI>
   <SAMP><VAR>JDK_HOME</VAR>/sample/jmx/</SAMP>   
  </LI>
  <LI>
   na stronie <A HREF="http://coldjava.hypermart.net/jmx/jmx-html.htm">coldjava.hypermart.net/jmx/jmx-html.htm</A> znajduje siê adapter dla jêzyka HTML. 
  </LI>    
</UL>
Witryna <A HREF="http://java-source.net/open-source/jmx">java-source.net/open-source/jmx</A> udostêpnia narzêdzia <EM>open-source</EM> dla JMX.
</P>
<HR>

</body>
</html>
