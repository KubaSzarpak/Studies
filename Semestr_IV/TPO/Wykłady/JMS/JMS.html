<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN">
<html
 lang="pl"><head rel="stylesheet" type="text/css"
 href="../style/common.css"> <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1250"> <title>JMS</title><link
 rel="stylesheet" type="text/css" href="../style/common.css"></head>
<body>&lt;
<div align="center"><a name="W12"></a><a name="JMS"></a><h1>Interakcja
za pomocπ komunikatÛw (JMS)</h1>
</div><hr>
<p><i>W úrodowiskach rozproszonych modu≥y aplikacji mogπ
wspÛldzia≥ac poprzez wymianÍ komunikatÛw. Jest to dobry i
ciekawy sposÛb programowania, pozwala bowiem uniezaleøniaÊ kody
modu≥Ûw. Poznamy go na przyk≥adzie JMS (Java Messaging Service).</i><br>
</p><hr>
<a name="W12.1"></a><a name="JMS.1"></a><h2>1. Wprowadzenie</h2>
<br>Klienci (fragmenty systemu, aplikacje itp.)&nbsp; w úrodowisku
rozproszonym mogπ wspÛ≥dzia≥aÊ poprzez wymianÍ
komunikatÛw, przy czym:<br>
<ul> <li>klient-producent wysy≥a komunikat,</li> <li>klient-konsument
odczytuje komunikat,</li> <li>obaj klienci nie muszπ dzia≥aÊ
rÛwnoczeúnie,</li> <li>øaden z nich nie musi nic "wiedzieÊ" o budowie,
kodzie itp. drugiego.</li>
</ul><div class="important"> WspÛ≥dzia≥anie aplikacji poprzez wymianÍ
komunikatÛw ma tÍ zaletÍ, øe uniezaleønia kody programÛw
od siebie ("loose coupling")</div><br>
<br>Ten sposÛb programowania realizowany jest na rÛønych
platformach poprzez rÛøne technologie - np.&nbsp; IBM MQseries.<br>
<br>W úrodowisku Javy mamy do dyspozycji JMS (Java Messaging Service).<br>
<br><div class="def"><br>
<div style="text-align: center;"><span style="font-weight: bold;"><!----><a
 name="ind.12.1"></a>Java Messaging Service</span> to API (zestaw
interfejsÛw), ktÛre zapewnia m.in.:<br>
</div><ul> <li>synchronicznπ wymianÍ komunikatÛw (klient czeka na
komunikat, spodziewa siÍ go),</li> <li>asynchronicznπ wymianÍ
komunikatÛw (JMS wysy≥a komunikat
do klienta, gdy tylko komunikat siÍ pojawi, a klient nie musi
sprawdzaÊ czy komunikat jest, obs≥uguje go na zasadzie "callback"),</li>
<li>niezawodnoúÊ - gwarancjÍ, øe komunikat zostanie "dostarczony" raz i
tylko raz.<!----></li>
</ul></div><br>
<hr style="width: 100%; height: 2px;"><br><a name="W12.2"></a><a
 name="JMS.2"></a><a name="JMS.2"></a><h2>2.<!----> <a name="ind.12.2"></a>Architektura JMS<!----></h2>
<br><span style="text-decoration: underline; font-weight: bold;">Sk≥adowe
aplikacji JMS</span><br>
<br><ul> <li>serwis (<!----><a name="ind.12.3"></a>JMS provider<!---->)
implementuje interfejsy i dostarcza narzÍdzi administrowania,</li> <li>klienci
- tworzπ, wysy≥ajπ i odbierajπ komunikaty, </li> <li>obiekty
administrowane - destynacje oraz fabryki po≥πczeÒ (sπ
zwykle tworzone i konfigurowane przez narzÍdzia administracyjne, ale
rÛwnieø istnieje programistyczne API do tych celÛw)</li>
</ul><br>
<img style="border: 1px solid ; width: 307px; height: 161px;" alt="r"
 src="images/jms-architecture.gif"><br><span style="font-style: italic;">èrÛd≥o:
J2EE Tutorial (CF - connection factory, D - destination)</span><br>
<br><span style="font-weight: bold; text-decoration: underline;">Destynacje
i domeny</span><br>
<br><div class="def"><!----><a name="ind.12.4"></a>Destynacja JMS&nbsp;
jest miejscem w ktÛrym nadawca umieszcza
wiadomoúci i z ktÛrego odbiorca odczytuje wiadomoúci.<!----></div><br>
<br>Dwie moøliwe domeny (rodzaje destynacji):<br>
<ul> <li><span style="font-weight: bold;">kolejka (Queue)</span> -
&nbsp;Point-to-Point za poúrednictwem kolejki komunikatÛw,
nadawca wysy≥a do okreúlonej nazwanej kolejki (destynacji), odbiorca -
odbiera komunikat z tej kolejki.</li>
</ul><img
 style="border: 1px solid ; width: 365px; height: 108px; float: left;"
 alt="r" src="images/jms-pointToPoint.gif" hspace="10">∞ &nbsp; kaødy
komunikat moøe byÊ odebrany tylko przez jednego odbiorcÍ;<br>
∞ &nbsp; odbiorca moøe odebraÊ wiadomoúÊ niezaleønie od tego czy
nadawca dzia≥a czy teø juz zakoÒczy≥ dzia≥anie;<br>
∞ &nbsp; zasadπ jest, øe odbiorca potwierdza odebranie wiadomoúci,
co zapewnia, øe nie bÍdzie mu ona przys≥ana po raz kolejny.<br>
<br><br>
<span style="font-style: italic;">èrÛd≥o: J2EE Tutorial <br>
<br><br>
</span><ul> <li><span style="font-weight: bold;">temat (Topic)</span>
- zasada<!----> <a name="ind.12.5"></a>publikacji i subskrypcji<!---->.
</li></ul>
&nbsp;<br>
<img
 style="border: 1px solid ; width: 363px; height: 186px; float: left;"
 alt="r" src="images/jms-publishSubscribe.gif" hspace="10">∞ &nbsp;
kaøda wiadomoúÊ moøe mieÊ wielu odbiorcÛw (subskrybentÛw tematu),<br>
<br>∞ &nbsp; w danym temacie moøe publikowa≥ wielu nadawcÛw,<br>
<br>∞ &nbsp; odbiorca moøe odbieracz tylko te wiadomoúci z danego
tematu, ktÛre zosta≥y opublikowane po zapisaniu siÍ przez niego
do&nbsp;subskrypcji<br>
<br><br>
<br><span style="font-style: italic;"><br>
èrÛd≥o: J2EE Tutorial <br>
</span>Uwaga: wersja 1.1 JMS pozwala na oprogramowanie obu typÛw
komunikacji za pomocπ tych samych interfejsÛw.<br>
<br><span style="font-weight: bold; text-decoration: underline;">Architektura
aplikacji JMS</span><br>
<br><img style="border: 1px solid ; width: 339px; height: 252px;"
 alt="r" src="images/jms-programmingModel.gif"><br>
<span style="font-style: italic;">èrÛd≥o: J2EE Tutorial</span><br>
<span style="font-style: italic;"><br><br>
</span><span style="font-weight: bold;">ConnectionFactory</span> -
&nbsp;tworzy po≥πczenie do dostawcy serwisu JMS.<br>
<span style="font-weight: bold;">Destination</span> - okreúla
destynacjÍ nadawanych i odbieranych wiadomoúci.<br>
<br><hr style="width: 100%; height: 2px;">
<a name="W12.3"></a><a name="JMS.3"></a><h2>3. Konfigurowanie obiektÛw
administrowanych</h2>
Fabryka po≥πczeÒ (ConnectionFactory) i destynacja (Destination)
&nbsp;zwane sπ obiektami administrowanymi.<br>
<br><div class="def"><!----><a name="ind.12.6"></a>Administrowane
obiekty JMS okreúlajπ sposÛb ≥πczenia z
serwisem JMS oraz destynacje nadawanych i odbieranych
komunikatÛw i muszπ byÊ zdefiniowane przed uøyciem us≥ug JMS<!----></div><br>
<br>Zazwyczaj&nbsp;<span style="font-weight: bold;">obiekty
administrowane</span>
sπ okreúlane w konfiguracji serwera JMS (ktÛry moøe byÊ czÍúciπ
sk≥adowπ serwera aplikacji) i/lub za pomocπ narzÍdzi administracyjnych
serwera. W ten sposÛb aplikacja (kod programu) uniezaleønia siÍ
od konkretnych implementacji, ktÛre dla rÛønych
serwerÛw sπ rÛøne.<br>
<br>Np. w konfiguracji serwera <span style="font-weight: bold;">OpenJMS</span>
(zob. oprogaramowanie do≥πczone do kursu) definicja obiektÛw
administrowanych moøe wyglπdaÊ w nastÍpujπcy sposÛb:<br>
<pre>  &lt;Connectors&gt;
    &lt;Connector scheme="tcp"&gt;
      &lt;ConnectionFactories&gt;
        &lt;ConnectionFactory name="ConnectionFactory" /&gt;
      &lt;/ConnectionFactories&gt;
    &lt;/Connector&gt;
    &lt;Connector scheme="rmi"&gt;
      &lt;ConnectionFactories&gt;
        &lt;QueueConnectionFactory name="JmsQueueConnectionFactory" /&gt;
        &lt;TopicConnectionFactory name="JmsTopicConnectionFactory" /&gt;
      &lt;/ConnectionFactories&gt;
    &lt;/Connector&gt;
  &lt;/Connectors&gt;

.....

  &lt;AdministeredDestinations&gt;
    &lt;AdministeredTopic name="topic1"&gt;
      &lt;Subscriber name="sub1" /&gt;
      &lt;Subscriber name="sub2" /&gt;
    &lt;/AdministeredTopic&gt;

    &lt;AdministeredQueue name="queue1" /&gt;
    &lt;AdministeredQueue name="queue2" /&gt;
    &lt;AdministeredQueue name="queue3" /&gt;
  &lt;/AdministeredDestinations&gt;
&nbsp;</pre><span
 style="text-decoration: underline;"></span><br>
W srodowiskach sewrerÛw aplikacji zazwyczaj definiujemy obiekty
administrowane za pomoca odpowiednich narzÍdzi(.<br>
Poniøej pokazano konfiguracjÍ z pozomu konsoli Sun Java Application
Server (SJAS). <br>
<br><span style="font-weight: bold;">Definicja fabryki po≥πczeÒ:</span><br>
<br><img style="width: 700px; height: 590px;" alt="r"
 src="images/SunAppJMS.jpg"><br>
<br><br>
<span style="font-weight: bold;">Definicja fizycznej destynacji</span><br>
<br><img style="width: 700px; height: 590px;" alt="r"
 src="images/SunAppJMS2.jpg"> <br>
<br><span style="font-style: italic; font-weight: bold;">
</span><span style="font-weight: bold;">Powiπzanie nazwy JNDI z
fizycznπ destynacjπ.</span><br>
<br><img style="width: 700px; height: 590px;" alt="r"
 src="images/SunAppJMS3.jpg"><br>
<span style="font-style: italic;"></span><br><br>
Moøna teø tworzyÊ destynacje programistycznie np.&nbsp;<br>
<br><span style="text-decoration: underline;">uzyskanie dostÍpu do
narzÍdzi administracyjnych</span>:<br>
<pre>import org.exolab.jms.administration.AdminConnectionFactory;
import org.exolab.jms.administration.JmsAdminServerIfc;

// ...
    String url = "tcp://localhost:3035/";
    JmsAdminServerIfc admin = AdminConnectionFactory.create(url);</pre><br>
<span style="text-decoration: underline;">utworzenie destynacji -
kolejki o nazwie&nbsp;<span style="font-style: italic;">myqueue</span>:</span><br>
<div class="source"><pre>    String queue = "myqueue";
    Boolean isQueue = Boolean.TRUE;
    if (!admin.addDestination(queue, isQueue)) {
        System.err.println("Failed to create queue " + queue);
    }
        </pre>
</div><p><span style="text-decoration: underline;">utworzenie
destynacji-tematy o nazwie&nbsp;</span><em
 style="text-decoration: underline;">mytopic</em><span
 style="text-decoration: underline;">:</span> </p>
<div class="source"><pre>    String topic = "mytopic";
    Boolean isQueue = Boolean.FALSE;
    if (!admin.addDestination(topic, isQueue)) {
        System.err.println("Failed to create topic " + topic);
    }
        </pre>
</div>ürÛd≥o: OpenJMS User Guide.<br>
<hr style="width: 100%; height: 2px;"><a name="W12.4"></a><a
 name="JMS.4"></a><a name="JMS.4"></a><h2>4. Programowanie klientÛw JMS</h2>
<big><span style="font-weight: bold;"></span></big><br><span
 style="font-weight: bold; text-decoration: underline;"><!----><a
 name="ind.12.7"></a>DostÍp do obiektÛw administrowanych<!----></span><br>
<br>Majπc skonfigurowane obiekty administrowane (ConnectionFactory i
destynacje) w aplikacji JMS uzyskujemy do nich dostÍp za pomocπ JNDI.
Np.<br>
<br><pre>      Context ctx = new InitialContext();
      ConnectionFactory fact = (ConnectionFactory) ctx.lookup("ConnectionFactory");
      String admDestName = "myqueue";
      Destination dest = (Destination) ctx.lookup(admDestName);
</pre>
Uwaga: <br>
<ol style="font-style: italic;"> <li>tutaj nazwπ JNDI dla fabryki
po≥πczeÒ jest "ConnectionFactory", moøe byÊ inna nazwa (np.
jms/ConnectionFactory)</li> <li>dostawca inicjalnego kontekstu musi
byÊ okreslony w
jndi.properties albo za pomoca w≥aúciwoúci systemowych. zgodnie z
konfiguracjπ serwera JMS.</li>
</ol><br>
<span style="font-weight: bold; text-decoration: underline;"><!----><a
 name="ind.12.8"></a>Po≥πczenie i sesja<!----></span><br>
<br>NastÍpnym krokiem jest uzyskanie po≥aczenia z serwerem JMS -
uzyskanie
obiektu typu javax.jms.Connection, a na jego podstawie stworzenie <span
 style="font-weight: bold;">sesji</span>:<br>
<br><pre>      Connection con = fact.createConnection();
      Session ses = con.createSession(false, Session.AUTO_ACKNOWLEDGE);

// false - bez transakcyjnosci
// AUTO_ACKNOWLEDGE - automatyczne potwierdzanie</pre>
<br><div class="def"><span style="font-weight: bold;">Sesja JMS</span>
jest jednowπtkowym
kontekstem nadawania-odbierania wiadomoúci i s≥uøy do tworzenia
nadawcÛw i odbiorcÛw wiadomoúci oraz samych wiadomoúci</div> <br>
<br>Przed wysy≥kπ/odbiorem wiadomoúci naleøy otworzyÊ po≥πczenie, a po
zakoÒczeniu dzia≥ania na tym po≥πczeniu - zamknπÊ je:<br>
<br><pre>con.start();
// ....
// Nadawanie lub odbiÛr
//...
con.close();</pre>
<span style="font-weight: bold; text-decoration: underline;"> Wiadomoúci</span><br>
<br><!----><a name="ind.12.9"></a>Wiadomoúci sπ obiektami typÛw
pochodnych od typu Message.<!----><br>
WiadomoúÊ sklada siÍ z nag≥Ûwka, w≥aúciwoúci i zawartoúci (cia≥a
wiadomoúcu)<br>
<br><span style="font-weight: bold; text-decoration: underline;"></span>
<table summary="JMS Message Types" id="wp79628" border="1"> <tbody> <tr
 align="center"> <th> <div class="pCellHeading">&nbsp;Typ<br>
wiadomoúci&nbsp; </div> </th> <th> <div class="pCellHeading">ZawartoúÊ
</div> </th> </tr> <tr align="left"> <td> <div class="pCellBody">
TextMessage </div> </td> <td> <div class="pCellBody">Tekst (String)
</div> </td> </tr> <tr align="left"> <td> <div class="pCellBody">
MapMessage </div> </td> <td> <div class="pCellBody">
Mapa. Klucze = String, wartoúci = obiekty klas opakowujπcych typy
proste (np. Integer) </div> </td> </tr> <tr align="left"> <td> <div
 class="pCellBody"> BytesMessage </div> </td> <td> <div
 class="pCellBody">Zestaw bajtÛw. </div> </td> </tr> <tr
 align="left"> <td> <div class="pCellBody"> StreamMessage </div> </td>
<td> <div class="pCellBody">Sekwencyjny strumieÒ typÛw prostych </div>
</td> </tr> <tr align="left"> <td> <div class="pCellBody">
ObjectMessage </div> </td> <td> <div class="pCellBody">Serializowany
obiekt </div> </td> </tr> <tr align="left"> <td> <div
 class="pCellBody"> Message </div> </td> <td> <div class="pCellBody">
Pusta zawartoúc. RÛwnieø nadtyp dla w/w typÛw </div> </td> </tr> </tbody>
</table><p class="pBody">
Wiadomoúci tworzymy za pomocπ odpowiednich metod intefejsu Session np:</p>
<br><pre>// Utworzenie wiadomoúci tekstowej:
TextMessage msg = ses.createTextMessage();
msg.setText(...);</pre>
<br><span style="font-weight: bold; text-decoration: underline;">Nadawanie
wiadomoúci</span><br>
<br><pre>// Utworzenie nadawcy, ktÛry bÍdzie posy≥a≥ wiadomoúci do destynacji dest
MessageProducer sender = ses.createProducer(dest);

// Pos≥anie wiadomoúci msg
sender.send(msg);
</pre>
<br><span style="font-weight: bold; text-decoration: underline;">Odbieranie
wiadomoúci</span><br>
<br><pre>// Utworzenie odbiorcy, ktÛry bÍdzie odbiera≥ wiadomoúci z destynacji dest
MessageConsumer receiver = ses.createConsumer(dest);

// OdbiÛr
Message msg = receiver.receive(); // blokowanie,
                                  //dopÛki wiadomoúc nie bÍdzie dostÍpna
// ....
Message msg = receiver.receive(n); // blokowanie (ale nie d≥uøej niø n ms)
// ...
Message msg = receiver.receiveNoWait(); // wraca od razu; null - brak wiadomoúci
</pre>
<span style="font-weight: bold; text-decoration: underline;"><br></span>OgÛlnie
sposÛb programowania (uøycie
interfejsÛw) przy nadawaniu i odbieraniu wiadomoúci jest taki
sam, niezaleønie od tego czy destynacja jest kolejkπ (Queue) czy
tematem (Topic).<br>
Naleøy jednak pamiÍtaÊ o rÛønicach pomiÍdzy dzia≥aniem w trybie
"Point-to-Point" oraz publisher/subscriber.<br>
<br><br>
<span style="font-weight: bold; text-decoration: underline;">S≥uchacze
wiadomoúci</span><br>
<br><div class="def"><!----><a name="ind.12.10"></a>S≥uchacze
wiadomoúci sπ obiektami klas implementujπcych interfejs
MessageListener z jednπ metodπ onMessage(Message), ktÛra jest
wywo≥ywana, gdy wiadomoúÊ dociera do danej destynacji (moøe to byÊ
Queue lub Topic). W ten sposÛb realizowany jest asynchroniczny -
na zasadzie "callback" odbiÛr wiadomoúci.<!----></div><br>
<br>Po stworzeniu s≥uchacza wiadomoúci ustalamy go dla danego odbiorcy
za pomocπ metody setMessageListener().<br>
<br><pre>class MsgListener implements MessageListener {
   public void onMessage(Message msg) {
       // ... przetwarzanie wiadomoúci msg
   }
}

// ....
MessageConsumer receiver;
// ....&nbsp;
MessageListener msgl = new MsgListener();
//....
receiver.setMessageListener(msgl);
</pre>
<br><div class="important">Ten mechanizm JMS jest stosowany w tzw.
message-driven Enterprise Java Beans.</div> <br>
<hr style="width: 100%; height: 2px;"><a name="W12.5"></a><a
 name="JMS.5"></a><a name="JMS.5"></a><h2>5.<!----> <a name="ind.12.11"></a>Komunikaty w
trybie point-to-point<!----></h2>
Rozwaømy prosty przyk≥ad posy≥ania - odbioru wiadomoúci tekstowych. <br>
Poniøej pokazano teksty programÛw klienckich.<br>
<br><span style="text-decoration: underline;">Nadawca<br>
</span>Posy≥a wiadomoúÊ tekstowπ (podanπ jako drugi argument) do
destynacji podanej jako pierwszy argument<span
 style="text-decoration: underline;"><br>
</span><pre>import javax.naming.*;
import javax.jms.*;

public class Sender {

  public static void main(String[] args) {

    Connection con = null;
    try {
      Context ctx = new InitialContext();
      ConnectionFactory factory = (ConnectionFactory) ctx.lookup("ConnectionFactory");
      String admDestName = args[0];
      Destination dest = (Destination) ctx.lookup(admDestName);
      con = factory.createConnection();
      Session ses = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
      MessageProducer sender = ses.createProducer(dest);
      con.start();
      TextMessage msg = ses.createTextMessage();
      msg.setText(args[1]);
      sender.send(msg);
      System.out.println("Sender sent msg: " + args[1]);
    } catch (Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    } finally {
        if (con != null) {
          try {
            con.close();
          } catch (JMSException exc) {
              System.err.println(exc);
          }
        }
    }
    System.exit(0);
  }
}</pre>
<br><span style="text-decoration: underline;">Odbiorca<br>
</span>Odbiera wiadomoúÊ tekstowπ z destynacji podanej jako argument.<span
 style="text-decoration: underline;"><br>
</span><pre>import javax.naming.*;
import javax.jms.*;

public class Receiver {

  public static void main(String[] args) {
      Connection con = null;
      try {
        Context ctx = new InitialContext();
        ConnectionFactory factory = (ConnectionFactory) ctx.lookup("ConnectionFactory");
        String admDestName = args[0];
        Destination dest = (Destination) ctx.lookup(admDestName);
        con = factory.createConnection();
        Session ses = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        MessageConsumer receiver = ses.createConsumer(dest);

        con.start();
        System.out.println("Receiver started");
        Message msg = receiver.receive();
        if (msg instanceof TextMessage) {
            TextMessage text = (TextMessage) msg;
            System.out.println("Received: " + text.getText());
        } else if (msg != null) {
            System.out.println("Received non text message");
        }
      } catch (Exception exc) {
          exc.printStackTrace();
          System.exit(1);
      } finally {
          if (con != null) {
            try {
              con.close();
            } catch (JMSException exc) {
                System.err.println(exc);
            }
          }
      }
      System.exit(0);
  }
}</pre>
<br><span style="font-weight: bold;"></span>Do przetestowania dzia≥ania
pokazanych klas uøyjemy destynacji queue1 z konfiguracji serwera
OpenJMS.<br>
<br><span style="text-decoration: underline;">Kolejnoúc uruchomienia</span>:
nadawca, odbiorca<br>
<br><div class="listing100"><br>
E:\&gt;java -cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Sender queue1 "ala ma
kota"<br>
Sender sent msg: ala ma kota<br>
E:&gt;_<br>
</div><br><br>
Nadawca zakoÒczy≥ dzia≥anie. Uruchomienie odbiorcy (w innej sesji
znakowej) skutkuje natychmiastowym odczytaniem wiadomoúci:<br>
<br><div class="listing100"><br>
E:\&gt;java -cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver queue1<br>
Receiver started<br>
Received: ala ma kota<br>
E:\&gt;_<br>
</div><br><br>
WiadomoúÊ zostala skonsumowana. Ani ten ani øaden inny klient queue1
nie dostanie jej wiÍcej.<br>
<br>Teraz zmienimy kolejnoúÊ.<br>
<span style="text-decoration: underline;">Kolejnoúc uruchomienia</span>:
odbiorca, nadawca<br>
<br><div class="listing100"><br>
E:\&gt;java -cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver queue1<br>
Receiver started<br>
</div><br><br>
Odbiorca jest zablokowany i czeka na ew. wiadomoúc.<br>
<br>Po wystartowaniu nadawcy:<br>
<div class="listing100"><br>E:\&gt;java
-cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Sender queue1 "Witam. Co slychac?"<br>
Sender sent msg:&nbsp;Witam. Co slychac?<br>
E:&gt;_<br>
</div><br><br>
odbiorca natychmiast odbierze wiadomoúÊ i zakoÒczy dzia≥anie:<br>
<br><div class="listing100"><br>
Received:&nbsp;Witam. Co slychac?<br>
E:\&gt;_<br>
</div><br><br>
<br><span style="font-weight: bold;"><a href="mm/w12p1/w12p1.html"
 target="_blank">Zobacz prezentacjÍ multimedialnπ </a>&nbsp;<a
 href="mm/w12p1/w12p1.html"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt="r"
 src="../STYLE/video2.gif"></a></span><br>
<br><hr style="width: 100%; height: 2px;">
<a name="W12.6"></a><a name="JMS.6"></a><h2><span
 style="font-weight: bold;">6. S≥uchacze wiadomoúci - przyk≥ad</span></h2>
Poniøszy program reaguje na komunikaty posy≥ane do kolejki <span
 style="font-style: italic;">queue1</span>.<br>
<pre>import javax.naming.*;
import javax.jms.*;
import javax.swing.*;
import java.awt.event.*;

import javax.naming.*;
import javax.jms.*;
import javax.swing.*;
import java.awt.event.*;

public class AsynchrReceiver extends JFrame implements MessageListener {

  private Connection con;
  private JTextArea ta = new JTextArea(10, 20);

  public AsynchrReceiver(String destName) {

    try {
      Context ctx = new InitialContext();
      ConnectionFactory factory = (ConnectionFactory) ctx.lookup("ConnectionFactory");
      Destination dest = (Destination) ctx.lookup(destName);
      con = factory.createConnection();
      Session ses = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
      MessageConsumer receiver = ses.createConsumer(dest);
      receiver.setMessageListener(this);
      con.start();
    } catch (Exception exc) {
         exc.printStackTrace();
         System.exit(1);
    }

    add(new JScrollPane(ta));

    addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        try { con.close(); } catch(Exception exc) {}
        dispose();
        System.exit(0);
      }
    });
    setTitle("Czekam");
    pack();
    setLocationRelativeTo(null);
    show();
  }

  int i=0;
  public void onMessage(Message msg) {
    setTitle("Received msg " + ++i);
    try {
      ta.append(((TextMessage) msg).getText() + "\\\\n");
    } catch(JMSException exc) { System.err.println(exc); }
  }

  public static void main(String[] args) {
    new AsynchrReceiver("queue1");
  }

}</pre><br>
<span style="font-weight: bold;"><a href="mm/w12p2/w12p2.html"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt="r"
 src="../STYLE/video2.gif"></a><a href="mm/w12p2/w12p2.html"
 target="_blank">Zobacz przentacjÍ mulimedialnπ dzia≥ania programu</a> </span><br>
<hr style="width: 100%; height: 2px;"><a name="W12.7"></a><a
 name="JMS.7"></a><a name="JMS.7"></a><h2><span style="font-weight: bold;">7.<!----> <a
 name="ind.12.12"></a>Dzia≥anie w trybie publisher/subscriber<!----></span></h2>
<br>Dla tych samych klientÛw - klas Sender i Receiver - uøyjemy teraz
destynacji topic1 z konfiguracji serwera OpenJMS.<br>
<br><span style="text-decoration: underline;">Kolejnoúc uruchomienia</span>:
nadawca, odbiorca<br>
<br><div class="listing100"><br>
E:\&gt;java -cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Sender topic1 "ala ma
kota"<br>
Sender sent msg: ala ma kota<br>
E:&gt;_<br>
</div><br><br>
Nadawca opublikowa≥ wiadomoúÊ i zakoÒczy≥ dzia≥anie. <br>
Uruchamiamy odbiorcÍ&nbsp;<br>
<br><div class="listing100"><br>
E:\&gt;java -cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver topic1<br>
Receiver started<br>
</div><br><br>
Subskrybent nie odebra≥ wiadomoúci i jest zablokowany, bowiem
publikacja nastπpila w czasie, gdy subskrybent by≥ nieaktywny.<br>
<br>Moøemy wystartowaÊ kilku innych sybskrybentÛw. Wszyscy bÍdπ czekali.<br>
<br><table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2"> <tbody> <tr> <td
 style="font-family: monospace; background-color: rgb(3, 0, 3); color: rgb(255, 255, 255);">E:\&gt;java
-cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver topic1<br>
Receiver started<br> </td> <td
 style="font-family: monospace; background-color: rgb(3, 0, 3); color: rgb(255, 255, 255);">E:\&gt;java
-cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver topic1<br>
Receiver started<br> </td> <td></td> </tr> </tbody>
</table><br>
Dopiero opublikowanie kolejnej wiadomoúci (np. "Ponownie: ala ma kota")
spowoduje, øe wszyscy dzia≥ajπcy subskrybenci jπ otrzymajπ i zakoÒczπ
dzialanie.<br>
<br><table style="text-align: left; width: 100%;" border="1"
 cellpadding="2" cellspacing="2"> <tbody> <tr
 style="color: rgb(255, 255, 255);"> <td
 style="background-color: rgb(3, 0, 3);">E:\&gt;java
-cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver topic1<br>
Receiver started<br>
Received: Ponownie: ala ma kota<br>
E:&gt;_</td> </tr> <tr style="color: rgb(255, 255, 255);"> <td
 style="background-color: rgb(3, 0, 3);">E:\&gt;java
-cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver topic1<br>
Receiver started<br>
Received: Ponownie: ala ma kota<br>
E:&gt;_</td> </tr> <tr style="color: rgb(255, 255, 255);"> <td
 style="background-color: rgb(3, 0, 3);">E:\&gt;java
-cp&nbsp;openjms-0.7.7-alpha-1.jar;.; Receiver topic1<br>
Receiver started<br>
Received: Ponownie: ala ma kota<br>
E:&gt;_</td> </tr> </tbody>
</table><br>
<hr style="width: 100%; height: 2px;"><h1><span
 style="font-weight: bold;">8.<!----> <a name="ind.12.13"></a>Trwali
subskrybenci<!----></span></h1>
<br>Aby zapewniÊ dostÍp do wiadomoúci publikowanych w danym temacie w
trakcie nieaktywnoúci subskrybenta naleøy zarejestrowaÊ subskrybenta w
danym temacie jako "trwa≥ego subskrybenta" z unikalnπ nazwπ subskrypcji.<br>
<pre>String subName = "MySub";
MessageConsumer topicSubscriber =
&nbsp;&nbsp;session.<span
 style="font-weight: bold;">createDurableSubscriber</span>(myTopic, subName);</pre>JMS
bÍdzie zbieraÊ publikowane w temacie wiadomoúci dla takiego
subskrybenta w czasie gdy jest on nieaktywny i przeúle mu je gdy bÍdzie
aktywny.<br>
<br>Oto przyk≥adowy program trwa≥ego subskrybenta:<br>
<pre>import javax.naming.*;
import javax.jms.*;

public class DurableSubscriber {

  static void printMsg(Message message) throws Exception {
    if (message instanceof TextMessage) {
        TextMessage text = (TextMessage) message;
        System.out.println("Received: " + text.getText());
    } else if (message != null) {
        System.out.println("Received non text message");
    }
  }

  public static void main(String[] args) {
    Connection con = null;
    try {
      Context ctx = new InitialContext();
      ConnectionFactory factory = (ConnectionFactory) ctx.lookup("ConnectionFactory");
      String admTopicName = args[0];
      String subscriptionName = args[1];
      Topic topic = (Topic) ctx.lookup(admTopicName);
      con = factory.createConnection();
      Session ses = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
      TopicSubscriber subs = ses.createDurableSubscriber(topic, subscriptionName);

      con.start();
      while (true) {
        Message message = subs.receiveNoWait();
        if (message == null) {
          System.out.println("Waiting... Press ctrl-c to stop");
          try { Thread.sleep(10000); } catch (Exception exc) { break; }
        }
        else printMsg(message);
      }
    } catch (Exception exc) {
      exc.printStackTrace();
      System.exit(1);
    } finally {
      if (con != null) {
          try {
              con.close();
          } catch (JMSException exc) {
              System.err.println(exc);
          }
      }
    }
    System.exit(0);
  }

}</pre><br>
i scenariusze dzialania.<br>
<br>Startujemy subskrybenta. Poniewaø w temacie nie ma&nbsp; jeszcze
øadnej wiadomoúci - subskrybent czeka na jakπú.<br>
<br><div class="listing100"><br>
E:\&gt;java -cp
E:\openjms-0.7.7-alpha-1\lib\openjms-0.7.7-alpha-1.jar;.;
DurableSubscriber topic1 MojaSubskrypcja<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
</div><br><br>
Ale subskrybent i jego subskrypcja juø zostali zarejestrowani, co mozna
np. zobaczyÊ w konsoli administracyjnej OpenJMS.<br>
<br><img style="width: 300px; height: 300px;" alt="r"
 src="images/subs.jpg"><br>
<br>Przeriwjmy teraz dzia≥anie sybskrybenta i opublikujemy w temacie
topic1
kilka wiadomoúci (mogπ to zrobiÊ rÛøni nadawcy). PamiÍtajmy
odbiorca-subskrybent jest niekatywny.<br>
<br><br>
<div class="listing100"><br>E:\&gt;java -cp
E:\openjms-0.7.7-alpha-1\lib\openjms-0.7.7-alpha-1.jar;.; Sender topic1
"W Londynie jest 17 stopni"<br>
Sender sent msg:&nbsp;W Londynie jest 17 stopni<br>
E:\&gt;java -cp
E:\openjms-0.7.7-alpha-1\lib\openjms-0.7.7-alpha-1.jar;.; Sender topic1
"W Kielcach pada deszcz"<br>
Sender sent msg: W Kielcach pada deszcz<br>
E:\&gt;java -cp
E:\openjms-0.7.7-alpha-1\lib\openjms-0.7.7-alpha-1.jar;.; Sender topic1
"W Hiszpanii&nbsp; upaly"<br>
Sender sent msg:&nbsp;W Hiszpanii&nbsp; upaly<br>
</div><br><br>
Jeøeli teraz (albo za godzine, albo jutro) wystartujemy naszego
subskrybenta - otrzyma on wszystkie zachowane wiadomosci.<br>
<br><div class="listing100"><br>
E:\&gt;java -cp
E:\openjms-0.7.7-alpha-1\lib\openjms-0.7.7-alpha-1.jar;.;
DurableSubscriber topic1 MojaSubskrypcja<br>
Received: W Londynie jest 17 stopni<br>
Received: W Kielcach pada deszcz<br>
Received: W Hiszpanii upaly<br>
Waiting... Press ctrl-c to stop<br>
Waiting... Press ctrl-c to stop<br>
</div><br><br>
Uwagi: <br>
<ol> <li>jeøeli potwierdzamy odbiÛr wiadomoúci (a tak jest w trybie
AUTOMATIC_ACKNOWLEDGE), to otrzymane wiadomoúci nie bÍdπ ponownie
posy≥ane</li> <li>moøemy ustaliÊ czas przechowywania nieodebranych
wiadomoúci (domyúlnie wiadomoúci zachowane sπ na stale).</li>
</ol><br>
<hr style="width: 100%; height: 2px;"><a name="W12.8"></a><a
 name="JMS.8"></a><a name="JMS.8"></a><h2>9. Podsumowanie</h2>
<br>Zapoznaliúmy siÍ z interakcjπ w úrodowiskach rozproszonych za
pomocπ wymiany komunikatÛw.<br>
Przedstawiona zosta≥ architektura JMS i sposoby programowania i
dzia≥ania&nbsp; aplikacji, w szczegÛlnoúci:<br>
<ul> <li>w trybie point-to-point,</li> <li>asynchronicznie, poprzez
nas≥uch komunikatÛw,</li> <li>w trybie publikacji-subskrypcji.</li>
</ul><br>
Pokazano przyk≥ady dzia≥ania w úrodowisku serwera OpenJMS, a takøe
sposoby konfigurowania fabryk i destynacji w SJAS.<br>
<hr style="width: 100%; height: 2px;"><a name="W12.9"></a><a
 name="JMS.9"></a><a name="JMS.9"></a><h2>10. Zadania</h2>
<br><span style="font-weight: bold;">Zadanie</span><br>
<br>StworzyÊ aplikacjÍ rozproszonπ, komunikujπca siÍ poprzez zlecenia
posy≥ane w trybie point-to-point oraz rozsy≥ajπcπ wiadomoúci w trybie
publisher/subscriber. WymyúliÊ praktyczny przyk≥ad zastosowania.<br>
</body></html>