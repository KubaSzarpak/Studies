<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="TPR">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2009">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Nowe wejœcie-wyjœcie (NIO)</title>
</head>
<body>
<br><br>
<div align="Center">
<a name="NIO"></a><h1>Nowe wejœcie-wyjœcie (NIO)</h1>
</div>
<br>

</div>
<hr>
<br><span style="font-style: italic;"> Programowanie aplikacji niemal zawsze wymaga wykonywania operacji wejœcia-wyjœcia. W Javie nie jest to banalne, choæby
ze wzglêdu na bardzo du¿¹ liczbê klas, które temu s³u¿¹. Tu poznamy prawie
wszystkie te klasy, ale przede wszystkim koncepcje, le¿¹ce u podstaw konstrukcji
niezwykle bogatego w mo¿liwoœci, ale jednoczeœnie doœæ zawik³anego œrodowiska&nbsp;
programowania wejœcia-wyjœcia w Javie.</span>
<hr>
<a name="NIO.1"></a><h2>1.  Przegl¹d</h2>

Niew¹tpliwie podstawowym motywem wprowadzenia nowych œrodków wejœcia-wyjœcia,
zawartych w pakiecie java.nio i jego podpakietach by³o zapewnienie zwiêkszenia
efektywnoœci dzia³ania programów w wysokim stopniu obci¹¿onych operacjami
wejœcia-wyjœcia o du¿ej czêstotliwoœci.<br>
  <br>
Tradycyjne wejœcie-wyjœcie w Javie jest <b>blokuj¹ce</b>, tzn. w¹tek, który
podejmuje próbê odczytania danych ze strumienia (metoda read()) jest blokowany,
jeœli danych w strumieniu (jeszcze) nie ma. Zatem obs³uga strumieni po³¹czeñ
sieciowych (przez serwer) musia³a byæ wykonywana poprzez wiele w¹tków, ka¿dy
z których obs³ugiwa³ strumieñ zwi¹zany z jednym gniazdem (socket) i ew. by³
blokowany na tym strumieniu, czekaj¹cy na dane. W takiej sytuacji przy du¿ej
liczbie po³¹czeñ dzia³a równolegle du¿o w¹tków, a poniewa¿ liczba po³aczeñ
zmienia siê dynamicznie, to z du¿¹ czêstotliwoœci¹ wiele w¹tków powstaje
i umiera (przechodzi do stanu Dead). W sumie prowadzi to do problemów efektywnoœciowych,
a tak¿e jest trudne w programowaniu, gdy¿:<br>
  <ul>
    <li>tworzenie i prze³¹czanie w¹tków (realizowane przez JVM) jest czasowo kosztowne,</li>
    <li>szybkie narastanie niepotrzebnych obiektów (zakoñczonych w¹tków)
powoduje zmniejszenie efektywnoœci dzialania programu ze wzglêdu na zwiêkszaj¹c¹
siê zajêtoœc pamiêci, bowiem standardowy odœmiecacz JVM nie &nbsp;jest odpowiednio
przystosowany do takiej sytuacji,</li>
    <li>synchronizowanie du¿ej liczby w¹tków na wspóldzielonych zasobach
mo¿e byæ trudne w programowaniu, zawodne i bardzo czasoch³onna z punktu widzenia efektywnoœci
dzialania programu.&nbsp; </li>
  </ul>
Podstawowym elementem nowego wejœcia-wyjœcia, odpowiadaj¹cym na te problemy,&nbsp; jest koncepcja <b>kana³u</b>.<br>
  <br>
<div class="def"><b>Kana³</b> reprezentuje otwarte po³¹czenie do obiektu, który wykonuje
jedn¹ lub wiele ró¿nych operacji wejœcia-wyjœcia. Takim obiektem mo¿e byæ
urz¹dzenie sprzêtowe, plik, gniazdo sieciowe, a nawet komponent programu.</div><br>
  <br>
<div class="notel"><b>Gniazdo sieciowe</b> (socket) jest punktem docelowym dwustronnej komunikacji
dwóch programów dzia³aj¹cych równolegle w sieci</div>Kana³y pod³¹czone do gniazd
sieciowych (np. klasa SocketChannel)&nbsp; umo¿liwiaj¹ <b>nieblokuj¹ce</b> (asynchroniczne) wejœcie-wyjœcie.<br>
Przy czytaniu z takiego kana³u za pomoca metody read(...), w¹tek nie jest
blokowany, gdy brak danych. Metoda read(...) natychmiast zwraca wynik - liczbê
przeczytanych bajtów (jeœli nie ma jeszcze danych - to 0).<br>
Umo¿liwia to <b>odpytywanie</b> (polling) - sprawdzanie co jakiœ czas czy dane nadesz³y. W¹tek nie jest blokowany i mo¿e wykonywaæ inne zadania.<br>
  <br>
  <div align="center"><b>Schemat nieblokuj¹cego wejœcia</b><br>
  </div>
  <br>
  <pre>SocketChannel socketChannel = SocketChannel.open(); // otwarcie kana³u
socketChanel.connect(...)                           // pod³¹czenie do gniazda
socketChannel.configureBlocking (false);            // tryb nieblokuj¹cy

...

while (true) {
   ...
   if (socketChannel.read (buffer) != 0) {  // czy s¹ jakieœ dane?
      processInput (buffer);                // tak - przetwórz je
   }
   else {                                   // nie - wykonuj inne czynnoœci
     ...
   }
}
</pre>
Uwaga: co to jest buffer? O tym za chwilê.<br>
  <br>
Jasne jest, ¿e stanowi to alternatywê dla wielu w¹tków, z których ka¿dy blokowany
jest na czytaniu danych z kana³u. Teraz jeden w¹tek mo¿e obs³ugiwaæ wiele
kana³ów bez blokowania przy braku danych.<br>
Nazywa siê to <b>multipleksowaniem kana³ów wejœcia/wyjœcia</b>. <br>
  <br>
Ale samo nieblokowane wejœcie-wyjœcie nie wystarcza jeszcze, by prawid³owo
rozwi¹zaæ problem obs³ugi wielu po³¹czeñ. "Rêczne" odpytywanie wielu kana³ów
ma wady:<br>
  <ul>
    <li>trzeba je oprogramowaæ (i mo¿na przy tym pope³niæ b³êdy),</li>
    <li>polega na wysy³aniu instrukcji we/wy za poœrednictwem JVM (read(...)),
co jest czasowo kosztowne i w rezultacie - przy du¿ej liczbie po³¹czeñ -&nbsp;
mo¿e niedopuszczalnie zmniejszaæ czas reakcji na ka¿dym z po³aczeñ.</li>
  </ul>
Dlatego w java.nio wprowadzono mechanizm <b>selektorów</b>, który ³¹czy ze sob¹ zalety nieblokuj¹cego odpytywania oraz natychmiastowej reakcji na dane po blokowaniu w¹tku na odczycie.<br>
  <br>
Dziêki nieblokuj¹cemu we/wy, a szczególnie <b>selektorom</b>:<br>
  <ul>
    <li>jeden w¹tek mo¿e ³atwo monitorowaæ du¿¹ liczbê gniazd sieciowych,</li>
    <li>w¹tek ten mo¿e byæ zablokowany dopóki nie pojawi¹ siê dane z <b>któregokolwiek</b> gniazda, a po ich pojawieniu siê natychmiast wznowiony,</li>
    <li>mo¿e
przy tym dowiedzieæ siê, który ze strumieni danych jest gotowy do
przetwarzania i natychmiast podj¹c to przetwarzanie.&nbsp; </li>
  </ul>
Niew¹tpliwie przy nieblokuj¹cym wejœciu-wyjœciu mo¿na by to oprogramowaæ
w Javie i bez selektorów, ale u¿ycie selektorów ma dwie podstawowe zalety:<br>
  <ul>
    <li>zwalnia nas od obowi¹zku pisania trudnego kodu,</li>
    <li>jest efektywne, bowiem multipleksowanie i selekcja kana³ów s¹ zrealizowane
w du¿ej mierze przez odwolania do rodzimych funkcji platformy systemowej
i - wobec tego - omija JVM, pozostawiaj¹c ciê¿k¹ pracê do wykonania procedurom
systemowym, które robi¹ to najsprawniej.</li>
  </ul>
  <br>
O u¿yciu kana³ów i selektorów do komunikacji w œrodowiskach sieciowych bêdziemy
mogli powiedzieæ wiêcej przy okazji omawiania programowania klient-serwer..<br>
  <br>
"Nowe wejœcie-wyjœcie" ma rownie¿ szereg niezwi¹zanych z programowaniem
sieciowym, maj¹cych ogólniejsze znaczenie, w³asciwoœci. <br>
  <br>
Obecnie w Javie kana³y mog¹ byæ po³¹czone z gniazdami, plikami oraz dowolnymi
strumieniami klas InputStream, OutputStream (te ostatnie kana³y nazwiemy
kana³ami strumieniowymi).<br>
  <br>
Wszystkie takie kana³y maj¹ jedn¹ wspóln¹ w³aœciwoœæ: kana³y wejœciowe wprowadzaj¹ dane do&nbsp; <b>buforow bajtowych</b>, a kana³y wyjœciowe wyprowadzaj¹ dane z tych buforów. <br>
<div class="notel">Bufor bajtowy przypomina nieco tablicê bajtów: jest to skoñczona sekwencja
bajtów, na której mo¿na wykonywaæ pewne operacje (m.in. pobieranie i dodawanie);
od zwyk³ej tablicy ró¿ni siê przede wszystkim tym, ¿e operacje na buforze
s¹ dostosowane do potrzeb wejœcia-wyjœcia</div> Zatem zapoznanie siê z koncepcj¹
buforów -&nbsp; równie¿ jednego z elementów "nowego wejœcia-wyjœcia" - jest nieodzowne
do korzystania z kana³ów.<br>
Bufory mog¹ byæ te¿ stosowane samodzielnie i dostarczaj¹ pewnych nowych,
ciekawych mo¿liwoœci, które mog¹ byæ wykorzystywane niezale¿nie od kana³owego
wejœcia-wyjœcia.<br>
  <br>
Zanim przejdziemy do bardziej konkretnego omawiania niektórych nowych mo¿liwoœci,
dostarczanych przez&nbsp; kana³y i bufory, warto rzuciæ okiem na syntezê tych
mo¿liwoœci (tablica).<br>
  <br>
  <table border="1" cellpadding="2" cellspacing="2" width="100%">
    <tbody>
      <tr>
        <td rowspan="1" colspan="4" bgcolor="#ffffcc" valign="top">
        <div align="center"><b>KANA£Y</b><br>
        </div>
        </td>
      </tr>
      <tr>
        <td bgcolor="#ffcccc" valign="top"><br>
        </td>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Kana³y gniazdowe</b><br>
        <br>
        </div>
        </td>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Kana³y plikowe<br>
        </b></div>
        </td>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Kana³y strumieniowe</b><br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top">uzyskanie kana³u<br>
        </td>
        <td valign="top">metoda open() z klas SocketChannel,<br>
ServerSocketChannel,<br>
DatagramChannel<br>
+ connect<br>
        </td>
        <td valign="top">Metoda<br>
        <b>getChannel()</b><br>
z klas:<br>
FileInputStream<br>
FileOutputStream<br>
RandomAccessFile&nbsp; <br>
        </td>
        <td valign="top">Metody statyczne klasy<br>
Channels:<br>
newChannel(InputStream)<br>
newChannel(OutputStream)<br>
        </td>
      </tr>
      <tr>
        <td valign="top"><br>
        </td>
        <td rowspan="1" colspan="3" bgcolor="#ffcccc" valign="top">
        <div align="center">Mo¿liwoœci dostarczane przez kana³y<br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top"><b>nieblokuj¹ce </b>wejœcie-wyjœcie<br>
i mo¿liwoœæ stosowania <b>selektorów</b><br>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
nie<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
nie<br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top">atomistyczne czytanie rozprowadzaj¹ce po wielu buforach (<b>scattering read</b>), atomistyczne pisanie gromadz¹ce z wielu buforów (<b>gathering write</b>)<br>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
nie<br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top"><b>mapowanie</b> plików na pamiêæ <br>
        </td>
        <td valign="top">
        <div align="center"><br>
nie<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
nie<br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top"><b>bezpoœrednie transfery kana³owe</b> (np. jedno wywo³anie kopiuje ca³y plik do innego w sposób bardzo efektywny) <br>
        </td>
        <td valign="top">
        <div align="center">tak, jeœli jednym z kana³ów jest kana³ plikowy<br>
        </div>
        </td>
        <td valign="top">
        <div align="center">tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center">tak, jeœli jednym z kana³ów jest kana³ plikowy<br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top">blokowanie (<b>lock</b>) dostêpu do ca³ego pliku&nbsp;&nbsp; lub jego czêœci<br>
        </td>
        <td valign="top">
        <div align="center"><br>
nie<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
nie<br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top">czytanie, pisanie do/z buforów <br>
(zob. mo¿liwoœci buforów)<br>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
        <td valign="top">
        <div align="center"><br>
tak<br>
        </div>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
  <br>
  <br>
  <table border="1" cellpadding="2" cellspacing="2" width="100%">
    <tbody>
      <tr>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Mo¿liwoœci, dostarczane przez bufory</b><br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top">ró¿ne <b>widoki buforów</b> bajtowych (jako ci¹gu bajtów lub elementów wybranego typu pierwotnego)</td>
      </tr>
      <tr>
        <td valign="top"><b>przestawianie bajtów</b> (mo¿liwoœæ wyboru i/lub
³atwej zmiany&nbsp; konwencj uporz¹dkowania bajtów danych binarnych - czy bardziej
znacz¹ce czêsci danej maj¹ w pamiêci mniejsze czy wiêksze adresy)<br>
        </td>
      </tr>
      <tr>
        <td valign="top"><b>kodowanie - dekodowanie</b> danych w buforach
znakowych przy uwzglêdnieniu wybranej strony kodowej (klasy Charset, CharsetDecoder
i CharsetEncoder, operuj¹ce na buforach) <br>
        </td>
      </tr>
      <tr>
        <td valign="top"><b>bufory bezpoœednie</b> (bufory takie&nbsp; "opakowuj¹"
pamiêæ alokowan¹ poza JVM przez natywne œrodki platformy systemowej i umo¿liwiaj¹
m.in. wysok¹ efektywnoœæ operacji kana³owych, a tak¿e daj¹ programiœcie mo¿liwoœæ
dostêpu z poziomu programu Javy do dowolnego obszaru pamiêci, alokowanego
w systemie - np. bezpoœredniej pamiêci graficznej)<br>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
  <br> Zwróæmy na koniec jeszcze raz uwagê, ¿e "nowe wejœcie-wyjœcie" (NIO)
nie zastêpuje "starego" (klas strumieniowych). Generalnie klasy strumieniowe
operuj¹ na wy¿szym poziomie abstrakcji, kana³y zaœ przeznaczone s¹ przede
wszystkim do zwiêkszenia efektywnoœci operacji wejœcia-wyjœcia i ukierunkowane
s¹ raczej na niskopoziomowe operowanie na sekwencjach bajtów.<br>
  
<a name="NIO.2"></a><h2>2.  NIO: bufory</h2>


<div class="def">Bufor jest ci¹g³¹, skoñczon¹ sekwencj¹ elementów jednego z typów pierwotnych: byte, short, char, long, float, double</div><br>
  <br>
Odpowiednio do tego mamy ró¿ne klasy opisuj¹ce bufory np.<br>
  <br>
ByteBuffer - bufor bajtów (elementy typu byte),<br>
IntBuffer &nbsp;- bufor zawieraj¹cy liczby calkowite typu int,<br>
DoubleBuffer - bufor liczb typu double.<br>
  <br>
Oprócz tych klas, odpowiadaj¹cych typom pierwotnym, istnieje rownie¿ klasa
MappedBuffer, za pomoc¹ której mo¿emy mieæ dostêp do pliku mapowanego na
pamiêæ.<br>
Ogólne charakterystyki i funkcjonalnoœæ wszystkich klas buforowych okreœla klasa abstrakcyjna Buffer.<br>
  <br>
Rysunek przedstawia hierarchiê klas buforowych.<br>
  <br>
  <img src="images/Bufferclasses.jpg" alt="r" border="1" height="335" width="572">
  <br>
  <br><b>UWAGA: Kana³y operuj¹ wy³¹cznie na buforach bajtowych.</b><br>
  <br><div class="notel">Opakowanie danych tablicy przez bufor oznacza, ¿e dane s¹ te same
- zarówno w buforze jak i tablicy, a operacje na buforze, zmieniaj¹ce dane
bufora zmieniaj¹ równoczeœnie dane w tablicy i vice versa</div>Bufory mog¹ byæ
tworzone poprzez:   <ul>
    <li>alokowanie prywatnej pamiêci bufora - metody <b>allocate</b> i <b>allocateDirect</b> (ta ostatnia dla buforów bezposrednich),</li>
    <li><b>opakowanie</b> istniej¹cej <b>tablicy elementów</b> wybranego typu pierwotnego - metoda <b>wrap</b>,</li>
    <li><b>mapowanie</b> plików lub ich czêœci (metoda map(...) z klasy FileChanel)<br>
    </li>
  </ul>
Dane do buforów mog¹ byæ zapisywane za pomoca metod <b>put(..)</b> z klas
buforowych oraz na skutek czytania z kana³u (read(...) z klas kana³owych).
Metody kana³owe zapisuj¹ do bufora&nbsp; ca³e sekwencje bajtów.<br>
Dane z buforów mog¹ byæ pobierane za pomoc¹ metod <b>get(...)</b> &nbsp;z klas buforowych oraz zapisywane do kana³u (write()...) z klas kana³owych). <br>
  <br>
Metody put(...) i get(...) dziel¹ siê na <b>relatywne</b> (zapisuj¹ce lub odczytuj¹ce bufor poczynaj¹c od jego bie¿¹cej pozycji) i <b>absolutne</b> (zapisuj¹ce/odczytuj¹ce element na podanej pozycji w buforze).<br>
Operacje relatywne mog¹ dotyczyæ pojedynczego elementu lub ich sekwencji
(zapisywanych do bufora z tablicy lub innego bufora, odczytywanych z bufora
do tablicy).<br>
  <br><br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr>
        <td rowspan="1" colspan="2" valign="top">
        <div align="center"><b>
Metody get(...) z klas buforowych</b><br>

(<i><b>typ</b></i> oznacza byte, char, short, int, long, float, doble - w zale¿noœci od typu bufora).<br>
        </div>
        </td>
      </tr>
<tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%">
        <div align="center"><code>&nbsp; <i>typ</i></code></div>
</td><td><code><b>get</b>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relatywna metoda get - zwraca bie¿¹cy element</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;<b><i>typ</i></b>Buffer</code></td><td><code><b>get</b>(<b>typ</b>[]&nbsp;dst)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relatywna
metoda get - zapisuje tablicê dst elementami bufora, poczynaj¹c od jego
bie¿acej pozycji.</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td><td><code><b>get</b>(<b>typ</b>[]&nbsp;dst,
    int&nbsp;offset,
    int&nbsp;length)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j.w. ale diotyczy czêœci tablicy</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><i><code>typ</code></i></td><td><code><b>get</b>(int&nbsp;index)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Absolutna metoda get - zwraca element na pozycji index.</td></tr></tbody>
  </table>
  <br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr>
        <td rowspan="1" colspan="2" valign="top">
        <div align="center"><b>
Metody put z klas buforowych</b><br>

(<i><b>typ</b></i> oznacza byte, char, short, int, long, float, doble - w zale¿noœci od typu bufora).<br>
        </div>
        </td>
      </tr>
<tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td><td><code><b>put</b>(<b><i>typ</i></b> b)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relatywna metoda put - zapisuje element b&nbsp; na bie¿¹cej pozycji</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td><td><code><b>put</b>(<b><i>typ</i></b>[]&nbsp;src)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Relatywna metoda put - zapisuje do bufora tablicê elementów</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td><td><code><b>put</b>(<i><b>typ</b></i>[]&nbsp;src,
    int&nbsp;offset,
    int&nbsp;length)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j.w. - czêœæ tablicy</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td><td><code><b>put</b>(<b><i>typ</i></b>Buffer&nbsp;src)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Relatywna metoda put - zapisuje zawartosc bufora src do bufora</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;<i><b>typ</b></i>Buffer</code></td><td><code><b>put</b>(int&nbsp;index, <i><b>typ</b></i> b)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Absolutna metoda put, zapisuje b na pozycji index</td></tr><tr>
        <td rowspan="1" colspan="2" valign="top">Uwaga: je¿eli bufor jest tylko do odczytu (read-only), to u¿ycie metody put(...) spowoduj¹ powstanie wyj¹tku <b>ReadOnlyBufferException</b>. Bufor mo¿emy uczyniæ "tylko do odczytu" za pomoc¹ metod <b>asReadOnly()</b> z klas buforowych.<br>
        </td>
      </tr>
</tbody>
  </table>
  <br>
  <br>
<div class="syntax">Ka¿dy z buforów ma nastêpuj¹ce (<b>wa¿ne</b>, a czasem nieintuicyjne) charakterystyki:
  <ul>
    <li>pojemnoœæ (<i>capacity</i>) - liczbê elementów bufora (niezmienn¹!),</li>
    <li>limit (<i>limit</i>) - indeks pierwszego elementu, który <b>nie mo¿e</b> byæ czytany z bufora lub zapisany do bufora,</li>
    <li>pozycjê (<i>position</i>) - indeks kolejnego elementu, który bêdzie odczytany lub zapisany (inaczej bie¿¹c¹ pozycjê bufora).</li>
  </ul>
Informacje o tych charakterystykach mo¿na uzyskac za pomoc¹ metod <b><br>
</b>
  <ul>
    <li><b>int capacity() </b></li>
    <li><b>int limit() </b></li>
    <li><b>int position()</b> </li>
  </ul>
Pojemnoœæ bufora nie mo¿e byæ zmieniona, ale pozycjê i limit mo¿emy sustawiaæ za pomoc¹ metod<br>
  <ul>
    <li><b>Buffer position(int pos)</b> </li>
    <li><b>Buffer limit(int lim)</b></li>
  </ul>
Metoda <b>remaining()</b> zwraca liczbê elementów znajduj¹cych siê pomiêdzy pozycj¹ a limitem.<br>

Metoda <b>hasRemaining()</b> zwraca true, jeœli liczba ta jest wiêksza od 0.</div> <br>
  <br>
Ka¿dy <b>relatywny</b> zapis do bufora zapisuje element b¹dŸ elementy do
bufora poczynaj¹c od jego bie¿¹cej pozycji i zmienia pozycjê, tak by wskazywa³a
na nastêpny element (miejsce), który mo¿e byæ zapisany.<br>
Ka¿de <b>relatywne</b> czytanie z bufora czyta element b¹dŸ elementy, poczynajac
od jego bie¿¹cej pozycji i zmienia pozycjê tak, by wskazywala na nastêpny
jeszcze nie odczytany element.<br><br>
  <font color="#ff0000"><b>Uwaga:<br>
Operacje absolutne nie zmieniaj¹ pozycji bufora.<br>
  </b><b>Czytanie z bufora b¹dŸ zapis do bufora nie zmieniaj¹ limitu bufora.<br>
  </b></font>

  <br>
Próba odczytu danych <b>poza limitem</b> spowoduje powstanie wyj¹tku <b>BufferUnderflowException
</b>(brak danych w buforze), natomiast próba zapisu danych poza limit spoowoduje
wyj¹tek <b>BufferOverflowException</b> (przepe³nienie bufora). <br>
  <br>
<div class="notec">Po zapisaniu danych do bufora, po to by mo¿na by³o je odczytaæ nale¿y bufor <b>przestawiæ</b>.<br>
  <br>
  <b>Przestawienie bufora</b> polega na wywolaniu metody <b>flip()</b>, która ustawia <b>limit na bie¿¹c¹ pozycjê</b>, po czym ustala <b>pozycjê na zero</b>.<br>
  <br>
Je¿eli &nbsp;po odczytaniu danych z bufora chcemy jeszcze raz przeczytaæ je od pocz¹tku, powinniœmy bufor <b>przewin¹æ</b>. S³u¿y temu metoda <b>rewind()</b>, która ustala pozcycjê na zero, pozostawiaj¹c limit bez zmian</div><br>
  <br>Zachowanie buforów i zmiany ich charakterystyk ilustruje poni¿szy program.<br>
  <br>
  <pre>import java.nio.*;

class Buffers {

  static void say(String s) { System.out.println(s); }

  static void showParms(String msg, Buffer b) {
    say("Charakterystyki bufora - " + msg);
    say("capacity  :" + b.capacity());
    say("limit     :" + b.limit());
    say("position  :" + b.position());
    say("remaining :" + b.remaining());
  }

  public static void main(String args[]) {

    // alokacja bufora 10 bajtowego (inicjalnie waroœci elementów = 0)
    ByteBuffer b = ByteBuffer.allocate(10);
    showParms("Po utworzeniu", b);

    // Zapis dwóch bajtów do bufora
    b.put((byte) 7).put((byte) 9);
    showParms("Po dodaniu dwóch elementów", b);

    // Przestawienie bufora
    b.flip();
    showParms("Po przestawieniu", b);

    // Teraz mo¿emy czytaæ wpisane dane
    say("Czytamy pierwszy element: " + b.get());
    showParms("Po pobraniu pierwszego elementu", b);
    say("Czytamy drugi element: " + b.get());
    showParms("Po pobraniu drugiego elementu", b);

    say("Czy mo¿emy jeszcze czytaæ?");
    try {
      byte x = b.get();
    } catch (BufferUnderflowException exc) {
       say("No, nie - proszê spojrzeæ na ostatni limit!");
    }

    // Jeszcze raz odczytajmy dane z bufora
    // w tym celu musimy go przewin¹æ
    b.rewind();
    showParms("Po przewiniêciu", b);

    say("Czytanie wszystkiego, co wpisaliœmy");
    while (b.hasRemaining())
      say("Jest: " + b.get());
  }
}
</pre>
który na wyjœciu da:<br>
<div class="listing100"><br>Charakterystyki bufora - Po utworzeniu<br>
capacity: 10<br>
limit: 10<br>
position: 0<br>
remaining: 10<br>
Charakterystyki bufora - Po dodaniu dwóch elementów<br>
capacity: 10<br>
limit: 10<br>
position: 2<br>
remaining: 8<br>
Charakterystyki bufora - Po przestawieniu<br>
capacity: 10<br>
limit: 2<br>
position: 0<br>
remaining: 2<br>
Czytamy pierwszy element: 7<br>
Charakterystyki bufora - Po pobraniu pierwszego elementu<br>
capacity: 10<br>
limit: 2<br>
position: 1<br>
remaining: 1<br>
Czytamy drugi element: 9<br>
Charakterystyki bufora - Po pobraniu drugiego elementu<br>
capacity: 10<br>
limit: 2<br>
position: 2<br>
remaining: 0<br>
Czy mo¿emy jeszcze czytaæ?<br>
No, nie - proszê spojrzeæ na ostatni limit!<br>
Charakterystyki bufora - Po przewiniêciu<br>
capacity: 10<br>
limit: 2<br>
position: 0<br>
remaining: 2<br>
Czytanie wszystkiego, co wpisaliœmy<br>
Jest: 7<br>
Jest: 9<br>
</div><br>
  <br>
  <br>
Warto podkreœliæ, ¿e nawigacja "po buforze" zawsze odbywa siê w kontekœcie typu jego elementów.<br>
Np.&nbsp; w buforze typu IntBuffer&nbsp;elementami s¹ liczby typu int, get zwraca element
typu int, a&nbsp; pozycja bêdzie siê przesuwaæ tak, by wskazywaæ na nastêpny element
typu int (4 bajty).<br>
Natomiast w buforze typu ByteBuffer pobieranie, zapisywanie i zmiany pozycji dotycz¹ pojedynczych bajtów.<br>
Nale¿y zwróciæ szczególn¹ uwagê na bufory bajtowe, bowiem<br>
  <br>
<div class="important">Bufory bajtpwe (typu ByteBuffer) odgrywaj¹ szczególn¹ rolê, bowiem tylko one s¹ u¿ywane w operacjach na kanalach.</div><br>
  <br>
  
<a name="NIO.3"></a><h2>3.  NIO: kana³y i bufory</h2>

Aby u¿ywaæ kanalów musimy importowaæ nazwy klas z pakietu java.nio.channels.<br>
Bufory wymagaj¹ importu java.nio.<br>
  <br>
Schematy u¿ycia kana³ów w operacjach wejœcia-wyjœcia przedstawiono poni¿ej.
Dla ustalenia uwagi pos³ugujemy siê wy³¹cznie kana³ami plikowymi.<br>
  <br>
  <table bgcolor="#ffffcc" border="1" cellpadding="2" cellspacing="2" width="100%">
    <tbody>
      <tr>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Zapis do&nbsp; kana³u</b><br>
        </div>
        </td>
      </tr>
      <tr>
        <td valign="top"><b>1. Alokacja bufora bajtowego</b><br>
        <br>
&nbsp; &nbsp; &nbsp;ByteBuffer buf = ByteBuffer.allocate(N); // N - rozmiar bufora<br>
        <br>
        <b>2. Zapis danych do bufora (</b>np. z u¿yciem metod put...)<br>
        <br>
        <b>3. Uzyskanie kana³u klasy FileChannel "do zapisu"</b><br>
        <br>
Mo¿emy go uzyskaæ za pomoc¹ metod getChannel() z klas FileOutputStream oraz
&nbsp; RandomAccessFile (kana³ "do zapisu i do odczytu", jeœli taki by³ tryb otwarcia
pliku o dostêpie swobodnym). Np.<br>
        <br>
&nbsp; &nbsp; FileOutputStream out &nbsp;= new FileOutputStream(...);<br>
&nbsp; &nbsp; FileChannel fc = out.getChannel();<br>
        <br>
        <b>4. Zapis bufora - u¿ycie metod write z klasy FileChannel. Np.</b><br>
        <br>
&nbsp; &nbsp;fc.write(buf);<br>
        <br>
        <b>&nbsp;Zamkniêcie kana³u:</b><br>
        <br>
&nbsp; &nbsp;fc.close();<br>
        <br>
Zamkniêty kana³ pozostaje zamkniêty. Metoda isOpen() pozwala stwierdziæ czy kana³ jest otwarty.<br>
        <br>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
  <br>
  <br>
  <table bgcolor="#ffffcc" border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td bgcolor="#ffcccc" valign="top"><div align="center"><b>Czytanie z&nbsp; kana³u</b><br></div></td></tr><tr><td valign="top"><b>1. Alokacja bufora bajtowego</b><br><br>
&nbsp; &nbsp; &nbsp;ByteBuffer buf = ByteBuffer.allocate(N); // N - rozmiar bufora<br><br><b>2. Uzyskanie kana³u klasy FileChannel "do odczytu"</b><br><br>
Mo¿emy go uzyskaæ za pomoc¹ metod getChannel() z klas FileInputStream oraz
&nbsp; RandomAccessFile (kana³ "do zapisu i do odczytu", jesli taki by³ tryb otwarcia
pliku o dostêpie swobodnym). Np.<br><br>
&nbsp; &nbsp; FileInputStream out &nbsp;= new FileInputStream(...);<br>
&nbsp; &nbsp; FileChannel fc = out.getChannel();<br><br><b>3. Czytanie do bufora - u¿ycie metod read z klasy FileChannel. Np.</b><br><br>
&nbsp; &nbsp;fc.read(buf);<br>
        <br>
        <b>4. Zamkniêcie kana³u:</b><br>
        <br>

&nbsp; &nbsp;fc.close();<br>
        <br>

Zamkniêty kana³ pozostaje zamkniêty.<br>
        <br>
        <b>15. Okreœlenie w³aœciwej pozycji i limitu bufora po wczytaniu do niego danych. </b><br>
&nbsp; &nbsp; Np. poprzez przestawienie bufora:<br>
        <br>
&nbsp; &nbsp; buf.flip();<br>
        <br>
        <b>6. Odczytanie danych z bufora za pomoc¹ metod get...</b><br>
        <br>
</td></tr></tbody>
  </table>
  <br>
  <br>
Poni¿szy program ilustruje powy¿szy schemat. Komentarze szczegó³owo omawiaj¹ u¿yte w nim konstrukcje. <br>
  <br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class SimpleChannel {

  String fname = "test.tmp";
  byte[] data = {1,2,3,4,5 };

  SimpleChannel() {
    try {
      writeChannel(fname, data);
      byte[] wynik = readChannel(fname);
      for (int i=0; i &lt; wynik.length; i++) System.out.println(wynik[i]);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }

  void writeChannel(String fname, byte[] data) throws Exception {

    // Mo¿emy utworzyæ bufor przez opakowanie istniej¹cej tablicy
    ByteBuffer buf = ByteBuffer.wrap(data);

    FileOutputStream out = new FileOutputStream(fname);

    // Uzyakanie kana³u
    FileChannel fc = out.getChannel();

    //Zapis
    fc.write(buf);
    fc.close();
  }

  byte[] readChannel(String fname) throws Exception {

    // U¿ywamy obiektu klasy File
    // by dowiedzieæ siê jaki jest rozmiar pliku
    // i odpowiednio alokowac bufor
    File file = new File(fname);

    // Stworzenie strumienia na podstawie obiektu klasy File
    FileInputStream in = new FileInputStream(file);

    // Uzyskanie kana³u
    FileChannel fc = in.getChannel();

    // Metoda size() z klasy FileChannel
    // zwraca long -rozmiar plku, do którego podl¹czony jest kana³
    int size = (int) fc.size();

    // Utworzenie bufora
    ByteBuffer buf = ByteBuffer.allocate(size);

    // Czytanie do bufora
    // nbytes - liczba przeczytanych bajtów
    int nbytes = fc.read(buf);
    fc.close();

    // Po przeczytaniu danych musimy bufor przestawiæ
    buf.flip();

    // Stworzenie tablicy na wynik czytania
    // jej rozmiar bêdzie okreœlony przez liczbê przeczytanuych bajtów
    // któr¹ mo¿emy podaæ na dwa sposoby: poprzednie nbytes
    // lub uzyskuj¹c informacjê o liczbie jeszcze nieodczytanych bajtów z bufora

    byte[] wynik = new byte[buf.remaining()];
    buf.get(wynik);
    return wynik;
  }

  public static void main(String args[]) {
   new SimpleChannel();
  }
}  &nbsp;
</pre>
  <br>
W klasie FileChannel zdefiniowano wiele metod pozwalaj¹cych na czytanie z
- zapis do kana³ów oraz pozycjonowanie i przewijanie plików, do których te
kana³y s¹ podl¹czone.<br>

  
<a name="NIO.4"></a><h2>4.  Widoki buforów bajtowych</h2>

Jak ju¿ wiemy, w operacjach kanalowych u¿ywa siê wy³¹cznie buforów bajtowych,.<br>
Zapewniaj¹ one ³atwy dostêp do elementów - bajtów.<br>
Ale jak w &nbsp;takim razie przetwarzaæ dane innych typów (ni¿ bajty) pobierane z kana³ów lub zapisywaæ takie dane do kana³u?<br>
  <br>
S¹ po temu przynajmniej dwie mo¿liwoœci.<br>
  <br>
Pierwsza polega na u¿yciu metod klasy ByteBuffer: <br>
  <br>
&nbsp;&nbsp;&nbsp; <i><b>ttt</b></i> elt = get<i><b>Ttt</b></i>() <br>
&nbsp;&nbsp;&nbsp; put<i><b>Ttt</b></i>(<i><b>Ttt</b></i> elt)<br>
  <br>
które umo¿liwaj¹ zapisywanie i pobieranie danych typu ttt (short, int, long, float, double, char).<br>
  <br>
Drugi sposób - znacznie ciekawszy i przyjemniejszy - polega na u¿yciu <b>widoków</b> buforów bajtowych<br>
  <br>
<div class="syntax">Metoda klasy ByteBuffer:<br>
  <br>
&nbsp;&nbsp;&nbsp; <i><b>Ttt</b></i>Buffer as<i><b>Ttt</b></i>Buffer()<br>
  <br>
gdzie: <i><b>ttt</b></i> - jeden z typów short, int, long, float, double, char<br>
  <br>
u¿yta wobec bufora bajtowego buf zwraca referencjê do bufora klasy <i><b>Ttt</b></i>Buffer, co pozwala na dzia³anie na danych pierwotnego bufora bajtowego buf za pomoc¹ metod <b>get</b> i <b>put</b> klasy <i><b>Ttt</b></i>Buf czyli tak, jakby pierwotny bufor bajtowy zawiera³ elementy typu <i><b>ttt</b></i>.<br>
  <br>
Mówimy, ¿e metoda ...asBuffer() zwraca <b>widok</b> bufora bajtowego jako bufora typu <i><b>Ttt</b></i>Buffer, gdy¿ nie nastêpuej tu ¿adne kopiowanie danych i zmiany danych wykonywane
za poœrednictwem obu obiektów - bufora pierwotnego oraz jego widoku dotycz¹
tego samego bufora.</div><br>
  <br>
Koncepcjê widoku bufora bajtowego ilustruje poni¿szy program.<br>
  <br>
  <pre>import java.nio.*;

class BufView1 {

  public static void main(String args[]) {

    final int SHORT_SIZE = 2;
    // Alokacja buforu bajtowego,
    // mog¹cego przechowywaæ do 10 liczb typu short
    ByteBuffer bb = ByteBuffer.allocate(10*SHORT_SIZE);

    // Widok na ten bofor jak na short-bufor
    <b>ShortBuffer sb = bb.asShortBuffer();</b>

    // Dodanie trzech liczb typu short
    short a = 1, b = 2, c = 3;
    sb.put(a).put(b).put(c);

    // Co wpisano do bufora? Na wydruku: 1, 2, 3
    sb.flip();
    while (sb.hasRemaining()) System.out.println(sb.get());

    // Operujemy teraz na nim za pomoc¹ bufora bajtowego
    // zmieniaj¹c bajty na pozycji 1, 3 i 5.
    byte  x = 4, y = 5, z = 6;
    bb.put(1, x).put(3, y).put(5, z);

    // Co poka¿e short-bufor? Na wydruku 4, 5, 6
    sb.rewind();
    while (sb.hasRemaining()) System.out.println(sb.get());
  }
}
</pre>
  <br>
Z widokami bufora bajtowego wi¹¿e siê jednak pewna pu³apka.<br>
Otó¿, mimo, ¿e bufor i jego widok dotycz¹ tych samych danych to jednak mamy
dwa bufory (bufor bajtowy i jego widok jakiegoœ wybranego typu - np. ShortBuffer
), a w tych buforach zmiany pozycji oraz limitu s¹ niezalezne od siebie.<br>
  <br>
<div class="important">Pozycja i limit bufora bajtowego s¹ <b>niezale¿ne</b> od pozycji i limitu&nbsp; jego widoku.</div><br>
  <br>
Gdybyœmy np. chcieli w poprzendim przykladzie po wpisaniu liczb short do
bufora bajtowego (za pomoc¹ jego widoku) pokazaæ kolejne bajty wszystkich
wpisanych liczb, to moglibyœmy pojœæ b³êdnym tropem: po wpisaniu danych przestawiæ
bufor short (flip) i s¹dz¹c, ¿e pierwotny bufor bajtowy tak¿e dostosuje swoj¹
pozycjê i limit wypsiywaæ bajty w pêtli dopóki hasRemaining() nie zwróci
false.<br>
Ilustruje to poni¿szy program (w którym u¿ywamy metody showParms zpoprzednich przyj³adów dla pokazania charakterystyk bufora):<br>
  <br>
  <pre>  public static void main(String args[]) {

    final int SHORT_SIZE = 2;
    ByteBuffer bb = ByteBuffer.allocate(10*SHORT_SIZE);
    ShortBuffer sb = bb.asShortBuffer();
    short a = 1, b = 2, c = 3;
    sb.put(a).put(b).put(c);
    showParms("bufor short - po dodaniu liczb", sb);
    showParms("bufor bajtowy - po dodaniu liczb", bb);

    sb.flip();
    showParms("bufor short - po przestawieniu", sb);
    showParms("bufor bajtowy - po flip bufora short", bb);
    System.out.print("Dane");
    while (bb.hasRemaining()) System.out.print(" " + bb.get());
  }
}
</pre>
&nbsp;Wydruk.<br>
<div class="listing100"><br>
Charakterystyki bufora - bufor short - po dodaniu liczb<br>
capacity: 10<br>
limit: 10<br>
position: 3<br>
remaining: 7<br>
  <br>
Charakterystyki bufora - bufor bajtowy - po dodaniu liczb<br>
capacity: 20<br>
limit: 20<br>
position: 0<br>
remaining: 20<br>
  <br>
Charakterystyki bufora - bufor short - po przestawieniu<br>
capacity: 10<br>
limit: 3<br>
position: 0<br>
remaining: 3<br>
  <br>
Charakterystyki bufora - bufor bajtowy - po flip bufora short<br>
capacity: 20<br>
limit: 20<br>
position: 0<br>
remaining: 20<br>
Dane 0 1 0 2 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0</div><br>
  <br>
Zwrócmy uwagê: dodanie elementów do widoku bufora bajtowego nie zmienia jego
pozycji i limitu, zmienia tylko pozycjê i limit w widoku, Rownie¿ flip()
widoku nie ma wp³ywu na te parametry bufora bajtowego. Program wypisuje ca³y
bufor, bajt po bajcie, a nie bajty tych elementów, ktore zosta³y dodane.<br>
  <br>
Aby w tym przyk³adzie wypisac tylko bajty wpisanych danych, powinniœcmy po
przestawieniu widoku bufora zmieniæ odpowiednio limit bufora bajtowego:
  <pre>    sb.flip();
    bb.limit(sb.limit()*SHORT_SIZE);
    System.out.print("Bajty wpisanych danych");
    while (bb.hasRemaining()) System.out.print(" " + bb.get());
</pre>
  <br>
Jednak przy czytaniu danych z kana³ów nie ma takiej potrzeby. Dane s¹ wczytywane
do bufora bajtowego, a nie do jego widoku. Zatem nale¿y przestawiæ bufor
bajtowy, a dopiero potem stworzyæ i pos³ugiwaæ siê jego widokiem. Jest to sensowne,
bowiem widok bierze pod uwagê pozycjê i limit bufora, na podstawie którego
jest tworzony, odpowiednio ustawiaj¹c swoj¹ pozycjê i limit.<br>
  <br>
Co pokazuje poni¿szy program.<br>
  <br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class BuffChan {

  String fname = "testfile.tmp";

  // inicjacja danych testowych
  void init() throws Exception {
    double[] data = { 0.1, 0.2, 0.3 };
    DataOutputStream out = new DataOutputStream(
                             new FileOutputStream(fname)
                            );
    for (int i=0; i &lt; data.length; i++) out.writeDouble(data[i]);
    out.close();

  }

  BuffChan() throws Exception {

    // inicjalcja danych testowych
    init();

    // utworzenie bufora
    ByteBuffer buf = ByteBuffer.allocate(1000); // nie wiemy ile, maks 100B

    // uzyskanie kana³u
    FileChannel fcin = new FileInputStream(fname).getChannel();

    // czytanie z kana³u do bufora
    fcin.read(buf);
    fcin.close();

    // przestawienie bufora bajtowego
    buf.flip();

    // Utworzenie widoku bufora
    DoubleBuffer dbuf = buf.asDoubleBuffer();

    // Wypisanie odczytanych danych
    while (dbuf.hasRemaining()) System.out.println(dbuf.get());
  }

  public static void main(String args[]) throws Exception {
    new BuffChan();
  }
}
</pre>
  <br>
  <br>
  
<a name="NIO.5"></a><h2>5.  NIO: bufory - uporz¹dkowanie bajtów (endianess)</h2>


  Przy czytaniu i zapisywaniu plików, tworzonych na ró¿nych platformach
sprzêtowych, &nbsp;powstaje problem uporz¹dkowania (kolejnoœci wystêpowania) bajtów
danych binarnych,<br>
Wynika to z tego w jaki sposób dane binarne przechowywane s¹ w pamiêci (i jak zapisywane w rejestrach procesora).<br>
  <br>
Porz¹dek bajtów w reprezentacji binarnej danych okreœla siê terminem <b><i>endianess</i></b>.<br>
  <br>
Istniej¹ dwa ró¿ne porz¹dki:<br>
  <br>
  <ul>
    <li>
Porz¹dek BIG ENDIAN oznacza, ¿e mniej znacz¹ce bajty danych s¹ zapisywane
pod wiêkszymi adresami pamiêci (niejako od prawej do lewej) </li>
    <li>
Porz¹dek LITLLE ENDIAN jest odwrotny: najpierw s¹ zapisywane mniej znacz¹ce bajty, póŸniej bardziej (od lewej do prawej).</li>
  </ul>


Ilustruje to rysunek, na którym pokazano porz¹dek bajtów liczby typu int równej 1234567 (heksadecymalnie 0x12D687).<br>
  <br>
  <img src="images/Endianess.jpg" alt="r" border="1" height="299" width="363">
  <br>
  <br>
O tym jaki jest porz¹dek bajtów w buforach mo¿emy dowiedzieæ siê za pomoc¹
metody <b>order()</b>, która zwraca referencjê do obiektu klasy <b>ByteOrder</b>.<br>
W przypadku buforów bajtowych (i tylko dla nich) &nbsp;mo¿emy zmieniæ porz¹dek
za pomoc¹ wywo³ania metody <b>order(ByteOrder)</b> z argumentem bêd¹cym sta³¹ statyczn¹
z klasy ByteOrder:<br>
  <br>
  <ul>
    <li><b>
order (ByteOrder.BIG_ENDIAN) - zmienia porz¹dek na BIG ENDIAN</b></li>
    <li><b>
order (ByteOrder.LITTLE_ENDIAN) - zmienia porz¹dek na&nbsp;LITTLE ENDIAN</b></li>
  </ul>


<div class="important"><b>Widoki</b> bufora bajtowego maj¹ ten porz¹dek bajtów, który wystêpowa³ dla
bufora bajtowego w momencie tworzenia widoku (mo¿emy powiedzieæ, ¿e widok
dziedziczy porz¹dek swojego bufora,&nbsp; bajtowego&nbsp;obowi¹zuj¹cy w chwili tworzenia
widoku)</div><br>
  <br>
Ilustruje to poni¿szy program:<br>
  <br>
  <pre>import java.nio.*;

class Endianness {

   static void show(int n) {
       String s = Integer.toHexString(n);
       int l = s.length();
       for (int i=l; i &lt; 8; i++) s = '0' + s;
       System.out.println("Liczba " + n + " hex -&gt; " + s.toUpperCase());
   }

   public static void main(String args[]) {
     int num = Integer.parseInt(args[0]);
     ByteBuffer buf = ByteBuffer.allocate(4);
     System.out.println(buf.order().toString());
     IntBuffer b1 = buf.asIntBuffer();
     System.out.println("Porz¹dek b1 " + b1.order());
     b1.put(num);
     b1.flip();
     show(b1.get());
     buf.order(ByteOrder.LITTLE_ENDIAN);
     System.out.println("Porz¹dek buf " + buf.order());
     System.out.println("Porz¹dek b1 " + b1.order());
     b1.rewind();
     show(b1.get());
     System.out.println("Porz¹dek buf " + buf.order());
     System.out.println("Porz¹dek dziedzizcony " + buf.asIntBuffer().order());
     show(buf.asIntBuffer().get());
  }
}
</pre>
który dla podanej jako argument liczby 987654321 wyprowadzi nastêpuj¹ce wyniki:<br>
  <br>
<div class="listing100"><br>
BIG_ENDIAN<br>
Porz¹dek b1 BIG_ENDIAN<br>
Liczba 987654321 hex -&gt; 3ADE68B1<br>
Porz¹dek buf LITTLE_ENDIAN<br>
Porz¹dek b1 BIG_ENDIAN<br>
Liczba 987654321 hex -&gt; 3ADE68B1<br>
Porz¹dek buf LITTLE_ENDIAN<br>
Porz¹dek dziedzizcony LITTLE_ENDIAN<br>
Liczba -1318527430 hex -&gt; B168DE3A<br>
</div><br>
  <br>
  <br>
<br>
  
<a name="NIO.6"></a><h2>6.  NIO: bufory znakowe. Kodowanie i dekodowanie.</h2>

Bufory znakowe (klasa CharBuffer) reprezentuj¹ sekwencje elementów typu char (znaki unikodu).<br>
Maj¹ one wszystkie w³aœciwoœci buforów (o których ju¿ by³a mowa), ale dodatkowo zapewniaj¹ pewn¹ specyficzn¹ funkcjonalnoœæ.<br>
  <br>
Zauwa¿my, ¿e sekwencje znaków s¹ reprezentowane równie¿ przez obiekty klas String i StringBuffer. <br>
W Javie 1.4 uogólniono wiêc pewne elementarne operacje na sekwencjach znaków, wprowadzaj¹c interfejs <b>CharSequence</b>
. Interfej ten implementowany jest przez wszystkie klasy w/w klasy: String,
StringBuffer i CharBuffer, dziêki czemu mo¿liwe jest (do pewnego stopnia)
uniwersalne operowanie na sekwencjach znaków, niezaleznie od tego, czy s¹
one obiektami klas String, StringBuffer czy CharBuffer. <br>
  <br>
Metody interfejsu CharSequence podano w tablicy,<br>
  <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;char</code></td><td><code><b>charAt</b>(int&nbsp;index)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca znak na pozycji index</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;int</code></td><td><code><b>length</b>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca d³ugoœæ sekwencji znaków</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;CharSequence</code></td><td><code><b>subSequence</b>(int&nbsp;start,
            int&nbsp;end)</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca
podsekwencjê od znaku na pozycji start do znaku na pozycji end
(wy³acznie)</td></tr><tr class="TableRowColor" bgcolor="white"><td align="right" valign="top" width="1%"><code>&nbsp;String</code></td><td><code><b>toString</b>()</code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Zwraca
referencjê do nowego obiektu klasy String, zawieraj¹cego tê sekwencjê
znaków.</td></tr></tbody>
  </table>
  <br>
U¿ywaj¹c tych metod mo¿na napisac uniwersaln¹ metodê operuj¹c¹ na sekwncjach
znaków, która jako argument mo¿e przyjmowaæ referencjê do obiektu dowolnej
z klas: String, StringBUffer i CharBuffer (nale¿y siê spodziewaæ, ¿e zetsaw
metod interfejsu CharSequence zostanie w przysz³oœci wzbogacony, co rozszerzy
mo¿liwoœci pisania uniwersalnych fragmentów kodu). Ju¿ teraz zreszt¹ CharSequence
pe³ni istotn¹ u¿yteczn¹ rolê, bowiem metody klas pakietu java.util.regex,
umozliwiaj¹ce anlalizê ³añcuchów znakowych za pomoc¹ wyra¿eñ regularnych,
operuj¹ na obiektach typu CharSequence.<br>
  <br>
Z punktu widzenia buforów znakowych, wprowadzenie interfejsu CharSequence ma dwie wa¿ne konsekwencje:<br>
  <ul>
    <li>poza znanymi nam metodami buforowymi na buforach znakowych mo¿na operowac za pomoc¹ metod tego interfejsu, </li>
    <li>klasa CharBuffer dostarcza metody wrap opakowuj¹cej dowoln¹ sekwencjê
znaków (obiekt klasy implementuj¹cej interfejs CharSequence) i dziêki temu
mo¿emy np. w nastêpuj¹cy sposób tworzyæ bufory znakowe.:</li>
  </ul>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; String txt = editor.getText();<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CharBuffer buf = CharBuffer.wrap(txt);<br>
  <br>
To mi³e, ¿e mamy takie bufory znakowe, ale przecie¿ kana³y mog¹ operowac wy³¹cznie na buforach bajtowych.<br>
Przy kana³owym czytaniu i zapisie strumieni tekstowych powstaje wiêc problem kodowania i dekodowania informacji tekstowej. <br>
Znany nam sposób kodowania-dekodowania za pomoc¹ klas InputStreamReader i
OutputStreamReader dotyczy tylko plików, a przy tym nie nadaje siê do zastosowania
przy pol¹czeniach kana³owych, bowiem kana³y plikowe mo¿na uzyskaæ tylko od
obiektów klas FileInputStream, FileOutputStream i RandomAccessFile. <br>
  <br>
Dla rozwi¹zania problemu dekodowania - kodowania mo¿na,&nbsp; co prawda, zastosowaæ
klasê String, jak pokazuje poni¿szy program (konwertuj¹cy pliki z jednej
strony kodowej na inn¹).<br>
  <br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class Ende1 {

  public static void main(String[] args) {

    if (args.length != 4) {
      System.out.println("Syntax: in in_enc out out_enc");
      System.exit(1);
    }

    String infile  = args[0],     // plik wejœciowy
           in_enc  = args[1],     // wejœciowa strona kodowa
           outfile = args[2],     // plik wyjœciowy
           out_enc = args[3];     // wyjœciowa strona kodowa

    try {
       FileChannel fcin = new FileInputStream(infile).getChannel();
       FileChannel fcout = new FileOutputStream(outfile).getChannel();
       ByteBuffer buf = ByteBuffer.allocate((int)fcin.size());

       // czytanie z kana³u
       fcin.read(buf);

       // przeniesienie zawartoœci bufora do tablicy bytes
       buf.flip();
       byte[] bytes = new byte[buf.capacity()];
       buf.get(bytes);

       // dekodowanie - za pomoc¹ konstruktora klasy String
       String txt = new String(bytes, in_enc);

       // enkodowanie za pomoc¹ metody getBytes z klasy String
       // utworzenie nowego bufora dla kana³u wyjœciowego
       // zapis do pliku poprzez kana³
       bytes = txt.getBytes(out_enc);
       buf = ByteBuffer.wrap(bytes);
       fcout.write(buf);

       fcin.close();
       fcout.close();
    } catch (Exception e) {
        System.err.println(e);
        System.exit(1);
    }

  }
}&nbsp;</pre>
ale jest to rozwi¹zanie dodatkowo obci¹¿aj¹ce pamiêæ operacyjn¹ oraz - jak widaæ - ma³o wygodne w programowaniu.<br>
  <br>
W NIO rozwi¹zano problem kodowania-dekodowania za pomoca wprowadzenia nowych klas <b>Charset, CharsetDecoder, CharsetEncoder</b> w pakiecie java.nio.charset. <br>
  <br>
  <ul>
    <li>Klasy
CharsetDecoder i CharsetEncoder&nbsp; dostarczaj¹ bogatych œrodków i
pe³nej kontroli nad procesem kodowania i dekodowania. </li>
  </ul>
  <ul>
    <li>Klasa Charset dostarcza definicji stron kodowych, a tak¿e wygodnych
metod kodowania i dekodowania (które s¹ ³atwiejsze w u¿yciu ni¿ zastosowanie
klas CharsetEncoder i CharsetDecoder).</li>
  </ul>
<div class="syntax"><br>
  <div align="center"><b>Dekodowanie-kodowanie za pomoc¹ Charset polega na:</b></div>
  <ul>
    <li>utworzeniu obiektu klasy Charset, za pomoc¹ statycznej metody forName(String),
reprezentuj¹ccgo stronê kodow¹, której nazwê podano jako argument np:</li>
  </ul>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Charset charset = Charset.forName("ISO-8895-2");<br>
  <br>
  <ul>
    <li><b>dekodowaniu</b> bajtów z bufora bajtowego z danej strony kodowej
na sekwencjê znaków Unicode, zapisan¹ w buforze znakowym &nbsp;za pomoc¹ metody
decode(...):</li>
  </ul>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ByteBuffer buf &nbsp;= ...<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CharBuffer cbuf = charset.decode(buf);<br>
  <br>
  <ul>
    <li>lub <b>kodowaniu</b> znaków Unicodu z bufora znakowego do bajtów, reprezentuj¹cych tekst zakodowany wedle danej strony kodowej w buforze bajtowym:</li>
  </ul>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CharBuffer cbuf&nbsp; = ...<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ByteBuffer buf = charset.encode(cbuf);<br>
</div><br>
&nbsp;<br>
Informacjê o nazwach dostêpnych w danej implementacji JVM stron kodowych mo¿na
uzyskaæ za pomoc¹ metody availCharsets() z klasy Charset.<br>
  <br>
Przyk³adowy program pokazuje zastosowanie tej procedury do konwersji plików
z jednej strony kodowej na inn¹ (z wykorzystaniem kana³ów).<br>
  <br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;


class Ende2 {

  public static void main(String[] args) {

    if (args.length != 4) {
      System.out.println("Syntax: in in_enc out out_enc");
      System.exit(1);
    }

    String infile  = args[0],     // plik wejœciowy
           in_enc  = args[1],     // wejœciowa strona kodowa
           outfile = args[2],     // plik wyjœciowy
           out_enc = args[3];     // wyjœciowa strona kodowa

    try {
       FileChannel fcin = new FileInputStream(infile).getChannel();
       FileChannel fcout = new FileOutputStream(outfile).getChannel();
       ByteBuffer buf = ByteBuffer.allocate((int)fcin.size());

       // czytanie z kana³u
       fcin.read(buf);

       // Strony kodowe
       Charset inCharset  = Charset.forName(in_enc),
               outCharset = Charset.forName(out_enc);

       // dekodowanie bufora bajtowego
       buf.flip();
       CharBuffer cbuf = inCharset.decode(buf);

       // enkodowanie bufora znakowego
       // i zapis do pliku poprzez kana³

       buf = outCharset.encode(cbuf);
       fcout.write(buf);

       fcin.close();
       fcout.close();
    } catch (Exception e) {
        System.err.println(e);
        System.exit(1);
    }
  }
}
</pre>
  <br>
  <br>
  
<a name="NIO.7"></a><h2>7.  NIO: operacje kana³owe na wielu buforach (scattering i gathering)</h2>


  Kana³y pozwalaj¹ za jednym odwo³aniem czytaæ dane do wielu buforów (<i><b>scatter read</b></i>) lub
zapisywaæ dane z wielu buforów (<i><b>gather write</b></i>). <br>
S³u¿¹ do tego metody read i write (z klas
kana³owych), które jako argument maj¹ <b>tablice buforów</b>.<br>
  <br>
  <br>
<br>
Jest to bardzo u¿yteczna w³aœciwoœæ, pozwala bowiem w ³atwiejszy sposób &nbsp;programowaæ
uzyskiwanie przez kana³y danych, maj¹cych okreœlon¹ strukturê, w której mo¿na
wyró¿niæ jakieœ czêœci o okreœlonym rozmiarze.<br>
Przyk³adem mog¹ byæ &nbsp;pliki graficzne lub dane z nag³ówkami komunikacyjnymi.<br>
  <br>
Program testuj¹cy czytanie do wielu buforów.<br>
  <br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;

public class ScatteringTest {

  static final String fname = "scatter.tst";  // nazwa pliku testowego

  public static void main(String[] args) throws Exception {

    // Zapisywanie danych testowych

    DataOutputStream out = new DataOutputStream(
    	                       new FileOutputStream(fname) );
    short[]  dat1 = { 1, 2, 3, };
    double[] dat2 = { 10.1, 10.2, 10.3 };
    for (int i=0; i &lt; dat1.length; i++) out.writeShort(dat1[i]);
    for (int i=0; i &lt; dat2.length; i++) out.writeDouble(dat2[i]);
    out.close();

    //-----------------------------------------------------------+
    // Odczytywanie danych testowych                             |
    //-----------------------------------------------------------+

    FileInputStream in = new FileInputStream(fname);

    // Uzyskanie kana³u
    FileChannel channel = in.getChannel();

    // Tablica bajt-buforów
    final int SHORT_SIZE  = 2,  // ile bajtów ma short
              DOUBLE_SIZE = 8;  // ........... i double

    ByteBuffer[] buffers = { ByteBuffer.allocate(dat1.length*SHORT_SIZE),
                             ByteBuffer.allocate(dat2.length*DOUBLE_SIZE)
                           };
    <b>// jedno czytanie z kana³u zapisuje kilka buforów !</b>
    long r = <b>channel.read(buffers)</b>;

    System.out.println("Liczba bajtów przeczytanych do obu buforów: " + r);

    // Przed uzyskiwaniem danych z buforów - trzeba je przestawiæ!
    buffers[0].flip();
    buffers[1].flip();

    // Pierwssy bufor
    // Widok na bufor jako na zawieraj¹cy liczby short
    ShortBuffer buf1 = buffers[0].asShortBuffer();
    System.out.println("Dane 1");
    while ( buf1.hasRemaining()) {
      short elt = buf1.get();
      System.out.println(elt);
    }

    // Drugi bufor
    // Widok na bufor jako na zawieraj¹cy liczby double
    DoubleBuffer buf2 = buffers[1].asDoubleBuffer();
    System.out.println("Dane 2");
    while ( buf2.hasRemaining()) System.out.println(buf2.get());
  }
}
</pre>
wyprowadzi nastêpuj¹ce wyniki:<br>
<div class="listing100">Liczba bajtów przeczytanych do obu buforów: 30<br>
Dane 1<br>
1<br>
2<br>
3<br>
Dane 2<br>
10.1<br>
10.2<br>
10.3</div><br>
  <br>
Równie¿ przy zapisywaniu danych przez kana³y, mo¿liwoœæ jednorazowego zapisu
z wielu buforów mo¿e byæ wielce wygodna. Np. w pewnych buforach mo¿emy przygotowaæ
sta³e fragmenty danych i ju¿ ich nie zmieniaæ, inne zaœ bufory wype³niaæ
dynamicznie zmieniaj¹c¹ siê treœci¹.<br>
Potrzebne bêdzie tylko jedno wywo³anie metody write, by zapisaæ ca³y zestaw
buforów (co oprócz wygody programistycznej ma równie¿ pozytywny wp³yw na efektywnoœæ
dzia³ania naszego programu).<br>
  <br>
Przyk³adowy program zapisuje kilka plików, ka¿dy z których ma taki sam nag³ówek
i zakoñczenie. Czêsæ œrodkow¹ wype³niaj¹ zmieniaj¹ce siê - od pliku do pliku
- dane.<br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

class GatheringTest {

  public static void main(String[] args) throws Exception {

    // To bêd¹ sta³e czêœci ka¿dego pliku
    String sHeader = "To jest nag³ówek. Mo¿e byæ du¿y";
    String sFooter = "To jest zakoñczenie. Mo¿e byæ du¿e";

    // To bêd¹ dane, które siê zmieniaj¹ od pliku do pliku
    byte[][] dane = { { 1, 2, 3},       // dane 1-go pliku
                     { 9, 10, 11, 12 }, // dane 2-go pliku
                     { 100, 101}        // dane 3-go pliku
                   };

    Charset charset = Charset.forName("windows-1250");
    ByteBuffer header = charset.encode(CharBuffer.wrap(sHeader)),
               footer = charset.encode(CharBuffer.wrap(sFooter));

    // Drugi element tablicy buforów bêdzie dynamicznie siê zmienial
    // na razie = null
    ByteBuffer[] contents = { header, null, footer };
    for (int i = 0; i&lt;dane.length; i++) {
      FileChannel fc = new FileOutputStream("plik"+i).getChannel();
      contents[1] = ByteBuffer.wrap(dane[i]);  // podstawienie zmiennych danych
      <b>fc.write(contents);</b>                      // zapis danych ze wszystkich buforów!
      fc.close();
      header.rewind();
      footer.rewind();
    }
  }


}
</pre>
<br>
Czytanie i pisanie "po wielu buforach" od razu, nazywane tak¿e wektorowym wejœciem-wyjœciem (<i><b>vectored I/O</b></i>) jest <b>atomistyczne</b>
 nie tylko w tym sensie, ¿e realizowane jest przez jedno odwo³anie z poziomu
programu. Na nowoczesnych platformach systemowych daje ono du¿¹ poprawê efektywnoœci,
bowiem nastêpuje znaczna redukcja liczby niskopoziomowych (na poziomie j¹dra
systemu) operacji we/wy oraz ich optymalizacja (w skrajnym przypadku do atomistycznej
- pojedynczej - calkowicie zoptymalizowanej niskopoziomowej operacji we/wy).<br>
  <br>
<br>
  
<a name="NIO.8"></a><h2>8.  NIO: mapowanie plików</h2>


  <div class="def">Mapowanie pliku polega na odzwierciedleniu ca³oœci lub czêœci pliku w pamiêci, bezpoœrednio dostêpnej dla programu.</div><br>
  <br>
Mapowanie pliku w NIO uzyskujemy poprzez uzyskanie kana³u pod³¹czonego do
pliku (niech oznacza go zmienna channel), a nastêpnie u¿ycie metody map z
klasy FileChannel. Metoda ta zwraca referencjê do obiektu klasy MappedByteBuffer
(pochodnej od Buffer), który jest bajtowym buforem bezpoœrednim (direct),
zawieraj¹cym bajty pliku lub jego wybranego segmentu.<br>
  <br>
<div class="syntax"><br>
  <div align="center"><b>Mapowanie pliku</b><br>
  <div align="left"><br>
  </div>
  </div>
&nbsp;&nbsp;&nbsp; FileChannel channel = ....; // pod³¹czenie kana³u do pliku<br>
&nbsp;&nbsp;&nbsp; MappedByteBuffer buf = channel.map( tryb, pozycja, rozmiar);<br>
  <br>
gdzie:<br>
  <ul>
    <li>buf - bufor bajtowy, reprezentuj¹cy zwartoœæ pliku lub jego segmentu<br>
    </li>
    <li>tryb - jedna z opcji bêd¹cych sta³ymi statycznymi klasy FileChannel.MapMode o nazwach</li>
    <ul>
      <li>READ_ONLY - mo¿liwe tylko odczytywanie bufora</li>
      <li>READ_WRITE - mo¿liwe zmiany w buforze i ew. automatycznej propagacji
zmian do pliku i ew. widocznoœi tych zmian przez inne programy mapuj¹ce ten
sam plik,</li>
      <li>PRIVATE - mo¿liwe zmiany w buforze, ale bez propagowania ich do
pliku (bêd¹ wiêc niewidoczne dla innych programów mapuj¹cych ten plik)</li>
    </ul>
    <li>pozycja - pzocucja pliku, od ktorej zaczyna siê mapowanie</li>
    <li>rozmiar - rozmiar mapowanego segmentu pliku<br>
    </li>
  </ul>
</div><br>
  <br>
Po zmapowaniu pliku, na uzyskanym buforze bajtowym i jego widokach mo¿emy
wykonywaæ operacje, znane nam z klas buforowych, a operacje te de-facto bêd¹
operacjami na zawartoœci pliku. <br>
  <br>
Dostêpne tryby dzialania zale¿¹ od trybów pod³¹czenia (otwarcia) kana³u.<br>
Tryb READ_ONLY mo¿e byæ u¿yty tylko dla kana³ów otwartych do czytania, natomiast
tryby READ_WRITE oraz PRIVATE wymagaj¹ kana³ów otwartych w trybie odczytu-zapisu.<br>
  <br>
Odpowiednioœæ miêdzy trybami kana³ów, a rodzajami plików/strumieni pokazuje poni¿sza tablica.<br>
  <br>
  <table border="1" cellpadding="2" cellspacing="2" width="100%">
    <tbody>
      <tr>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Tryb mapowania<br>
        </b></div>
        </td>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Tryb otwarcia kana³u<br>
        </b></div>
        </td>
        <td bgcolor="#ffcccc" valign="top">
        <div align="center"><b>Rodzaj pliku, <br>
do którego pod³¹czamy kana³<br>
metod¹ getChannel()<br>
        </b></div>
        </td>
      </tr>
      <tr>
        <td valign="top">READ_ONLY<br>
        </td>
        <td valign="top">tylko do odczytu<br>
        </td>
        <td valign="top">FileInputStream<br>
RandomAccesFile otwarty w trybie tylko do odczytu ("r")<br>
        </td>
      </tr>
      <tr>
        <td valign="top">READ_WRITE<br>
PRIVATE<br>
        </td>
        <td valign="top"><br>
do odczytu-zapisu <br>
        </td>
        <td valign="top"><br>
RandomAccesFile otwarty w trybie pisania-czytania ("rw")<br>
        </td>
      </tr>
    </tbody>
  </table>
  <br>
  <br>
Mapowanie plików mo¿e byæ wygodne z punktu widzenia programowania (dzia³anie
na pliku jak na buforze i jego widokach - lub w niektórych przypadkach jak
na tablicy).<br>
  <br>
<div class="important">Ale nie tylko to jest zalet¹ mapowania plików. <br>
Otó¿ uzyskiwany bufor mapuj¹cy (obiekt klasy MappedByteBuffer) &nbsp;jest <b>buforem bezpoœrednim</b>, czyli alokowanym poza przestrzeni¹ adresow¹ programu . <br>
W&nbsp;nowoczesnych systemach operacyjnych mo¿e on prawie w ogóle nie zajmowaæ
pamiêci systemu! &nbsp;Oczywiœcie jakieœ fragmenty pamiêci s¹ u¿ywane dla prowadzenia
odwzorowania, ale generalnie strony pamiêci wirtualnej nie s¹ zajête. Obszarem
stronicowanie jest sam plik!</div><br>
  <br>
Sprawia to, i¿ wiele programów naraz mo¿e mapowaæ ten sam du¿y plik i dzia³aæ
na nim, nawet jeœli sumaryczna wielkoœæ wszystkich odwzorowañ przekracza
wielkoœæ dostêpnej pamiêci operacyjnej.<br>
Z drugiej strony, to ¿e bufory dla mapowanych plików s¹ bezpoœrednie (czyli
alokowane gdzieœ poza programami) sprawia, ¿e mapowane pliki mog¹ stanowiæ
wygodn¹ realizacjê <b>pamiêci dzielonej</b> (przez ró¿ne procesy) i sposobem na komunikwoanie siê tych procesów.<br>
  <br>
Zobaczmy przyk³ady.<br>
Pierwszy program ilustracyjny zapisuje najpierw plik testowy liczbami ca³kowitymi,
nastêpnie uzyskuje kana³ i mapuje plik, po czym wykonuje zmiany w tym pliku,
operuj¹c wyl¹cznie na mapuj¹cym buforze. <br>
  <br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;

class MapFiles1 {

  String fname = "test";

  public MapFiles1() throws Exception {
    init();         // inicjacja pliku testowego
    mapAndChange(); // mapowanie i zmiana danych pliku
    checkResult();  // sprawdzenie wyników
  }

  void init() throws IOException {
    int[] data = { 10, 11, 12, 13 };
    DataOutputStream out = new DataOutputStream(
                               new FileOutputStream(fname)
                            );
    for (int i=0; i&lt;data.length; i++) out.writeInt(data[i]);
    out.close();
  }

  void mapAndChange() throws IOException {

    // Aby dokonywaæ zmian musimy przy³¹czyæ kanal
    // do pliku otwartego w trybie "read-write"
    RandomAccessFile file =  new RandomAccessFile(fname, "rw");
    FileChannel channel = file.getChannel();

    // Mapowanie pliku
    MappedByteBuffer buf;
    buf  = channel.map(
                FileChannel.MapMode.READ_WRITE,  // tryb "odczyt-zapis"
                                             0,  // od pocz¹tku pliku
                            (int)channel.size()  // ca³y plik
            );

    // Uzyskujemy widok na bufor = zmapowany plik
    IntBuffer ibuf = buf.asIntBuffer();

    // Dla ciekawoœci: jakie charakterystyki widoku
    System.out.println(ibuf + " --- Direct: " +  ibuf.isDirect());

    int i = 0;
    while (ibuf.hasRemaining()) {
      int num = ibuf.get();       // pobieramy kolejny element
      ibuf.put(i++, num * 10);    // zapisujemy jego wartoœæ*10 na jego pozycji    }
    }

    // Zapewnia, ¿e zmiany na pewno zostan¹ odzwierciedlone w pliku
    buf.force();

    channel.close();
  }

  void checkResult() throws IOException {
    DataInputStream in = null;
    try {
      in = new DataInputStream(new FileInputStream(fname));
      while(true) System.out.println(in.readInt());
    } catch(EOFException exc) {
        return;
    } finally {
        in.close();
    }
  }

  public static void main(String[] args) throws Exception  {
    new MapFiles1();
  }
}
</pre>
Program wyprowadzi:<br>
<div class="listing100">java.nio.DirectIntBufferS[pos=0 lim=4 cap=4] --- Direct: true<br>
100<br>
110<br>
120<br>
130</div><br>
  <br>
Na przyk³adzie tego programu warto zwróciæ uwagê na nastêpuj¹ce kwestie:<br>
  <ul>
    <li>program praktycznie nie konsumuje pamiêci dla przechowywania pliku
(zarówno MappedByteBuffer, jak i jego widok jako IntBuffer s¹ buforami bezpoœrednimi)</li>
    <li>po zmapowaniu pliku, pozycja bufora bajtowego jest ustawiona na
0, &nbsp;a jego pojemnoœæ i limit na liczbê zmapowanych bajtów; widoki "dziedzicz¹"
te ustawienia, dokonuj¹c jedynie przeliczeñ limitu i pojmenoœci z uwzglêdnieniem
rozmiaru typu elementów,<br>
    </li>
    <li>u¿ycie metody <b>force()</b> z klasy MappedByteBuffer zapewnia fizyczny
zapis do pliku; sposób i czêstostliwoœæ fizycznego zapisu zmienianych w buforze
danych zale¿y od systemu operacyjnego, mo¿e siê okazaæ, ¿e nawet po zamkniêciu
kana³u, systemowe czy sprzêtowe cache/bufory nie s¹ wymiatane.</li>
  </ul>
Drugi program ma trochê bardziej praktyczne zastosowanie. Pozwala on "w miejscu"
zmieniæ kodowanie podanego jako argument pliku z Windows1250 na ISO-8859-2
jednoczeœnie zamieniaj¹c wszystkie litery na du¿e.<br>
Przy okazji zobaczymy, ¿e:<br>
  <ul>
    <li>dekodowanie bufora bajtowego tworzy nowy bufor znakowy, który opakowuje
tablicê elementów typu char[]. Ta tablica istnieje (ona w³asnie, praktycznie,
jest tym buforem znakowym) i mo¿emy mieæ do niej dostêp poprzez odwo³anie
      <b>array()</b> z klasy CharBuffer (dla wszystkich klas buforowych metoda array zwraca tablicê opakowan¹ przez bufor, ale tylko wtedy, <b>gdy takie opakowanie mia³o miejsce</b>),</li>
    <li>czasem potrzebne mo¿e byæ zastosowanie klasy CharsetEncoder (jej
metody encode u¿ywamy po to by dokonaæ kodowania do ju¿ istniej¹cego bufora
bajtowego, &nbsp;w naszym przypadku - mapuj¹cego plik). Analogicznie (ale niejako
w drug¹ stronê)&nbsp; mo¿e byæ zastosowana klasa CharsetDecoder.</li>
  </ul>
Oto tekst programu. Proszê go przetestowac na jakimœ samodzielnie utworzonym
pliku html, zapisanym w stronie kodowej Windows 1250). <br>
  <pre>import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

class MapFiles2 {

  public static void main(String[] args) throws Exception  {
    Charset inCharset = Charset.forName("windows-1250"),
           outCharset = Charset.forName("ISO-8859-2");

    RandomAccessFile file = new RandomAccessFile(args[0], "rw");
    FileChannel fc = file.getChannel();

    // Mapowanie pliku
    MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE,
                                  0, (int) fc.size());

    // Utworzenia bufora znakowego ze zdekodowanymi znakami
    // z bufora bajtowego (mapuj¹ce plik). Konwersja: win1250-&gt;unicode
    CharBuffer cbuf = inCharset.decode(mbb);

    // Okazuje siê, ¿e ten nowo utworzony bufor opakowuje tablicê
    // zatem mo¿emy j¹ uzyskaæ i dzia³aæ na jej elementach
    // to dzialanie oznacza dzialanie na elementach bufora
    char[] chArr = cbuf.array();
    for (int i=0; i &lt; chArr.length; i++)
      chArr[i] = Character.toUpperCase(chArr[i]);

    // Po dekodowaniu bufor bajtowy musi byæ przewiniêty do pocz¹tku
    // aby koder (zob. dalej) móg³ w nim zapisywaæ kodowane dane
    mbb.rewind();

    // Utworzenie kodera, zamieniaj¹cego Unicode na wyjœciow¹ stronê kodow¹
    CharsetEncoder encoder = outCharset.newEncoder();

    // Koder zapisuje istniej¹cy bufor mbb (ten który mapuje plik)
    // ostatni argument - true oznacza zakoñczenie pracy kodera na tym wywo³aniu
    encoder.encode(cbuf, mbb, true);
    fc.close();
  }
}
</pre>
  <br>
  <br>
<br>
  
<a name="NIO.9"></a><h2>9.  NIO: bezpoœrednie transfery kana³owe</h2>


  <div class="def">Bezpoœredni transfer kana³owy polega na przeslaniu wszystkich danych
jednego kana³u do drugiego kana³u za pomoc¹ jednego odwo³ania z poziomu programu,
z mo¿liwym (w zale¿noœci od systemu operacyjnego i platformy sprzêtowej)
pominiêciem systemowych operacji wejœcia-wyjœcia, a zrealizowanym jako bardzo
szybki trarnsfer wykonywany przez sam sprzêt ze wsparciem ze strony j¹dra
systemu</div>&nbsp; <br>
  <br>
Obecnie w NIO bezpoœrednie transfery kana³owe dotycz¹ tarnsferów do/z plików.<br>
Klasa FileChannel dostarcza dwóch metod, które pozwalaj¹ na:<br>
  <br>
  <ul>
    <li>bezpoœredni transfer kana³owy z dowolnego kanalu do kanalu plikowego (metoda <b>transferTo</b>)</li>
    <li>bezpoœredni transfer kanalowy z kanalu plikowego do dowlonego kana³u (metoda <b>transferFrom</b>)</li>
  </ul>
Bezpoœrednie transfery kana³owe w systemach, które w swoim j¹drze zapewniaj¹
wsparcie takich transferów, mog¹ byæ bardzo szybkie i efektywne. <br>
W innych systemach (jak np. Windows), poprawa efektywnoœci (w porównaniu
z tradycyjnymi sposobami kopiowania danych) mo¿e byæ ró¿na, nawet doœæ nieznaczna.<br>
  <br>
Zawsze jednak zalet¹ stosowania metod <b>transfer...</b> &nbsp;z klasy FileChannel
pozostaje mo¿liwoœc unikniêcia potrzeby programowania (w kliku wierszach,
ale zawsze to trochê pracy) procedur kopiowania danych z/do plików.<br>
  <br>
Oto przyk³adowy program, porównuj¹cy dwa sposoby kopiowania plików: za pomoc¹
bezpoœredniego transferu kana³owego i poprzez buforowane strumienie.<br>
  <pre>import java.nio.*;
import java.nio.channels.*;
import java.io.*;

class DirectTransfer {

  String inFileName;
  String outFileName;

  DirectTransfer(String infn, String outfn) throws Exception {
    inFileName  = infn;
    outFileName = outfn;
    directTransfer();
    copyByStream();
  }


  void directTransfer() throws Exception {

    FileInputStream in = new FileInputStream(inFileName);
    FileOutputStream out =  new FileOutputStream(outFileName);
    FileChannel fcin = in.getChannel();
    FileChannel fcout = out.getChannel();
    long size = fcin.size();
    System.out.println("Copying file " + size + "B.");

    long start =  System.currentTimeMillis();

    // Bezpoœredni transfer
    fcout.transferFrom(fcin, 0, size);

    long end = System.currentTimeMillis();

    System.out.println("Direct transfer time " + (end - start));

   }


  final int BUFSIZE = 5000000;
  void copyByStream() throws Exception  {

    FileInputStream fin = new FileInputStream(inFileName);
    BufferedInputStream in = new BufferedInputStream(fin, BUFSIZE );
    FileOutputStream fout = new FileOutputStream(outFileName);
    BufferedOutputStream out = new BufferedOutputStream(fout, BUFSIZE);

    byte[] b = new byte[BUFSIZE];
    long start =  System.currentTimeMillis();
    while (true) {
      int n = in.read(b);
      if (n == -1) break;
      out.write(b, 0, n);
    }
    in.close();
    out.close();

    long end = System.currentTimeMillis();
    System.out.println("Stream time " + (end - start));
  }


   public static void main(String[] args) throws Exception {
     new DirectTransfer(args[0], args[1]);
   }
}
</pre>
Mo¿liwy wynik:<br>
<div class="listing100"><br>
Copying file 51793936B.<br>
Direct transfer time 2470<br>
Stream time 6150</div><br>
  <br>
  <br>
<br>
  <br>
  
</body>
</html>
