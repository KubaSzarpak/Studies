<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
		<meta name="author" content="Artur Stanek">
		<meta name="description" content="Scala - techniki rozproszone">
		<meta name="copyright" content="(c) autor PJWSTK 2010">
		<link rel="stylesheet" type="text/css" href="../STYLE/common.css">
		
		<title>Scala - techniki rozproszone - WYK£AD 2</title>
		
	</head>

	<body>

		<div align="center">
			<a name="S2Rozwin"></a><h1>Scala - techniki rozproszone - WYK£AD 2</h1>
		</div>
		
		<hr><br>
		
		<i>
			Ci¹g wyk³adów dotycz¹cy technik rozproszonych realizowanych za pomoc¹ Scali poprzedzony zdobyciem wiedzy o tym jêzyku programowania. 
			
			<br><br>
			
			Wyk³ad 2 : informacje zaawansowane o jêzyku			
		</i>
		
		<br><hr>
		
		<a name="S2Rozwin.1"></a><h2>1. Symbole</h2>
		
		<font class="chapter">
		
			Symbole s¹ bardzo prostym i przyjemnym tematem.
			
			<br><br>
			
			Budujemy je u¿ywaj¹c specjalnej sk³adni :
			
			<br><br>
			
			<font class="code">val symbol : scala.Symbol = 'mojSymbol</font>
			
			<br><br>
			
			lub wykorzystuj¹c metodê faktoryzacyjn¹ <font class="code">apply()</font> w obiekcie <font class="code">scala.Symbol</font> :
			
			<br><br>
			
			<font class="code">val symbol = scala.Symbol( "mojSymbol" )</font>	
			
			<br><br>
			
			Symbole zapewniaj¹ mo¿liwoœæ otrzymania takich samych obiektów dla tych samych ³añcuchów tekstowych, co umo¿liwia porównywanie referencyjne <font class="code">== </font> :
			
			<br>
			
			<font class="code">
val symbol1 : scala.Symbol = 'jakisTekst           
val symbol2 = scala.Symbol( "jakisTekst" )
val symbol3 = 'jakisTekst
        
println( symbol1 == symbol2 )
println( symbol2 == symbol3 )
println( symbol1 == symbol3 )
			</font>	
			
			<br>
			
			da :
			
			<br>
			
			<font class="code">
true
true
true
			</font>	
			
		</font>	

		<br><hr>
		
		<a name="S2Rozwin.2"></a><h2>2. Wyra¿enia zwracaj¹ce wartoœæ</h2>
		
		<font class="chapter">

			Istnieje w Javie pewna zmiennogenna sprawa: nic (oprócz operatora <font class="code">?:</font>) nie zwraca wartoœci! My jako programiœci jesteœmy zmuszeni wiêc przed ka¿dym <font class="code">if</font> czy <font class="code">for</font> tworzyæ zmienne, na których zapamiêtamy interesuj¹ce nas, zwrócone wyniki.

			<br><br>
			
			Zosta³o to dostrze¿one przez twórców Scali i usprawnione (za wyj¹tkiem pêtli while oraz <font class="code">do-while</font>). Z pewnoœci¹ nie bez znaczenia jest tak¿e funkcyjnoœæ Scali - wszystko jest funkcj¹ i mo¿e zwracaæ wartoœæ. Nie jest to mo¿e strategicznie wa¿n¹ funkcjonalnoœci¹, jednak takie podejœcie wp³ywaja na ca³kowity odbiór Scali, przyczyniaj¹ siê tak¿e do ogólnej przejrzystoœci kodu i przyjemnoœci wynikaj¹cej z programowania.

			<br><br>
			
			[Pêtle <font class="code">while</font> oraz <font class="code">do-while</font>, nie zwracaj¹ nic co mog³oby nas interesowaæ (zwracanym typem jest dok³adnie <font class="code">Unit</font>, czyli javowy <i>void</i>). Mo¿na uznaæ, ¿e nie s¹ wyra¿eniami - zapewne twórcom Scali przyœwieca³a idea prostej, nieskomplikowanej pêtli.]

		</font>

		<br>
		
		<a name="S2Rozwin.3"></a><h2>2.1. Blok kodu</h2>
		
		<font class="chapter">
		
			Ka¿dy blok kodu zwraca wartoœæ. Zwracan¹ wartoœci¹ jest wartoœæ ostatniego wyra¿enia :

			<br>
			
			<font class="code">
val czasJakoTekst =
{
    var s = "";
    s = "" + System.currentTimeMillis
    s
}
			</font>
			
			<br>
			
			a tak¿e :

			<br>
			
			<font class="code">
val czasJakoTekst =
{
    var czas = System.currentTimeMillis

    {
        var s = "";
        s = "" + czas
        s
    }
}
			</font>
			
			<br>
			
			W przypadku drugiego przyk³adu wartoœci¹ zwrócon¹ bêdzie wartoœæ ostatniego wyra¿enia. Ostatnim wyra¿eniem jest jednak blok kodu, który zostanie potraktowany jako ca³oœæ. To co on zwróci zostanie zwrócone i zapamiêtane na zmiennej <font class="code">czasJakoTekst</font>.		
		
		</font>

		<br>
		
		<a name="S2Rozwin.4"></a><h2>2.2. if</h2>
		
		<font class="chapter">
		
			Ka¿da instrukcja <font class="code">if</font> zwraca wartoœæ :

			<br><br>

			<font class="code">val wynik = if( jakasWartosc > 10 ) jakasWartosc / 2 else jakasWartosc % 2</font>
			
			<br><br>
			
			Jeœli rozpiszemy siê w Scali zapewne czêsto bêdziemy pomijaæ deklarowanie typów, tak jak w tym przyk³adzie pominiêto typ sta³ej <font class="code">wynik</font>. Kryje siê tutaj ukryta pu³apka, gdy¿ drogi rozwi¹zania instrukcji <font class="code">if</font> s¹ dwie, rozwa¿my kolejny przyk³ad :
			
			<br><br>
			
			<font class="code">val wynik = if( jakasWartosc > 10 ) jakasWartosc / 2 else "" + jakasWartosc % 2</font>
			
			<br><br>
			
			Skoro sami nie zadeklarowaliœmy typu <font class="code">wynik</font> to kompilator zajmie siê tym za nas. Jak widaæ zwrotem z <font class="code">if</font> mo¿e byæ wartoœæ liczbowa lub <font class="code">String</font>. Kompilator poszukuj¹c wspólnego mianownika zapewne obierze <font class="code">AnyRef</font> (czyli odpowiednik <font class="code">java.lang.Object</font>). To mo¿e jednak nie byæ to czego siê spodziewamy.
			
			<br><br>
			
			Warto wiêc napisaæ to, czego siê spodziewamy :
			
			<br>
			
			<font class="code">
val wynik : Int = if( jakasWartosc > 10 ) jakasWartosc / 2 else "" + jakasWartosc % 2
	// <- blad kompilacji, sekcja else zwraca String, spodziewany jest Int
			</font>
					
		</font>

		<br>
		
		<a name="S2Rozwin.5"></a><h2>2.3. for</h2>
		
		<font class="chapter">

			Instrukcja <font class="code">for</font> ju¿ nie jest tak trywialna jak <font class="code">if</font> - jak wiemy mo¿e mieæ wiele iteracji lub bardzo ma³o. Jest to nieprzewidywalne, ale na szczêœcie jest struktura danych, która rozwi¹zuje nasze problemy - kolekcja.
			
			<br><br>
			
			<font class="code">val kolekcja = for( val i <- 1 to 10 ) yield i</font>
			
			<br><br>
			
			Powy¿sza linia powoduje odk³adanie (za pomoc¹ s³ówka <font class="code">yield</font>) do zainicjowanej za nas kolekcji kolejnych wartoœci <font class="code">i</font> (w tym wypadku od 1 do 10). Kiedy pêtla <font class="code">for</font> siê skoñczy kolekcja jest zwracana - czyli zapamiêtana na sta³ej <font class="code">kolekcja</font>.
			
			<br><br>
			
			Warto wspomnieæ, i¿ jeœli nie chcemy niczego zwraca z <font class="code">for</font> (nie chcemy niczego odk³adaæ do kolekcji) to nie musimy u¿ywaæ <font class="code">yield</font>. Jednak w przeciwnym przypadku to w³aœnie po s³ówku <font class="code">yield</font> powinien staæ ca³y blok kodu, którego wartoœæ zwrócon¹ <font class="code">yield</font> umieœci w kolekcji.
			
			<br><br>
			
			Poprawnie :
			
			<br><br>
			
			<font class="code">val kolekcja = for( val i <- 1 to 10 ) yield { val c = i * 2; c }</font>
			
			<br><br>
			
			Niepoprawnie :
			
			<br>
			
			<font class="code">
val kolekcja = for( val i <- 1 to 10 ) { val c = i * 2; yield c }
	// <- blad kompilacji !! Nieprawidlowe uzycie yield.
			</font>
			
			<br>
			
			Mo¿naby powiedzieæ, ¿e nie jest to do koñca to czego poszukujemy, gdy¿ ka¿da iteracja pêtli zmusza nas do od³o¿enia czegoœ do kolekcji. Rozwi¹zaniem tego jest skorzystanie z nowych mo¿liwoœci sk³adniowych pêtli <font class="code">for</font> i odpowiednie jej zaprojektowanie.

		</font>

		<br>
		
		<a name="S2Rozwin.6"></a><h2>2.4. try-catch-finally</h2>
		
		<font class="chapter">

			<font class="code">
val wynik = try
{
    instr1
    instr2
    ”ok”
}
catch
{
    case ioe : IOException =>
    {
        instr2
        new Integer( 0 )
    }

    case e : Exception =>
    {
        instr3
        ”err”
    }
}
finally
{
    instr5
}
			</font>
			
			<br>
			
			Poniewa¿ wynik nie ma okreœlonego typu kompilator przypisze go za nas, znajduj¹c wspólny mianownik dla <font class="code">String</font> (zwracany z sekcji <font class="code">try</font>), <font class="code">Integer</font> (zwracany z sekcji <font class="code">catch</font>, <font class="code">IOException</font>) oraz dla <font class="code">String</font> (zwracany z sekcji <font class="code">catch</font>, <font class="code">Exception</font>). Aby nie pope³niæ w takich przypadkach b³êdu warto od razu napisaæ przy zmiennej wynik jaki typ oczekujemy (<font class="code">val wynik : String = try...</font>).
			
			<br><br>
			
			Wa¿na uwaga dla sekcji <font class="code">finally</font>. Wykona siê ona tak samo jak w Javie (czyli w momencie kiedy by³ i kiedy nie by³o wyj¹tku), jednak jej zwrot nie jest brany pod uwagê (liczy siê tylko zwrot z sekcji <font class="code">try</font> i/lub <font class="code">catch</font>). 

		</font>

		<br><hr>
		
		<a name="S2Rozwin.7"></a><h2>3. Interfejsy ... czyli traits</h2>
		
		<font class="chapter">

			W Scali rozszerzono mo¿liwoœci interfejsów i nazwano je cechami (traits).
			
			<br><br>
			
			Ilekroæ w Javie widzimy konstrukcje klas abstrakcyjnych wybudowane po to by omin¹æ problem braku wielodziedziczenia. Raz napisana implementacja interfejsu umieszczana jest w klasie abstrakcyjnej jakby 'na si³ê' w³o¿on¹ w hierarchiê klas. Niestety, nie ma ³atwej mo¿liwoœci na wielokrotne wykorzystanie raz poœwiêconego czasu i poczynionej implementacji. Najgorszym z mo¿liwych rozwi¹zañ jest u¿ycie copy & paste, co prowadzi do dublowania kodu. Wiêcej kodu to d³u¿szy czas analizy (d³u¿szy czas analizy to wiêksze koszty...). Poprawka lub rozszerzenia ponownie wprowadzone do jednej implementacji musz¹ byæ replikowane na inne kopie.
			
			<br><br>
			
			Traits przychodz¹ nam z pomoc¹. W odró¿nieniu od swoich Javowych odpowiedników pozwalaj¹ one (dodatkowo) na umieszczanie pól oraz zaimplementowanych metod. Dziêki temu trait mo¿e przechowywaæ stan i operowaæ na nim. Tak jak w Javie, jedna klasa mo¿e 'implementowaæ' wiele traitsów. Powstaj¹ dziêki temu mo¿liwoœci 'wielodziedziczenia' - czyli tworzenia miksów. Ograniczeniem na³o¿onym na traitsy jest niemo¿liwoœæ posiadania przez nich konstruktorów.

			<br>
			
			<font class="code">
trait CechaWiek
{
    private var wiek = 0

    def getWiek = wiek
    def setWiek( nowyWiek : Int ) { wiek = nowyWiek }
}

trait CechaImie
{
    private val imie = ""
    def getImie = imie
    def setImie( noweImie : String ) { imie = noweImie }
}


class KlasaFinalna extends CechaWiek with CechaImie
			</font>
			
			<br>
			
			(lub <font class="code">class KlasaFinalna extends JakasSuperklasa with CechaWiek with CechaImie</font>)

			<br><br>
			
			<font class="code">val kf = new KlasaFinalna</font>

			<br><br>

			Dziêki swym w³aœciwoœciom traitsy s¹ fundamentem odzyskiwania kodu w Scali. Wystarczy przyjrzeæ siê kolekcjom, aby zobaczyæ jak du¿y u¿ytek robi¹ one z dobrze przemyœlanych i raz zaimplementowanych tratisów.
			
			<br><br>
			
			Od teraz znaj¹c traitsy mo¿ecie zmieniæ Pañstwo swoje myœlenie o powstawaniu i projektowaniu klas. Tworz¹c klasê rozbijajcie j¹ na szereg cech, które ma ona posiadaæ. Cechy implementujcie w oddzielnych traitsach, a sam¹ klasê finaln¹ twórzcie jako miks pewnych cech. Rozwijaj¹c siê dalej k³adŸcie nacisk na jak najmniejsze tworzenie klas, a jak najwiêksze tworzenie cech - cech, które bêd¹c uniwersalne zaprojektowane oka¿¹ siê wielokrotnie przydatne w ró¿nych klasach i projektach.
			
			<br><br>
			
			Ciekawostka : co oznacza s³owo '<font class="code">trait</font>' w jêzyku polskim ??? :)

		</font>

		<br>
		
		<a name="S2Rozwin.8"></a><h2>3.1. Miksy (mixins)</h2>
		
		<font class="chapter">

			U¿ywaj¹c cech z powy¿szego przyk³adu tworzyliœmy klasê <font class="code">KlasaFinalna</font>. Mo¿na siê do niej odwo³ywaæ jako do typu, mo¿na swobodnie tworzyæ wiele jej instancji. Jeœli jednak poszukiwalibyœmy czegoœ szybszego, to mo¿emy stworzyæ mixin :

			<br><br>
			
			<font class="code">val kf1 = new CechaWiek with CechaImie</font>

			<br><br>
			
			(lub <font class="code">val kf1 = new JakasSuperklasa with CechaWiek with CechaImie</font>)

			<br><br>
			
			W tym momencie instancja obiektu zapamiêtana na sta³ej <font class="code">kf1</font> mo¿e byæ rzutowana na <font class="code">CechaWiek</font> oraz na <font class="code">CechaImie</font> (oraz na klasê z której dziedziczy - czyli superklasê). Sama jednak jest swoistego rodzaju miksem bowiem trudno jest odpowiedzieæ na pytanie (wskazaæ) jakiego dok³adnie typu jest <font class="code">kf1</font>.

		</font>

		<br>
		
		<a name="S2Rozwin.9"></a><h2>3.2. Jak to dzia³a ?</h2>
		
		<font class="chapter">

			Otó¿ jak siê dobrze Pañstwo domyœlacie kompilator Scali, dziêki swej pozycji (znajduje siê przed kodem docelowym Java i sam go generuje), kod traitów automatycznie umieszcza w generowanych klasach. Dzia³a wiêc na zasadach copy & paste, wyrêczaj¹c nas z koniecznoœci zarz¹dzania du¿¹ iloœci¹ kopii tego samego kodu.

		</font>

		<br>
		
		<a name="S2Rozwin.10"></a><h2>3.3. super</h2>
		
		<font class="chapter">

			Poniewa¿ w przypadku tratisów mamy znamiona wielodziedziczenia wyt³umaczenie regu³ u¿ywania s³ówka <font class="code">super</font> nie jest takie proste i wymaga³oby zbyt du¿o czasu. Przyjrzymy siê tylko prostemu przyk³adowi.
			
			<br>
			
			<font class="code">
class Zwierze { def hello { println( "Zwierze" ) } }

trait Siersciowate extends Zwierze
{
	override def hello { println( "Siersciowate" ); super.hello }
}

trait Ogoniaste extends Zwierze
{
	override def hello { println( "Ogoniaste" ); super.hello }
}

trait DlugoOgoniaste extends Ogoniaste
{
	override def hello { println( "DlugoOgoniaste" ); super.hello }
}

class Pies extends Zwierze with Siersciowate with DlugoOgoniaste

val pies = new Pies
			</font>
			
			<br>
			
			Wywo³anie :

			<br><br>
			
			<font class="code">pies.hello</font>

			<br><br>
			
			da :

			<br>
			
			<font class="code">
DlugoOgoniaste
Ogoniaste
Siersciowate
Zwierze
			</font>
			
			<br>
			
			Tak wiêc, jak widzimy kolejnoœæ idzie 'od prawej' (od najbardziej prawego, domiksowanego traitsu) czyli <font class="code">DlugoOgoniaste</font>. Nastêpnie wywo³anie <font class="code">super</font> przechodzi do klasy z której on (<font class="code">DlugoOgoniaste</font>) dziedziczy, a wiêc <font class="code">Ogoniaste</font>. Poniewa¿ z ogoniastych doszlibyœmy do <font class="code">Zwierze</font> wykonujemy krok wstecz do siersciowatych. W tym momencie wyczerpane zosta³y ju¿ wszystkie mo¿liwoœci i wykonywana jest metoda z klasy <font class="code">Zwierze</font>.
			
			<br><br>
			
			Warto dodaæ, i¿ kolejnoœæ wywo³añ <font class="code">super</font> jest ustalana przez kompilator dynamicznie w czasie kompilacji i nigdy nie mo¿emy byæ do koñca pewni jaka klasa bêdzie siê znajdowa³a 'nad nami' (czyli z jakiej klasy wywo³amy metodê któr¹ przes³oniliœmy).

		</font>

		<br>
		
		<a name="S2Rozwin.11"></a><h2>3.4. Typy strukturalne (structural types)</h2>
		
		<font class="chapter">

			Pozostaj¹c nadal w temacie traitsów/interfejsów czas na ma³e oderwanie.
			
			<br><br>
			
			Czy jest mo¿liwy œwiat bez interfejsów ? Otó¿ tak, mog¹ byæ to albo domkniêcia (<i>closures</i>) albo ... <i>structural types</i>.

			<br>
			
			<font class="code">
def prowadz( samochod : { def start() : Unit ; def stop() : Unit } )
{
    samochod.start
    samochod.stop
}
			</font>
			
			<br>

			Jak widzimy, mo¿emy narzuciæ pewnego rodzaju filtr na obiekt przekazany jako argument do metody <font class="code">prowadz()</font>. W typ wypadku narzucamy, ¿e mo¿e byæ to dowolna instancja dowolnej klasy/obiektu jednak musi ona posiadaæ dwie metody:
			
			<br>
			
			- <font class="code">start()</font> - nieposiadaj¹c¹ ¿adnych argumentów oraz nic niezwracaj¹c¹
			
			<br>
			
			- <font class="code">stop()</font> - porobnie jak <font class="code">start()</font>, nieposiadaj¹c¹ ¿adnych argumentów oraz nic niezwracaj¹c¹
			
			<br><br>
			
			To zadanie Scala realizuje za pomoc¹ refleksji, tak wiêc jest to rozwi¹zanie wolniejsze od standardowych interfejsów (trait'sów). To co zyskujemy to na pewno zmniejszona iloœæ interfejsów w programie.

		</font>

		<br><hr>
		
		<a name="S2Rozwin.12"></a><h2>4. Mutable / immutable - dyskusja</h2>
		
		<font class="chapter">

			PrzeprowadŸmy krótk¹ dyskusjê za i przeciw na temat struktur danych zmiennych i niezmiennych (mutalbe/immutable).
			
			<br><br>
			
			Przypomnijmy, w Javie struktura niezmienna to na przyk³ad <font class="code">java.lang.String</font> :

			<br>
			
			<font class="code">
var s = new String( "ala ma kota" )
s = s.substring( 4 ) // ma kota
			</font>
			
			<br>
			
			zaœ struktura zmienna to na przyk³ad <font class="code">java.util.Vector</font> :

			<br>
			
			<font class="code">
val v = new java.util.Vector[ Integer ]
v.add( 1 )
v.add( 2 )
			</font>
			
			<br>
			
			(Wywo³ania metody <font class="code">add()</font> dokonuj¹ zmiany wewn¹trz wektora.)

			<br><br>
			
			W Scali struktura niezmienna to na przyk³ad <font class="code">scala.collection.immutable.Queue</font> :

			<br>
			
			<font class="code">
var q = scala.collection.immutable.Queue[ String ]()
q = q + "a"
q = q + "b"
			</font>
			
			<br>
			
			zaœ zmienna to na przyk³ad <font class="code">scala.collection.mutable.Set</font>:

			<br>
			
			<font class="code">
val s = scala.collection.mutable.Set[ String ]()
s += "a"
s += "b"
			</font>

		</font>

		<br>
		
		<a name="S2Rozwin.13"></a><h2>4.1. Zmienne (mutable)</h2>
		
		<font class="chapter">
		
			<b>Zalety</b>
			
			<br>
			
			- nie powstaje du¿o nowych obiektów (GC odci¹¿ony)
			
			<br>
			
			- pola trzymaj¹ce referencjê do struktury danych mog¹ byæ sta³ymi (gdy¿ zmiany odbywaj¹ siê w tej jednej instancji)
			
			<br><br>
			
			<b>Wady</b>
			
			<br>
			- wytworzenie obrony dla danych na ich odczyt, zapis, modyfikacje, ...
			
			<br>
			
			- wymagana wiedza i doœwiadczenie z zakresu synchronizacji
			
			<br>
			
			- d³ugi czas wytworzenia, a potem analizowania
			
			<br>
			
			- skomplikowanie kodu
			
			<br>
			
			- czêste i tak niedok³adne zabezpieczenie wszystkich mo¿liwych sytuacji
			
			<br>
			
			- utrata wydajnoœci 
			
		</font>
		
		<br>
		
		<a name="S2Rozwin.14"></a><h2>4.2. Niezmienne (immutable)</h2>
		
		<font class="chapter">		

			<b>Zalety</b>
			
			<br>
			
			- prostota tworzenia
			
			<br>
			
			- niewymagana bogata wiedza i doœwiadczenie o zabezpieczeniach (synchronizacja)
			
			<br>
			
			- szybki czas wykonania
			
			<br>
			
			- ³atwa analiza
			
			<br><br>
			
			<b>Wady</b>
			
			<br>
			
			- czêste przepisywanie dziesi¹tek/setek/tysiêcy referencji
			
			<br>
			
			- du¿o pracy spada na barki GC, gdy¿ jest to technika obiektogenna
			
			<br>
			
			- pola trzymaj¹ce referencjê do struktury danych czêsto musz¹ byæ zmiennymi, aby móc po dokonanej zmianie zapamiêtaæ ponownie na niej nowy obiekt

		</font>

		<br>
		
		<a name="S2Rozwin.15"></a><h2>4.3. Podsumowanie</h2>
		
		<font class="chapter">	

			Napisanie struktury zmiennej wymaga od jej twórcy dodatkowo bogatej wiedzy z zakresu synchronizacji i wielow¹tkowoœci. Z pocz¹tku prosty kod zaczynamy otaczaæ murami (najpierw pierwszym na read, potem drugim na write,...), staje siê on coraz bardziej nieprzejrzysty i przez to nieprzyjemny. Coraz wiêcej czasu up³ywa nam zanalizowanie go i ponowne rozwijanie.
			
			<br><br>
			
			Synchronizacja poch³ania czas procesora i w zasadzie wszystko by³oby dobrze dla programów o ma³ej iloœci w¹tków (spowodowanych ma³¹ iloœci¹ dostêpnych rdzeni). Jednak musimy wzi¹æ pod uwagê, ¿e nadchodz¹ce czasy bêd¹ obfitowaæ w procesory o coraz wiêkszej iloœci rdzeni. Komputery niedalekiej przysz³oœci bêd¹ tak¿e udostêpnia³y nam moc ró¿nych procesorów (g³ówny, graficzny, fizyczny,...), w których bêdzie wiele rdzeni dedykowanych b¹dŸ ogólnego przeznaczenia (czasami nawet setki).
			
			<br><br>
			
			Nale¿a³oby siê zastanowiæ czy przypadkiem nie zbli¿amy siê do granicy w której utracony czas (takty procesora) podczas operowania wielu w¹tków na wielu blokach synchronized nie staje siê wiêkszy, ni¿ pozbycie siê wszystkich tego typu bloków na rzecz struktur immutable.
			
			<br><br>
			
			Ich kosztem jest zwiêkszona praca odœmiecacza (GC), gdy¿ podczas próby jakiejkolwiek 'modyfikacji' tworzony jest nowa instancja o zmodyfikowanych danych. Stara zapewne nie jest ju¿ potrzebna i podlega odœmieceniu. Mo¿na powiedzieæ, i¿ podczas tworzenia nowej instancji - szczególnie w kolekcjach - odbywa siê bardzo du¿o przepisywañ. Dodanie na koñcu du¿ej kolekcji jednego elementu powoduje utworzenie nowej - a wiêc przepisanie ca³ej starej - powiêkszonej o ten jeden element na koñcu. To tak¿e zajmuje czas, a wiêc jest kosztem - jednak musimy wiedzieæ, i¿ nie s¹ kopiowane olbrzymie iloœci danych. Przepisywaniu ulegaj¹ tylko referencje. Proces ten z pewnoœci¹ jest bardzo zoptymalizowany, dodatkowo jest to tak¿e coœ co zrzucamy z naszych (programistycznych) barków na JVM.

		</font>

		<br><hr>
		
		<a name="S2Rozwin.16"></a><h2>5. Metody</h2>
		
		<a name="S2Rozwin.17"></a><h2>5.1. Zwracanie wielu wartoœci z metody</h2>
				
		<font class="chapter">		

			Kolejna uci¹¿liwa technika z Javy zosta³a bardzo ³adnie rozwi¹zana w Scali. Mianowicie chodzi o zwracanie wielu wartoœci z metody.
			
			<br><br>
			
			Ka¿dy z nas czêsto spotyka siê z potrzeb¹ zwrócenia z metody wiêcej ni¿ jednej danej. W takim przypadku istniej¹ dwie drogi: albo zwróciæ tablicê obiektów albo stworzyæ dedykowan¹ klasê w roli pude³ka na zwracane dane.
			
			<br><br>
			
			Poniewa¿ rozwi¹zanie pierwsze nie jest takie mi³e (utrata typów), czêsto wybierane jest rozwi¹zanie drugie, a wiêc tworzenie specjalnej klasy tylko dla tego jednego celu - aby zwróciæ dane z jednej metody.
			
			<br>
			
			Bior¹c pod uwagê fakt, ¿e potrzeba zwrócenia wielu danych z wielu metod wystêpuje dosyæ czêsto, mo¿na siê domyœliæ jak bardzo klasogenna jest to potrzeba.
			
			<br><br>
			
			W Scali istnieje coœ takiego jak <i>Tuple</i> i pozwala nam ³atwo zwróciæ wiele danych z metody :
			
			<br>
			
			<font class="code">
def m2 : Tuple2[ Int , Int] =
{
    ...
    ( wynik1 , wynik2 )
}
			</font>
			
			<br>
			
			Jak widzimy jest to tak proste jak ubranie kilku danych do zwrócenia w nawiasy i postawienie pomiêdzy nimi przecinków.
			
			<br><br>
			
			Oczywiœcie mo¿na pomin¹æ jawne pisanie typu zwracanych danych, gdy¿ kompilator mo¿e je wywnioskowaæ samemu :
			
			<br>
			
			<font class="code">
def m2 =
{
    ...
    ( wynik1 , wynik2 )
}
			</font>
			
			<br>
			
			Tak naprawdê istnieje szereg klas <font class="code">Tuple</font> (<font class="code">Tuple1[ T1 ]</font>, <font class="code">Tuple2[ T1 , T2 ]</font>, <font class="code">Tuple3[ T1 , T2 , T3 ]</font>, ...), kompilator wybiera odpowiedni¹ i inicjuje danymi.
			
			<br><br>
			
			W <i>Tuple</i> nigdy nie tracimy typu zwracanych danych, ale nazwy ulegaj¹ anonimizacji (tak, nic nie zast¹pi dedykowanej klasy - pude³ka na zwracane dane) :
			
			<br>
			
			<font class="code">
val zwroconyTuple = m2

val wynik1 = zwroconyTuple._1
val wynik2 = zwroconyTuple._2
			</font>
			
			<br>
			
			Dostêp do poszczególnych danych odbywa siê poprzez numer (licz¹c od 1) poprzedzony podkreœleniem.

		</font>

		<br>

		<a name="S2Rozwin.18"></a><h2>5.2. Zwracanie wielu wartoœci z metody</h2>

		<font class="chapter">			

			Ciekawych technik w Scali nie brak. Co powiecie Pañstwo na metodê o dwóch listach argumentów??? Zapytacie zapewne, jak to wygl¹da oraz gdzie mo¿e byæ przydatne.

		</font>
		
		<br>

		<a name="S2Rozwin.19"></a><h2>5.2.1. Definiowanie</h2>

		<font class="chapter">			

			Metoda wygl¹da niezbyt skomplikowanie, co poka¿e nastêpuj¹cy przyk³ad.
			
			<br><br>
			
			Zdefiniujmy sobie metodê :
			
			<br><br>
			
			<font class="code">def dodajLubOdejmij( a : Int , b : Int , c : Int , czyDodac : Boolean )</font>
			
			<br>
			
			ewentualnie
			
			<br>
			
			<font class="code">def dodajLubOdejmij( czyDodac : Boolean , a : Int , b : Int , c : Int )</font>
			
			<br><br>
			
			Jak widaæ dokonujemy tutaj pomieszania tego 'co' oraz tego 'co z tym zrobiæ', posprz¹tajmy to :
			
			<br><br>
			
			<font class="code">def dodajLubOdejmij( a : Int , b : Int , c : Int )( czyDodac : Boolean )</font>
			<br>
			ewentualnie
			<br>
			<font class="code">def dodajLubOdejmij( czyDodac : Boolean )( a : Int , b : Int , c : Int )</font>
			
			<br><br>
			
			Dziêki mo¿liwoœci dwóch list argumentów mo¿emy separowaæ sobie czyste dane oraz akcje, które mo¿emy na nich wykonaæ.

		</font>

		<br>

		<a name="S2Rozwin.20"></a><h2>5.2.2. Wywo³ywanie</h2>

		<font class="chapter">	

			Wywo³anie takiej metody wygl¹da nastêpuj¹co :
			
			<br><br>

			<font class="code">dodajLubOdejmij( 1 , 2 , 3 )( true )</font>

			<br><br>
			
			I w tym momencie mo¿na by uznaæ, ¿e to koniec tematu, gdyby nie jeden szczegó³  podczas wywo³ywania takiej metody Scala pozwala nam nawiasy drugiej listy argumentów zamieniæ na klamrowe w momencie, jeœli jest tam tylko jeden argument :
			
			<br><br>

			<font class="code">dodajLubOdejmij( 1 , 2 , 3 ){ true }</font>
			
			<br><br>
			
			Nie musimy tego pisaæ w jednej linii :
			
			<br>

			<font class="code">
dodajLubOdejmij( 1 , 2 , 3 )
{
    true
}
			</font>
			
			<br>
			
			Mo¿emy wstawiæ do œrodka tak¿e ca³y blok kodu, byle by koñczy³ siê zwróceniem wartoœci <font class="code">Boolean</font> :
			
			<br>

			<font class="code">
dodajLubOdejmij( 1 , 2 , 3 )
{
    println( "przygotowuje dane do wywolania metody dodajLubOdejmij" )
    println( "dodawanie przeprowadze jesli reszta z dzielenia obecnego" )
    println( "czasu w milisekundach jest rowna zero" )
    
    System.currentTimeMillis % 2 == 0
}
			</font>
			
			<br>
			
			Co istotne : ten blok kodu wykona siê przed wywo³aniem metody! Zostanie on przetworzony, a wynik (<font class="code">Boolean</font>) zostanie wstawiony jako drugi argument metody.

		</font>

		<br>

		<a name="S2Rozwin.21"></a><h2>5.2.3. Tworzenie w³asnych instrukcji jêzykowych</h2>

		<font class="chapter">	

			Co powiecie na mo¿liwoœæ tworzenia w³asnych 'instrukcji' jêzykowych ? Nie wa¿ne czy jesteœcie fizykiem j¹drowym czy chemikiem molekularnym - byæ mo¿e zetknêliœcie siê z tym, ¿e normalnie dostêpne instrukcje s¹  niezbyt pomocne podczas rozwi¹zywania postawionego problemu ?
			
			<br>
			
			Najlepszym rozwi¹zaniem jest poœwiêciæ trochê czasu najpierw i przygotowaæ sobie zestaw pomocnych instrukcji.
			
			<br><br>
			
			Zobaczmy jak ³atwo wytworzyæ swoje w³asne narzêdzia, w tym wypadku w³asn¹ pêtlê :

			<br>

			<font class="code">
def petla( warunek : => Boolean )( cialoPetli : =>Unit )
{
    while( warunek ) cialoPetli
}
			</font>

			<br>
			
			Co siê dzieje w powy¿szym kawa³ku kodu ? Poniewa¿ Scala jest jêzykiem obiektowo-funkcyjnym, zdefiniowaliœmy sobie metodê dwu-argumentow¹. Jako pierwszy argument przekazujemy metodê, która nie bierze ¿adnych argumentów, a w wyniku swojej pracy zwraca <font class="code">Boolean</font>. Jako drugi argument przekazujemy metodê, która nie bierze ¿adnych argumentów oraz nie zwraca nic (<font class="code">Unit</font> w Scali mo¿emy traktowaæ jako <font class="code">void</font> z Javy).
			
			<br><br>
			
			Tak zdefiniowan¹ metodê mo¿emy u¿yæ w nastêpuj¹cy sposób :

			<br>
			
			<font class="code">
var i = 0
petla( i < 10 )
{
    i += 1
    println( "i = " + i )
}
			</font>
			
			<br>
			
			entualnie :

			<br>

			<font class="code">
var i = 0
petla( { i += 1 ; i<=10 } ) println( "i = " + i )
	// kod w tym miejscu moze wydawac sie niezrozumialy, jako pierwszy argument metody
	// przekazujemy metode anonimowa, ktora po wykonaniu sie zwraca wartosc Boolean,
	// a wiec to czego oczekuje nasza metoda 'petla'
			</font>

			<br>

			Oczywiœcie powy¿szy przyk³ad jest banalny, jednak wszystko zale¿y od problemu, który zosta³ postawiony. Byæ mo¿e stworzona pêtla dzia³aj¹c w dziedzinie fizyki j¹drowej czy chemii molekularnej bêdzie dzia³aæ w zupe³nie odmienny sposób ni¿ to rozumiemy pod pojêciem 'pêtla'.
			
			<br><br>
			
			Na koniec proszê o refleksjê, co czujecie patrz¹c na nastêpuj¹cy kawa³ek kodu :

			<br>
			
			<font class="code">
var i = 0
while( i < 10 )
{
    i += 1
    println( "i = " + i )
}
			</font>

		</font>

		<br>

		<a name="S2Rozwin.22"></a><h2>5.3. Metody domyœlne</h2>

		<font class="chapter">	

			W Scali zosta³y wprowadzone dwie bardzo pomocne metody, na których opiera siê du¿a iloœæ innych konstrukcji jêzykowych.
			
			<br><br>
			
			Metody te mo¿na nazwaæ domyœlnymi (automatycznymi), gdy¿ wywo³anie ich nast¹pi automatycznie kiedy (po nazwie klasy/obiektu) bez pisania kropki czy nazwy metody u¿yjemy nawiasów pó³okr¹g³ych.
			
			<br><br>
			
			Na pocz¹tku definicja klasy oraz uzupe³nienie jej danymi, aby by³o wiadomo co robimy :
			
			<br>

			<font class="code">
class WynikiGonitw
{
    private var numerGonitwy = 0
    
    private val db = new scala.collection.mutable.Hashmap[ Int , Int ]
    	// numer_gonitwy -> wynik_gonitwy

    def dodajWynik( wynikGonitwy : Int )
    {
    	db.put( numerGonitwy , wynikGonitwy )
    	numerGonitwy += 1
    }
}

val wyniki = new WynikiGonitw
wyniki.dodajWynik( 20 )
wyniki.dodajWynik( 18 )
wyniki.dodajWynik( 21 )
			</font>
			
		</font>

		<br>

		<a name="S2Rozwin.23"></a><h2>5.3.1. apply()</h2>

		<font class="chapter">	

			Odpytanie o wynik gonitwy 2 :
			
			<br><br>
			
			<font class="code">val wynikDrugiejGonitwy = wyniki( 2 )</font>
			
			<br><br>
			
			Tak w³aœnie odwo³ujemy siê do metody <font class="code">apply()</font>. Kompilator zamieni to wywo³anie na <font class="code">wyniki.apply( 2 )</font>, jednak kod siê nie skompiluje, dopóki nie dostarczymy jej definicji :
			
			<br><br>
			
			<font class="code">def apply( numerGonitwy : Int ) = db.get( numerGonitry )</font>

		</font>

		<br>

		<a name="S2Rozwin.24"></a><h2>5.3.2. update()</h2>

		<font class="chapter">	
		
			Skoro mo¿emy zapytaæ siê o wyniki gonitwy, to powinniœmy mieæ tak¿e mo¿liwoœæ ustawienia jej wynku.
			
			<br><br>
			
			<font class="code">wyniki( 2 ) = 19</font>
			
			<br><br>
			
			Powy¿sz¹ liniê kompilator zamieni na wywo³anie <font class="code">wyniki.update( 2 , 19 )</font>. Tak jak poprzednio, kod siê nie skompiluje, dopóki sami nie dostarczymy definicji tej¿e metody :
			
			<br><br>
			
			<font class="code">def update( numerGonitwy : Int , wynikGonitwy : Int ) { db.put( numerGonitwy , wynikGonitwy ) }</font>
			
			<br><br>
			
			Dodatkowo mo¿emy u¿ywaæ tej metody nie podaj¹c pierwszego argumentu :
			
			<br><br>
			
			<font class="code">wyniki() = 20</font>
			
			<br><br>
			
			dla metody <font class="code">update()</font> :
			
			<br><br>
			
			<font class="code">def update( wynikGonitwy : Int ) { ... }</font>



			<br><br><br><br>
			
			Na koniec tej czêœci rozdzia³u pytanie: co powiecie teraz o nastêpuj¹cym kawa³ku kodu ?
			
			<br>

			<font class="code">
var tablica = new Array[ String ]( 1 )

tablica( 0 ) = "a"

val pierwszyString = tablica( 0 )
			</font>
			
			<br>
			
			Czy¿ nie wygl¹da to znajomo ? :)		
					
		</font>

		<br>

		<a name="S2Rozwin.25"></a><h2>5.4. Metody poprzednikowe/jednoargumentowe (unary)</h2>

		<font class="chapter">	

			W jednym z poprzednich dzia³ów omawialiœmy nazewnictwo metod. Istnieje jednak ma³a grupa specjalnych 4-ech metod 'poprzednikowych'. Ich nazwa postawiona jest przed instancj¹ klasy (lub obiektem) na rzecz, którego jest wywo³ywana.
			
			<br><br>
			
			Nastêpuj¹ce cztery wywo³ania :
			
			<br>
			
			<font class="code">
-2.0
!2.0
+2.0
~2.0
			</font>
			
			<br>
			
			Scala zamieni automatycznie na wywo³anie metod :
			
			<br>
			
			<font class="code">
(2.0).unary_-
(2.0).unary_!
(2.0).unary_+
(2.0).unary_~
			</font>
			
			<br>
			
			(Uwaga : patrz¹c dok³adnie w API Scali widzimy, ¿e w klasie <font class="code">Double</font> wystêpuj¹ tylko dwie metody unary : <font class="code">.unary_-</font> oraz <font class="code">.unary_+</font> , dwie kolejne zosta³y u¿yte tutaj tylko w ramach przyk³adu.)
			
			<br><br>
			
			Obrazuje siê to tym, i¿ jeœli gdziekolwiek w kodzie zawrzemy np. wywo³anie :
			
			<br>
			
			<font class="code">
val samochod = new Scamochod( Color.RED , 1999 )
!samochod
			</font>
			
			<br>
			
			to Scala nie skompiluje kodu, dopóki w definicji klasy Samochod nie dodamy metody nazwanej <font class="code">.unary_!</font> .
			
			<br>
			
			<font class="code">
class Samochod( kolor : Color , rokProdukcji : Int )
{
    def unary_! = new Samolot( kolor , rokProdukcji )
    	// skoro zaprzeczenie ('nie samochod') to z pewnoscia samolot
}
			</font>

		</font>

		<br>

		<a name="S2Rozwin.26"></a><h2>5.5. Metoda jako typ danych</h2>

		<font class="chapter">	

			Typ danych 'metoda'/funkcja jest czymœ bardzo naturalnym w Scali i czêsto stosowanym.
			
			<br><br>
			
			Na pocz¹tku przyjrzyjmy siê jak opisaæ metodê.
			
			<br><br>
			
			<font class="code">var boolean2String : (Boolean) => String = null</font>
			
			<br><br>
			
			Jak to w Scali nazwa zmiennej (<font class="code">var</font>) znajduje siê po s³ówku <font class="code">var</font>, a przed znakiem dwukropka. Nasza zmienna nosi nazwê <font class="code">boolean2String</font> i jak siê domyœlacie jest typu funkcyjnego. Po dwukropku znajduje siê miejsce na typ zmiennej. Aby by³a to metoda powinna ona posiadaæ nastêpuj¹c¹ konstrukcjê :
			
			<br><br>
			
			( <font class="code">tutaj_argument1</font> , <font class="code">tutaj_argument2</font> , <font class="code">tutaj_argument3</font> ) => <font class="code">tutaj_typ_zwracanych_danych</font>
			
			<br><br>
			
			W nawiasach pó³okr¹g³ych znajduj¹ siê typy argumentów (bez nazw zmiennych) przedzielone przecinkami. Znaczek '<font class="code">=></font>' mo¿emy t³umaczyæ jako 'zamieni¹ siê na' (przekazane agumenty w wyniku wywo³ania funkcji zamieni¹ siê na). Nastêpnie nastêpuje znak równoœci i waroœæ zmiennej - naszym przypadku <font class="code">null.</font>
			
			<br><br>
			
			Teraz przypiszmy coœ do tej zmiennej :
			
			<br>
			
			<font class="code">
boolean2String = ( b : Boolean ) =>
{
	println( "zmieniam boolean b " + b + " na string" ); "" + b
}
			</font>
			
			<br>
			
			Zosta³a stworzona anonimowa metoda. Jako argument typu <font class="code">Boolean</font> bierze zmienn¹ <font class="code">b</font>. Po znaku równoœci nastêpuje cia³o metody. W nim wypisujemy napis na konsole oraz konwertujemy zmienn¹ logiczn¹ na ³añcuch tekstowy. Jako, ¿e jest to ostatnia linia w metodzie, jest on zwracany.
			
			<br><br>
			
			Wywo³anie tej metody jest bardzo proste :
			
			<br><br>
			
			<font class="code">boolean2String( true )</font>
			
			<br><br>
			
			Co jeszcze mo¿emy przypisaæ do tej zmiennej? Otó¿ jeœli posiadalibyœmy inn¹ metodê spe³niaj¹c¹ za³o¿enia <font class="code">(Boolean)=>String</font> to mo¿na by j¹ przypisaæ.
			
			<br><br>
			
			<font class="code">def boolean2StringBis( b : Boolean ) = { "" + b }</font>
			
			<br><br>
			
			<font class="code">boolean2String = boolean2StringBis</font>
			
			<br><br>
			
			Metody zadeklarowane w klasach (za pomoc¹ <font class="code">def</font>) oraz te zadeklarowane jako zmienne <font class="code">var</font> (lub sta³e <font class="code">val</font>) traktowane s¹ na równi.
			
			<br><br>
			
			Jeœli uznamy, ¿e metoda <font class="code">boolean2String</font> ma zbyt d³ug¹ nazwê to mo¿emy j¹ skróciæ u¿ywaj¹c jej aliasu :
			
			<br><br>
			
			<font class="code">val b2s = boolean2String // od tej pory oprocz boolean2String mozemy takze uzywac b2s</font>
			
			<br><br>
			
			Tak zdefiniowan¹ metodê mo¿na tak¿e przekazaæ gdzieœ, gdzie jest spodziewana :
			
			<br>
			
			<font class="code">
def testerKonwerteraBoolean2String( konwerter : (Boolean) => String )
{
    if( !konwerter( true ).equals( "true" ) || !konwerter( false).equals( "false" ) )
    	throw new Exception( "konwerter nie pracuje poprawnie" )
}

testerKonwerteraBoolean2String( b2s )
			</font>
			
			<br>
			
			Prosze zauwa¿yæ, jak do metody <font class="code">testerKonwerteraBoolean2String</font>, przekazywana jest metoda <font class="code">b2s</font>, gdy¿ spe³nia ona warunki argumentu, jakiego siê ona (<font class="code">testerKonwerteraBoolean2String</font>) spodziewa (a spodziewa siê dowolnej metody, która jako argument pobiera <font class="code">Boolean</font> i zwraca <font class="code">String</font>).

		</font>

		<br>

		<a name="S2Rozwin.27"></a><h2>5.6. Funkcje wy¿szego poziomu (higher order functions)</h2>

		<font class="chapter">	

			Poniewa¿ Scala jest jêzykiem funkcyjnym (dla œcis³oœci oczywiœcie obiektowo-funkcyjnym) istniej¹ w niej bardzo dobrze rozwiniête metody, które aby wykonaæ swoje dzia³anie musz¹ otrzymaæ jako argument inn¹ metodê.
			
			<br><br>
			
			Poniewa¿ dla javowca trudno na pierwszy rzut zorientowaæ siê o co chodzi to rozpatrzmy nastêpuj¹cy przyk³ad.
			
			<br><br>
			
			Interfejs (a dok³adniej <font class="code">trait</font>) <font class="code">scala.Iterable</font> jest implementowany przez wiele kolekcji (m.in. przez <font class="code">scala.collection.mutable.Queue</font>). Posiada on w sobie wiele funkcji wy¿szego poziomu, a my przyjrzymy siê metodzie <font class="code">foreach()</font>. Jej definicja to :

			<br><br>
			
			<font class="code">def foreach( f : ( A ) = > Unit ) : Unit</font>

			<br><br>
			
			i oznacza, ¿e ta metoda bierze jako agument metodê (która jako swój jedyny argument bierze typ generyczny A oraz nic nie zwraca), sama zaœ nic nie zwraca.
			
			<br><br>
			
			Wywo³anie :

			<br>
			
			<font class="code">
val q = new scala.collection.mutable.Queue[ String ]
q += "a"
q += "b"

q.foreach( ( s ) => println( s ) )
			</font>
			
			<br>
			
			da na konsoli :
			
			<br>
			
			<font class="code">
a
b
			</font>
			
			<br>
			
			Przyjrzyjmy siê temu, co przekazujemy do metody <font class="code">foreach()</font>, czyli <font class="code">( s ) => println( s )</font>. Jest to anonimowa metoda, która bierze jeden argument (zmienna <font class="code">s</font>). Jako swoje cia³o wywo³uje metodê <font class="code">println()</font> i za jej pomoc¹ wypisuje na konsoli ka¿dy zgromadzony element kolejki.
			
			<br><br>
			
			Nie musimy definiowaæ naszej anonimowej metody w œrodku wywo³ania <font class="code">foreach()</font>. Mo¿emy przygotowaæ sobie metodê i zapamiêtaæ na sta³ej lub u¿yæ metody aktualnie zdefiniowanej w klasie :

			<br>
			
			<font class="code">
def foreachWypisywacz1( s : String ) { println( s ) } // metoda z klasy

val foreachWypisywacz2 = ( s : String ) => { println( s ) }

q.foreach( foreachWypisywacz1 )
q.foreach( foreachWypisywacz2 )
			</font>

			<br>
			
			Obie te funkcje robi¹ to samo i to samo wypisz¹ na konsoli.
			
			<br><br>
			
			W przypadku wypisywania na konsoli tego, co mamy w kolekcji mo¿emy zrezygnowaæ z powy¿szych funkcji i u¿yæ <font class="code">println()</font> :
			
			<br>
			
			<font class="code">
q.foreach( println )
	// metoda println() pobiera jako argument String i zwraca Unit, a wiec idealnie tutaj pasuje
			</font>
			
			<br>
			
			Jak widaæ jako argumenty metody wy¿szego poziomu mo¿emy w pe³ni definiowaæ metody 'z rêki' b¹dŸ przekazywaæ inne metody pod jednym warunkiem: musz¹ one braæ odpowiedni¹ listê argumentów oraz zwracaæ odpowiedni typ danych.
			
			<br><br>
			
			W Scali jest bardzo du¿o metod <i>higher order functions</i> i opis ich nie zmieœci³by siê tutaj. Mam jednak nadziejê, ¿e przenikaj¹c ze œwiata obiektowego Javy po pewnym czasie zaczniecie Pañstwo czerpaæ du¿o przyjemnoœci z funkcyjnego programowania.

		</font>

		<br>

		<a name="S2Rozwin.28"></a><h2>6. Pêtla FOR</h2>

		<font class="chapter">

			Specjalny rozdzia³ dla 'specjalnej' pêtli : <font class="code">for</font> . W porównaniu do Javy zosta³a ona znacznie rozwiniêta daj¹c programistom wiêcej mo¿liwoœci.

		</font>

		<br>

		<a name="S2Rozwin.29"></a><h2>6.1. Definicja</h2>

		<font class="chapter">

			Ogólny wygl¹d pêtli :
			
			<br><br>
			
			<font class="code">for( sekwencja ) yield wyra¿enie</font>
			
			<br><br>
			
			( Dla przypomnienia : s³ówko <font class="code">yield</font> umieszcza ka¿dy wynik wyra¿enia w niejawnie zadeklarowanej liœcie, która bêdzie zwrócona jako wynik pêtli :
			
			<br><br>
			
			<font class="code">val listaParzystychIntow = for( ... ) yield { if( i%2 == 0 ) i else i+1 }</font> )
			
			<br><br>
			
			W sekcji 'sekwencja' powinien znajdowaæ siê <i>generator</i> oraz mog¹ znajdowaæ siê <i>definicje</i> i <i>filtry</i> - sekcje s¹ przedzielone œrednikami. Zobaczmy jak to wygl¹da :
			
			<br>
			
			<font class="code">
val listaCzerwonychOwocow = for( owoc <- listaOwocow ; kolor = owoc.getKolor ;
			if( kolor == Color.RED ) ) yield owoc
			</font>
			
			<br>
			
			Kawa³ek <font class="code">owoc <- listaOwocow</font> jest tzw. generatorem i tworzy on nam pozycje do przejrzenia. Symbol <font class="code"><-</font> reaguje z ka¿dym typem, który ma odpowiednie metody, w tym przypadku jest to <font class="code">foreach()</font>.
			
			<br>
			
			Ka¿da pozycja <font class="code">listyOwocow</font> jest zapamiêtywana w sta³ej (<font class="code">val</font>) <font class="code">owoc</font>. Po œredniku znajduje siê sekcja definicji, gdzie zdefiniowana zosta³a sta³a <font class="code"></font>kolor. Dziêki temu w ciele pêtli mo¿emy unikn¹æ zaciemniaj¹cych kod definicji. Po kolejnym œredniku znajduje siê sekcja filtru, która ogranicza iloœæ wywo³añ cia³a tylko do owoców o kolorze czerwonym.
			
			<br>
			
			Tak zbudowana pêtla pokazuje, ¿e cia³o pêtli nie zwróci dok³adnie ka¿dego owoca z listy owoców, a jedynie te, które przesz³y przez sekcjê z filtrami.


		</font>

		<br>

		<a name="S2Rozwin.30"></a><h2>6.2. Generator</h2>

		<font class="chapter">

			Sekcja generatora daje nam kilka u¿ytecznych poleceñ.
			
			<br><br>
			
			Jeœli chcemy przejœæ przez ca³¹ kolekcjê lub tablicê :
			
			<br><br>
			
			<font class="code">for( element <- kolekcjaLubTablicaElementow ) ...</font>
			
			<br><br>
			
			Jeœli chcielibyœmy wygernerowaæ liczby od 1 do 5 w³¹cznie (inclusive) :
			
			<br><br>
			
			<font class="code">for( i <- 1 to 5 ) println( i ) // 1, 2, 3, 4, 5</font>

			<br><br>
						
			Zaœ jeœli chcielibyœmy wygernerowaæ liczby od 1 do 5 wy³¹cznie (exclusive) :
			
			<br>
			
			<font class="code">
for( i <- 1 to 5 ) println( i ) // 1, 2, 3, 4
for( index <- 0 until tablicaStringow.length ) tablicaStringow( index ) ...
			</font>
			
			<br>
			
			Mo¿na tak¿e zagnie¿d¿aæ generator w generatorze :
			
			<br><br>
			
			<font class="code">for( x <- 1 to 1024 ; y <- 1 to 768 ) ...</font>
			
			<br><br>
			
			Odpowiednikiem tego kodu jest Javowy :
			
			<br>
			
			<font class="code">
// kod Java
for( int x = 1 ; x <= 1024 ; x++ )
{
    for( int y = 1 ; y <= 768 ; y++ )
    {
        ...
    }
}
			</font>
			
			<br>
			
			Powróæmy jeszcze do przyk³adu z pocz¹tku tej sekcji :
			
			<br>
			
			<font class="code">for( element <- kolekcjaLubTablicaElementow ) ...</font>
			
			<br><br>
			
			Utorzona sta³a <font class="code">element</font> nie mo¿e byæ zmienn¹, tak wiêc nie mo¿na jej poprzedziæ s³ówkiem <font class="code">var</font> (zaœ s³ówko <font class="code">val</font> mo¿emy pomin¹æ).
			
			<br><br>
			
			Oczywiœcie, jeœli chcemy to mo¿emy okreœliæ typ dla <font class="code">element</font>, aby wszystko by³o jasne :
			
			<br>
			
			<font class="code">for( element : Owoc <- kolekcjaLubTablicaElementow ) ...</font>

		</font>

		<br>

		<a name="S2Rozwin.31"></a><h2>6.3. Definicje</h2>

		<font class="chapter">

			W tej sekcji mo¿emy tworzyæ dowolne sta³e (s³ówko <font class="code">val</font> mo¿na pomin¹æ).
			
			<br>
			
			<font class="code">
for( samochod <- listaSamochodow ; rokProdukcji = samochod.getRokProdukcji ;
	kolor = samochod.getKolor ) ...
	
	// zdefinowane zostaly stale rokProdukcji oraz kolor
			</font>
			
		</font>

		<br>

		<a name="S2Rozwin.32"></a><h2>6.4. Filtry</h2>

		<font class="chapter">
		
			Ka¿dy filtr zaczyna siê od s³ówka <font class="code">if</font>, jego zadaniem jest zwrócenie wartoœci <font class="code">Boolean</font>. W przypadku spe³nienia warunku (<font class="code">true</font>) wykonane zostanie cia³o pêtli.
			
			<br>
			
			Mo¿na umieœciæ wiele filtrów przedzielaj¹c je œrednikami i za ka¿dym razem od nowa u¿ywaj¹c s³ówka <font class="code">if</font>. S¹ one traktowane jako iloczyn logiczny (koniunkcja - aby wykona³o siê cia³o pêtli wszystkie musz¹ zwróciæ <font class="code">true</font>).
			
			<br>
			
			<font class="code">
for( samochod <- listaSamochodow ; rokProdukcji = samochod.getRokProdukcji ;
	kolor = samochod.getKolor ; if rokProdukcji >= 1999 ; if color != Color.RED ) ...
	
	// dla wszystkich samodchodów wyprodukowanych od 1999 roku innych niz czerwone
			</font>
			
			<br>
			
			Poniewa¿ zapisanie tego w jednej linii kodu staje siê ma³o czytelne to mo¿na to podzieliæ :

			<br>
			
			<font class="code">
for
(
    samochod <- listaSamochodow ;
    rokProdukcji = samochod.getRokProdukcji ;
    kolor = samochod.getKolor ;
    if rokProdukcji >= 1999 ;
    if color != Color.RED
) ...		
			</font>
		
		</font>

		<br>

		<a name="S2Rozwin.33"></a><h2>6.5. break i continue</h2>

		<font class="chapter">

			W Sclali porzucono break*  i continue poniewa¿ Ÿle siê to komponowa³o z funkcyjnoœci¹ jêzyka. O ile jeszcze mo¿na powiedzieæ jak¹ rolê ma continue w pêtli, tak trudno jest powiedzieæ co robi³oby w funkcji (w Scali mo¿emy pisaæ zarówno imperatywnie jak i funkcjonalnie).
			
			<br>
			
			Jako zamiennik break i continue twórca Scali poleca dobre u³o¿enie warunków (filtrów) w pêtli <font class="code">for</font> - dziêki temu nie mamy tak nienaturalnych konstrukcji jak kontynuuj i przerwij - wszystko wykonuje siê naturalnie. Pêtla koñczy siê, kiedy generator siê wyczerpie lub kiedy warunek (dla pêtli <font class="code">while</font>) nie zostanie spe³niony.
			
			<br><br>
			
			Inne mo¿liwe rozwi¹zania :
			
			<br>
			
			- break mo¿na zast¹piæ rozbijaj¹c kod na mniejsze metody i u¿ywajaæ <font class="code">return</font> do szybszego zakonczenia metody (metody, która 'nic nie zwraca' - a wiêc <font class="code">Unit</font>);
			
			<br>
			
			- continue mo¿na zast¹piæ upakowuj¹c kawa³ki kodu w <font class="code">if</font> .
			
			<br><br>
			
			Jeszcze inne rozwi¹zanie to napisaæ w³asny odpowiednik pêtli <font class="code">while</font> do której bêdzie przekazywany warunek (pierwszy argument) oraz funkcja z 'cia³em pêtli do wykonania' (drugi argument). Wnêtrze pêtli opakowujemy w <font class="code">try-catch</font> i wywo³uj¹c 'nasze continue' wyrzucamy wyj¹tek, który prze³apujemy. Zewnêtrze pêtli opakowujemy tak¿e w try-catch, gdzie wy³apujemy nasz wyj¹tek wyrzucany w momencie wykonania 'naszego break'. Przyk³adowa implementacja :

			<br>

			<font class="code">
object BreakLoop
{
    object Break extends RuntimeException
    object Continue extends Exception

    def break { throw Break }

    def continue { throw Continue }

    def whileTrue( condition : => Boolean ) ( block : => Unit )
    {
        try
        {
            while( condition ) try { block } catch { case Continue => }
        }
        catch
        {
            case Break =>
        }
    }

}
			</font>
			
			<br>
			
			Oraz zastosowanie :

			<br>
			
			<font class="code">
import BreakLoop._

var i = 0
whileTrue
{
    i += 1
    if (i < 3) continue
    if (i >= 5) break
}
			</font>
			
			<br>
			
			* - na stronach Scali (www.scala-lang.org) mo¿na znaleŸæ informacjê, ¿e break bêdzie wprowadzone do Scali v2.8

		</font>

		<br><hr>

		<a name="S2Rozwin.34"></a><h2>7. Case class</h2>

		<font class="chapter">

			Kr¹¿¹ pog³oski, i¿ prawdziwy javowiec bêdziê mia³ du¿e problemy ze zrozumieniem czym s¹ <i>case class</i>.
			
			<br><br>
			
			Postarajmy siê to zmieniæ !!
			
			<br><br>
			
			<font class="code">case class Owoc( nazwa : String , waga : Int )</font>
			
			<br><br>
			
			Za pomoc¹ dodatkowego s³ówka case zyskaliœmy :
			
			<br>
			
			- przes³oniêt¹ metodê <font class="code">toString()</font>, która od tej pory skupia siê na przekazanych przez nas argumentach do konstruktora daj¹c nastêpuj¹cy, czytelny output : <font class="code">Owoc(jablko,12);</font>
			
			<br>
			
			- brak koniecznoœci pisania operatora <font class="code">new</font>* podczas tworzenia instancji tej¿e klasy, wystarczy tylko <font class="code">val owoc = Owoc( "jablko" , 12 );</font>
			
			<br>
			
			- argumenty <font class="code">nazwa</font> oraz <font class="code">waga</font> s¹ sta³ymi**, dla ka¿dej z nich zostaje wygenerowany getter w postaci jej nazwy, tak wiêc mo¿na otrzymaæ wartoœæ poprzez wywo³anie <font class="code">val nazwa = owoc.nazwa;</font>
			
			<br>
			
			- porównywanie referencyjne <font class="code">==</font> zamieniane jest na porównywanie argumentów przekazanych do konstruktora, tak wiêc wykonane zostanie <font class="code">o1.name.equals( o2.name ) && o1.waga == o2.waga;</font>
			
			<br>
			
			- zalety zwi¹zane z <i>pattern maching</i> (o czym mowa bêdzie póŸniej).
			
			<br><br>
			
			Có¿ mo¿na zauwa¿yæ z powy¿szych punktów? Otó¿: <i>case class</i> jest klas¹ nastawion¹ na dane przekazane do konstruktora. W przedstawiony przyk³adzie najwa¿niejsze staj¹ siê <font class="code">nazwa</font> oraz <font class="code">waga</font> - mo¿na powiedzieæ, i¿ 'graj¹ pierwsze skrzypce'.
			
			<br><br>
			
			Poza tym <i>case class</i> nie ró¿ni¹ siê niczym od najnormalniejszych klas. Mog¹ dziedziczyæ, mog¹ byæ dziedziczone, mog¹ posiadac pola oraz metody.
			
			<br><br><br>
			
			* - jak to jest realizowane ? Otó¿ automatycznie jest generowany companion object w postaci singletonu :
			
			<br>
			
			<font class="code">
object Owoc
{
    def apply( nazwa : String , waga : Int ) = new Owoc( nazwa , waga )
}
			</font>
			
			<br>
			
			Wywo³anie <font class="code">Owoc( "jablko" , 12 )</font> powoduje wywo³anie jego metody <font class="code">apply()</font>, która bierze argumenty takie same, jak konstruktor i zwraca instancje nowego obiektu.
			
			<br><br><br>
			
			** - dodaj¹c s³ówko <font class="code">var</font> przed ka¿d¹ z nich zamieni je na zmienne i bêdzie mo¿na nadawaæ im wartoœæ <font class="code">poprzez owoc.nazwa = "truskawka"</font>, chc¹c uczyniæ je prywatnymi mo¿na dodaæ modyfikator <font class="code">private</font> : <font class="code">case class Owoc( private var nazwa : String , waga : Int )</font> - jednak ukrywanie zmiennych nie do koñca le¿y w naturze <i>case class</i>

		</font>

		<br><hr>

		<a name="S2Rozwin.35"></a><h2>8. Porównywanie wzorców (pattern matching)</h2>

		<font class="chapter">

			Istnieje w Scali pewna konstrukcja jêzykowa, któr¹ najproœciej porównaæ do <font class="code">switch</font> (z Javy). Oczywiœcie nie trzeba dodawaæ, ¿e ta konstrukcja posiada du¿o wiêksze mo¿liwoœci :).
			
			<br><br>
			
			Po pewnym czasie od jej poznania, mo¿e znacznie zmniejszyæ siê iloœæ u¿ywanych instrukcji <font class="code">if</font>. Dodatkowo niesie ze sob¹ wa¿ne dla poprawnoœci i bezpieczeñstwa kodu praktyki (klasy <i>sealed</i>, jak <font class="code">Option[T]</font> lub <font class="code">Either[L,R]</font>).
			
			<br><br>
			
			Postaæ ogólna to :
			
			<br><br>
			
			selector <font class="code">match</font> { alternatywy }
			
			<br><br>
			
			Selektor to nazwa zmiennej lub sta³ej, któr¹ chcemy rozpatrzyæ.
			
			<br><br>
			
			Alternatywa ma postaæ :
			
			<br><br>
			
			<font class="code">case warunek => { blok_kodu }</font>
			
			<br><br>
			
			Warunki dla przejrzystoœci opisano poni¿ej i mo¿na je ze sob¹ mieszaæ.

		</font>

		<a name="S2Rozwin.36"></a><h2>8.1. Po wartoœciach</h2>

		<font class="chapter">

			<font class="code">
zmiennaLubStala match
{
    case "Ala" => println( "opcja 1 - string 'Ala'" )
    case 5 => println( "opcja 2 - integer 5" )
    case true => println( "opcja 3 - boolean true" )
    case _ => println( "opcja 4 - cokolwiek niesklasyfikowanego wyzej" )   
}
			</font>
			
			<br>
			
			W przedstawiony powy¿ej kawa³ku kodu dokonujemy rozpatrywania po wpisanych na sta³e wartoœciach jak <font class="code">String</font>, <font class="code">Integer</font> i <font class="code">Boolean</font>.
			
			<br><br>
			
			Ostatnia linia zawiera znaczek '<font class="code">_</font>' oznaczaj¹cy w tym wypadku 'dowoln¹ inn¹ wartoœæ nie z³apan¹ powy¿ej' (odpowiednik sekcji <font class="code">default</font> z Javowego switch). Mo¿e to byæ na przyk³ad <font class="code">String</font>, o ile nie bêdzie mia³ wartoœci "Ala". T¹ ostatni¹ liniê mo¿na zamieniæ na :
			
			<br><br>
			
			<font class="code">case wartoscDowolna => println( "opcja 4 - " + wartoscDowolna)</font>
			
			<br><br>
			
			Teraz '<font class="code">_</font>' zamieniliœmy na <font class="code">wartoscDowolna</font> i pe³ni ona t¹ s¹m¹ rolê co powy¿ej, gdy¿ nie ogranicza ona wyniku, co do wartoœci lub typu - jednym s³owem 'z³apie wszystko'. Co j¹  odró¿nia od '<font class="code">_</font>' to to, ¿e mo¿emy jej u¿yæ w ciele alteratywy (w tym wypadku w <font class="code">println()</font>).

		</font>

		<a name="S2Rozwin.37"></a><h2>8.2. Po typach danych</h2>

		<font class="chapter">

			<font class="code">
zmiennaLubStala match
{
    case s : String => println( "opcja 1 - " + s )
    case i : Int => println( "opcja 2 - " + i )
    case b : Boolean => println( "opcja 3 - " + b )
    case _ => println( "opcja 4 - cokolwiek niesklasyfikowanego wyzej" )   
}
			</font>

			<br>

			W tym przyk³adzie porównujemy po typach danych, jednoczeœnie od razu zapamiêtuj¹c wartoœæ na sta³ej.

		</font>

		<a name="S2Rozwin.38"></a><h2>8.3. Po case class</h2>

		<font class="chapter">

			Jedn¹ z najciekawszych ról case class jest mo¿liwoœæ rozpatrywania ich w sekcji match otrzymuj¹c od razu dostêp do wartoœci z jakimi zosta³y stworzone.
			
			<br>
			
			<font class="code">
case class OdpowiedzZSerwera( response : String )
case class ZaptanieDoSerwera( request : String )

val stalaDoRozpatrzenia : Any = new OdpowiedzZSerwera( "hello from server" )

stalaDoRozpatrzenia match
{
    case OdpowiedzZSerwera( odpowiedz ) => println( "odpowiedz z serwera : " + odpowiedz )
    case ZaptanieDoSerwera( zapytanie ) => println( "zapytanie do serwera : " + zapytanie )
}
			</font>
			
			<br>
			
			Powy¿szy kod przestawia jak zosta³y zdewiniowane dwie case class: jedna stworzona do wys³ania zapytania do serwera i druga z jego odpowiedzi¹. Nastêpnie tworzmy instancjê jednej z nich i rozpatrujemy w sekcji <font class="code">match</font>. Dziêki nacechowaniu case class na dane z konstruktora mo¿emy je od razu popraæ.
			
			<br><br>
			
			Mo¿emy tak¿e ³atwo przemieniæ powy¿szy przyk³ad na porównywanie po typach danych :
			
			<br>
			
			<font class="code">
stalaDoRozpatrzenia match
{
    case o : OdpowiedzZSerwera => println( "odpowiedz z serwera : " + o.response )
    case z : ZaptanieDoSerwera => println( "zapytanie do serwera : " + z.request )
}
			</font>

		</font>

		<a name="S2Rozwin.39"></a><h2>8.4. Po tuple</h2>

		<font class="code">
zmiennaLubStala match
{
    case ( a , b , c ) => println( "tuple 3, a = " + a + ", b = " b + ", c = " + c )
    case _ => println( "cala reszta" )
}		
		</font>
		
		<a name="S2Rozwin.40"></a><h2>8.5. Po sekwencjach</h2>

		<font class="chapter">
		
			Mo¿na tak¿e porównywaæ sekwencje (jak lista czy tablica) okreœlaj¹c czego poszukujemy i na którym miejscu :
			
			<br>
			
			<font class="code">
zmiennaLubStala match
{
    case List( 0 , _ , _ ) =>
    {
    	println("znaleziono liste, ktora na pierwszym miejscu ma integer 0 i posiada")
    	println("tylko trzy elementy")
    }
    
    case _ =>
}
			</font>
			
			<br>
			
			Mo¿na tak¿e u¿yæ parametru '<font class="code">_*</font>' dla okreœlenia dowolnej iloœci elementów sekwencji (w³¹cznie z ich brakiem, a wiêc zerowym rozmiarem).
			
			<br>
			
			<font class="code">
zmiennaLubStala match
{
    case List( 0 , _* ) =>
    {
    	println("znaleziono liste, ktora na pierwszym miejscu ma integer 0, a nastepnie")
    	println("posiada dowolna ilosc elementow")
    }
    	
    case _ =>
}
			</font>

		</font>
		
		</font>
		
		<a name="S2Rozwin.41"></a><h2>8.6. Ograniczanie alternatyw</h2>

		<font class="chapter">
		
			Dodatkowo mo¿emy u¿yæ if</font> do ograniczania danej alternatywy :

			<br><br>

			<font class="code">
zmiennaLubStala match
{
    case i : Int if i > 5 => ...
    case Punkt( x , y ) if x > y => ...
    case _ => ...
}
			</font>
		
		</font>
		
		</font>
		
		<a name="S2Rozwin.42"></a><h2>8.7. Wy³uskanie danych poprzez przypisanie sta³ej</h2>

		<font class="chapter">
		
			Jeœli jesteœmy zainteresowani zainicjowaniem sta³ej z którejœ z wewnêtrznych mo¿liwoœci alternatywy to mo¿emy uczyniæ to za pomoc¹ znaczka <font class="code">@</font> :
			
			<br>
			
			<font class="code">
val lista : Any = List( 0 , 1 , 2 , 3 )
            
lista match
{
    case List( 0 , drugi @ _ , trzeci @ _* ) =>
    {
    	println( "drugi = " + drugi + ", trzeci = " + trzeci )
    }
}
			</font>
			
			<br>
			
			Powy¿ej do sta³ych <font class="code">drugi</font> oraz <font class="code">trzeci</font> prze³apujemy wartoœci drugiego i trzeciego elementu sekwencji.
			
			<br><br>
			
			Wykonuj¹c powy¿szy kod uzyskamy :
			
			<br><br>
			
			<font class="code">drugi = 1, trzeci = List(2, 3)</font>
			
			<br><br>
			
			Oczywiœcie ten sposób (<font class="code">@</font>) mo¿emy stosowaæ w dowolnym przypadku :
			
			<br>
			
			<font class="code">
case class Punkt( x : Int , y : Int )
        
val stala : Any  = Punkt( 20 , 10 )
            
stala match
{
    case i : Int if i > 5 =>
    
    case Punkt( x , yBis @ y ) if x > y =>
    {
    	println( "x = " + x + ", y = " + y + ", yBis = " + yBis )
    }
    
    case _ =>
}   
			</font>
			
			<br>
			
			da :
			
			<br><br>
			
			<font class="code">x = 20, y = 10, yBis = 10</font>
			
			<br><br>
			
			(Ponownie prze³apanie <font class="code">y</font> - w postaci <font class="code">yBis</font> - mo¿e nie jest tutaj konieczne. Jednak dziêki temu wiemy, i¿ jeœli mielibyœmy alternatywê rozpatruj¹c¹ <i>case class</i>,  zaœ jej konstruktor bra³by kolejn¹ <i>case class</i>, a ta znów ponown¹, zaœ ta mia³aby wiele argumentów to mo¿emy w ten sposób wy³uskaæ sobie dowoln¹ dan¹.)		
					
		</font>
		
		<a name="S2Rozwin.43"></a><h2>8.8. Niedopasowany wzorzec</h2>

		<font class="chapter">
		
			W momencie kiedy ¿adna z alternatyw nie bêdzie pasowaæ blok <font class="code">match</font> wyrzuci wyj¹tek <font class="code">scala.MatchError</font>.
			
			<br><br>
			
			Czasami jest to bardzo wa¿ne aby on zainstnia³ i powiedzia³ nam dok³adnie, ¿e ¿adna z alternatyw nie pasowa³a. Jeœl jednak chcemy unikn¹æ wyj¹tku mo¿na zawsze na koñcu dodaæ alternatywê, która prze³apie wszystko :
			
			<br>
			
			<font class="code">
a match
{
    case 20 => println( "alternatywa 1" )
    case "Ala" => println( "alternatywa 2" )
    case _ => println( "alternatywa 3 - przelapujaca wszystko co nie zostalo dopasowane" )
}
			</font>
		
		</font>
		
		<a name="S2Rozwin.44"></a><h2>8.9. Extractors</h2>

		<font class="chapter">
		
			Ekstraktory pomagaj¹ budowaæ jeszcze bardziej zaawansowane alternatywy. Dziêki nim jesteœmy w stanie u¿ywaæ/rozpatrywaæ wszystkie zaawansowane przypadki z postawionego przed nami problemu w sekcji <font class="code">match</font>.
			
			<br>
			
			<font class="code">
object Email
{
    def unapply( s : String ) : Option[ ( String , String ) ] =
    {
        val tablica = s.split( "@" )

        if( tablica.length == 2 )
            Some( ( tablica(0) , tablica(1) ) )
        else
            None
    }
}
			</font>
			
			<br>
			
			Ekstraktor to obiekt posiadaj¹cy metodê <font class="code">unapply()</font>, która zwraca <font class="code">Option[T]</font>. Jest on sparametryzowany przez <i>Tuple</i> (dok³adniej to <font class="code">Tuple2[ String , String]</font>). Zwraca <font class="code">Some( ( nazwaUzytkownika , domena ) )</font>, jeœli przekazany <font class="code">String</font> bêdzie spe³nia³ za³o¿enia (bêdzie adresem email), oraz <font class="code">None</font> w przeciwnym przypadku.
			
			<br><br>
			
			Jak rozpatrzyæ ten ekstraktor ?
			
			<br>
			
			<font class="code">
val adres : String = "as@pjwstk.edu.pl"

adres match
{
    case Email( uzytkownik , domena ) =>
    {
    	println( "to jest adres email, uzytkownik to " + uzytkownik + ", domena to " + domena )
    }
    
    case _ => println( "to nie jest adres email" )
}
			</font>
		
		</font>
		
		<a name="S2Rozwin.45"></a><h2>8.10. Sealed class</h2>

		<font class="chapter">
		
			W zasadzie ten dzia³ powinien znaleŸæ siê w opisuj¹cym case classy, jednak poniewa¿ u¿ywany jest tylko w <i>pattern maching</i> to zostanie opisany tutaj.
			
			<br><br>
			
			Czasem istnieje potrzeba wymuszenia na sprawdzaj¹cym (<font class="code">match</font>), aby rozpatrzy³ wszystkie mo¿liwoœci, a nie tylko te, które sobie upatrzy³ (lub których siê spodziewa).
			
			<br><br>
			
			Z pomoc¹ przychodzi tutaj s³ówko <font class="code">sealed</font>. Wszystkie klasy <i>case class</i>, które bêd¹ dziedziczyæ z klasy oznaczonej <font class="code">sealed</font> zostan¹ automatycznie uznane za zbiór niezbêdny do rozpatrzenia.
			
			<br><br>
			
			Zobaczmy to na przyk³adzie :
			
			<br>
			
			<font class="code">
sealed class Owoc
       
case class Jablko( waga : Int ) extends Owoc
case class Pomarancz( waga : Int ) extends Owoc

val j = Jablko( 2 )
val p = Pomarancz( 1 )
			</font>
			
			<br>
			
			I <font class="code">Jablko</font> i <font class="code">Pomarancz</font> dziedzicz¹ z klasy <font class="code">Owoc</font> oznaczonej jako <font class="code">sealed</font>. Rozpatruj¹c teraz :
			
			<br>
			
			<font class="code">
val owoc : Owoc = p

owoc match
{
    case Jablko( waga ) => ...
}
			</font>
			
			<br>
			
			jeœli zapomnimy rozpatrzyæ wszystkie mo¿liwe opcje (w tym wypadku zapomnieliœmy dodaæ <font class="code">case Pomarancz( waga ) => ...</font> ) to kompilator upomni nas stosownym ostrze¿eniem.
			
			<br><br>
			
			Ta bardzo przydatna praktyka pozwala pisaæ jeszcze lepsze programy. Mamy pewnoœæ, ¿e w przysz³oœci, kiedy pula mo¿liwych opcji siê nam zwiêkszy to kompilator podpowie, gdzie trzeba powprowadzaæ nowe rozpatrzenia.		
					
		</font>
		
		<a name="S2Rozwin.46"></a><h2>8.11. Option[ T ]</h2>

		<font class="chapter">
		
			Idealn¹ sytuacj¹, kiedy chcemy zwróciæ z jakiejœ metody coœ-albo-nic jest wykorzystanie klasy <font class="code">Some[ T ]</font>. Aby zapewniæ sytuacje 'nic' jest jeszcze obiekt <font class="code">None</font>. I <font class="code">case class Some[ T ]</font> i <font class="code">case object None</font> dziedzicz¹ z <font class="code">sealed class Option[ T ]</font> dziêki czemu rozpatruj¹c <font class="code">Some</font> (i chc¹c uzyskaæ to co on przechowuje w sobie) musimy tak¿e rozpatrzyæ <font class="code">None</font>.
			
			<br>
			
			<font class="code">
def pobierzSamochod( typ : Int ) : Some[ Samochod ] =
{
    if( typ < 0 )
        None
    else
    if( typ == 1 )
        Some( new Maluch() )
    else
        Some( new Polonez() )
}
			</font>
			
			<br>
			
			W powy¿szej metodzie w zale¿noœci od przekazanego typu zwracamy instancjê jakiegoœ samochodu (<font class="code">Maluch</font> lub <font class="code">Polonez</font>) opakowane w klasê <font class="code">Some</font>. Jednak, jeœli jest to niepoprawny typ, to zwracamy <font class="code">None</font>. Nastêpnie mo¿emy rozpatrzyæ :
			
			<br>
			
			<font class="code">
val samochod = pobierzSamochod( 1 )

samochod match
{
    case Some( maluch ) => println( maluch )
    	// jako ze Some jest to case class tak wiec mozemy w ten sposob uzykac obiekt z
    	// jakim zostala utworzona
    	
    case Some( polonez ) => println( polonez )
    
    case None => println( "zly typ samochodu" )
}
			</font>
			
			<br>
			
			Jeœli sprawdzaj¹c <font class="code">Some</font> pominiemy <font class="code">None</font>, lub jeœli tylko sprawdzimy <font class="code">None</font>, ale bez Some to kompilator na pewno o tym przypomni.
			
			<br><br>
			
			<font class="code">Option[ T ]</font> jest bardzo czêsto wykorzystywany w kolekcjach Scali - wszêdzie tam gdzie w Javie spodziewalibyœmy siê otrzymac cos-albo-null. W Scali (dziêki <font class="code">Option[T]</font>) praktycznie zosta³ wyeliminowany problem niezainicjowanych obiektów (<font class="code">null</font>) i <font class="code">NullPointerException</font>.
			
			<br><br>
			
			Wykorzystywanie <font class="code">Option</font> w mapach :
			
			<br>
			
			<font class="code">
val valueOption = map.get( key )

valueOption match
{
    case Some( value ) => ...
    case None => ...
}
			</font>
			
			<br>
			
			lub proœciej :
			
			<br>
			
			<font class="code">
map.get( key ) match
{
    case Some( value ) => ...
    case None => ...
}
			</font>
					
		</font>
		
		<a name="S2Rozwin.47"></a><h2>8.12. Either[ L , R ]</h2>

		<font class="chapter">
		
			Uzupe³nieniem <font class="code">Option[ T ]</font> jest <font class="code">Either[L,R]</font>, które pozwala na zwrot dwóch wykluczaj¹cych siê wartoœci : albo lewej albo prawej (mo¿na to definowaæ jako dobra/z³a wartoœæ, ciep³o/zimno, pies/kot, ...). W odró¿eniniu do <font class="code">Option[T]</font> mo¿emy zwórciæ coœ w sytuacji <font class="code">None</font> i zazwyczaj jest to <font class="code">Left</font> (dla powiedzenia lewy w sensie z³y, niepoprawny, nieoczekiwany).
			
			<br>
			
			<font class="code">
def pobierzSamochodZBazyDanych( id : Int ) : Either[ Exception , Samochod ] =
{
    try
    {
        ...
        Right( samochod )
    }
    catch
    {
        case e : Exception => Left( e )
    }
}
			</font>
			
			<br>
			
			I wywo³anie powy¿szej metody :
			
			<br>
			
			<font class="code">
pobierzSamochodZBazyDanych( 10 ) match
{
    case Left( exception ) => println( "blad podczas pobierania z bazdy danych, " + exception )
    case Right( samochod ) => println( "pobrany samochod to " + samochod )
}		
			</font>
			
		</font>
		
		<br><hr>
		
		<a name="S2Rozwin.48"></a><h2>9. Ukryte konwersje (implicit conversions)</h2>

		<font class="chapter">
				
			Czêsto ¿a³ujemy z powodu tego, i¿ ktoœ uczyni³ swoj¹ klasê jako <font class="code">final</font> - przez co zablokowa³ mo¿liwoœæ dziedziczenia z niej. Jak wiemy œwiat siê rozwija, pojawiaj¹ siê nowe mo¿liwoœci oraz nowe potrzeby. Klasa, kiedyœ dobrze napisana i prawid³owo zabezpieczona jako <font class="code">final</font>, po kilku latach staje siê niedoœæ dobrze odpowiadaæ panuj¹cym realiom. Dodatkowo jest jeszcze gorzej, jeœli w takiej klasie odkryje siê b³êdy.
			
			<br><br>
			
			U¿ywaj¹c Scali okazuje siê, ¿e nie do koñca wszystko jest stracone.				
				
		</font>
		
		<a name="S2Rozwin.49"></a><h2>9.1. Jako metody</h2>

		<a name="S2Rozwin.50"></a><h2>9.1.1. U¿ywanie</h2>
		
		<font class="chapter">
		
			Przyjrzyjmy siê nastêpuj¹cej linii :
			
			<br><br>
			
			<font class="code">val lista = "Czesc".toList</font>
			
			<br><br>
			
			Wywo³ujemy metodê <font class="code">toList()</font> na obiekcie klasy <font class="code">String</font>. Jednak sama klasa <font class="code">String</font> nie posiada takowej metody, a dodatkowo uniemo¿liwia nam dziedziczenie gdy¿ jest <font class="code">final</font>.
			
			<br><br>
			
			Technika ukrytych konwersji przychodzi nam z pomoc¹. Szukaj¹c odnajdujemy, i¿ dla powy¿szej linii wykonana jest konwersja umieszczona w obiekcie <font class="code">scala.Prefef</font> o nazwie <font class="code">stringWrapper()</font> :
			
			<br><br>
			
			<font class="code">implicit def stringWrapper( x : String ) = new runtime.RichString( x )</font>
			
			<br><br>
			
			Jak widaæ ukryta konwersja ma postaæ metody oznaczonej dodatkowym s³ówkiem <font class="code">implicit</font>. To dziêki niemu kompilator dostaje, i¿ jeœli zajdzie potrzeba zamiany typu A na typ B to mo¿e skorzystaæ z tej metody.
			
			<br><br>
			
			Przeanalizujmy powy¿szy przyk³ad.
			
			<br><br>
			
			W Javie w takim momencie kompilator wyrzuci³by komunikat, i¿ klasa String nie posiada takowej metody - i by³o by 'po sprawie'. Jednak Scala daje nam jeszcze jedn¹ szansê. W momencie, kiedy mia³by pojawiæ sie takowy komunikat o b³êdzie, przeszukuje on wszystkie obecnie dostepne metody <font class="code">implicit</font>, sprawdzaj¹c czy konwersja oferowana przez któr¹œ z nich nie zaspokaja tego ¿¹dania. W tym wypadku kompilator sprawdza po której zamianie Stringa-na-inny-obiekt bêdzie mo¿liwe wykonanie metody <font class="code">toList()</font>. Tak samo jak podczas wywo³ywania metod czy nazewnictwa klas - jeœli sytuacja bêdzie niederministyczna (dwie konwersje pozwol¹ uruchomic metodê <font class="code">toList()</font>) kompilator odst¹pi od konwersji i nas o tym zawiadomi.
			
			<br><br>
			
			Sk¹d kompilator bierze metody <font class="code">implicit</font> ? Otó¿ mo¿emy myœleæ o nich w kategoriach normalnych metod. Tak jak ka¿e inne u¿ywane przez nas metody i ta musi siê znajdowaæ w zasiêgu (<i>scope</i>). Mo¿na tak¿e uznaæ, ¿e jest to technika wyrêczaj¹ca nas z napisania nastêpuj¹cej linii :
			
			<br><br>
			
			<font class="code">stringWrapper( "Czesc" ).toList</font>
			
			<br><br>
			
			Techniki tej - jak ka¿dej innej - trzeba u¿ywaæ rozs¹dnie!
			
			<br><br>
			
			Skoñczmy analizowaæ powy¿szy przyk³ad. Wszystkie metody z <font class="code">scala.Predef</font> s¹ zaimportowane do ka¿dego pliku automatycznie. Znajduje siê tam szereg u¿ytecznych metod, a tak¿e i metody <font class="code">implicit</font>. Wœród nich <font class="code">stringWrapper()</font>, która zamieni <font class="code">String</font> na <font class="code">RichString</font>. ( Nie wg³êbiaj¹c siê w <font class="code">RichString</font> wystarczy nam informacja, ¿e w jej œrodku znajduje siê wywo³ana metoda <font class="code">toList()</font>. )
					
		</font>
		
		<a name="S2Rozwin.51"></a><h2>9.1.2. Zastosowania</h2>
		
		<font class="chapter">
		
			<i>Implicit conversions</i> mo¿e nam pomóc podczas operowania na <font class="code">javax.Swing</font> (nie <font class="code">scala.swing</font>).
			
			<br><br>
			
			Przyjemne i proste wywo³anie :
			
			<br><br>
			
			<font class="code">jButton.addActionListener( (e:ActionEvent) => ... )</font>
			
			<br><br>
			
			mo¿emy zrealizowaæ z pomoc¹ konwersji :
			
			<br>
			
			<font class="code">
implicit def actionPerformedWrapper( func : (ActionEvent) => Unit ) =
	new ActionListener { def actionPerformed( e : ActionEvent ) = func( e ) }
			</font>
			
			<br>
			
			Co siê tutaj dzieje? Otó¿ nic skomplikowanego ! Do metody <font class="code">addActionListener()</font> przekazujemy anonimow¹ funkcjê, która jako swój parametr pobiera <font class="code">ActionEvent</font> oraz nic nie zwraca (<font class="code">Unit</font>). Normalnie to doprowadzi³oby do b³êdu, jednak kompilator rozgl¹da siê za tak¹ konwersj¹, która pobiera³aby tak¹ w³aœnie metodê jako argument i zwróci³a porz¹dany <font class="code">ActionListener</font>.
			
			<br>
			
			W metodzie <font class="code">implicit</font> pobieramy ca³¹ przekazan¹ wczeœniej funkcjê do <font class="code">addActionListener()</font> i zapamiêtujemy j¹ na zmiennej <font class="code">func</font>. Nastêpnie tworzymy <font class="code">ActionListener</font>, w którego metodzie <font class="code">actionPerformed()</font> wywo³ujemy <font class="code">func</font>.
		
		</font>
		
		<a name="S2Rozwin.52"></a><h2>9.2. Jako zmienne/sta³e</h2>
		
		<font class="chapter">
		
			Za³ó¿my, ¿e mamy nastêpuj¹c¹ metodê pobieraj¹c¹ dwie listy argumentów :
			
			<br>
			
			<font class="code">
def metoda( argument1 : String )( implicit argument2 : String )
{
    println( "argument1 = " + argument1 + ", argument2 = " + argument2 )
}
			</font>
			
			<br>
			
			Jak widzimy drugi argument oznaczony jest s³ówkiem <font class="code">implicit</font>, co oznacza, ¿e w przypadku jeœli go nie u¿yjemy to zostanie dopasowany jakiœ z dostêpnych. Zdefiniujmy go :
			
			<br><br>
			
			<font class="code">implicit val drugiArgument = "drugi"</font>
			
			<br><br>
			
			Sta³a ta pe³ni tak¹ sam¹ rolê jak metody oznaczone jako <font class="code">implicit</font> - a podpowiadamy kompilatorowi, i¿ mo¿e jej u¿yæ w pewnych warunkach.
			
			<br><br>
			
			Od tej pory, jeœli czasami 'zapomnimy' o drugim argumencie, a w naszym zasiêgu bêdzie siê znajdowa³a odpowiednia zmienna (lub sta³a) oznaczona <font class="code">implicit</font> wywo³anie :
			
			<br><br>
			
			<font class="code">metoda( "pierwszy" )</font>
			
			<br><br>
			
			da :
			
			<br><br>
			
			<font class="code">argument1 = pierwszy, argument2 = drugi</font>
		
			<br><br>
		
			W przypadku jeœli w naszym zasiêgu (scope) nie by³oby odpowiedniej zmiennej/sta³ej to kompilator zg³osi b³¹d - w koñcu nie mo¿na wywo³ywaæ metody dwu-argumentowej zapominaj¹c o jednym z nich. 
		
		</font>
		
		<br><hr>
		
		<a name="S2Rozwin.53"></a><h2>10. Zakoñczenie </h2>
		
		<font class="chapter">
		
			To ju¿ koniec poznawania podstaw Scali. Dziêki zdobytej wiedzy sk³adnia, informacje przedstawione w nastêpnym rozdziale, nie powinny stwarzaæ problemu.
		
		</font>
		
		<a name="S2Rozwin.54"></a><h2>10.1. Scala 2.8</h2>
		
		<font class="chapter">
		
			Obecnie (styczeñ 2010) trwaj¹ prace nad wersj¹ 2.8. Zawieraæ ona bêdzie szereg kolejnych, ciekawych technik, poprawki (choæ te wydawane s¹ dosyæ czêsto) oraz udoskonalenia (jak np. przyspieszenie procesu kompilacji).
		
		</font>
		
		<a name="S2Rozwin.55"></a><h2>10.1.1. Nazwy dla argumentów metod - named parameters</h2>
		
		<font class="chapter">
		
			W przypadku metod wieloargumentowych, zw³aszcza w momencie kiedy wiêkszoœæ z nich jest tego samego typu, ³atwo o pomy³kê.
			
			<br><br>
			
			Z pomoc¹ przychodz¹ <i>named parameters</i>, czyli nazwy dla parametrów.
			
			<br><br>
			
			Na przyk³ad, dla metody :
			
			<br>
			
			<font class="code">
def polaczZBazaDanych( ip : String , port : Int , databaseName : String ,
	userName : String , userPassword : String , additionalConnectParameters : String )
			</font>
			
			<br>
			
			zmêczony programista, goniony przez terminy (byæ mo¿e pracuj¹cy po nocy) mo¿e pope³niæ b³¹d i pomyliæ siê w przekazywanych stringowych argumentach. Oczywiœcie kompilator nie wy³apie tego typu b³êdu wiêc wszystko wydaje siê byæ w porz¹dku.
			
			<br><br>
			
			U¿ywanie named parameters w Scali 2.8 bêdzie bardzo ³atwe. Dla zaprezentowanej powy¿ej metody bêdzie to :
			
			<br>
			
			<font class="code">
val johnsPassword = "mySecretPassword"
val databasePort = 15123
polaczZBazaDanych( databaseName = "test" , userName = "john" , userPassword = johnsPassword ,
	ip = "127.0.0.1" , port = databasePort , additionalConnectParameters = "" )
			</font>
			
			<br>
			
			Proszê zauwa¿yæ, ze umiejscowienie przekazywanych przez nas argumentów nie gra roli. Najwa¿niejsze s¹ nazwy, które kompilator odpowiednio przypisze.

		</font>
		
		<a name="S2Rozwin.56"></a><h2>10.1.2. Argumenty domyœlne</h2>
		
		<font class="chapter">
		
			Kolejn¹ nowoœci¹ w odró¿nieniu do obecnej wersji Scali (v 2.7) bêd¹ domyœlne wartoœci dla argumentów (nie) przekazanych metodzie.
			
			<br><br>
			
			Dla metody :
			
			<br>
			
			<font class="code">
def polaczZBazaDanych( ip : String = "127.0.0.1" , port : Int = 115123 , databaseName : String ,
	userName : String , userPassword : String , additionalConnectParameters : String = "" )
			</font>
			
			<br>
			
			jej wywo³ania mog¹ wygl¹daæ nastêpuj¹co :
			
			<br>
			
			<font class="code">
polaczZBazaDanych( "192.168.1.1" , , "test" , "john" , "mySecretPassword" )
// pominiêto port oraz additionalConnectParameters gdy¿ bêd¹ one mia³y domyœln¹ wartoœæ
// przedefiniowano ip, z wartosci domyslnej do nowej

polaczZBazaDanych( userName = "john" , userPassword = "mySecretPassword" , databaseName = "test" )
// uzywajac named parameters w ogole nie uzywamy parametrow posiadajacych wartosci domyslne
			</font>

		</font>
		
		<a name="S2Rozwin.57"></a><h2>10.1.3. Pozosta³e zmiany i nowoœci</h2>
		
		<font class="chapter">
		
			Pozosta³e zmiany i nowoœci których mo¿emy spodziewaæ siê w Scali 2.8 :
			
			<br>
			
			- przedefiniowana struktura kolekcji ,aby by³y one bardziej regularne i przewidywalne, s¹ to zmiany typowo organizacyjne, a wiêc wiêkszoœæ kodu Ÿród³owego nie zostanie zmieniona;
			
			<br>
			
			- package objects - do dzisiaj to coœ definiowanego jako pogrupowane pliki w pewne logiczne 'paczki', jednak Twórcy Scali myœl¹ aby uwolniæ package od plików i wprowadzaj¹c s³ówko kluczowe package na równi z class lub object pozwoliæ nam je definiowaæ;
			
			<br>
			
			- nowoœci i usprawnienia w Scala Swing;
			
			<br>
			
			- interpreter REPL (w którym mo¿na testowaæ i pisaæ programy 'z rêki') zostanie odœwie¿ona i uzupe³niona o nowe mo¿liwoœci;
			
			<br>
			
			- kontynuacje - dodane jako modu³ rozszerzeñ do kompilatora, opisane szerzej w innym dziale.
			
			<br><br>
			
			Kierunek na przysz³oœæ : uczyniæ Scalê ca³kowicie zrównoleglon¹ i konkurencyjn¹. Dzisiejsza bol¹czka programistów ma byæ zmniejszona dziêki temu, ¿e to sama Scala (jej biblioteka standardowa) w miarê dostêpnych procesorów/rdzeni bêdzie przeprowadzaæ operacje równolegle, a zatem wykorzystywaæ ca³¹ moc drzemi¹c¹ w dostêpnym sprzêcie.
		
		</font>
		
		<a name="S2Rozwin.58"></a><h2>10.2. Biblioteki dodatkowe</h2>
		
		<font class="chapter">
		
			Grupy mi³oœników Scali zaczê³y tworzyæ biblioteki dodatkowe, uzupe³niaj¹ce standartowe API o wiele przydatnych funkcjonalnoœci.
			
			<br><br>
			
			G³ównie s¹ to :
			
			<br>
			
			- Lift Web Framework http://liftweb.net/ - dzia³aj¹cy w kontenerze Java pozwala pisaæ w Scali aplikacje sieciowe wielow¹tkowe, du¿y projekt, tworzy go wiele znakomitych postaci;
			
			<br>
			
			- The Scala Community Library (Scalax) http://scalax.scalaforge.org/ - biblioteka ogólnego przeznaczenia uzupe³niaj¹ca biblioteke standartowa Scali;
			
			<br>
			
			- Scalaz (Scar-lah-zed) http://code.google.com/p/scalaz/ - biblioteka dostarczaj¹ca funcjonalnoœci nie dostêpne obecnie w Scali;
			
			<br>
			
			- Scala/xml http://lamp.epfl.ch/~emir/projects/ - dodatkowe narzêdzia dla XMLa;
			
			<br>
			
			- Scales http://code.google.com/p/scala-scales/ - eksperymentalny DSL pozwalaj¹cy pisaæ strony WWW;
			
			<br>
			
			- Specs http://code.google.com/p/specs/ - pozwala na tworzenie BDD (Behavior-Driven-Design), toworzony jako alternatywa dla JUnit.
			
			<br><br>
			
			Lista ta ca³y czas siê powiêksza i jest dostêpna na stronie Contributed Libraries and Tools ( http://www.scala-lang.org/node/1209 ).		
					
		</font>
		
		<a name="S2Rozwin.59"></a><h2>10.3. O czym nie zosta³o powiedziane </h2>
		
		<font class="chapter">
		
			Poniewa¿ nie da siê w tak krótkim czasie przedstawiæ wszystkich mo¿liwoœci i zalet Scali warto by wspomnieæ o tym co siê nie zmieœci³o :
			
			<br><br>
			
			- Scala Swing - dziêki swoim mo¿liwoœciom Scala u³atwia pisanie aplikacji GUI, staje siê to mo¿liwe za pomoc¹ do³¹czonego do jêzyka pakietu scala.swing - wykorzystuj¹c zawarte tam wrappery pisanie okienek staje siê bardzo przyjemne;
			
			<br><br>
			
			- Scala w sposób naturalny traktuje XML pozwalaj¹c pisaæ tagi wprost, tak jak ka¿d¹ inn¹ instrukcjê. Podejœcie to dodatkowo jest uzupe³nione o u¿yteczne klasy i metody z pakietu scala.xml, co czyni pracê nad XMLem bardzo ³atw¹.
				
		</font>


		<br><hr>
				
	</body>

</html>