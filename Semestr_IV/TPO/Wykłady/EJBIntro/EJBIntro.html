<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN">
<html
 lang="pl"><head rel="stylesheet" type="text/css"
 href="../style/common.css"> <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1250"> <title>EJB</title><link
 rel="stylesheet" type="text/css" href="../style/common.css"><meta
 content="Krzysztof Barteczko" name="author"></head>
<body>&lt;
<div align="center"><a name="W13"></a><a name="EJBIntro"></a><h1>&nbsp;Wprowadzenie do
Enterprise Java Beans</h1>
</div><hr>
<p><i> Materia≥ zawiera wprowadzenie do EJB - czym sπ, jakie sπ ich
rodzaje. OprÛcz tego zapoznamy siÍ z ogÛlnym mechanizmem
dzia≥ania EJB, zwracajπc szczegÛlnπ uwagÍ na obiekty
poúredniczπce i &nbsp;interfejsy Home. Zostanie pokazany przyk≥ad
aplikacji, opracowanej w wersji EJB 2.1&nbsp;. &nbsp;Specyfikacja EJB
3.0, znacznie u≥atwia sposÛb programowania EJB. Jednak
mechanizm dzia≥ania EJB (choÊ w nowej wersji moøe byÊ ukryty przed
programistπ) pozostaje ten sam i warto z nim - choÊby w zarysach siÍ
zapoznaÊ. Wyklad koÒczy omÛwienie najwaøniejszych cech nowszej i
wygodniejszej wersji EJB - EJB 3.</i><br><a href="mm/audio/ejb.mp3"><span
 style="font-weight: bold;"></span></a><br>
</p><hr>
<br><a name="EJBIntro.1"></a><h2>1. Potrzeba middleware - oprogramowania poúredniczπcego</h2>
<br>W systemach rozproszonych, opartych na programowaniu komponentowym
i
architekturze n-warstwowej niezbÍdne jest<!----> <a name="ind.10.2"></a>oprogramowanie
poúredniczπce
(middleware), ktÛre m.in.:<br>
<ul><li>zapewnia odpowiedniπ komunikacjÍ miÍdzy warstwami,</li><li>realizuje
komunikacjÍ pomiÍdzy rozproszonymi czÍúciami systemu
(m.in. zdalne wywo≥anie procedur, metod, obs≥uga komunikatÛw),</li><li>zarzπdza
transakcjami,</li><li>zapewnia niezawodnoúÊ (obs≥uga b≥ÍdÛw sieciowych,
klastering),</li><li>zarzπdza dostÍpem (autoryzacja i uwierzytelnienie),</li><li>pozwala
na ≥atwe, na logicznym poziomie identyfikowanie zasobÛw, </li><li>zarzπdza
cyklem øycia komponentÛw (obiektÛw) - kiedy majπ powstawaÊ, kiedy majπ
ginπÊ itp.</li><li>zarzπdza trwa≥oúciπ - utrwalanie komponentÛw,
opisujπcych stany systemu,</li><li>zapewnia dynamiczne wdraøanie
komponentÛw (system w
trakcie dzia≥ania moøe zmieniaÊ swÛj kszta≥t i funkcjonalnoúÊ),</li><li>umoøliwia
integracjÍ z innymi systemami (juø istniejπcymi w firmie).<!----></li></ul>
Oczywiúcie, tworzπc duøe nowe systemy nie sposÛb tych wszystkich
problemÛw rozwiπzywaÊ od nowa i od nowa, pisaÊ w≥asny middleware
(koszt i czas). Od poczπtku lat 70-tych pojawia≥y siÍ wiÍc rÛøne
gotowe rozwiπzania - zarÛwno w postaci specyfikacji
standardÛw jak i &nbsp;gotowych produktÛw.<br>
<br><br>
<span style="text-decoration: underline;">Przyk≥adowy problem</span>: <br>
<ul><li>programy (aplikacje lub fragmenty aplikacji)
dzia≥ajπ&nbsp; rÛwnolegle (np. w sieci),</li><li>jak z jednego programu
przekazaÊ informacje do innego?</li><li>w szczegÛlnoúci jak z jednego
fragmentu programu spowodowaÊ wykonanie
innego
fragmentu, znajdujπcego siÍ w innym miejscu sieci (np. na innym
komputerze)&nbsp;?</li></ul>
<span style="text-decoration: underline;">Rozwiπzania:<br>
<br></span>
<ol><li>Moøna napisaÊ serwer, ktÛry bÍdzie poúredniczy≥ miÍdzy
aplikacjami (to jest w pewnym sensie w≥asny middleware). Trzeba biedzie
przy tym
wymyúliÊ jakiú protokÛ≥ komunikacji (specyfikacja) i zapewniÊ
aby aplikacje do tej specyfikacji siÍ stosowa≥y. Czy warto? czasem dla
specyficznych drobnych problemÛw - tak. Ale nie jest to
ogÛlne rozwiπzanie.</li><li>Moøna skorzystaÊ z gotowego middleware'u,
najlepiej takiego, ktÛry stanowi otwarty standard. </li></ol>
Wycinkowe spojrzenie na middleware (na bazie przyk≥adowego problemu)<br>
<br><br>
<img style="border: 1px solid ; width: 630px; height: 335px;" alt="r"
 src="images/middleware.gif"><br><br>
Za chwilÍ zobaczymy jak korzystaÊ z&nbsp;niektÛrych wymienionych
standardÛw.<br>
<br>Do korzystania z middleware'u potrzebne sπ serwery (a zatem i
odpowiednie protoko≥y sπ zdefiniowane). Moøemy np. mieÊ serwer ORB,
serwer JMS, serwer JMX, serwer aplikacji web; uøywaÊ &nbsp;odpowiednich
protoko≥Ûw (np. transportowych: IIOP czy TCP/IP, wyøszego
poziomu - RMI itp.)<br>
<br>Zwykle wszystkie te serwery (a takøe ca≥a wspomniana wczeúniej
funkcjonalnoúÊ, dotyczπca np. bezpieczeÒstwa, trwa≥oúci,
transakcyjnoúci) jest zintegrowana w tzw. <span
 style="font-weight: bold;">serwerach aplikacji.<br>
<br>Przyk≥adowe serwery aplikacji: IBM WebSphere, JBoss, BEA WebLogic,
Sun Java Application Server.<br>
</span><br><a name="EJBIntro.2"></a><h2>2. Architektura N-warstwowa, technologie i serwery
aplikacji w JEE </h2>
<br><div class="def"><!----><a name="ind.10.3"></a> J2EE jest zestawem
protoko≥Ûw, serwisÛw i
interfejsÛw programistycznych (API) s≥uøπcych do tworzenia
n-warstwowych rozproszonych aplikacji biznesowych&nbsp;w oparciu o
paradygmaty programowania komponentowego, ≥atwego "ponownego uøycia" i
architektury zorientowanej na serwisy (SOA).<!----><br>
<br><!----><a name="ind.10.4"></a>J2EE zapewnia w sposÛb modularny
wszystkie us≥ugi typu
"middleware", umoøliwiajπc jednoczeúnie ich ≥atwπ&nbsp; implementacjÍ i
integrowanie w rÛønych serwerach aplikacji. Serwery aplikacji
implementujπce serwisy, protoko≥y i interfejsy J2EE nazywane sπ
ogÛlnie serwerami J2EE.<!----><br>
<br>Od strony uøytkownika J2EE&nbsp; jest otwartym, przenoúnym
standardem
tworzenia i wdraøania rozproszonych aplikacji biznesowych, zapewniajπc
przy tym ≥atwe w uøyciu úrodki skalowania aplikacji, obs≥ugi
transakcji, zapewniania niezawodnoúci i bezpieczeÒstwa.</div><br>
<br><br>
<br><span style="text-decoration: underline;">Szybki rzut oka - 3
warstwy.</span><br>
<br><br>
<img style="width: 482px; height: 339px;" alt="r"
 src="images/N_Tier_Model.png"><br>èrÛd≥o:
SUN<br>
<br>ZwrÛÊmy uwagÍ:<br>
<ul><li>oparcie logiki biznesowej na programowaniu komponentowym
(Enterprise Java Beans sπ komponentami realizujπcymi logikÍ biznesowπ),</li><li>zapewnienie
úrodkÛw integracji z innymi systemami biznesowym oraz aplikacjami
"spadkowymi".</li><li><span style="font-weight: bold;">kontenery</span>
zajmujπ siÍ zarzπdzaniem komponentami (aplikacji WEB lub logiki
biznesowej),</li></ul>
<br><table border="1" cellpadding="2" cellspacing="2" width="100%"> <tbody>
<tr align="center"> <td colspan="3" rowspan="1">Inny podzia≥ na:</td> </tr>
<tr> <td>warstwÍ klienta,</td> <td colspan="1" rowspan="2">zazwyczaj
traktowane jaka "Warstwa
prezentacji"; jej odseparowanie pozwala zazwyczaj skupiÊ siÍ na
prezentacji bez koniecznego wchodzenia w szczegÛ≥y logiki
biznesowej</td> <td></td> </tr> <tr> <td>warstwÍ aplikacji WEB,</td>
<td colspan="1" rowspan="2">tymi warstwami zarzπdza<br>
serwer J2EE</td> </tr> <tr> <td>warstwÍ logiki biznesowej,</td> <td>jej
odseparowanie pozwala skupiÊ siÍ na rozwiπzywaniu<br>
problemÛw biznesowych</td> </tr> <tr> <td>warstwÍ EIS</td> <td>istniejπca
informacyjna infrastruktura firmy - systemy
zarzπdzania bazami danych, ERP (enterprise resource planning), systemy
transakcyjne itp.</td> <td></td> </tr> <tr> <td></td> <td><img
 style="width: 372px; height: 186px;" alt="r"
 src="images/overview-webTier.gif"></td>
<td></td> </tr> <tr> <td></td> <td><img
 style="width: 436px; height: 186px;" alt="r"
 src="images/overview-businessAndEisTiers.gif"><br>
ürÛd≥o: Sun</td> <td></td> </tr> </tbody>
</table><br>
<br><span style="text-decoration: underline;">Architektura J2EE</span><br>
<br><img style="width: 782px; height: 511px;" alt="r"
 src="images/overview-j2eeArchitecture.gif"><br>
ürÛd≥o: Sun<br>
<br>Objaúnienia:<br>
<br><ul><li><span style="font-weight: bold;"><!----><a name="ind.10.5"></a>EJB</span>
- specyfikacja
Enterprise Java Beans (w tej chwili nowa wersja 3.0) opisuje
sposÛb programowania komponentÛw logiki biznesowej,
dzia≥ajπcych w úrodowisku rozproszonym i zarzπdzanych przez kontener
EJB.<!----></li><li><span style="font-weight: bold;"><!----><a
 name="ind.10.6"></a>Serwlety i JSP</span> - technologie tworzenia
komponentÛw aplikacji Web<!----></li><li><span
 style="font-weight: bold;">JMS</span> - Java Messaging Service API,</li><li><span
 style="font-weight: bold;"><!----><a name="ind.10.7"></a>JMX</span> +
Mgmt. - Java
Management Extensions - zarzπdzanie aplikacjami Javy, umoøliwiajπce
m.in ≥atwiejszπ komunikacjÍ w úrodowiskach rozproszonych, dynamiczne
konfigurowanie aplikacji i systemÛw oraz ich rozbudowÍ na zasadzie
plug-in<!---->,</li><li><span style="font-weight: bold;"><!----><a
 name="ind.10.8"></a>JTA</span> - Java Transaction API - zarzπdzanie
transakcjami<!---->,</li><li><span style="font-weight: bold;">JAF</span>
- Java Beans Activation Framework (g≥Ûwnie dla potrzeb Java Mail),</li><li><span
 style="font-weight: bold;">SAAJ</span> - Soap with
Attachments for Java (realizacja specyfikacji SOAP) - niskopoziomowe
narzÍdzia, raczej uøywane poúrednio z poziomu JAX-RPC,</li><li><span
 style="font-weight: bold;">JAX-RPC</span> - Java API for
XML based RPC -&nbsp; bazujπce na protokole SOAP&nbsp;i
transporcie&nbsp; HTTP - zdalne wywo≥anie metod i dostÍp do
serwisÛw (web serwisy)</li><li><span style="font-weight: bold;">JAXR</span>
- Java API for XML Registries -&nbsp; dostÍp do Web-rejestrÛw (m.in.
opisujπcych web serwisy),</li><li><span style="font-weight: bold;">Connectors
(JCA - Java Connectors Architecture)</span>
-&nbsp;architektura ≥πcznikÛw, pozwalajπca na integrowanie
aplikacji J2EE z istniejπcymi systemami firmy. Razem z JAX-RPC
umoøliwia eksponowanie istniejπcych systemÛw w formie web
serwisÛw,</li><li><span style="font-weight: bold;">Java Persistence API
</span>- &nbsp;programistyczne úrodki utrwalania obiektÛw w konwencji
odwzorowania obiektowo-relacyjnego (O/R mapping),</li><li><span
 style="font-weight: bold;">StAX </span>- Streaming API for XML
(po≥aczenie zalet podejúcia DOM i SAX).</li></ul>
<br>OprÛcz pokazanych na rysunku elementÛw aplikacje J2EE
wykorzystujπ wszystko to co jest w standarcie J2SE, w tym nastÍpujπce
technologie:<br>
<br><span style="font-weight: bold;">JNDI</span> - &nbsp;Java Naming
and Directory Interfaces - identyfikacja zasobÛw na poziomie logicznym.<br>
<span style="font-weight: bold;">JAAS</span> (Java Authentication and
Authorization Service) - autoryzacja i uwierzytelnianie<br>
<span style="font-weight: bold;">JDBC</span> - dostÍp do baz danych.
<br><a name="W13.1"></a><a name="EJBIntro.3"></a><h2>3. Komponenty EJB</h2>
<br><div class="def"><span style="font-weight: bold;"><!----><a
 name="ind.13.1"></a>Enterprise Java Bean</span> jest komponentem
programistycznym, realizujπcym
logikÍ biznesowπ, dzia≥ajπcym w n-warstwowym úrodowisku rozproszonym po
stronie serwera aplikacji&nbsp; i &nbsp;zarzπdzanym przez kontener EJB.
<!----><br><br>
Konieczne jest by:<br>
<ul> <li>oprogramowanie komponentu spe≥nia≥o wymogi specyfikacji EJB
(m.in. potrzebne jest uøycie odpowiednich interfejsÛw),</li> <li>komponent
by≥ wdroøony (deployed), co wymaga odpowiednich deskryptorÛw wdroøenia.</li>
</ul></div><br>
<br>Specyfikacja EJB&nbsp; rozrÛønia nastÍpujπce typy Enterprise Java
Beans:<br>
<br><ul> <li><span style="font-weight: bold;"><!----><a name="ind.13.2"></a>komponenty
sesyjne (session beans)</span> - wykonujπ dzia≥ania (np. wyp≥ata z
konta). Dwa typy: <span style="font-weight: bold;">bezstanowe
(stateless)</span> i <span style="font-weight: bold;">stanowe
(stateful)</span>.
Te ostatnie zachowujπ poúrednie stany wykonywanych czynnoúci dla danego
klienta ("prowadzπ" stan poprzez szereg kolejnych zleceÒ - np. zakupy w
e-sklepie i stan koszyka).<!----></li> <li><span
 style="font-weight: bold;"><!----><a name="ind.13.3"></a>komponenty
encyjne (entity beans)</span> - modelujπ (odzwierciedlajπ) dane (np.
produkty, klienci).<!----></li> <li> <span style="font-weight: bold;"><!----><a
 name="ind.13.4"></a>komponenty sterowane komunikatami</span> (<span
 style="font-weight: bold;">message driven beans</span>) - podobne do
sesyjnych, ale akcje sterowane komunikatami (zob. JMS)<!---->.</li>
</ul><br>
<img style="border: 1px solid ; width: 633px; height: 418px;" alt="r"
 src="images/Ejb.gif"><br>èrÛd≥o: Ed Roman et al. Mastering EJB, Willey
2005<br>
&nbsp;<br>
EJB jest komponentem przygotowanym do dzia≥ania w úrodowisku
rozproszonym - obiektem zdalnym.<br>
Abstrahujπc od msg-driven beans zdalna komunikacja odbywa siÍ za
púrednictwem RMI-IIOP. <br>
Czyli tak jak juø widzieliúmy?<br>
<br><img style="border: 1px solid ; width: 362px; height: 256px;"
 alt="r" src="images/rmiIIOP.gif"><br> <br>
Nie do koÒca! To tylko po≥owa drogi.<br>
<hr style="width: 100%; height: 2px;"><br><a name="W13.2"></a><a name="EJBIntro.4"></a><h2>4.
EJB, uslugi middleware a logika biznesowa</h2>
Potrzebne jest zapewnienie dodatkowych us≥ug typu middleware np.
zwiπzanych z bezpieczeÒstwem, transakcyjnoúciπ itp. W "czystym"
RMI-IIOP musimy je zapewniÊ sami np. zawierajπc odpowiedni kod w
metodach zdalnego obiektu (uøycie API zwiπzanego z bezpieczeÒstwem,
transakcyjnoúciπ itp.).<br>
<br><img style="border: 1px solid ; width: 577px; height: 202px;"
 alt="r" src="images/Ejb_RMI.gif"><br>
<br>Ale g≥Ûwnπ ideπ EJB jest to aby w programowaniu komponentÛw skupiaÊ
siÍ na logice biznesowej.<br>
Us≥ugi middleware powinny byÊ wiÍc zapewnianie automatycznie i dla
programisty komponentowego - niewidocznie.<br>
Tutaj w≥aúnie pojawia siÍ rola <span style="font-weight: bold;"><!----><a
 name="ind.13.5"></a>kontenera EJB</span>. Zapewnia on te dodatkowe
us≥ugi.<br>
Jak? Poprzez automatyczne generowanie odpowiedniego kodu poúredniczπcego<!---->:<br>
<br><img style="border: 1px solid ; width: 532px; height: 244px;"
 alt="r" src="images/Ejb_RMI2.gif"><br>
<br><br>
<br>Ale to wymaga - <span style="font-weight: bold;">jednak!!! </span>-
aby
komponenty EJB programowaÊ w bardzo specyficzny sposÛb - zgodny
ze specyfikacjπ, spe≥niajπc przy tym szereg wymagaÒ. I dodatkowo -
potrzebne jest powiedzenie kontenerowi EJB jakich konkretnie us≥ug i w
jakiej konfiguracji od niego siÍ wymaga - i stπd potrzeba&nbsp;<span
 style="font-weight: bold;">deskryptorÛw wdroøenia</span>.
Tak przynajmniej by≥o w wersji EJB 2.1. W wersji EJB 3.0 od wielu
mÍczπcych obowiπzkÛw moøemy byÊ zwolnieni (zob. nastÍpny wyk≥ad).<br>
<hr style="width: 100%; height: 2px;"><br><a name="W13.3"></a><a name="EJBIntro.5"></a><h2>5.
Programowanie komponentÛw EJB 2.1</h2>
<br>SposÛb oprogramowania komponnetow EJB 2.1 zostanie zilustrowany
na prostym przyk≥adzie obliczania podatku od dochodÛw osobistych.<br>
<br>Klasy komponentÛw EJB muszπ implementowaÊ odpowiednie interfejsy.<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2"> <tbody> <tr> <td style="text-align: center;">Rodzaj
EJB</td> <td style="text-align: center;">Implementuje</td> </tr> <tr>
<td>session bean</td> <td><code class="cCode">javax.ejb.SeesionBean</code></td>
</tr> <tr> <td>entity bean</td> <td><code class="cCode">javax.ejb.EntityBean</code></td>
</tr> <tr> <td>message-driven bean</td> <td><code class="cCode">javax.ejb.MessageDrivenBean<br>
</code></td> </tr> </tbody>
</table>Wszystkie te interfejsy sπ pochodne od javax.ejb.EnterpriseBean<br>
<br>A zatem&nbsp; implementacja sesyjnego komponentu podatkowego
wyglπda nastÍpujπco:<br>
<br><pre>package pit;

import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import java.math.*;


public class PitBean implements SessionBean {

    private BigDecimal taxRate = new BigDecimal("0.14");

    public PitBean() {
    }

    public BigDecimal taxToPay(BigDecimal income) {
        BigDecimal result = income.multiply(taxRate);

        return result.setScale(2, BigDecimal.ROUND_UP);
    }


    // Metoda wo≥ana przy tworzeniu obiektu ziarna
    public void ejbCreate() {
    }

    // Metody interfejsu SessionBean

    public void ejbRemove() {
    }

    public void ejbActivate() {
    }

    public void ejbPassivate() {
    }

    public void setSessionContext(SessionContext sc) {
    }
}</pre>
Metod interfejsu SessionBean moøemy uøyÊ (na zasadzie call-back) do
rÛønych dzia≥aÒ w fazach zwiπzanych z tworzeniem, usuwaniem,
aktywacjπ, deaktywacjπ obiektu, jak rÛwnieø do dostÍpu do
kontekstu sesji (przekazanego w argumencie metody setSessionContext).<br>
<br>Ale rÛwnieø - tutaj w≥aúnie - definiujemy metody inicjacji naszego
obiektu biznesowego.<br>
Metody te:<br>
<ul> <li>majπ&nbsp;nazwÍ ejbCreate,</li> <li>typ wyniku void,</li> <li>sπ
publiczne,</li> <li>mogπ mieÊ argumenty, ale typy argumentÛw muszπ
spe≥niaÊ
wymagania zdalnego dostÍpu (np. przekazanie przez referencjÍ dotyczyÊ
moøe tylko zdalnych obiektÛw),</li> <li>mogπ sygnalizowaÊ wyjπtek
CreateException - zwykle jako reakcja na wadliwe argumenty wywo≥ania.</li>
</ul>Moglibyúmy np. dodaÊ jeszcze jednπ metodÍ ejbCreate(BigDecimal), z
argumentem -
stawkπ podatku.<br>
<br>Ani metod interfejsu SessionBean, ani metod ejbCreate(..) - nie
wywo≥ujemy<br>
PamiÍtajmy: &nbsp;to serwer aplikacji (kontener EJB) tworzy nasze
obiekty, nie my!<br>
<br>Ciekawostka: nasza metoda taxToPay(...) moøe byÊ wywo≥ana zdalnie,
jednak nie implementujemy øadnych zdalnych narzÍdzi (jak w RMI-IIOP).<br>
<br>I tu w≥aúnie jest najwaøniejsza zmiana koncepcyjna. Polega na tym,
øe <span style="font-weight: bold;"><!----><a name="ind.13.6"></a>pomiÍdzy
klientem a naszym komponentem-ziarnem znajduje siÍ poúrednik</span> - i
to <span style="font-weight: bold;">do niego idπ wszystkie odwo≥ania
od klienta</span>.<!----><br>
<br><div class="important">Poúrednikiem jest tzw. <span
 style="font-weight: bold; color: rgb(102, 0, 204);"><span
 style="color: rgb(255, 255, 102);">EJB</span></span><span
 style="font-weight: bold; color: rgb(102, 0, 204);"><span
 style="color: rgb(255, 255, 102);"></span></span><span
 style="font-weight: bold; color: rgb(102, 0, 204);"><span
 style="color: rgb(255, 255, 102);">Object</span></span></div><br>
<br>Ten mechanizm - przejmowanie zleceÒ klientÛw przez EJBObject,
ktÛry deleguje je nastÍpnie do wykonania przez ziarno biznesowe,
umoøliwia kontenerowi EJB automatyczne dostarczanie us≥ug typu
middleware, dotyczπcych:<br>
<ul> <li>bezpieczeÒstwa,</li> <li>transakcyjnoúci,</li> <li>zarzπdzania
zasobami, w tym cyklem zyciowym komponentu,</li> <li>trwa≥oúci
(utrwalania stanÛw i danych),</li> <li>zarzπdzania wielodostÍpem
(zapewniony wspÛlbieøny dostÍp ze strony wielu klientÛw jednoczeúnie),</li>
<li>itp.</li>
</ul><br>
Skπd siÍ bierze <span style="font-weight: bold;">EJBObject</span>?
Jest <span style="font-weight: bold;">generowany automatycznie</span>
przez kontener.<br>
Ale skoro odwo≥ania klientÛw muszπ trafiaÊ do niego, a dopiero
za jego poúrednictwem do naszego ziarna biznesowego, to musimy
powiedzieÊ kontenerowi, aby przy generacji EJBObject <span
 style="font-weight: bold;">uwzglÍdni≥
interfejs biznesowy naszego ziarna</span>. Dlatego do generacji
&nbsp;EJBObjectu musimy dostarczyÊ odpowiedniego interfejsu.<br>
<br>Jeøeli dostÍp do EJB ma byÊ zdalny (o lokalnym dostÍpie powiemy
kilka s≥Ûw na koniec), to musimy dostarczyÊ <span
 style="font-weight: bold;"><!----><a name="ind.13.7"></a>zdalnego</span>
interfejsu<!----> na ktÛrym oprze siÍ&nbsp;generacja EJBObject. W nim
dostarczymy naszego
interfejsu biznesowego. Ten zdalny interfejs (naturalnie) nazywa siÍ w
rÛønych narzÍdziach wdroøeniowych <span style="font-weight: bold;">Remote</span>.<br>
<br>To nie jest zwyk≥y zdalny interfejs. Poniewaø s≥uøy do generowania
EJBObject, to musi rozszerzaÊ interfejs EJBObject.<br>
<pre>package pit;

import javax.ejb.EJBObject;
import java.rmi.RemoteException;
import java.math.*;

public interface Pit extends EJBObject {
    public BigDecimal taxToPay(BigDecimal income) throws RemoteException;
}
</pre>Sam
EJBObject rozszerza java.rmi.Remote, wiÍc mamy zdalny obiekt, a w
naszej metodzie biznesowej musimy uwzglÍdniÊ moøliwoúÊ zg≥oszenia
wyjπtku RemoteException.<br>
<br><span style="font-weight: bold;"><div class="important">Ten w≥aúnie
(zdalny) interfejs (a nie
jakiú implementowany w ziarnie biznesowym) s≥uøy zdalnym klientom do
komunikowania siÍ z naszym ziarnem.</div></span><br
 style="font-weight: bold;">
<br><br>
Ale to jeszcze nie wszystko.<br>
Klienci muszπ uzyskaÊ dostÍp do EJBObjectu poúredniczπcego w
odwo≥aniach do naszego ziarna biznesowego.<br>
Ten obiekt jest tworzony przez kontener: kiedy i jak?<br>
Potrzebny jest kolejny poúrednik: fabryka obiektÛw EJBObject, ktÛra
zajmuje siÍ ich:<br>
<ul> <li>tworzeniem,</li> <li>odnajdywaniem istniejπcych,</li> <li>usuwaniem.</li>
</ul><!----><a name="ind.13.8"></a>TÍ fabrykÍ (ktÛra teø jest
generowana automatycznie) musimy
jednak dostroiÊ. Np. powiedzieÊ jak sπ tworzone obiekty (øe sπ np.
inicjowane Stringiem lub BigDecimal). Dlatego dostarczamy&nbsp;jeszcze
jednego interfejsu ktÛry siÍ nazywa <span style="font-weight: bold;">Home</span>.
Ten interfejs rozszerza EJBHome (w ktÛrym znajdujπ siÍ juø odpowiednie
metody).<!----><br>
<br><pre>package pit;

import java.rmi.RemoteException;
import javax.ejb.CreateException;
import javax.ejb.EJBHome;


public interface PitHome extends EJBHome {
    Pit create() throws RemoteException, CreateException;
}</pre>
Tutaj dodaliúmy metodÍ tworzenia obiektu (bez inicjacji jakimiú
argumentami) - create().<br>
Uwagi: <br>
<ul> <li>fabryczne metody tworzenia obiektu (create) muszπ byÊ zgodne
(pod
wzglÍdem nazwy i typÛw argumentÛw) z metodami inicjacji
ziarna w implementacji komponentu biznesowego (ejbCreate).</li> <li>tutaj
mamy zdalny obiekt Home, dlatego wyjπtek RemoteException</li>
</ul><br>
Co mamy:<br>
<ul> <li>klasÍ ziarna biznesowego PitBean,</li> <li>
interfejs Remote - o nazwie Pit, s≥uøπcy do generacji zdalnego obiektu
EJBObject, poúredniczπcego w odwo≥aniach do naszego ziarna,</li> <li>
interfejs Home - o nazwie PitHome, s≥uøπcy do generacji fabryki
EJB-obiektÛw, za pomoca ktÛrej klienci tworzπ obiekty i
uzyskujπ do nich dostÍp.</li>
</ul><br>
<div class="important">W zdalnym programie klienckim pos≥ugujemy siÍ
tylko interfejsami Home i Remote.</div><br>
<br>Co musi zrobiÊ zdalny klient?<br>
<ul> <li>uzyskaÊ dostÍp do fabryki obiektÛw (interfejs Home = u nas
PitHome) - oczywiúcie poprzez JNDI,</li> <li>za poúrednictwem Home
uzyskac dostÍp do obiektu poúredniczπcego (interfejs Remote = u nas
Pit),</li> <li>wywo≥ywac metody interfejsu Pit, ktÛre za poúrednictwem
EJBObject odwo≥ujπ siÍ do analogicznych metod klasy ziarna biznesowego
(PitBean).</li>
</ul><pre>import pit.Pit;
import pit.PitHome;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.rmi.PortableRemoteObject;
import java.math.BigDecimal;


public class PitClient {
    public static void main(String[] args) {
        try {
            Context initial = new InitialContext();
            Context myEnv = (Context) initial.lookup("java:comp/env");
            Object objref = myEnv.lookup("ejb/Pit");

            PitHome home =
                (PitHome) PortableRemoteObject.narrow(objref,
                    PitHome.class);

            Pit pit = home.create();

            BigDecimal income = new BigDecimal("100000.00");
            BigDecimal tax = pit.taxToPay(income);

            System.out.println("Podatek wynosi: " + tax);

            System.exit(0);

        } catch (Exception ex) {
            System.err.println("Caught an unexpected exception!");
            ex.printStackTrace();
        }
    }
}</pre>
<br>Obrazowo dzia≥anie ca≥ej aplikacji moøna przedstawiÊ na rysunku.<br>
<br><img style="border: 1px solid ; width: 582px; height: 268px;"
 alt="r" src="images/Ejb_Run.gif"><br>
<br>Zatem aplikacja EJB sk≥ada siÍ z wielu czÍúci, a wiele jej
fragmentÛw jest automatycznie generowane przez kontener EJB.<br>
<hr style="width: 100%; height: 2px;"><br><a name="W13.4"></a><a name="EJBIntro.6"></a><h2>6.&nbsp;Sk≥adanie
i wdraøanie aplikacji JEE&nbsp;</h2>
Aplikacja dzieli siÍ na modu≥y m.in. modu≥y &nbsp;EJB oraz modu≥
klienta.<br>
Modu≥y sπ pakowane do plikÛw JAR (lub WAR - jeúli to modu≥ Web).<br>
Modu≥y (JARY)&nbsp;sπ archiwizowane w pliku EAR (Enterprise Archive), z
tym, øe modu≥y klienckie mogπ byÊ z niego wy≥πczone.<br>
<br>OprÛcz naszych klas i interfejsÛw, w archiwach aplikacji muszπ
znaleüÊ siÍ odpowiednie<!----> <a name="ind.13.10"></a>deskryptory
wdroøenia<!---->.<br>
Sπ dwa typy tych deskryptorÛw: <br>
<ul> <li>uniwersalne - zgodne ze specyfikacjπ EJB, uøywane w kaødym
serwerze aplikacji,</li> <li>specyficzne - wymagane przez konkretne
serwery aplikacji. </li>
</ul>Podstawowym deskryptorem&nbsp;jest ejb-jar.xml, ktÛry opisuje
konfiguracjÍ dostÍpu do ziarna biznesowego, a takøe kwestie zwiπzane z
transakcyjnoúciπ i bezpieczeÒstwem (oraz wiele innych).<br>
Przyk≥ad:<br>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ejb-jar xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="2.1"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
    http://java.sun.com/xml/ns/j2ee/ejb-jar_2_1.xsd"&gt;

&lt;display-name&gt;PitAppJar&lt;/display-name&gt;
&lt;enterprise-beans&gt;
&lt;session&gt;
&lt;display-name&gt;PitBean&lt;/display-name&gt;
&lt;ejb-name&gt;PitBean&lt;/ejb-name&gt;
&lt;home&gt;pit.PitHome&lt;/home&gt;
&lt;remote&gt;pit.Pit&lt;/remote&gt;
&lt;ejb-class&gt;pit.PitBean&lt;/ejb-class&gt;
&lt;session-type&gt;Stateless&lt;/session-type&gt;
&lt;transaction-type&gt;Bean&lt;/transaction-type&gt;
&lt;security-identity&gt;
&lt;use-caller-identity/&gt;
&lt;/security-identity&gt;
&lt;/session&gt;
&lt;/enterprise-beans&gt;
&lt;/ejb-jar&gt;
</pre>OprÛcz
tego potrzebny jest opis powiπzaÒ pomiÍdzy zasobami a
nazwami JNDI (np. w naszym przyk≥adzie pomiedzy odwo≥aniem ejb/Ref a
konkretnym ziarnem biznesowym).<br>
Po stronie klienta (w archiwum klienta) musimy w tym celu dostarczyÊ
pliku wdroøeniowego application-client.xml:<br>
<br><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;application-client xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.4" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/application-client_1_4.xsd"&gt;
&lt;display-name&gt;PitAppClient&lt;/display-name&gt;
&lt;ejb-ref&gt;
&lt;ejb-ref-name&gt;ejb/Pit&lt;/ejb-ref-name&gt;
&lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
&lt;home&gt;pit.PitHome&lt;/home&gt;
&lt;remote&gt;pit.Pit&lt;/remote&gt;
&lt;/ejb-ref&gt;
&lt;/application-client&gt;</pre>
<br>RÛøne serwery aplikacji mogπ stosowaÊ swoje dodatkowe regu≥y.
Dlatego takich informacji dostarczamy w deskryptorach wdroøenia dla
specyficznych serwerÛw np. dla serwera Sun Application Server w
pliku sun-ejb-jar.xml: <br>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE sun-ejb-jar PUBLIC "-//Sun Microsystems, Inc.//DTD Application Server 8.1 EJB 2.1//EN" "http://www.sun.com/software/appserver/dtds/sun-ejb-jar_2_1-1.dtd"&gt;

&lt;sun-ejb-jar&gt;
  &lt;enterprise-beans&gt;
    &lt;name&gt;PitAppJar&lt;/name&gt;
    &lt;ejb&gt;
      &lt;ejb-name&gt;PitBean&lt;/ejb-name&gt;
      &lt;jndi-name&gt;PitBean&lt;/jndi-name&gt;
    &lt;/ejb&gt;
  &lt;/enterprise-beans&gt;
&lt;/sun-ejb-jar&gt;
</pre><br>
oraz (po stronie klienta) &nbsp;sun-application-client.xml:<br>
<br><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE sun-application-client PUBLIC "-//Sun Microsystems, Inc.//DTD Application Server 8.1 Application Client 1.4//EN" "http://www.sun.com/software/appserver/dtds/sun-application-client_1_4-1.dtd"&gt;
&lt;sun-application-client&gt;
&lt;ejb-ref&gt;
&lt;ejb-ref-name&gt;ejb/Pit&lt;/ejb-ref-name&gt;
&lt;jndi-name&gt;PitBean&lt;/jndi-name&gt;
&lt;/ejb-ref&gt;
&lt;/sun-application-client&gt;
</pre>
<br>Po zdefiniowaniu deskryptorÛw wdroøenia oraz skompilowaniu
wszystkich klas, spakowaniu ich w modu≥y (JARY) nasza aplikacja sk≥ada
siÍ z pliku EAR (PitApp.ear) i modu≥u klienckiego PitAppClient.jar.<br>
Ich strukturÍ pokazujπ rysunki.<br>
<img
 style="border: 1px solid ; width: 246px; height: 384px; float: right;"
 alt="r" src="images/PitAppClientJar.jpg"><br><img
 style="border: 1px solid ; width: 200px; height: 281px;" alt="r"
 src="images/PitAppEar.jpg"><br>
<br><br>
<br><br>
<br><br>
<br><br>
Modu≥ EJB wdraøamy na serwerze i uruchamiamy aplikacjÍ.<br>
<br>Modu≥ kliencki s≥uøy do zdalnego dostÍpu. Jak widzieliúmy jest to
zwyk≥a wolnostojπca aplikacja.<br>
Moøna teø dostarczyÊ klientÛw Web (czyli aplikacji Web,
ktÛre pozwalajπ na dzia≥anie za poúrednictwem dynamicznie
generowanych stron HTML. Ale o tym sporo by≥o w ramach "Metod
programowania" i teraz to pominiemy.<br>
<br>Jak dzia≥a&nbsp;klient?<br>
I tutaj sprawa nie jest prosta. Jeúli nie chcemy grzebaÊ we
"wnÍtrznoúciach" specyfikacji serwera aplikacji, klienta powinniúmy
uruchamiaÊ w tzw. <span style="font-weight: bold;"><!----><a
 name="ind.13.12"></a>kontenerze klienta</span>. <br>
Kontener ten jest specjalnie skonfigurowany w taki sposÛb, by
bezproblemowo ≥πczyÊ siÍ z serwisami nazw czy JMS, korzysta z szeregu
klas J2EE, wykorzystuje deskryptory dostarczone w pliku JAR. <br>
W úrodowisku serwera Sun App Server do uruchamiania klientÛw w
kontenerze klientÛw s≥uøy plik wsadowy <span style="font-weight: bold;">appclient.bat</span>.<!----><br>
<br><br>
Na szczÍúcie tworzenie deskryptorÛw i wdraøanie aplikacji jest znacznie
u≥atwione dziÍki narzÍdziom wdroøeniowym a takøe nowym rozwiπzaniom.
zwiπzanym z zastosowaniem wzorca dependency injection i adnotacjii.<br><br><a name="EJBIntro.7"></a><h2>7.
"Loose coupling", wzorzec "dependency injection" i lekkie kontenery</h2>
Przy pisaniu programÛw, szczegÛlnie duøych, sk≥adajπcych
siÍ z wielu czÍúci i dzia≥ajπcych w úrodowiskach rozproszonych
konieczne jest dbanie o "loose coupling" - czyli s≥abπ
wspÛ≥zaleønoúÊ poszczegÛlnych modu≥Ûw systemu, a
nawet fragmentÛw kodu.<br>
<br><div class="def"><!----><a name="ind.14.1"></a>"Loose coupling"
jest &nbsp;w≥aúciwoúciπ systemu komputerowego,
ktÛra oznacza, øe jego poszczegÛlne modu≥y mogπ byÊ
traktowane w duøym stopniu niezaleønie i ich kody nie sπ ze sobπ úciúle
powiπzane<!----></div><br>
<br><br>
Programowanie w kategoriach interfejsÛw daje nam pewnπ niezaleønoúÊ,
ale nie ca≥kowitπ.<br>
Np. taki kod:<br>
<br><pre>List list = new ArrayList();</pre>
<br>zaleøy od klasy ArrayList i nie spe≥nia warunku "loose coupling" <br>
<br>SytuacjÍ poprawia zastosowanie fabryk:<br>
<br><pre>List list = ListFactory.createList();</pre>
<br>Ten kod nie zaleøy od konkretnej implementacji listy. Fabryka moøe
dostarczyÊ dowolnej implementacji (czÍsto zaleønej od kontekstu), a
program nie musi czyniÊ øadnych za≥oøeÒ co do tej implementacji.<br>
ZwrÛÊmy jednak uwagÍ, øe musimy odwo≥aÊ siÍ do konkretnej fabryki i w
tym sensie kod nie jest w pe≥ni niezaleøny.<br>
<br>O konkretnej implementacji chcielibyúmy przesπdzaÊ w trakcie
wdraøania
aplikacji (a nie pisania kodu). ByÊ moøe tÍ konkretnπ implementacjÍ
(w≥aúciwπ dla úrodowiska, w ktÛrym wykonuje siÍ program) zna
tylko kontener, w ktÛrym program&nbsp;jest wdraøany. ByÊ moøe w
rÛønych kontenerach implementacje sπ rÛøne. <br>
Nie powinniúmy wiÍc od tego uzaleøniaÊ naszego kodu.<br>
Programujmy tylko w kategoriach interfejsÛw, a
zadanie&nbsp;tworzenia i dostarczenia obiektÛw klas bÍdπcych
konkretnymi implementacjami tych interfejsÛw od≥Ûømy do
momentu wdroøenia aplikacji i obarczmy nim kontener, w ktÛrym
aplikacja jest wdraøana.<br>
Jest to zasadniczy sens zastosowania wzorca "dependency injection".<br>
<br>&nbsp;<br><!----><a name="ind.14.2"></a>
Wzorzec "dependency injection" polega na przeniesieniu procesu
tworzenia obiektu i ≥πczenia go z referencjami typÛw interfejsu
poza kod programu. Odpowiednie referencje (do obiektÛw klasy
implementujπcej dany interfejs) sπ wstrzykiwane w kod programu w fazie
wdroøenia lub nawet wykonania przez úrodowisko zewnÍtrzne, zazwyczaj
kontener, w sposob domyúlny lub na podstawie informacji z plikÛw
wdroøeniowych.<!----><br>
<br>OgÛlnie, iniekcje mogπ byÊ dokonywane: <br><ul><li>
bezpoúrednio w pola klasy,</li><li>
za poúrednictwem konstruktora,</li><li>
poprzez settery.</li></ul>
<br><span style="text-decoration: underline;">Iniekcja w pole</span>:<br>
<br><pre>List list;  // po iniekcji list wskazuje na obiekt implementujπcy interfejs List
            // trzeba jeszcze powiedzieÊ jakoú, øe w tym miejscu jest potrzebna iniekcja </pre>
Iniekcja za poúrednictwem konstruktora:<br>
<br><pre>class A {

   private List list;

   public A(List l) {    // iniekcja dokonana za poúrednictwem konstruktora
      list = l;          // konstruktorowi przekazywany jest obiekt klasy implementujπcej List
   }

}</pre>
<br>Iniekcja za pomocπ settera:<br>
<br><pre>class A {

   private List list;

   public void setList(List l) {    // iniekcja poprzez setter
      list = l;
   }

}</pre>
<br>Wzorzec "dependency injection" od jakiegoú juø czasu stosowany jest
w tzw. lekkich konenerach.<br>
Naleøπ do nich m.in.<br>
<a href="http://www.picocontainer.org/">PicoContainer</a><br>
<a href="http://nanocontainer.codehaus.org/">NanoContainer</a><br>
<a href="http://www.springframework.org/">Spring</a><br>
<br><span style="font-weight: bold;">ProszÍ odwiedziÊ powyøsze linki i
przeczytaÊ o tych úrodowiskach i sposobie realizacji w nich wzorca
"dependency injection".</span><br style="font-weight: bold;">
<br><div class="def"><span style="font-weight: bold;"><!----><a
 name="ind.14.3"></a>Lekkie kontenery</span>&nbsp;nazywane
sπ lekkimi, poniewaø w przeciwieÒstwie do kontenerÛw EJB 2.1
pozwalajπ na programowanie za pomocπ zwyk≥ych klas Javy (POJO - "plain
old Java objects") i nie wymagajπ od programisty uøywania
specyficznych, niejako "technicznych" konstrukcji, zwiπzanych z
"wnÍtrznoúciami" kontenera (np. w rodzaju interfejsu Home, klasy
EJBObject itp.). Ta lekkoúÊ osiπgana jest m.in. za pomocπ zastosowania
wzorca "dependency injection".<!----></div> &nbsp;<br>
<br><br>
Wspomniane "lekkie kontenery" rÛønie realizujπ wzorzec
"dependency injection". Np. dla PicoContainera trzeba dostarczyÊ
kodÛw (programikÛw) konfigurujπcych. W Spring Application
Framework mamy pliki konfiguracyjne XML.<br>
<br>Po wprowadzeniu w Javie 1.5 mechanizmu adnotacji pojawi≥a siÍ
rÛwnieø moøliwoúÊ oznaczania punktÛw iniekkcji za pomocπ
opdowiednich adnotacji.<br>
Jest to g≥Ûwny (choÊ nie jedyny moøliwy) mechanizm stosowany w
EJB 3.0, ktÛra to specyfikacja czyni wreszcie kontenery EJB
lekkimi i zmacznie u≥atwia programowanie aplikacji J2EE.<br>
<br><br>
<hr><a name="W14.2"></a><a name="EJBIntro.8"></a><h2>8. EJB 3.0&nbsp;- przeglπd</h2>
Dotychczasowy model EJB (zob. poprzedni wyk≥ad) by≥:<br>
<ul><li>trudny w rozumieniu i uøyciu,</li><li>zawik≥any, obarczajπcy
programistÍ wielu szczegÛ≥ami technicznymi,</li><li>wreszcie oparty na
typie "ciÍøkiego kontenera" - zaprzeczenie
loose coupling (zbyt duøo sztywnych powiπzaÒ, klasy nie sπ typu POJO)</li></ul>
<br><!----><a name="ind.14.4"></a>Specyfikacja EJB 3.0 pozwala na
zastosowanie w programowaniu klas POJO.
Za pomocπ mechanizmu "dependency injection" i z wykorzystaniem
adnotacji umoøliwia ≥atwiejsze i bardziej elastyczne (m.in. usuwajπce
zaleønoúci od klas kontenerowych i deskryptorÛw wdroøenia)
tworzenie i wdrazanie aplikacji.<!----><br>
<br><div class="def"><br>
<h2 style="text-align: center; color: rgb(255, 0, 0);">EJB 3.0 = POJO +
adnotacje + dependency injection</h2>
</div><br><br>
Praktycznie w nowym modelu znikajπ (moøna nie uøywaÊ):<br>
<ul><li>interfejsÛw Home,</li><li>deskryptorÛw wdroøenia.</li><li>dziedziczenia
xxxxBean&nbsp;</li><li>zdalnych wyjπtkÛw (RemoteException)</li></ul>
<br>Interfejsy sπ <span
 style="color: rgb(255, 0, 0); font-weight: bold;">POJO</span>!<br>
Obiekty (EJB) sπ <span
 style="font-weight: bold; color: rgb(255, 0, 0);">POJO</span>!<br>
Te POJO sπ zarzπdzane przez kontener (czasem na zasadzie wzorca
dependency injection), z dodatkowπ, niewidocznπ dla programisty,
autogeneracjπ niezbÍdnych ≥πcznikÛw, obiektÛw
poúredniczπcych itp.<br>
Jak ma siÍ to dziaÊ - okreúlajπ w sposÛb deklaratywny <span
 style="font-weight: bold; color: rgb(255, 0, 0);">adnotacje</span>,
ew. moøna teø uøyÊ deskryptorÛw wdroøenia lub stosowac obie te metody
rÛwnolegle. <br>
<br><span style="font-weight: bold;">Interfejsy biznesowe</span><br>
<br>W nowym modelu pos≥ugujemy siÍ "czystymi" (POJO) interfejsami
biznesowymi.<br>Przywo≥ujπc omÛwiony wczeúniej przyk≥ad kalkulatora
podatkowego zamiast nienaturalnego<br>
<br><pre>import javax.ejb.EJBObject;
import java.rmi.RemoteException;
import java.math.*;

public interface Pit extends EJBObject {
    public BigDecimal taxToPay(BigDecimal income) throws RemoteException;
}
</pre>
<br>moøemy teraz pisaÊ:<br>
<br><pre>import java.math.BigDecimal;
import javax.ejb.Remote;

@Remote
public interface Pit {
  public BigDecimal taxToPay(BigDecimal income);
}
</pre>
<br><!----><a name="ind.14.5"></a><!---->Adnotacja @Remote mÛwi o tym,
øe interfejs pos≥uøy zdalnym
obiektom. Bez niej (lub z uøyciem adnotacji @Local) &nbsp;bÍdziemy
mieli obiekty lokalne.<br>
<br>Warto zwrÛciÊ uwagÍ, øe to jest prawdziwy interfejs biznesowy,
implementowany w klasie biznesowego ziarna. Programowanie odbywa siÍ
dalej w kategoriach tego interfejsu, a nie interfejsu Home.<br>
<br><span style="font-weight: bold;"><!----><a name="ind.14.6"></a>EJB
3.0 - komponenty sesyjne<!----><br>
<br></span>Sesyjne komponenty EJB:<br>
<ul><li>sπ programowane za pomocπ klas typu POJO i nie muszπ
dziedziczyÊ
SessionBean i dostarczaÊ implementacji metod SessionBean (zatem mogπ
dziedziczyÊ inne klasy POJO),</li><li>oznaczamy je adnotacjπ @Stateless
(w przypadku komponentÛw
bezstanowych) lub @Stateful (dla kompoenntÛw stanowych).</li></ul>
<br>Zamiast:<br>
<br><pre>import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import java.math.*;


public class PitBean implements SessionBean {

    private BigDecimal taxRate = new BigDecimal("0.14");

    public PitBean() {
    }

    public BigDecimal taxToPay(BigDecimal income) {
        BigDecimal result = income.multiply(taxRate);

        return result.setScale(2, BigDecimal.ROUND_UP);
    }


    // Metoda wo≥ana przy tworzeniu obiektu ziarna
    public void ejbCreate() {
    }

    // Metody interfejsu SessionBean

    public void ejbRemove() {
    }

    public void ejbActivate() {
    }

    public void ejbPassivate() {
    }

    public void setSessionContext(SessionContext sc) {
    }
}</pre>
<br>piszemy teraz&nbsp;znacznie krÛcej i bardziej naturalnie, uøywajπc<!----> <a
 name="ind.14.7"></a><!---->adnotacji @Stateless:<br>
<br><pre>package pit.ejb;
import java.math.BigDecimal;
import javax.ejb.*;


@Stateless
public class PitBean implements Pit {
  private BigDecimal taxRate = new BigDecimal("0.14");

  public PitBean() {
  }

  public BigDecimal taxToPay(BigDecimal income) {
      BigDecimal result =  income.multiply(taxRate);
      return result.setScale(2, BigDecimal.ROUND_UP);

  }

}</pre>
<br>Klasa komponentu moøe implementowaÊ od razu dwa interfejsy - zdalny
i lokalny.<br>
Ponadto, jeúli nie opatrzymy interfejsu adnotacjπ @Remote, to o
"zdalnoúci" obiektu moøemy zdecydowac przy implementacji:<br>
<br><pre>public interface Pit {
//...
}

@Stateless @Remote
public PitBean implements Pit {
// ...
}
</pre>
NiektÛre serwery aplikacji (JBoss, Resin)&nbsp; potrafiπ takøe
generowaÊ niezbÍdne interfejsy na podstawie<!----> <a name="ind.14.8"></a><!---->adnotacji
@BusinessMethod w
klasie komponentu.<br>
Uwaga: autogeneracja interfejsÛ biznesowych nie jest najlepszym
pomys≥em i naleøy tego unikaÊ, bowiem jesteúmy wtedy przywiπzani do
wygenerowanych nazw.<br>
<br>Po wdroøeniu EJB automatycznie generowane sπ obiekty posredniczπce
i
klient ma do nich dostÍp m.in.&nbsp; poprzez JNDI. Wyszukiwanie jest
uproszczone, nie ma teø mÍczπcego rzutowania za pomocπ metody
narrow(...). Nie trzeba dostarczaÊ øadnych deskryptorÛ wdroøenia!<br>
<br>Zobaczmy.<br>
Dotychczas musieliúmy pisaÊ tak.<br>
<pre>import javax.naming.Context;
import javax.naming.InitialContext;
import javax.rmi.PortableRemoteObject;
import java.math.BigDecimal;

public class PitClient {
    public static void main(String[] args) {
        try {
            Context initial = new InitialContext();
            Context myEnv = (Context) initial.lookup("java:comp/env");
            Object objref = myEnv.lookup("ejb/Pit");

            PitHome home =
                (PitHome) PortableRemoteObject.narrow(objref,
                    PitHome.class);

            Pit pit = home.create();

            BigDecimal income = new BigDecimal("100000.00");
            BigDecimal tax = pit.taxToPay(income);

            System.out.println("Podatek wynosi: " + tax);

            System.exit(0);

        } catch (Exception ex) {
            System.err.println("Caught an unexpected exception!");
            ex.printStackTrace();
        }
    }
}</pre>I
na dodatek dostarczyÊ odpowiedniego deskryptora wdroøenia.<br>
<br>Teraz pos≥ugujemy siÍ bezpoúrednio interfejsem biznesowym (bez
interfejsu Home), nie musimy uøywac metody create() ani teø pisaÊ czy
generowaÊ deskryptorÛw:<br>
<br><pre>Pit pit;
// ....&nbsp;

     try {
        InitialContext ic = new InitialContext();
        pit = (Pit) ic.lookup("pit.ejb.Pit");
      } catch (NamingException e) {
        e.printStackTrace();
      }
      BigDecimal income = new BigDecimal("100000.00");
      BigDecimal tax = pit.taxToPay(income);
      System.out.println("Podatek wynosi: " + tax);
</pre>
ZwrÛÊmy uwagÍ, øe forma nazwy JNDI dla zdalnego obiektu
biznesowego jest zaleøna od serwera aplikacji. W podanym przyk≥adzie
pit.ejb.Pit jest nazwπ automatycznie generowanπ przez Sun Application
Server 9 dla typu Pit umieszczonego w pakiecie pit.ejb.<br>
<br>Pojawiajπ siÍ&nbsp; g≥osy, øe zastosowanie JNDI nie jest najlepszym
rozwiπzaniem, bo:<br>
<ul><li>nazwa zasobu musi byÊ uzgodniona pomiÍdzy klientem i serwerem
(a to jest String, nie ma wiÍc kontroli),</li><li>mamy rzutowanie,
ktÛry moøe powodowaÊ ClassCastException</li><li>lookup (zawsze w bloku
try) jest nieco ømudny,
szczegÛlnie, jesli go trzeba powtarzaÊ w rÛønych
czÍúciach aplikacji.</li></ul>
Z poziomu klientÛw dzia≥ajπcych w kontenerach WEB oraz
kontenerach klienckich moøna -<!----> <a name="ind.14.9"></a><!---->zamiast
JNDI - zastosowac<!----> <a name="ind.14.10"></a><!---->adnotacjÍ
@EJB. W tym miejscu zadzia≥a mechanizm "dependency injection", a
oprogramowanie klienta staje siÍ jeszcze prostsze, a przy tym przenoúne
pomiÍdzy rÛønymi serwerami aplikacji.<br>
Np.<br>
<pre>public class PitClient  {

  @EJB
  private static Pit pit;    // iniekcja obiektu zdalnego

  public static void main(String[] args) {
      BigDecimal income = new BigDecimal("100000.00");
      BigDecimal tax = pit.taxToPay(income);
      System.out.println("Podatek wynosi: " + tax);
  }

}
</pre>Uwaga:
powyøej pole pit musi byÊ statyczne, poniewaø iniekcja nastÍpuje
podczas wywo≥ania statycznej metody main.<br>
<br><span style="font-weight: bold;">Zarzπdzanie cyklem øycia EJB</span><br>
<br>W klasycznym EJB do zarzπdzania cyklem øycia komponentÛw sπ
stosowane metody typu callback (implementacja interfejsu SessionBean).<br>
Nawet jeúli ich nie potrzeba - to musimy daÊ puste implementacje.<br>
W EJB 3.0 - kaøda metoda w klasie EJB (POJO) moøe byÊ typu "life cycle
management callback", jeúli opatrzymy jπ odpowiedniπ adnotacjπ. <br>
Rodzaje adnotacji.<br>
<ul><li><span style="font-weight: bold;"><!----><a name="ind.14.11"></a>@PostConstruct<!----></span>:
Metoda wo≥ana zaraz po utworzeniu obiektu. Stateless i
stateful session beans.</li><li><span style="font-weight: bold;"><!----><a
 name="ind.14.12"></a>@PreDestroy</span><!---->: Metoda wo≥ana tuø
przed usuniÍciem egzemplarza z puli obiektÛw. Stateless i stateful
session beans.</li><li><span style="font-weight: bold;"><!----><a
 name="ind.14.13"></a>@PrePassivate</span><!---->: &nbsp;Przed
pasywacjπ stateful session bean.</li><li><span
 style="font-weight: bold;"><!----><a name="ind.14.14"></a>@PostActivate</span><!---->:
Po aktywacji</li><li><span style="font-weight: bold;"><!----><a
 name="ind.14.15"></a>@Init</span><!---->: Jak @PostConstruct ale moøe
byÊ wiele metod z adnotacjπ @Init
(dla stetful). KtÛra z nich jest wo≥ana, zaleøy do tego jak
ziarno zosta≥o utworzone (zob.&nbsp; EJB 3.0 specification). Metoda
@PostConstruct jest wo≥ana po @Init.</li></ul>
<span style="font-weight: bold;"><!----><a name="ind.14.16"></a>Iniekcje
zasobÛw<!----></span><br>
<br>Zasoby (takie jak zasoby bazodanowe, konteksty sesji, kolejki JMS)
moøna definiowac za pomocπ adnotacji<!----> <a name="ind.14.17"></a><!---->@Resource.
Powoduje to
"wstrzykniÍcie" odpowiednich referencji, pozwala unikaÊ stosowania
metody lookup(...) i rzutowania, a takøe ogranicza lub nawet
ca≥kowiecie eliminuje &nbsp;koniecznoúc stosowania deskryptorÛw
wdroøenia.<br>
<br>Przyk≥ady:<br>
<pre>@Resource
SessionContext ctx;


@Resource (name="jdbc/SomeDB")
DataSource myDb;

@Resource (name="ConnectionFactory")
QueueConnectionFactory factory;

@Resource (name="queue/A")
Queue queue;
</pre><br>
<span style="font-weight: bold;">Iniekcje za poúrednictwem setterÛw</span><br>
<br>Adnotujπc metody set (dla pÛl) uzyskujemy ten sam efekt co przy
adnotacji pÛl. Np.<br>
<br><pre>@Resource(name="jdbc/JakasBD")
public void setDataSource(DataSource ds)
&nbsp; &nbsp;this.ds = da;
}
</pre>
To samo dotyczy adnotacji @EJB.<br>
<br><span style="font-weight: bold;">Programowanie aspektowe</span><br>
<br>W EJB 3.0 dostÍpna jest prosta forma programowania aspektowego.
DziÍki
tzw.<!----> <a name="ind.14.18"></a><!---->interceptorom moøemy
przechwytywaÊ wywo≥ania metod
komponentÛw EJB, sprawdzaÊ lub zmieniaÊ ich argumenty,
modyfikowac wyniki.<br>
<br>Moøna np. adnotowaÊ klasÍ bezstanowego komponentu sesyjnego za
pomocπ
adnotacji<!----> <a name="ind.14.19"></a><!---->@Interceptors, podajπc
klasy odpowiedzialne za
przechwytywanie wywo≥aÒ metod komponentu.<br>
<br><pre>@Stateless
@Interceptors{ (Test.class) }
public class SlesBean implements BusInterf {
//...
}</pre>
W klasach tych metody przechwytujπce oznaczamy adnotacjπ<!----> <a
 name="ind.14.20"></a><!---->@AroundInvoke.<br>
Metody takie - jako argument - powinny mieÊ referencjÍ do obiektu typu
InvocationContext i powinny zwracaÊ wynik typu Object.<br>
<pre>public class Test {

  @AroundInvoke
  public Object testArgsAndAddTxtToResult(InvocationContext ic) throws Execption {
  // ...
  }&nbsp;&nbsp;</pre>Interfejs
InvocationContext dostarcza metod manipulacji na argumentach wywo≥ania
i otrzymanych wynikach.<br>
<br><span style="font-weight: bold;"><!----><a name="ind.14.21"></a>EJB
3.0 - komponenty encyjne<!----> i&nbsp;Java Persistance API</span><br>
<br>DziÍki rozbudowanemu<!----> <a name="ind.14.22"></a><!---->Java
Persistance API (korzystajπcego z najlepszych
doúwiadczeÒ Hibernate, JDO i TopLInk) niezwykle ≥atwe staje siÍ
odzworowanie obiektowo-relacyjne (O/R mapping).<br>
<br>Za pomocπ odpowiednich adnotacji komponenty encyjne "od razu"
definiujπ tabele w bazie danych. Np.<br>
<pre>@Entity
@Table(name="SCHOOL_STUDENT")   // nazwa tabeliw  bazie danych

public class Student implements Serializable {

  private String id;
  private String name;

  public Student() {
  }

  public Student(String index, String name) {
    this.id = index;
    this.name = name;
  }


  @Id                        // klucz g≥Ûwny
  public String getId() {
    return id;
  }

  public void setId(String index) {
    this.id = index;
  }



  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

}
</pre>Serwer
aplikacji odwzoruje tabelÍ SCHOOL_STUDENT z domyúlnymi nazwami
kolumn ID i NAME na obiekty klasy Student. A nawet - przy odpowiednio
ustawionych opcjach - utworzy takπ tabelÍ jeúli jej nie ma. Moøemy teø
dostosowaÊ nazwy kolumn za pomocπ odpowiednich adnotacji @Column
stawianych przed getterami.<br>
<br>ZwrÛÊmy uwagÍ, øe Entity Bean jest tu klasπ POJO, moøe spokojnie
dziedziczyÊ inne klasy, implementowaÊ dowolne interfejsy itp. Co wiÍcej
- obiekty tej klasy mogπ byÊ dostÍpne po stronie klienta, co w starym
modelu nie by≥o moøliwe i powodowa≥o koniecznoúÊ stosowania tzw.
Transfer Object (tylko po to, by udostÍpniÊ wartoúci odczytane z bazy).
Tutaj wystarczy zapewniÊ serializacjÍ komponentu encyjnego by by≥ on
dostÍpny zdalnie po stronie klienta.<br>
<br><!----><a name="ind.14.23"></a><!---->Relacje pomiÍdzy tabelami
wprowadzamy za pomocπ adnotacji:<br>
@ManyToMany, @ManyToOne, @OneToOne, @OneToMany<br>
a takøe z uzyciem po≥πczeÒ tabel za poúrednictwem adnotacji @JoinTable.<br>
(przyk≥ady bÍdπ omÛwione dalej).<br>
<br>Komponentami encyjnymi zarzπdza tzw.<!----> <a name="ind.14.24"></a><!---->EntityManager.
<!----><a name="ind.14.25"></a><!---->Zestaw zarzπdzanych
komponentÛw nazywa siÍ kontekstem persystencji (Persistence
Context). Aby uzyskaÊ dostÍp do zarzπdcy stosujemy iniekcjÍ:<br>
<br><pre>@PersistenceContext
EntityManager em;
</pre>
<br>Obiekty utrwalamy w bazie za pomoca metody persist()
EntityManagera, usuwamy za pomocπ metody remove(). Na przyk≥ad:<br>
<br><pre>@PersistenceContext EntityManager em;
// ...

Student s = new Student("s0001", "Kowalski Jan");
em.persist(s);

// ....
Student p =  em.find(Student.class, "s0001");
em.remove(p);


</pre>
Uwaga: pominÍto obs≥ugÍ wyjπtkÛw<br>
<br>Przy usuwaniu&nbsp;najpierw za pomocπ find wyszukujemy w bazie
odpowiedni obiekt.<br>
Oczywiúcie - find ma ogÛlne zastosowanie - wyszukiwania obiektu po
kluczu g≥Ûwnym.<br>
<br>Bardziej zaawansowane sposoby przeszukiwania bazy danych wymagajπ
uøycia tzw.<!----> <a name="ind.14.26"></a><!---->Java Persistance
Query Language (JPQL). Jest on podobny
sk≥adniowo do instrukcji SELECT, ale dzia≥a na obiektach i pozwala
nawigowaÊ pomiÍdzy obiektami. EntityManager - za pomocπ metod -
createQuery(...) i createNamedQuery(...) pozwala tworzyÊ i wykonywac
dynamiczne i statyczne zapytania.<br>
Np.<br>
<pre>public List&lt;Student&gt; findStudents(String name) {
  return em.createQuery(
&nbsp;&nbsp;  "SELECT s FROM Student s WHERE s.name LIKE :studName")
&nbsp;&nbsp;     .setParameter("studName", name)
     &nbsp;&nbsp;.getResultList();
}</pre>Tutaj
createQuery() tworzy obiekt typu Query. Jest to zapytanie z
parametrem o nazwie studName. Za pomocπ metody setParameter (wo≥anej na
rzecz Query) ustalamy wartoúÊ parametru. Metoda getResultList() zwraca
listÍ wynikÛw zapytania.<br>
<br><!----><a name="ind.14.27"></a><!---->Zapytania nazwane
("namedQueries") sπ statyczne. Ich zaletπ jest to, øe
podlegajπ sk≥adniowej weryfikacji w fazie wdroøenie. Mogπ byÊ takøe
prekompilowane.<br>
Definiujemy je (w klasach komponentÛ encyjnych) za pomocπ adnotacji
@NamedQuery lub @NamedQueries np.<br>
<pre>@NamedQuery(
&nbsp;&nbsp;name="getAllStudents",
&nbsp;&nbsp;query="SELECT s FROM Student s"
)</pre>i
uøywamy za pomocπ metody createNamedQuery EntityManagera, np.:<br>
<br><pre>List&lt;Student&gt; result = em.createNamedQuery("getAllStudents").getResultList();</pre>
<br>Aby korzystaÊ z EntityManagera musimy dostarczyÊ plik
persistance.xml,
ktÛry definiuje tzw. jednostkÍ persystencji (persistence unit).
Zwykle bÍdzie to doúÊ prosty plik wdroøeniowy, ktÛry okreúla
rodzaj transakcji, nazwÍ JNDI dla ürÛd≥a danych oraz ew.
dodatkowe w≥aúciwoúci (np. czy tabele majπ byÊ generowane automatycznie
na podsatwie definiocji komponentÛw encyjnych). Plik taki oraz
jego umiejscowienie zostanie &nbsp;pokazany w dalszych przyk≥adach.<br>
<br>WiÍcej informacji o EJB 3.0 i Java Persistane API zobacz:<br>
J2EE 5 Tutorial<br>
EJB 3.0 Specification<br>
Java Persistance API Specification<br>
<br><a name="W14.3"></a><a name="EJBIntro.9"></a><h2>9. Praktyka EJB 3.0 i<!----> <a
 name="ind.14.28"></a>Sun Java System Application Server 9<!----></h2>
Aby mÛc praktycznie &nbsp;wyprÛbowaÊ dzia≥anie
elementÛw EJB 3.0 skorzystamy z pierwszego serwera aplikacji,
ktÛry implementuje finalnπ specyfikacjÍ EJB 3.0. Jest to Sun
Javav System Application Server 9. Powsta≥ on dosyÊ szybko dziÍki temu,
øe kod
poprzednich wersji serwera Sun zosta≥ otwarty i przekazany do projektu
GlassFish (<a href="http://java.sun.com/javaee/community/glassfish/">zob.
o projekcie GlassFish</a>).<br>
<br>PokaøÍ jednoczeúnie jak z poziomu Eclipse moøna w ≥atwy sposÛb<!----> <a
 name="ind.14.29"></a><!---->pisaÊ i wdraøaÊ aplikacje w úrodowsiku
SJAS 9.<br>
<br>Przede wszystkim po to by programy kompilowa≥y siÍ w Eclipse naleøy
dodaÊ odpowiednie JARy z katalogu lib serwrera. Moøna to zrobiÊ
definiujπc w Workspace bibliotekÍ, Nazwa≥me jπ j2ee5. Tworzπc nowy
projekt dodamy jπ do niego.<br>
<br><img style="width: 670px; height: 536px;" alt="r"
 title="Biblioteka z pakietami J2EE5"
 src="images/lib.jpg"><br>
<br><br>
&nbsp;<br>
BÍdziemy tworzyÊ prosty sesyjny komponent bezstanowy PitBean -
kalkulator pit.<br>
èrÛdla umieúcimy w katalogu src<br>
èrÛd≥owy pakiet nazwiemy pit, a komponent PitBean umieúcimy w
podpakiecie pit.bean.<br>
Po to by&nbsp; ten komponent, jak i wolnostojπcy klient mieli
niezaleøny dostÍp do interfejsu biznesowego Pit umieúcimy ten interfejs
w podpakiecie pit.common. Pakietem klienta bÍdzie pit.client i tam
dostarczymy klasy PitClient.<br>
èrÛd≥a bÍdπ kompilowane do katalogu bin (katalogi odpowiadajπce
pakietom zostanπ stworzone automatycznie). <br>
<img style="border: 1px solid ; width: 242px; height: 181px;" alt="r"
 src="images/pitsrc.jpg"><br><br>
<br>Taka organizacja kodu ürÛd≥owego przyda siÍ szczegÛlnie w bardziej
zaawansowanych przypadkach.<br>
Interfejs biznesowy juø znamy. Dla porzπdku:<br>
<br><table summary="" border="1" cellpadding="3" cellspacing="0"
 width="100%"> <tbody> </tbody>
</table><pre>package pit.common;

import java.math.BigDecimal;

public interface Pit {
  public BigDecimal taxToPay(BigDecimal income);
}</pre>
&nbsp;<br>
Sam komponent sesyjny takøe niczym siÍ nie wyrÛønia (warto tylko
zwrÛciÊ uwagÍ na&nbsp;adnotacje):<br>
<br><pre>package pit.ejb;
import java.math.BigDecimal;
import javax.ejb.*;

import pit.common.*;

@Stateless @Remote
public class PitBean implements Pit {
  private BigDecimal taxRate = new BigDecimal("0.14");

  public PitBean() {
  }

  public BigDecimal taxToPay(BigDecimal income) {
      BigDecimal result =  income.multiply(taxRate);
      return result.setScale(2, BigDecimal.ROUND_UP);
  }

}</pre>
<br>Natomiast piszπc program kliencki przewidziano trzy moøliwe tryby
jego uruchomienia, regulowane przez argument metody main:<br>
<ul><li>brak argumentu - klient dzia≥a w kontenerze klienta,</li><li>argument
"JAVA_CLIENT" - klient dzia≥a samodzielnie, poza kontenerem klienta</li><li>argument
"JAVA_APP" - ca≥oúÊ uruchamiana poza interakcjπ z
serwerem, jako zwyk≥a aplikacja Javy (np. w celach testowania
interfejsu graficznego)</li></ul>
Warto w &nbsp;tym miejscu odnotowaÊ, øe uruchomienie klienta w
kontenerze klienta wymaga zastosowania instrukcji appclient. Dostarcza
ona odpowiedniego úrodowiska, m.in. pozwalajπcego na dokonanie
odpowiedniej iniekcji w miejscu adnotacji @EJB. Poza kontenerem klienta
(opcja JAVA_CLIENT)&nbsp; iniekcja nie jest moøliwa i potrzebne jest
siÍgniÍcie do JNDI.<br>
Stπd teø w programie klienta pojawia siÍ wywo≥anie metody init(),
ktÛra -w &nbsp;zaleønoúci od opcji - odpowiednio inicjuje
referencjÍ Pit pit.<br>
<br><br>
<pre>import javax.naming.*;
import javax.swing.*;

import pit.common.*;


@SuppressWarnings("serial")
public class PitClient extends JFrame implements ActionListener {

  @EJB
  private static Pit pit;

  private JTextField intf = new JTextField(10);
  private JLabel result = new JLabel();

  public PitClient() {
    this("DEFAULT_CONTEXT");
  }

  public PitClient(String appType) {
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    init(appType);
    setTitle("Tax calculator");
    intf.setBorder(BorderFactory.createTitledBorder("Income"));
    result.setPreferredSize(intf.getPreferredSize());
    result.setOpaque(true);
    result.setBackground(Color.WHITE);
    result.setForeground(Color.RED);
    result.setBorder(BorderFactory.createTitledBorder("Tax to pay"));
    setLayout(new FlowLayout());
    JButton calc = new JButton("Calc");
    add(intf);
    add(calc);
    add(result);
    intf.addActionListener(this);
    calc.addActionListener(this);
    pack();
    this.setLocationRelativeTo(null);
    setVisible(true);
  }

  public void actionPerformed(ActionEvent e) {
    result.setText("");
    BigDecimal income = null;
    String in = intf.getText().trim();
    try {
      income = new BigDecimal(in);
    } catch (NumberFormatException exc) {
        JOptionPane.showMessageDialog(null, "Invalid income: " + in);
        return;
    }
    BigDecimal tax = pit.taxToPay(income);
    result.setText(tax.toString());
  }

  private void init(String type) {
    if (type.equals("JAVA_APP")) pit = new pit.ejb.PitBean();
    else if (type.equals("JAVA_CLIENT")) {
      try {
        InitialContext ic = new InitialContext();
        pit = (Pit) ic.lookup("pit.common.Pit");
      } catch (NamingException e) {
        e.printStackTrace();
      }
    }
  }



  public static void main(String[] args) {
    if (args.length &gt;= 1) new PitClient(args[0]);
    else new PitClient();
  }


}</pre>Oczywiúcie,
aplikacjÍ nie wystarczy skompilowac, trzeba jπ rÛwnieø wdroøyÊ.<br>
Wdroøenie wymaga:<br>
<ul><li>stworzenia archiwum JAR zawierajπcego komponenty EJB,</li><li>stworzenie
archiwum JAR zawierajπcego klienta, przy czym MANIFEST.MF musi zwieraÊ
nazwÍ g≥ownej klasy (zwierajπcej metodÍ main)</li><li>stworzenia
archiwum JAR zawierajπcego wspÛlne elementy,
dostÍpne dla wszystkich modu≥Ûw (w tym przypadku interfejs Pit).</li><li>stworzenia
archiwum WAR (zawierajπcego WEB modu≥ aplikacji; tutja go pominiemy),</li><li>spakowania
archiwÛw do archiwum EAR, przy czym biblioteki
dostÍpne dla wszystkich modu≥Ûw powinny siÍ znaleüÊ w katalogu
lib tego archiwum.</li></ul>
<br>BÍdziemy takøe chcieli stworzyÊ katalog javaclient, ktÛry bÍdzie
zawiera≥ klasy potrzebne do dzia≥ania wolnostojπcego klienta
(dzia≥ajπcego poza kontenerem klienta) oraz odpowiedni skrypt
uruchomieniowy (dostarczajπcy odpowiednich bibliotek dla dzia≥ania
poprzez JNDI).<br>
<br>Wszystkie te dzialania, jak rÛwnieø samo wdroøenie oraz
uzyskanie z serwera&nbsp;archiwum klienta gotowego do dzia≥ania w
kontenerze klienta zapiszemy jednokrotnie w skrypcie Anta. BÍdziemy
mogli go wykorzystaÊ dla kaødej innej aplikacji.<br>
<br>Skrypt - na podstawie w≥aúciwoúci zapisanych w pliku build.props
-wykonuje te wszystkie dzia≥ania. Poniewaø praktycznie dla kaødego
projektu bÍdziemy mieli tÍ samπ sekwencjÍ dzia≥aÒ g≥Ûwny kod
skryptu zapiszemy jednokrotnie jako defbuild.xml w katalogu common.
UmiÍscimy tam rÛwnieø wspÛlne w≥aúciwoúci dla wszystkich
projektÛw. Do kaødego projektu bÍdziemy dostarczaÊ takiego
samego, krÛtkiego build.xml, ktÛry wywo≥uje defbuild.xml.<br>
<br>Plik ogÛlnych w≥aúciwoúci common.properties:<br>
<pre>javaee.home= ... tu trzeba podaÊ úcieøkÍ do instalacji SJAS 9
javaee.server.name=localhost
javaee.server.port=8080
javaee.adminserver.port=4848
javaee.server.username=admin
asadmin=asadmin.bat</pre>Plik
specyficznych w≥aúciwoúci projektu - build.props:<br>
<pre>app=Pit1                                 // nazwa aplikacji
pack=pit                                 // pakiet
has.ejb=yes                              // czy ma modu≥ EJB
has.clientjar=yes                        // czy ma JAR klienta
has.javaclient=yes                       // czy zrobiÊ wolnostojπcego klienta
has.common=yes                           // czy ma klasy dzielone pomiÍdzy modu≥y
main.class=pit.client.PitClient          // nazwa g≥Ûwnej klasy klienta
</pre>Generalny
skrypt Ant - defbuild.xml<br>
<br><pre>&lt;!-- Konfiguracja wlasciwosci  --&gt;
&lt;property file="../common/common.properties"/&gt;
&lt;property file="build.props"/&gt;

&lt;target name="prepare" depends="init"&gt;
         &lt;mkdir dir="dist"/&gt;
         &lt;delete&gt;
           &lt;fileset dir="dist" includes="**/*.jar **/*.war **/*.ear"/&gt;
         &lt;/delete&gt;
&lt;/target&gt;


&lt;target name="ejb" if="has.ejb" depends="prepare"&gt;
  &lt;jar jarfile="dist/\${app}Ejb.jar"&gt;
       &lt;fileset dir="bin" includes="\${pack}/ejb/**.*class"/&gt;
       &lt;fileset dir="bin/\${pack}/ejb" includes="META-INF/**.*"/&gt;
  &lt;/jar&gt;
&lt;/target&gt;


&lt;target name="war" if="has.war" depends="prepare"&gt;
  &lt;delete dir="webbuild"/&gt;
  &lt;mkdir dir="webbuild"/&gt;
  &lt;mkdir dir="webbuild/WEB-INF"/&gt;
  &lt;mkdir dir="webbuild/WEB-INF/classes"/&gt;
  &lt;copy todir="webbuild"&gt;
     &lt;fileset dir="bin/\${pack}/web" excludes="**.*class"/&gt;
  &lt;/copy&gt;
  &lt;copy todir="webbuild/WEB-INF/classes"&gt;
    &lt;fileset dir="bin" includes="\${pack}/web/**.*class"/&gt;
  &lt;/copy&gt;
  &lt;jar jarfile="dist/\${app}.war" basedir= "webbuild"/&gt;
&lt;/target&gt;

&lt;target name="client-jar" if="has.clientjar" depends="prepare"&gt;
   &lt;manifest file="MANIFEST.MF"&gt;
     &lt;attribute name="Main-Class" value="\${main.class}"/&gt;
   &lt;/manifest&gt;
   &lt;jar jarfile="dist/\${app}Client.jar" manifest="MANIFEST.MF"&gt;
       &lt;fileset dir="bin" includes="\${pack}/client/**.*"/&gt;
   &lt;/jar&gt;
   &lt;delete file="MANIFEST.MF"/&gt;
&lt;/target&gt;

&lt;target name="prepare-lib"&gt;
  &lt;delete dir="dist/lib"/&gt;
  &lt;mkdir dir= "dist/lib"/&gt;
&lt;/target&gt;

&lt;target name="common" if="has.common" depends="prepare,prepare-lib"&gt;
  &lt;jar jarfile="dist/lib/\${app}Common.jar"&gt;
        &lt;fileset dir="bin" includes="\${pack}/common/**.*class"/&gt;
  &lt;/jar&gt;
&lt;/target&gt;

&lt;target name="entity" if="has.entity" depends="prepare,prepare-lib"&gt;
  &lt;jar jarfile="dist/lib/\${app}Entity.jar"&gt;
        &lt;fileset dir="bin" includes="\${pack}/entity/**.*class"/&gt;
        &lt;fileset dir="bin/\${pack}/entity" includes="META-INF/**.*"/&gt;
  &lt;/jar&gt;
&lt;/target&gt;


&lt;target name="java-client" if="has.javaclient" depends="prepare"&gt;
   &lt;mkdir dir="javaclient"/&gt;
   &lt;delete&gt;
     &lt;fileset dir="javaclient" includes="**/*.*"/&gt;
   &lt;/delete&gt;
   &lt;copy todir="javaclient"&gt;
     &lt;fileset dir="bin" includes="\${pack}/client/**.*class"/&gt;
     &lt;fileset dir="bin" includes="\${pack}/common/**.*class"/&gt;
     &lt;fileset dir="bin" includes="\${pack}/entity/**.*class"/&gt;
   &lt;/copy&gt;
   &lt;echo file="javaclient/runClient.bat" append="false"
     message="java -cp .;\${javaee.home}/lib/appserv-rt.jar;\${javaee.home}/lib/javaee.jar; \${main.class} JAVA_CLIENT"/&gt;
&lt;/target&gt;

&lt;target name="dist" depends="ejb,entity,war,common,client-jar"&gt;
   &lt;jar jarfile="dist/\${app}.ear" basedir="dist"/&gt;
&lt;/target&gt;

&lt;target name="deploy" depends="java-client,dist"&gt;
        &lt;exec executable="\${asadmin}"&gt;
            &lt;arg line=" deploy "/&gt;
            &lt;arg line=" --user \${javaee.server.username}" /&gt;
            &lt;arg line=" --passwordfile ../common/password.txt" /&gt;
            &lt;arg line=" --contextroot \${app}"/&gt;
            &lt;arg line=" --retrieve ."/&gt;
            &lt;arg line="dist/\${app}.ear" /&gt;
&lt;/exec&gt;
&lt;/target&gt;
</pre>
Jak widaÊ tworzony jest tu katalog dist, w ktÛrym umieszczane sπ
wszystkie JARy. Tworzone sπ teø niezbÍdne katalogi dla klienta itp.
Zadanie dist pakuje ostatecznie niezbÍdne modu≥u do pliku EAR. Zadanie
deploy uruchamia instrukcjÍ asadmin z opcjπ deploy, co powoduje
wdroøenie aplikacji na serwerze. Podajemy przy tym has≥o zapisane w
pliku password.txt, a takøe øadamy za≥adowania jaru klicnckiego (opcja
retrieve).<br>
<br>Majπc to wszystko przygotowane w ≥atwy sposÛb - z poziomu Eclipse -
bÍdziemy mogli wdraøac kaødπ aplikacjÍ.<br>
<br><a
 href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p1/w14p1.html"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt=""
 src="../../../../Stuint/ZaawTechPrg/Wyklady/STYLE/video2.gif"></a><a
 target="_blank"
 href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p1/w14p1.html">Zobacz
prezentacjÍ wdraøania aplikacji Pit</a>.<br>
<br>Po wdroøeniu moøemy sprawdziÊ stan komponentÛw za pomocπ konsoli
administracyjnej serwera. Warto podkreúliÊ, øe identyfikacja
modu≥Ûw przez serwer nastÍpuje na podstawie informacji zawartych
w samych klasach lub JARach (niepotrzeben by≥y øadne deskryptory).<br>
<a href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p2/w14p2.html"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt=""
 src="../../../../Stuint/ZaawTechPrg/Wyklady/STYLE/video2.gif"></a><a
 href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p2/w14p2.html"
 target="_blank">Zobacz prezentacjÍ</a>.<br>
<br><!----><a name="ind.14.30"></a><!---->Klienta aplikacji moøemy
uruchomiÊ teraz na trzy sposoby:<br>
<ul><li>poprzez<!----> <a name="ind.14.31"></a>WebStart<!----> (opcja
Launch na konsoli administracyjnej, ale rÛwnieø przez w≥asny html w
podanej dalej postaci),</li><li>w kontenerze klienta - za pomocπ
isntrukcji appclient,</li><li>jako wolnostojπcego klienta - poprzez
wygenerowany skrypt runClient.bat.</li></ul>
<br>Potrzebny do WebStartu html moøe wyglπdaÊ na przyk≥ad tak:<br>
<br><pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;
&lt;html lang="pl"&gt;
&lt;head&gt;
  &lt;title&gt;WebStart Test&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h2 style="text-align: center;"&gt;Start klienta aplikacji Pit&lt;/h2&gt;
&lt;br&gt;
&lt;div style="text-align: center;"&gt;
&lt;form method="get"
 action="http://localhost:8080/Pit1/Pit1Client"
 name="start"&gt;
 &lt;input name="b" value="Start aplikacji" type="submit"&gt;&lt;br&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>
<a href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p3/w14p3.html"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt=""
 src="../../../../Stuint/ZaawTechPrg/Wyklady/STYLE/video2.gif"></a><a
 href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p3/w14p3.html"
 target="_blank">Zobacz prezentacjÍ WebStartu</a>.<br>
<br><!----><a name="ind.14.32"></a><!---->Uruchomienie aplikacji w
kontenerze klienta odbywa siÍ za pomoca instrukcji appclient.<br>
<br><div class="syntax"><br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; appclient
-client <span style="font-style: italic;">nazwa_pliku_jar_klienta</span><br>
</div><br><br>
Ten JAR klienta dostajemy albo uøywajπc opcji -retrieve przy asadmin
deploy, albo z poziomu konsoli administracyjnej wybierajπc "Download
client stubs".<br>
W obu przypadkach uzyskiwany JAR (z serwera dzia≥ajπcego lokalnie)
zawiera pe≥ne klasy komponentÛw EJB, co oczywiúcie nie powinno
mieÊ miejsca (powinny byÊ tylko stuby).<br>
<br>Dlatego w≥aúnie testujemy teø wolnostojπcego klienta, ktÛry
zawiera tylko odwo≥ania do interfejsu biznesowego, a dostÍp do
komponentÛw EJB uzyskuje zdalnie poprzez JNDI. Tu kluczowπ
sprawπ jest dobÛr odpowiednich dostawcÛw JNDI.
Standardowy (zawarty w Java SE) nie dzia≥a.<br>
W tym celu wystarczy udostÍpniÊ bibliotekÍ appserv-rt.jar, ktÛra
zawiera plik jndi.properties w postaci:<br>
<pre>java.naming.factory.initial=com.sun.enterprise.naming.SerialInitContextFactory
java.naming.factory.url.pkgs=com.sun.enterprise.naming
# Required to add a javax.naming.spi.StateFactory for CosNaming that
# supports dynamic RMI-IIOP.
java.naming.factory.state=com.sun.corba.ee.impl.presentation.rmi.JNDIStateFactoryImpl
</pre>Wymienione
klasy sπ w bibliotece javaee.jar - zatem i jπ naleøy umieúciÊ na
úcieøce classpath.<br>
Robi to dla nas skrypt&nbsp;antowy, produkujπc w wyniku taki oto mniej
wiÍcej runClient.bat.<br>
<br><pre>setlocal
set elib= ... tu katalog lib serwera aplikacji
java -cp .;%elib%\\appserv-rt.jar;%elib%\\javaee.jar  pit.client.PitClient JAVA_CLIENT
endlocal</pre>
<br>Uruchomienie klienta w kontenerze klienta i jako wolnostojπcego <a
 href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p4/w14p4.html"
 target="_blank">pokazuje nastÍpujπca prezentacja</a>.<br>
<br><br>
<br><a name="W14.4"></a><a name="EJBIntro.10"></a><h2>10. Komponenty encyjne i<!----> <a
 name="ind.14.33"></a>elementy Java Persistance API<!----></h2>
Rozwaøymy teraz prosty przyk≥ad bazy danych studentÛw i kursÛw, w
ktÛrych uczestniczπ.<br>
Kaødy student moøe uczestniczyÊ w wielu kursach.&nbsp;<br>
W kaødym kursie moøe uczestniczyÊ wielu studentÛw.<br>
Mamy tu relacjÍ Many-to-Many.<br>
<br><!----><a name="ind.14.34"></a><!---->Komponenty encyjne
przedstawiono na poniøszych wydrukach programÛw.<br>
<br><pre>package school.entity;

import java.io.*;
import java.util.*;

import javax.persistence.*;

import static javax.persistence.CascadeType.REMOVE;

@SuppressWarnings("serial")
@Entity
@Table(name="SCHOOL_STUDENT")
@NamedQueries({
  @NamedQuery(name = "getAllStudents",query = "SELECT s FROM Student s"),

  @NamedQuery(name = "getStudentsForCourse",
      query = "SELECT s FROM Student s, IN (s.courses) AS c WHERE c.id = :course_id"
  )
})


public class Student implements Serializable {

  private String id;
  private String name;
  private Collection&lt;Course&gt; courses;

  public Student() {
  }

  public Student(String index, String name) {
    this.id = index;
    this.name = name;
  }


  @Id
  public String getId() {
    return id;
  }

  public void setId(String index) {
    this.id = index;
  }

  @ManyToMany(cascade = REMOVE, mappedBy = "students")
  public Collection&lt;Course&gt; getCourses() {
    return courses;
  }

  public void setCourses(Collection&lt;Course&gt; courses) {
    this.courses = courses;
  }


  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public String toString() {
    return id + " " + name;
  }


}
&nbsp;</pre>
<pre>package school.entity;

import java.io.*;
import java.util.*;

import javax.persistence.*;

import static javax.persistence.CascadeType.REMOVE;

@SuppressWarnings("serial")
@Entity
@Table(name="SCHOOL_COURSE")
@NamedQueries({
  @NamedQuery(name = "getAllCourses",
      query = "SELECT c FROM Course c"
  ),

  @NamedQuery(name = "getCoursesForStudent",
      query = "SELECT c FROM Course c, IN (c.students) AS s WHERE s.id = :stud_id"
  )

}
)

public class Course implements Serializable{
  private String id;
  private String name;
  private Set&lt;Student&gt; students;

  public Course() {
  }

  public Course(String id, String name) {
    this.id = id;
    this.name = name;
  }

  @Id
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  @ManyToMany(cascade = REMOVE)
  @JoinTable(name = "SCHOOL_COURSE_STUDENT",
    joinColumns = @JoinColumn(name = "COURSE_ID", referencedColumnName = "ID"),
    inverseJoinColumns = @JoinColumn(name = "STUDENT_ID", referencedColumnName = "ID")
  )
  public Set&lt;Student&gt; getStudents() {
    return students;
  }

  public void setStudents(Set&lt;Student&gt; students) {
    this.students = students;
  }

  public void addStudent(Student s) {
    getStudents().add(s);
  }

  public String toString() {
    return id + " " + name;
  }

}</pre>W
klasie Student relacja do kursÛw oznaczona jest adnotacjπ
@ManyToMany. Opcja cascade okreúla sposÛb postÍpowania z
powiπzanymi rekordami (przy usuwaniu). Opcja mappedBy okreúla
powiπzanie z odpowiednim polem klasy Course (istotnie students sπ
kolekcjπ studentÛw uczÍszczajπcych na dany kurs).<br>
W klasie Course okreúlamy powiπzania pomiÍdzy tabelami. &nbsp;Adnotacja
@JoinTable spowoduje wygenerowanie pomocniczej tabeli, w ktÛrej
identyfikatorom studentÛw bÍdπ przyporzπdkowane identyfikatory
kursÛw.<br>
W obu klasach dostarczono definicji nazwanych zapytaÒ (@NamedQueries).
Dok≥adny opis sk≥adni Java Persistence Query Language moøna znaleüÊ w
specyfikacji oraz w Java EE 5 Tutorial.<br>
<br>DostÍp do bazy danych uzyskujemy poprzez DbAccesBean implemntujπcy
interfejs DbAccess.<br>
<br><pre>package school.common;

import java.util.*;

import javax.ejb.*;

import school.entity.*;

@Remote
public interface DbAccess {

  void createCourse(String id, String name) throws SchoolDbException;;
  void createStudent(String id, String name) throws SchoolDbException;
  void assignCourseForStudent(String studId, String courseId) throws SchoolDbException;
  List&lt;Student&gt; getStudents(String courseId);
  List&lt;Course&gt; getCourses(String studId);

}</pre>
<pre>package school.ejb;

import java.util.*;

import javax.ejb.*;
import javax.persistence.*;

import school.common.*;
import school.entity.*;

@Stateful
public class DbAcessBean implements DbAccess {

  @PersistenceContext private EntityManager em;

  public void createCourse(String id, String name) throws SchoolDbException{
    Course c = new Course(id, name);
    try {
      em.persist(c);
    } catch (Exception exc) {
      throw new SchoolDbException(exc + "\\n" + exc.getCause());
    }
  }

  public void createStudent(String id, String name) throws SchoolDbException {
    Student s = new Student(id, name);
    try {
      em.persist(s);
    } catch (Exception exc) {
      throw new SchoolDbException(exc + "\\n" + exc.getCause()) ;
    }
  }



  public void assignCourseForStudent(String studId, String courseId) throws SchoolDbException {
      Student s = em.find(Student.class, studId);
      Course c = em.find(Course.class, courseId);
      if (s == null) throw new SchoolDbException("Invalid student id " + studId);
      if (c == null) throw new SchoolDbException("Invalid course id " + courseId);
      c.addStudent(s);

  }

  @SuppressWarnings("unchecked")
  public List&lt;Student&gt; getStudents(String courseId) {
    List&lt;Student&gt; result = null;
    if (courseId == null)
      result = em.createNamedQuery("getAllStudents").getResultList();
    else
      result = em.createNamedQuery("getStudentsForCourse")
                .setParameter("course_id", courseId)
                .getResultList();
    return result;
  }

  @SuppressWarnings("unchecked")
  public List&lt;Course&gt; getCourses(String studId) {
    List&lt;Course&gt; result = null;
    if (studId == null)
      result =  em.createNamedQuery("getAllCourses").getResultList();
    else
      result = em.createNamedQuery("getCourserForStudent")
                .setParameter("stud_id", studId)
                .getResultList();
    return result;
  }


}</pre>Po
to, by mÛc obs≥ugiwac wyjπtki typu SQLException wprowadziliúmy w≥asnπ
klasÍ SchoolDbException.<br>
<pre>package school.common;

import java.io.*;


@SuppressWarnings("serial")
public class SchoolDbException extends Exception implements Serializable  {

  public SchoolDbException() {
    super();

  }

  public SchoolDbException(String message) {
    super(message);

  }

  public SchoolDbException(String message, Throwable cause) {
    super(message, cause);

  }

  public SchoolDbException(Throwable cause) {
    super(cause);

  }

}</pre>Musi
ona byÊ serializowalna, aby mÛc uzyskaÊ dostÍp do wyjπtku po stronie
klienta.<br>
<br>Testowy klient tworzy studentÛw, kursy, przypisuje studentÛ do
kursÛw i pokazuje wyniki wybranych zapytaÒ.<br>
<br><pre>package school.client;

import java.util.*;

import javax.ejb.EJB;
import javax.naming.*;
import javax.swing.*;

import school.common.*;
import school.entity.*;

public class SchoolDbClient {

  @EJB
  private static DbAccess dba;

  public SchoolDbClient() {
    this("DEFAULT_CONTEXT");
  }

  public SchoolDbClient(String appType) {
    init(appType);
    String[] studs = { "Kowalski Jan", "Kowalska Anna", "Malinowski Jan" };
    try {
      for (int i = 0; i &lt; studs.length; i++) {
        System.out.println("Create student " + i + "\\n");

        dba.createStudent("s000" + i, studs[i]);
      }

      String[] kurs = { "PRG", "WPR", "MPR" };
      for (int i = 0; i &lt; kurs.length; i++) {
        dba.createCourse(kurs[i], kurs[i] + " - opis");
      }

      dba.assignCourseForStudent("s0000", "WPR");
      dba.assignCourseForStudent("s0000", "MPR");
      dba.assignCourseForStudent("s0001", "PRG");
      dba.assignCourseForStudent("s0002", "PRG");
      dba.assignCourseForStudent("s0002", "WPR");
      dba.assignCourseForStudent("s0002", "MPR");
    } catch (SchoolDbException exc) {
      exc.printStackTrace();
      System.exit(1);
    }

    StringBuffer sb = new StringBuffer();

    List&lt;Student&gt; s = dba.getStudents(null);
    for (Student info : s)
      sb.append(info).append('\\n');
    JOptionPane.showMessageDialog(null, sb.toString());

    sb.setLength(0);
    s = dba.getStudents("WPR");
    for (Student info : s)
      sb.append(info).append('\\n');
    JOptionPane.showMessageDialog(null, sb.toString());
  }

  private void init(String type) {
    if (type.equals("JAVA_APP"))
      throw new RuntimeException("Java App not supported");
    else if (type.equals("JAVA_CLIENT")) {
      try {
        InitialContext ic = new InitialContext();
        dba = (DbAccess) ic.lookup("school.common.DbAccess");
      } catch (NamingException e) {
        e.printStackTrace();
      }
    }
  }

  public static void main(String[] args) {
    if (args.length &gt;= 1)
      new SchoolDbClient(args[0]);
    else
      new SchoolDbClient();
  }

}
</pre>
<br>Warto zwrÛciÊ uwagÍ, øe klient pos≥uguje siÍ zdalnymi
komponentami encyjnymi. W przypadku dzia≥ania w kontenerze klienta nie
ma z tym problemu, ale<!----> <a name="ind.14.35"></a><!---->wolnostojπcy
klient nie ma dostÍpu do
niektÛrych klas (np. IndirectList) i po to, by mu to zapewniÊ
naleøy uøyÊ opcji -javaagent przy uruchamianiu.&nbsp;<br>
Tutaj podajemy jako agenta: toplink-essentials-agent.jar.<br>
Naleøy takøe zapewniÊ serializacjÍ klas.<br>
<br>Biblioteka TopLink pozwala takøe&nbsp;tworzyÊ tabele na podstawie
definicji klas encyjnych.<br>
OpcjÍ tÍ specyfikujemy w pliku persistence.xml:<br>
<br><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" version="1.0"&gt;
  &lt;persistence-unit name="em" transaction-type="JTA"&gt;
    &lt;jta-data-source&gt;jdbc/SchoolDB&lt;/jta-data-source&gt;
    &lt;properties&gt;
      &lt;property name="toplink.ddl-generation" value="drop-and-create-tables"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><!----><a
 name="ind.14.36"></a><!---->
ZwrÛÊmy uwagÍ na ürÛd≥o danych. Odpowiedniπ nazwÍ JNDI musimy stworzyÊ
np. z konsoli administracyjnej.<br>
<br><img style="width: 682px; height: 813px;" alt="r"
 src="images/jdbc.jpg"><br>
<br>Tu waøne jest by zapewniÊ odpowiedniπ<!----> <a name="ind.14.37"></a><!---->pulÍ
po≥aczeÒ (lista rozwijalna
Pool Name). Kaødy schemat bazodanowy (odrÍbna baza danych) winien mieÊ
swojπ pulÍ (ktÛrπ moøemy utworzyÊ wybierajπc odpowiedniπ opcjÍ i
podajπc "fizycznπ" nazwÍ bazy, host, port oraz inne parametry).<br>
W przyk≥adowych aplikacjach wygodnie jest korzystaÊ z wbudowanego w
&nbsp;serwer RDBMS Derby.<br>
<br>Dzia≥anie klienta aplikacji SchoolDb obrazuje nastÍpujπca <a
 href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p5/w14p5.html"
 target="_blank">prezentacja</a><a
 href="../../../../Stuint/ZaawTechPrg/Wyklady/W14/mm/w14p5/w14p5.html"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt=""
 src="../../../../Stuint/ZaawTechPrg/Wyklady/STYLE/video2.gif"></a>.<br>
<br><br>
<a name="W14.5"></a><br></body></html>