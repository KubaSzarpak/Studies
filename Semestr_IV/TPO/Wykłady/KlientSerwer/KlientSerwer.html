<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
  <meta name="author" content="Krzysztof Barteczko">
  <meta name="description" content="TPR">
  <meta name="copyright" content="(c) Krzysztof Barteczko PJWSTK 2010">
  <link rel="stylesheet" type="text/css" href="../STYLE/common.css">   
  <title>Programowanie klient serwer z uzyciem gniazd kanalow</title></head>
<body>
<div align="center">
<a name="KlientSerwer"></a><h1>Programowanie klient serwer z uøyciem gniazd, kana≥Ûw i selektorÛw</h1>
</div>
<hr>
<span style="font-style: italic;">Programowanie klient-serwer jest
jednπ z waøniejszych ogÛlnych i uniwersalnych
metodologii budowy systemÛw informatycznych. &nbsp;Zyska≥a ona&nbsp; na
znaczeniu w
dobie rozwoju sieci komputerowych i dzisiaj jest praktycznie
wszechobecna.
Zatem w tym rozdziale zostanie ona omÛwiona g≥Ûwnie pod kπtem aplikacji
sieciowych.
Wiele uwagi poúwiÍcimy oprogramowaniu komunikacji klient-serwer za
pomocπ
gniazd sieciowych, szczegÛlnie zaú stosunkowo nowym na platformie Javy
úrodkom &nbsp;programistycznym: nieblokujπcym kana≥om gniazd i ich
multipleksowaniu
za pomocπ selektorÛw. Przedstawione zostanπ pokrÛtce takøe podejúcia na
nieco
"wyøszym poziomie abstrakcji", m.in. klasy wspierajπce programowanie
klientÛw
protoko≥u HTTP. </span><br style="font-style: italic;"><span style="font-style: italic;">
Tematyka programowania sieciowego jest niezwykle obszerna, nie sposÛb jej
tu omÛwiÊ we wszystkich wymiarach i ze sczegÛlami. Materia≥ powinien byÊ
jednak wystaczajπcy dla nabycia podstawowych umiejÍtnoúci programowania klient-serwer
i tworzenia aplikacji sieciowych.</span><br>
<hr>
<a name="KlientSerwer.1"></a><h2>1. Architektura klient-serwer i sieÊ</h2>
Architektura klient-serwer jest technologiπ budowy systemÛw informatycznych,
polegajπcπ na podziale systemu na wspÛ≥dzia≥ajπce ze sobπ dwie kategorie
programÛw lub procesÛw: klientÛw i serwerÛw. <br>
<br>
<div class="def"><b>Klient</b> to program lub proces, ktÛry - oprÛcz wykonywania swoistych dla
niego dzia≥aÒ -&nbsp; ≥πczy siÍ z innym programem lub procesem, zwanym serwerem
i poprzez kana≥y komunikacyjne zleca mu wykonanie okreúlonych dzia≥aÒ; w
szczegÛlnoúci dostarczenia jakichú danych lub wynikÛw przetwarzania danych</div><br>
<br>
<div class="def"><b>Serwer</b> jest programem lub procesem, ktÛry - na zlecenie klientÛw - úwiadczy
okreúlone us≥ugi - np. dostarcza im dane lub wyniki przetwarzania jakichú
danych</div><br>
<br>
<br>
ZwrÛÊmy uwagÍ na to, øe pojÍcie "klient-serwer" jest natury software'owej,
a nie hardware'owej. Dotyczy programÛw, a nawet ich czÍúci (podprocesÛw,
wπtkÛw), a nie sprzÍtu. Typowym b≥Ídem, pope≥nianym nie tylko w popularnej
literaturze informatycznej, jest identyfikowanie pojÍcia serwer z komputerem
i traktowanie architektury klient-serwer jako wy≥πcznie sposobu komunikacji
pomiÍdzy rÛønymi komputerami w sieci.<br>
Tymczasem koncepcjÍ klient-serwer moøemy zastosowaÊ do budowy systemu informatycznego
dzia≥ajπcego na jednym komputerze w jednym systemie operacyjnym, a nawet
dla budowy systemu, sk≥adajπccego siÍ z jednego programu, w ktÛrym okreúlony
wπtek bÍdzie pe≥ni≥ role serwera, a inne wπtki bÍdπ zlecaÊ mu rÛøne us≥ugi
do wykonania.<br>
<br> Tak naprawdÍ takie by≥y poczπtki tej koncepcji, w czasach, kiedy jeszcze
komputery nie by≥y ≥πczone w sieci. Po to by zapewniÊ komunikacjÍ pomiÍdzy
procesami-serwerami i procesami-klientami w rÛønych systemach operacyjnych
wprowadzono specjalne mechanizmy komunikacji miÍdzyprocesowej (<b>IPC</b> - <i><b>interprocess communication</b></i>).<br>
Naleøπ do nich:<br>
<ul><li>potoki,</li><li>wspÛlne (dzielone) obszary pamiÍci,</li><li>kolejki (jest to bazowy mechanizm systemowy, nie naleøy go myliÊ np. z kolejkami zdarzeÒ).</li><li>semafory.<br>
  </li></ul>
<b>Potoki</b> - to swoiste kana≥y wymiany danych (bufory w pamiÍci), ≥πczπce procesy.<br>
Np. proces-klient moøe zapisywaÊ do potoku jakieú dane (powiedzmy øπdanie
przekazania informacji z serwera), proces-serwer odczytuje to i - poprzez
potok - przekazuje potrzebne klientowi informacje. <br>
<b>WspÛlne (dzielone) obszary pamiÍci</b> sπ tym na co wkazuje ich nazwa.
Jeden z procesÛw moøe alokowaÊ taki obszar, po czym przekazaÊ jego adres
innym procesom. Kaødy z nich teraz moøe korzystaÊ ze wspÛlnej puli informacji,
zmieniaÊ jπ, dodawaÊ do niej "swoje".<br>
<b>Kolejka</b> jest po prostu nazwanπ, uporzπdkowanπ listπ 32-bitowych elementÛw.
Procesy dodajπ elementy do kolejek i wyciπgajπ je z nich (na tym polega komunikacja).
Zwykle elementami tymi sπ adresy wspÛlnych (dzielonych) obszarÛw pamiÍci.
<br>
<br> Jak widzimy, same typy mechanizmÛw wymiany informacji sπ juø doúÊ rozbudowne.&nbsp;
W úrodowisku wielozadaniowym&nbsp; dochodzi jeszcze problem synchronizacji transakcji.
Do jednego "kana≥u" wymiany danych moøe mieÊ dostÍp rÛwnoczeúnie wiele procesÛw.
Co siÍ stanie gdy jeden z nich chce czytaÊ, a drugi pisaÊ w tym samym czasie
? Jak serwer ma stwierdziÊ, øe oto nadesz≥y od klienta instrukcje do wykonania
?<br>
Wszystkie te problemy - na poziomie bazowym - rozwiπzujπ rÛønego rodzaju semafory. <b>Semafory</b>
 stanowiπ znaczniki, ktÛre pokazujπ czy dany zasÛb w danym kontekúcie jest
dla jakiegoú procesu dostÍpny, czy teø jest zajÍty przez inny proces (np. potok do odczytania). <br>
Ale to jeszcze nie wszystko. Bazowe mechanizmy IPC sπ uzupe≥niane (w rÛønych
systemach rÛønie)&nbsp; przez inne komponenty systemowe - na przyk≥ad, strukturÍ
zdarzeniowego programowania aplikacji. Mamy to moøliwoúci posy≥ania odpowiednich
sygna≥Ûw z jednej aplikacji do kolejek zdarzeÒ innej aplikacji, a przez to
generowania zdarzeÒ i zsynchronizowanej wymiany informacji. Niejako unifikacjπ
(a takøe pewnym rozszerzeniem) tego podejúcia jest tzw. dynamiczna wymiana
danych (DDE - dynamic data exchange). DDE pozwala (przy wykorzystaniu prostych
regu≥ i zapewnianych w systemowym API funkcji) na odczytywanie/przekazywanie
danych (a takøe instrukcji do wykonania) pomiÍdzy aplikacjami klient - serwer,
oraz na dynamiczne wiπzanie danych (w≥πcznie z automatycznym odúwieøaniem:
np. gdy zmieniπ siÍ dane w jakimú arkuszu, to odpowiednia tabela w procesorze
tekstÛw ulegnie natychmiastowej modyfikacji). <br>
<br>
Te bogate úrodki wspÛ≥dzia≥ania aplikacji klient-serwer majπ dwie wady:<br>
<ul><li>sπ rÛønie (co do sposobu i co do zakresu) implementowane w rÛønych systemach operacyjnych,</li><li>nie dajπ siÍ ≥atwo uogÛlniaÊ na interakcjÍ pomiÍdzy serwerami i klientami w úrodowisku sieciowym.</li></ul>
A w≥aúnie w úrodowisku sieciowym zalety modelu klient-serwer stajπ siÍ bardzo
wyraüne. Do ogÛlnej lepszej strukturyzacji systemu (przy podziale jego komponentÛw
wedle zasady klient-serwer, co pozwala zarÛwno uproúciÊ system, jak i rÛwnolegle
rozwijaÊ jego rÛøne komponenty) dochodzπ tu bowiem:<br>
<ul><li>moøliwoúÊ podzia≥u pracy pomiÍdzy rÛønymi maszynami odpowiednio do ich potencja≥u i efektywnoúci,</li><li>moøliwoúÊ uzyskiwania us≥ug serwera na odleg≥oúÊ,</li><li>dane mogπ byÊ prowadzone w sposÛb scentralizowany (na serwerze) co zapewnia spÛjnoúÊ i bezpieczeÒstwo,</li><li>mogπ teø byÊ pzrechowywane w sposÛb rozproszony pomiÍdzy rÛznymi loakalizacjami
geograficznymi (rÛønymi serwerami i/lub klientami w rÛønych miejscach), co
zmniejsza ryzyko utraty danych przy awariach.</li></ul>
Wraz z rozpowszechnieniem úrodowisk rozproszonych (sieci) pojawi≥a siÍ potrzeba
swoistej unifikacji mechanizmÛw IPC, tak by mog≥y byÊ stosowane w jednolity
sposÛb do komunikacji &nbsp;klientÛw i serwerÛw dzia≥ajπcych na dowolnych komputerach
w sieci (rÛwnieø na jednym i tym samym komputerze).<br>
<br>Oczywiúcie, komunikacja wymaga przestrzegania pewnych regu≥. Regu≥y te sπ definiowane przez protoko≥y.<br>
<br>
<div class="def"><b>ProtokÛ≥</b> - to swoisty jÍzyk i zasady za pomocπ ktÛrych komunikujπ siÍ programy i procesy, w szczegÛlnoúci serwery i klienci</div><br>
<br>
Protoko≥y interakcji sieciowej sπ podzielone na warstwy, ktÛre wyznaczajπ
poziomy komunikacji. DziÍki temu z≥oøony problem interakcji sieciowej jest
podzielony na podproblemy, za rozwiπzywanie ktÛrych odpowiadajπ protoko≥y
poszczegÛlnych warstw.<br>
<br>
OgÛlny standard tego podzia≥u jest zapisany jako tzw.&nbsp; modelu&nbsp; ISO-OSI (OSI -Open Standards Interconnect).<br>
<p>Model OSI sk≥ada siÍ z&nbsp; siedmiu warstw:</p>
<table align="center" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td bgcolor="#666666"><table style="background-color: rgb(255, 255, 204);" border="0" cellpadding="2" cellspacing="2"><tbody><tr align="center" bgcolor="#cccccc"><td colspan="3" style="text-align: center; background-color: rgb(255, 255, 255);"><p><strong>Komputer 1</strong></p></td><td bgcolor="#ffffcc">&nbsp;</td><td colspan="3" bgcolor="#ffffff" valign="bottom"><p><strong>Komputer 2</strong></p></td></tr><tr align="center" bgcolor="#cccccc"><td align="right" bgcolor="#ffffff"><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Wa
rstwa aplikacji</font></td><td rowspan="6" bgcolor="#ffffcc" valign="bottom"><font color="#000000"><img src="images/v-arrow-r.gif" height="110" width="8">
            </font></td><td bgcolor="#ffffcc"><font color="#000000"><img src="images/h-arrow.gif" height="7" width="30">
            </font></td><td rowspan="6" bgcolor="#ffffcc" valign="bottom"><font color="#000000"><img src="images/v-arrow-r.gif" height="110" width="8">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa aplikacji</font></td><td align="right" bgcolor="#ffffff"><font color="#000000">dane</font></td></tr><tr align="center" bgcolor="#cccccc"><td align="right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa prezentacji</font></td><td bgcolor="#ffffcc"><font color="#000000"><img src="images/h-arrow.gif" height="7" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa prezentacji</font></td><td align="right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="center" bgcolor="#cccccc"><td align="right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sesji</font></td><td bgcolor="#ffffcc"><font color="#000000"><img src="images/h-arrow.gif" alt="r" height="7" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sesji</font></td><td align="right" bgcolor="#ffffff"><font color="#000000">|</font><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="center" bgcolor="#cccccc"><td align="right" bgcolor="#ffffff"><font color="#000000">||</font><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa transportowa</font></td><td bgcolor="#ffffcc"><font colo="" r="#000000"><img src="images/h-arrow.gif" height="7" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa transportowa</font></td><td align="right" bgcolor="#ffffff"><font color="#000000">||</font><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="center" bgcolor="#cccccc"><td align="right" bgcolor="#ffffff"><font color="#000000">|||</font><font color="#000000">|</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sieci</font></td><td bgcolor="#ffffcc"><font co="" lor="#000000"><img src="images/h-arrow.gif" height="7" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa sieci</font></td><td align="right" bgcolor="#ffffff"><font color="#000000">|||</font><font color="#000000">|</font><font color="#000000">dane</font></td></tr><tr align="center" bgcolor="#cccccc"><td align="right" bgcolor="#ffffff"><font color="#000000">|||||</font><font color="#000000">dane</font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa ≥πcza danych
                        </font></td><td bgcolor="#ffffcc"><font color="#000000"><img src="images/h-arrow.gif" height="7" width="30">
            </font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa ≥πcza danych</font></td><td align="right" bgcolor="#ffffff"><font color="#000000">|||||</font><font color="#000000">dane</font></td></tr><tr align="center" bgcolor="#cccccc"><td align="right" bgcolor="#ffffff"><font color="#000000">||||||</font><font color="#000000">dane</font></td><td align="center" bgcolor="#ffffff"><font color="#000000">Warstwa fizyczna</font></td><td colspan="3" bgcolor="#ffffcc"><font color="#000000"><img heigh="" t="7" src="images/h-arrow-r.gif" width="52"></font></td><td bgcolor="#ffffff"><font color="#000000">Warstwa fizyczna</font></td><td align="right" bgcolor="#ffffff"><font color="#000000">||||||</font><font color="#000000">dane</font></td></tr></tbody></table></td></tr></tbody>
</table>
<p>èrÛd≥o: InetDaemon.com tutorial</p>
<p></p>
<ol><li>aplikacje, dzia≥ajπce na dwÛch komputerachw &nbsp;sieci (klient i serwer) wymieniajπ dane.
                </li><li>kolejne protoko≥y w kolejnych warstwach dodajπ
nag≥Ûwki do danych otrzymywanycyh z warstwy powyøej. Dane opakowane w nag≥Ûwki
sπ transmitowane w tzw.&nbsp; <font color="#ff0000"><font color="#000000">Protocol
                Data Units</font> </font>(PDUs).&nbsp;
                </li><li>PDU sπ przesy≥ane w dÛ≥ sekwencji warstw i transmitowane
fizycznie przez warstwÍ fizycznπ, ktÛra reprezentuje fizyczne po≥πczenie
w sieci.
                </li><li>Dane otrzymane sπ przesy≥ane "w gÛrÍ" warstw i "odpakowywane" z kolejnych nag≥ÛwkÛw.
                </li></ol>
Jednπ z moøliwych, a przy tym obecnie czÍsto wystÍpujπcπ realizacjÍ tego modelu przedstawia poniøszy rysunek.<br>
<br>
<img src="images/osi2.jpg" alt="r" border="1" height="461" width="645">
<br><br>
<hr>
<a name="KlientSerwer.2"></a><h2>2. Gniazda.</h2>
<br>
Jak widaÊ z poprzedniego rysunku&nbsp; komunikacja pomiÍdzy procesami w sieci
moøe&nbsp; odbywaÊ siÍ za pomocπ jednego z wysokopoziomowych protoko≥Ûw sieciowych
(HTTP, FTP itp.), a &nbsp;takøe bardziej zaawansowanych mechanizmÛw takich jak
zdalne wywo≥anie metod (RMI, CORBA), zdalne wywo≥anie procedur (RPC), czy
SOAP (pozwalajπcy na zdalne wolanie metod i procedur - inaczej: zlecanie
us≥ug - za pomocπ przekazywania odpowiednio ustrukturyzowanych plikÛw XML
z zapisem "zadaÒ do wykonania").<br>
<br>
U podstaw wymiany informacji za pomocπ protoko≥Ûw najwyøszego poziomu leøy obecnie (najczÍúciej) komunikacja za pomocπ gniazd.<br>
<br>
<div class="def"><b>Gniazdo (socket)</b> - to abstrakcja programistyczna, oznaczajπca punkt
docelowy dwustronnej komunikacji dwÛch procesÛw dzia≥ajπcych rÛwnolegle w
sieci</div> <br>
<br>
To w≥aúnie koncepcja gniazd, wprowadzona w Uniksie w latach 70-tych, stanowi
wspomnianπ wczeúniej, sieciowo-zorientowanπ, unifikacjÍ mechanizmu IPC.<br>Naturalne by≥o
uczynienie&nbsp; komunikacji za pomocπ gniazd w idei podobnej do dobrze znanego
programistom paradygmatu operacji wejúcia-wyjúcia. Zatem mamy to naturalnπ
sekwencjÍ: otwarcie kana≥u komunikacji (gniazda), zapis lub odczyt (przes≥anie
lub otrzymanie danych za pomocπ gniazda), zamkniÍcie kana≥u komunikacyjnego
(zamkniecie gniazda).<br>
<br>
Zwykle komunikacja za pomocπ gniazd implementowane jest na bazie protoko≥u TCP lub protoko≥u UDP.<br>
<br><b>
 ProtokÛ≥ TCP (Transport Control Protocol)</b> jest protoko≥em po≥πczeniowym
(co znaczy, øe ustanawiana jest dwustronne po≥πczenie pomiÍdzy klientem i
serwerem). Zapewnia, øe dane posy≥ane poprzez gniazda docierajπ w ca≥oúci
i w odpowiedniej kolejnoúci. Inaczeje moøemy powiedzieÊ, øe realizowana jest
tu strumieniowa koncepeja wymiany danych, co oznacza, øe po ustanowieniu
po≥aczenia moøna przes≥aÊ dane o dowolnym rozmiarze i - jak zobaczymy - operacje
wymiany danych moøemy wykonywaÊ tutaj za pomocπ dobrze nam znanych úrodkÛw
strumieniowych.<br>
<br><b>
ProtokÛ≥ UDP (User Datagrams Protocol)</b> jest protoko≥em bezpo≥πczeniowym.
Dane przesy≥ane sπ pomiÍdzy procesami jako datagramy (pakiety danych o okreúlonej
maksymalnej wielkoúci np. 64 kB), przy czym z kaødym datagramem posy≥any
jest "adres" odbiorcy. Datagramy mogπ wiÍc przybywac na miejsce przeznaczenia
(do innego procesu) w dowolnje kolejnoúci (a niektÛre nawet mogπ w ogÛle
nie dotrzeÊ). <br>
<br>
Oba protoko≥y (TCP i UDP) sπ protoko≥ami typu "point-to-point", czyli kaødorazowo
zapewniajπcymi komunikacjÍ tylko pomiÍdzy dwoma procesami (w szczegÛlnoúci
na dwÛch rÛønych maszynach w sieci). <br>

Istnieje rÛwnieø moøliwoúÊ uøycia tzw. <b>multicastingu</b>. Ten rodzaj protoko≥Ûw
oznacza dystrybucje informacji z serwera od razu do wielu klientÛw. Oparty
jest on na protokole UDP. <br>
<br>
Identyfikacji maszyn biorπcych udzia≥
w komunikacji (tzw. hostÛw) s≥uøy protokÛl IP (Internet Protocol). Adresy
IP majπ ogÛlnie formÍ 32-bitowych (lub 128-bitowych w wersji IPv6) liczb i mogπ byÊ zapisywane jako sekwencja
czterech (oúmiu)&nbsp; liczb rozdzielonych kropkami (np. 192.33.71.12) lub - w formie "strawniejszej",
wykorzystujπcej DNS (Domain Name Service) jako: nazwa_hosta.nazwa_domeny
(np. boulder.ibm.com).<br><br>
Identyfikacja hosta jest jednak nie wystarczajπca dla komunikacji miedzy
procesami: na danym komputerze moøe siÍ przecieø wykonywaÊ rÛwnolegle wiele procesÛw.<br><br>
<div class="notel">Termin port uøywany jest rownieø w innych znaczeniach, dotyczπcych fizycznego
≥πczenia urzπdzeÒ np. port szeregowy czy USB</div>Po to, by dane dotar≥y do okreúlonego
procesu protoko≥y TCP i UDP pos≥ugujπ siÍ tzw. <b>portami</b>. <br>
Porty sπ identyfikowane przez 16-bitowe liczby - numery portÛw. Numery te
sπ uøywane przez TCP lub UDP do przesy≥anie danych do odpowiedniego procesu.<br>
<br>
W proko≥ach po≥πczeniowych (takich jak TCP) proces-serwer przydziela sobie
port o okreúloneym numerze i poprzez ten w≥aúnie port procesy klienckie mogπ
ustanawiaÊ po≥πczenia z serwerem.<br>
<br>
<img src="images/2tcp.gif" alt="r" border="1" height="60" width="302">
<br>
<br><br>
<br>
W protoko≥ach opartych na datagramach, pakiety datagramÛw zawierajπ numer
portu dziÍki ktÛremy dane kierowane sπ do w≥aúciwego procesu (aplikacji).<br>
<br>
<img src="images/3tcpudp.gif" alt="r" border="1" height="169" width="334">
<br>
<br><br>
<br>Teraz zajmiemy siÍ tylko najprostszym TCP.<br>
Inne:<br>
<ul>
  <li>multicasting
(w Javie - klasa MulticastDatagramSocket) </li>
  <li>bezpiecznπ transmisja danych opartπ na protokole SSL/TSL (Secure Socket
Layer/Transport Secure Layer). </li>
</ul>

<b>
Typowa interakcja pomiÍdzy klientem i serwerem opiera siÍ na nastÍpujπcym modelu</b>.<br>
<br>
<ol>
  <li>Serwer tworzy gniazdo zwiπzane z okreúlonym portem i na tym kanale komunikacyjnym czeka na proúbÍ po≥πczenia od klienta.</li>
  <li>Inicjatywa po≥πczenia wychodzi od klienta; klient musi znaÊ host serwera
oraz numer portu otwartego do przyjmowania po≥πczeÒ i podaje tÍ informacjÍ
tworzπc "u siebie" gniazdo zwiπzane z tak okreúlonym adresem</li>
  <li>Serwer akceptuje po≥aczenie od klienta i - aby pozostaÊ dostÍpnym dla
innych klientÛw na "kanale po≥πczeniowym" - tworzy inne gniazdo do komunikacji
z danym klientem; </li>
  <li>Z punktu widzenia klienta jest to (zazwyczaj) to samo gniazdo na ktÛrym zainicjowano
po≥πczenie; strumienie wejúciowy i wyjúciowy zwiπzane z tym gniazdem s≥uøπ
do komunikacji pomiÍdzy klientem i serwerem zgodnie z protoko≥em serwera.</li>
</ol>
<br>
Ilustruje to poniøszy rysunek.<br>
<img src="images/sockets1.jpg" alt="r" border="1" height="315" width="610">
<br>
<br>
Jest to oczywiúcie ogÛlny model. NiektÛre protoko≥y mogπ wprowadzaÊ pewne odstÍpstwa<br>
 od niego. Przyk≥adem jest protokÛl FTP, gdzie do komunikacji z serwerem
wykorzystywane sπ dwa gniazda: do posy≥ania poleceÒ i do posy≥ania/odczytywania
danych.<br>
<br>
Zatem pos≥ugujemy siÍ dwoma rodzajami gniazd:<br>
<ul>
  <li>gniazdami serwerowymi, w Javie &nbsp;reprezentowanymi przez klasÍ <b>ServerSocket</b>, uøywanymi przy programowaniu serwerÛw,</li>
  <li>gniazdami klienckimi, w Javie reprezentowanymi przez klasÍ <b>Socket</b>,
uøywanymi w &nbsp;programowaniu klientÛw, a w serwerach do komunikacji z klientem
po zaakceptowaniu po≥πczenia od niego.</li>
</ul><hr style="width: 100%; height: 2px;"><a name="KlientSerwer.3"></a><h2>3. Klienci. Protoko≥y i porty</h2>W Javie oprogramowanie klienta, komunikujπcego sie z serwerem - w wiÍkszoúci przypadkÛw - jest niezwykle proste i polega na:<br>

<ol>
  <li>Utworzeniu gniazda - obiektu klasy Socket, dajπcego po≥πczenie&nbsp; z serwerem.</li>
  <li>Uzyskaniu od tego obiektu strumieni wyjúciowego i wejúciowego, zwiπzanych z gniazdem.</li>
  <li>Posy≥anie zleceÒ dla serwera poprzez zapis do strumienia wyjúciowego gniazda.</li>
  <li>Odczytywanie odpowiedzi serwera poprzez odczyt ze strumienia wejúciowego.</li><li>ZamkniÍcie strumieni.</li>
  <li>ZamkniÍcie gniazda<br>
  </li>

</ol><div class="syntax"><br>
<div align="center"><b>Najprostszy schemat komunikacji klienta z serwerem przez gniazda&nbsp; </b><br>
</div>
<br>
try {<br>
&nbsp; // Utworzenie gniazda<br>
&nbsp; String serverHost = ... ; // adres IP serwera ("cyfrowo" lub z uøyciem DNS)<br>
&nbsp; int serverPort = ... ; &nbsp; &nbsp; &nbsp;// numer portu na ktÛrym nas≥uchuje serwer&nbsp; <br><br>
&nbsp; Socket socket = new Socket(serverHost, serverPort)<br>
&nbsp; <br>
&nbsp; // Uzyskanie strumieni do komunikacji<br>
&nbsp; OutputStream sockOut = socket.getOutputStream();<br>
&nbsp; InputStream &nbsp;sockIn = socket.getInputStream();<br>
<br>
&nbsp; // Komunikacja (zaleøna od protoko≥u)<br>
&nbsp; <br>
&nbsp; // Wys≥anie zlecenia do serwera<br>
&nbsp; sockOut.write(...);<br>
&nbsp; &nbsp; ...<br>
<br>
&nbsp; // Odczytanie odpowiedzi serwera<br>
&nbsp; sockIn.read(...);<br>
&nbsp; &nbsp;...<br>
<br>
&nbsp; // Po zakoÒczeniu komunikacji - zamkniecie strumieni i gniazda<br>
&nbsp; sockOut.close();<br>
&nbsp; sockIn.close();<br>
&nbsp; socket.close();&nbsp; <br>
<br>
} catch (UnknownHostException exc) {<br>
&nbsp; &nbsp; // nieznany host<br>
} catch (SocketException exc) {<br>
&nbsp; &nbsp; // wyjπtki zwiπzane z komunikacjπ przez gniazda<br>
} catch (IOException exc) {<br>
&nbsp; &nbsp; // inne wyjπtki we/wy<br>
}<br>
<br>
Uwaga: zazwyczaj strumienie zwiπzane z gniazdem bÍdziemy opakowywaÊ, zapewniajπc
okreúlone rodzaje przetwarzania (np. buforowanie, kodowanie-dekodowanie,
odczyt/zapis danych binarnych itp.).&nbsp; &nbsp; <br>
</div><br>
&nbsp;<br>
W komunikacji pomiÍdzy klientem i serwerem kluczowπ sprawπ jest znajomoúÊ
protoko≥u (czyli rodzajÛw i formatÛw zleceÒ, ktÛre moøna pos≥aÊ do serwera
oraz treúci i formatÛw odpowiedzi, ktÛre serwer przyszy≥a w reakcji na konkretne
zlecenia). <br>
<br><br>
Istniejπ&nbsp; pewne standardowe protoko≥y, dziÍki ktÛrym uzyskujemy dostÍp
do rÛønorodnych us≥ug w Internecie. Do najbardziej znanych (a czasem i&nbsp; uøytecznych)
naleøπ protoko≥y:<br>
<ul>
  <li> HTTP (Hypertext Transfer Protocol) s≥uøπcy m.in. do uzyskiwania dostÍpu
do stron WWW oraz przesy≥ania fromularzy (jego wersja HTTPS, oparta na protokole
TSL/ SSL - Transport Security Layer/Secure Sockets Layer - pozwala na bezpiecznπ
transmisjÍ danych),</li>
  <li>
FTP (File Transfer Protocol) s≥uøπcy do pobierania/zapisywania plikÛw (i jego bezpieczna wersja oparta na TSL/SSL - FTPS) </li>
  <li>
SMTP (Simple Mail Transfer Protocol) &nbsp;s≥uøπcy do przesy≥ania poczty elektronicznej (ESMPT - &nbsp;SMPT z rozszerzeniami).</li>
  <li>POP3 (Post Office Protocol) s≥uøπcy do pobierania poczty z serwera </li>
  <li>IMAP (Internet Message Access Protocol) j.w., z dodatkowymi moøliwoúciami.</li>
  <li>TELNET - umoøliwiajπcy zdalnπ prace na komputerze-hoúcie</li>
  <li>TIME &nbsp;- proste uzyskiwanie aktualnego czasu od serwerÛw czasu</li>
  <li>DAYTIME - proste uzyskiwanie daty i czasu</li>
  <li>NTP (Network Time Protocol) - zaawansowane moøliwoúci uzyskiwania dok≥adnego czasu</li>
  <li>NNTP (Network News Transfer Protocol) - przesy≥anie, dystrybucja i odbiÛr wiadomoúci z tzw. newsgroups.</li>
  <li>IRC - Internet Relay Chat - znane wszystkim internetowe "czaty",</li>
  <li>ECHO - &nbsp;"odbijajπcy" dane posy≥ane przez klienta (s≥uøy g≥Ûwnie do celÛw testowania klientÛw)</li>
  <li>DICT - wyszukiwanie definicji w bazach s≥ownikowych.</li>
</ul>

Protoko≥y te (a zatem format zleceÒ klienta i odpowiedzi serwera, kolejnoúÊ
wymiany informacji itp.) sπ szczegÛ≥owo opisane w dokumentach RFC (Request
For Comments). Dokumenty RFC opisujπ technologiczne i organizacyjne aspekty
Internetu. Od 1969 roku opublikowano prawie 4000 dokumentÛw RFC. Wiele z
nich uzyska≥o status standardu (m.in. prawie wszystkie opisujπce w/w protokoly).
Standartyzacjπ protoko≥Ûw internetowych zajmujπ siÍ nastÍpujπce organizacje:<br>
IETF - The Internet Engineering Task Force - http://www.ietf.org/home.html<br>
IESG - The Internet Engineering Steering Group<br>
IANA - Internet Assigned Numbers Authority (http://www.iana.org/), ktÛra
m.in. ustala rÛønego rodzaju parametry protoko≥Ûw, np. numery portÛw, czy
nazwy zbiorÛw znakÛw.<br>
<br>
PrzyjÍte jako standardy dokumenty RFC (Official Internet Protocol Standards),
w szczegÛlnoúci opisujπce protoko≥y, moøna znaleüÊ na stronie: http://www.rfc-editor.org/rfc.html.
Uzyskamy tam rÛwnieø dostÍp do bazy danych wszystkich dokumentÛw RFC. <br>
<br>
Tworzπc program kliencki, ktÛry ma komunikowaÊ siÍ z serwerem, musimy&nbsp; (oczywiúcie) wiedzieÊ na jakim hoúcie
dzia≥a serwer i przez jaki port moøemy siÍ z nim skontaktowaÊ.<br>
<br>
Z serwerami udostÍpniajπcymi opisane wczeúniej protoko≥y-us≥ugi (oprÛcz serwerÛw
DICT) ≥πczymy siÍ przez tzw. <b>dobrze-znane-porty</b>. "Dobrze-znane-porty" majπ
zarezerwowane numery od <b>0 do 1023</b> (tych numerÛw nie powinniúmy przydzielaÊ swoim
serwerom). Porty o numerach 1024-49151 sπ natomiast tzw. portami zarejestrowanymi.
Tych numerÛw moøemy uøywaÊ, ale naleøy liczyÊ siÍ z tym, øe wybrany przez
nas numer moøe byÊ "zarejestrowany" - czyli jego uøycie opisane&nbsp; publicznie
jako skojarzone z jakimú protoko≥em. Przyk≥adem jest protokÛl DICT, ktÛremu
przypisano port 2628.<br>
Pozosta≥y zakres numerÛw portÛw 49152-65535 okreúla tzw. porty dynamiczne lub prywatne. Moøemy ich uøywac.<br>
<br>
Kaødy ze standardowych protoko≥Ûw (a úciúlej kaødy z serwerÛw realizujπcych
dany protokÛ≥) ma úciúle okreúlony port kontaktowy, za pomocπ ktÛrgo klient
nawiπzuje po≥πczenie. Numery portÛw okreúla standard IANA - moøna je znaleüÊ
na stronie: http://www.iana.org/assignments/port-numbers.<br>
<br>
W poniøszej tabeli pokazano niektÛre standardowe numery portÛw.<br>
<br>
<br>

		
<table border="1" width="468">
<tbody><tr><th>Numer portu
			</th><th>ProtokÛ≥
			</th></tr><tr><td>7</td><td>ECHO</td></tr><tr><td>20</td><td>FTP -- Dane</td></tr><tr><td>21</td><td>FTP -- Polecenia<br>
 Uwaga: protokÛl FTP posluguje siÍ dwoma portami (a w konsekwencji dwoma
gniazdami): jednym dla przekazywania poleceÒ, drugim - dla transferu plikÛw).
W zaleønoúci od trybu p[rort danych moøe mieÊ numer 20, albo inny.&nbsp; <br>
</td></tr><tr><td>22</td><td>SSH Remote Login Protocol</td></tr><tr><td>23</td><td>Telnet</td></tr><tr><td>25</td><td>Simple Mail Transfer Protocol (SMTP)</td></tr><tr><td>37</td><td>Time</td></tr><tr><td>70</td><td>Gopher ("przodek" HTTP)<br>
Uwaga: jest jeszcze trochÍ dzia≥ajπcych serwerÛw Gopher m.in. w Kanadyjskim UrzÍdzie Statystycznym<br>
</td></tr><tr><td>80</td><td>HTTP</td></tr><tr><td>110</td><td>POP3</td></tr><tr><td>119</td><td>Newsgroup (NNTP)</td></tr><tr>
      <td valign="top">123<br>
      </td>
      <td valign="top">Network Time Protocol (NTP)<br>
      </td>
    </tr>
<tr><td>143</td><td>Internet Mail Access Protocol (IMAP)</td></tr><tr><td>194</td><td>Internet Relay Chat (IRC)</td></tr><tr><td>443</td><td>HTTPS (HTTP w oparciu o TSL/SSL)</td></tr><tr>
      <td valign="top">989<br>
      </td>
      <td valign="top">FTPS (w oparciu o TSL/SSL) - dane<br>
      </td>
    </tr>
    <tr>
      <td valign="top">990<br>
      </td>
      <td valign="top">FTPS (w oparciu o TSL/SSL) - polecenia<br>
      </td>
    </tr>
    <tr>
      <td valign="top">992<br>
      </td>
      <td valign="top">Telnets (Telnet w oparciu o TSL/SSL)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">993<br>
      </td>
      <td valign="top">IMAPS (IMAP4 w oparciu o TSL/SSL)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">994<br>
      </td>
      <td valign="top">IRCS (IRC w oparciu o TSL/SSL)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">995<br>
      </td>
      <td valign="top">POP3S (POP3 w oparciu o TSL/SSL)<br>
      </td>
    </tr>
<tr><td>2628</td><td>DICT</td></tr></tbody>
</table>
<br> Zanim przeanalizujemy nieco bardziej rozbudowane przyk≥ady programÛw
klienckich warto przyjrzeÊ najprostszym ilustracjom, i na ich&nbsp; przyk≥adach
poznaÊ pewne cechy gniazd. Zaczniemy od protoko≥u DAYTIME, zgodnie z ktÛrym
- zaraz po po≥πczeniu - serwer przesy≥a klientowi aktualnπ date i czas, po
czym zamyka po≥πczenie. Format odpowiedzi nie jest przez RFC okreúlony, jednak
kaødy serwer dostarcza&nbsp; informacji o sk≥adni komunikatu, zawierajπcego datÍ
i czas.<br>
<br>
W najprostszej postaci&nbsp; program odczytujπcy datÍ i czas z serwera czasu&nbsp; moøe wyglπdaÊ tak.<br>
<pre>import java.net.*;
import java.io.*;

class DateTime1 {

  public static void main(String[] args) {

    String host = null;
    int port = 13;

    try {
      host = args[0];  // host - jako argument wywo≥ania

      // Utworzenie gniazda
      Socket socket = new Socket(host, port);

      // Pobranie strumienia wejúciowego gniazda
      // Nak≥adamy dekodowanie i buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             <b>socket.getInputStream()</b>
                             )
                          );

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // ZamkniÍcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }

}
</pre>
<br>
Po uruchomieniu w wierszu poleceÒ np. z argumentem <b>time.nist.gov</b> uzyskamy odpowiedü w nastÍpujacej postaci:<br>
<div class="listing100"><br>
52943 07-10-31 22:06:50 00 0 0 223.2 UTC(NIST) *<br>
</div><br>
Uwaga: wyjaúnienie szczegÛ≥Ûw sk≥adni tej odpowiedzi moøna znaleüÊ na stronie www.time.nist.gov.<br>
<br>
<a name="KlientSerwer.4"></a><h2>4. Adresowanie i wyjπtki przy prÛbie po≥πczenia z serwerem</h2>
Przy tworzeniu gniazda adresy hostÛw moøna podawaÊ w postaci tekstowej (w formie DNS lub w formie "liczbowego" adresu IP).<br>
Np.<br>
<br>
Socket socket = new Socket("time.nist.gov", 13);<br>
lub<br>
Socket socket = new Socket("192.43.244.18", 13);<br>
<br>
Te formy konstruktorÛw klasy Socket zapewniajπ nie tylko utworzenie gniazda, ale rÛwnieø prÛbÍ po≥πczenia z serwerem.<br>
Podany serwer moøe nie istnieÊ, moøe istnieÊ ale nie zgodziÊ siÍ na po≥πczenie,
moøe siÍ teø zdarzyÊ øe przekroczony zostanie maksymalny czas oczekiwania na uzyskanie
po≥πczenia. Wszystkie te sytuacje sπ sygnalizowane jako odpowiednie wyjπtki.<br>
<br>
Pokazuje to poniøszy przyk≥ad, w ktÛrym staramy siÍ po≥πczyÊ z rÛønymi potencjalnymi
serwerami ECHO (serwery takie przyjmujπ jako zlecenie dowolny tekst, a ich
funkcjπ jest zwrÛcenie tego samego tekstu - by≥y kiedyú powszechnie wykorzystywane
do testowania, teraz jednak, ze wzglÍdÛw bezpieczeÒstwa, porty sπ blokowane
i raczej trudno jest znaleüÊ jakiú dzia≥ajπcy echo-serwer).<br>
<br>
<pre>import java.io.*;
import java.net.*;

public class EchoClient {

  final static int ECHO_PORT = 7;
  private Socket sck;
  private PrintWriter out;
  private BufferedReader in;

  public EchoClient() {}

  public void connect(String host)
              throws UnknownHostException, IOException   {
    sck = new Socket(host, ECHO_PORT);
    in = new BufferedReader (
            new InputStreamReader(sck.getInputStream()));
    out = new PrintWriter (
            new OutputStreamWriter(sck.getOutputStream()), true);
    System.out.println("Po≥πczony z hostem:" + sck.getInetAddress() );
  }

  public void echoMsg(String msg) throws IOException {
    out.println(msg);
    String response = in.readLine();
    System.out.println("Klient: " + msg);
    System.out.println("Serwer: " + response);
  }

  public void disconnect() throws IOException  {
    in.close();
    out.close();
    sck.close();
  }



  public static void main(String[] args) {
    String[] hosts = { "aeneas.mit.edu",
                       "cs.toronto.edu",
                       "cs.utah.edu",
                       "web.mit.edu",
                       "boulder.ibm.com",
                       "somethin"
                     };
    int i = 0;
    EchoClient ec = new EchoClient();
    for (; i&lt;hosts.length; i++) {
      try {
        ec.connect(hosts[i]);
        ec.echoMsg("DzieÒ dobry!");
        ec.disconnect();
      } catch(UnknownHostException exc) {
          System.out.println("Nieznany host: " + hosts[i]);
      } catch(IOException exc) {
          System.out.println(hosts[i] + " - " + exc);
      }
    }
  }


}
</pre>
Program wyprowadzi nastÍpujπcπ informacjÍ:<br>
<div class="listing100"><br>
aeneas.mit.edu - java.net.ConnectException: Connection refused: connect<br>
cs.toronto.edu - java.net.ConnectException: Connection refused: connect<br>
cs.utah.edu - java.net.ConnectException: Connection timed out: connect<br>
web.mit.edu - java.net.ConnectException: Connection timed out: connect<br>
boulder.ibm.com - java.net.ConnectException: Connection timed out: connect<br>
Nieznany host: somethin<br>
</div><br>
<br>
Zauwaømy:<br>
<ul>
  <li>wyjπtki powstajπce przy braku moøliwoúci po≥πczenia sπ klasy ConnectException (i jest to podklasa IOException),</li>
  <li>wadliwy (nieistniejπcy) host zg≥aszany jest w &nbsp;formie wyjπtku UnknownHostException,</li>
</ul>
Istnieje jeszcze inny sposÛb tworzenia gniazd i uøycia adresÛw internetowych. <br>
Moøemy w tym celu wykorzystaÊ klasy InetAddress i InetSocketAddress.<br>
<br>
Obiekty klasy InetAddress reprezentujπ adresy IP (podklasa Inet4Address w
wersji 4, a podklasa Inet6Adrres w wersji 6 protoko≥u IP) i zapewniajπ translacjÍ
adresÛw z postaci tekstowej do binarnej i odwrotnie. Adresy IP - obiekty
klasy uzyskujemy&nbsp; stosujπc statyczne metody klasy m.in.<br>
<ul>
  <li>InetAddres InetAddress.getByName(nazwa_hosta) - zwraca adres IP podanego hosta,</li>
  <li>InetAddress[] InetAddress.getAllByName(nazwa_hosta) - zwraca tablicÍ
adresÛw IP podanego hosta (nazwa hosta np. java.sun.com moøe byÊ skojarzona
z kilkoma adresami IP, uøywanymi alternatywnie dla zmniejszania obciπøenia
serwerÛw).</li>
</ul>
Uwagi: <br>
<ul>
  <li>podajπc nazwÍ hosta w postaci DNS (np. java.sun.com) uzyskujemy rozwiπzanie
referencji przez serwisy DNS (Domain Name Service) czy NIS (Network Information
Service); wywo≥anie jest blokujπce i ew. - dla nieistniejπcego hosta moøe
powstaÊ wyjπtek UnknownHostException</li>
  <li>podajπc nazwÍ hosta w tekstowej postaci IP (np. "192.33.87.12") uzyskujemy tylko formalne sprawdzenie poprawnoúci adresu,</li>
  <li>podajπc null uzyskamy adres interfejsu loopback.</li>
</ul>
Referencje do obiektu klasy InetAddress moøemy podaÊ przy tworzeniu gniazda np.<br>
<br>
<pre>    String host = "time.nist.gov";
    int port = 13;

    try {
      // Utworzenie adresu
      InetAddress inetadr = InetAddress.getByName(host);

      // Utworzenie gniazda
      Socket socket = new Socket(inetadr, port);
     ....
    }
</pre>
<br>
OprÛcz bardziej zaawansowanych dzia≥aÒ na adresach sieciowych, klasa InetAdress
jest wykorzystywana przy tworzeniu "adresÛw gniazd" (adres IP + port), ktÛre
sπ obiektami klasy InetSocketAddress. Te z kolei mogπ byÊ zastosowane do
odroczenia (odseparowania) ≥πczenia z serwerem od aktu utworzenia gniazda.<br>
<br>
Moøemy mianowicie najpierw utworzyÊ "niezwiπzane" gniazdo:<br>
<br><b>&nbsp;&nbsp;&nbsp; Socket socket = new Socket();</b><br>
<br>
<br>
odpowiednie adresy:<br>
<br><b>&nbsp;&nbsp;&nbsp; InetAdress inetadr = InetAddress.getByName(host);<br>
&nbsp;&nbsp;&nbsp; InetSocketAddress conadr = new InetSocketAddress(inetadr, port);<br>
</b>
<br>
po czym w odpowiednim, wybranym momencie po≥πczyÊ siÍ z serwerem:<br>
<br><b>&nbsp;&nbsp;&nbsp; socket.connect(conadr);</b><br>
<br>
Dok≥adniej obrazuje to poniøszy fragment programu:<br>
<pre>  public static void main(String[] args) {

    String host = "time.nist.gov";
    int port = 13;
    Socket socket = new Socket(); // utworzenie niezwiπzanego gniazda

    try {
      // Utworzenie adresÛw
      InetAddress inetadr = InetAddress.getByName(host);
      InetSocketAddress conadr = new InetSocketAddress(inetadr, port);

      // Po≥aczenie z serwerem
      socket.connect(conadr);

      // Pobranie strumienia wejúciowego gniazda
      // Nak≥adamy buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             socket.getInputStream()
                             )
                          );

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // ZamkniÍcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }
</pre>
Ten sposÛb programowania moøe sprzyjaÊ lepszemu izolowaniu fragmentÛw kodu,
okaøe siÍ takøe przydatny wtedy, gdy chcemy precyzyjnie okreúliÊ maksymalny
czas oczekiwania na po≥πczenie.<br>
<br>
<a name="KlientSerwer.5"></a><h2>5.&nbsp; Limity czasu ≥πczenia i odczytu</h2>
Czasami przydatne jest okreúlenie maksymalnego czasu oczekiwania na po≥πczenie
z serwerem jak rÛwnieø masymalnego czasu oczekiwania na odczyt kolejnych
danych z serwera. Na przyk≥ad - nie chcemy uzyskaÊ informacji o czasie od serwera
czasu po up≥ywie kilku sekund - chcemy mieÊ raczej dok≥adny, aktualny pomiar.<br>
<br>
Limit czasu na po≥πczenie (w milisekundach) specyfikujemy jako drugi argument
przeciπøonej metody connect. Gdybyúmy np. w poprzednim programie napisali:<br>
<pre>socket.connect(conadr, 100);
</pre>
to nie uzyskanie po≥πczenia w ciπgu 100 milisekund bÍdzie skutkowa≥o powstaniem wyjπtku SocketTimeoutException np.<br>
<div class="listing100"><br>
java.net.SocketTimeoutException: connect timed out<br>
</div><br>
<br>
Innym limitem czasowym jest limit odczytu. Moøemy uzyskaÊ po≥πczenie, ale
w komunikacji z serwerem (w trakcie czytania odpowiedzi serwera) mogπ wystπpiÊ
jakieú opÛünienia, ktÛrych nie chcemy zaakceptowaÊ. Limity czasu na odczyt
specyfikujemy w milisekunadach za pomocπ metody <b>setSoTimeout(...)</b>
z klasy Socket. Ten limit okreúla maksymalny czas blokowania operacji czytania
strumienia wejúciowego gniazda. Po przekroczeniu tego czasu blokowanie na
wejúciu jest przerywane i powstaje wyjπtek SocketTimedOutException. Gniazdo
i jego strumieÒ wejúciowy mogπ byÊ ponownie uøyte.<br>
Ustalenie limitu musi poprzedzaÊ wprowadzanie jakiejkolwiek blokujπcego czytania strumienia gniazda.<br>
&nbsp;<br>
Przyk≥adowy program pokazuje, øe po uzyskaniu po≥aczenia z serwerem czasu
odpowiedü (aktualny czas) uzyskujemy nie doúÊ szybko (jak sobie tego øyczymy)&nbsp;&nbsp; i powstaje
wyjπtek SocketTimeoutException.<br>
<pre>    try {
      // Utworzenie adresÛw
      InetAddress inetadr = InetAddress.getByName(host);
      InetSocketAddress conadr = new InetSocketAddress(inetadr, port);

      // Po≥aczenie z serwerem
      // Okreúlenie maksymalnego czasu oczekiwania na po≥πczenie
      socket.connect(conadr, 200);


      // Pobranie strumienia wejúciowego gniazda
      // Nak≥adamy buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             socket.getInputStream()
                             )
                          );
      // Okreslenie maksymalnego czasu oczekiwania na odczyt danych z serwera
      <b>socket.setSoTimeout(50);</b>

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // ZamkniÍcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }

</pre>
<div class="listing100"><br>
java.net.SocketTimeoutException: Read timed out<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at java.net.SocketInputStream.socketRead0(Native Method)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at java.net.SocketInputStream.read(SocketInputStream.java:129)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at sun.nio.cs.StreamDecoder$CharsetSD.readBytes(StreamDecoder.java:408)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at sun.nio.cs.StreamDecoder$CharsetSD.implRead(StreamDecoder.java:450)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:182)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at java.io.InputStreamReader.read(InputStreamReader.java:167)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at java.io.BufferedReader.fill(BufferedReader.java:136)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at java.io.BufferedReader.readLine(BufferedReader.java:299)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at java.io.BufferedReader.readLine(BufferedReader.java:362)<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; at DateTime2.main(DateTime2.java:36)<br>
</div><br>
<br>
<a name="KlientSerwer.6"></a><h2>6. Inne parametry gniazd kliencich.</h2>
<br>
Klasa Socket dostarcza wielu metod uzyskiwania informacji o stanie i opcjach gniazda. <br>
W syntetyczny sposÛb moøemy poznaÊ je za pomocπ poniøszego programiku, ktÛry
refleksyjnie wywo≥uje publiczne metody get...() i is...() z klasy Socket.<br>
<br>
<pre>import java.net.*;
import java.io.*;
import java.lang.reflect.*;

class DateTime2 {

  public static void main(String[] args) {

    String host = "time.nist.gov";
    int port = 13;
    Socket socket = new Socket();

    try {
      // Utworzenie adresÛw
      InetAddress inetadr = InetAddress.getByName(host);
      InetSocketAddress conadr = new InetSocketAddress(inetadr, port);

      // Po≥aczenie z serwerem
      // Okreúlenie maksymalnego czasu oczekiwania na po≥πczenie
      socket.connect(conadr, 200);


      // Pobranie strumienia wejúciowego gniazda
      // Nak≥adamy buforowanie
      BufferedReader br = new BufferedReader(
                            new InputStreamReader(
                             socket.getInputStream()
                             )
                          );
      // Okreslenie maksymalnego czasu oczekiwania na odczyt danych z serwera
      socket.setSoTimeout(200);

      // Czego moøemy siÍ dowiedzieÊ o stanie gniazda?
      report(socket);

      // Odczyt odpowiedzi serwera (data i czas)
      String line;
      while ((line = br.readLine()) != null) {
        System.out.println(line);
      }

      // ZamkniÍcie strumienia i gniazda
      br.close();
      socket.close();
    } catch (UnknownHostException exc) {
        System.out.println("Nieznany host: " + host);
    } catch (Exception exc) {
         exc.printStackTrace();
    }
  }

  // Dynamiczne wo≥anie metod z klasy Socket
  static void report(Socket s) throws Exception {
    Method[] methods = (java.net.Socket.class).getMethods();
    Object[] args = {};
    for (int i=0; i&lt;methods.length; i++) {
      String name = methods[i].getName();
      if ((name.startsWith("get") || name.startsWith("is")) &amp;&amp;
          !name.equals("getChannel") &amp;&amp;
          !name.equals("getInputStream") &amp;&amp;
          !name.equals("getOutputStream")) {

        System.out.println(name + "() = " +
                           methods[i].invoke(s, args));
      }
    }
  }


}
</pre>

<br>
Program wyprowadzi:<br>
<div class="listing100"><br>
getPort() = 13<br>
isClosed() = false<br>
getInetAddress() = time.nist.gov/192.43.244.18<br>
getKeepAlive() = false<br>
getLocalAddress() = /61.120.87.131<br>
getLocalPort() = 1178<br>
getLocalSocketAddress() = /61.120.87.131:1178<br>
getOOBInline() = false<br>
getReceiveBufferSize() = 8192<br>
getRemoteSocketAddress() = time.nist.gov/192.43.244.18:13<br>
getReuseAddress() = false<br>
getSendBufferSize() = 8192<br>
getSoLinger() = -1<br>
getSoTimeout() = 200<br>
getTcpNoDelay() = false<br>
getTrafficClass() = 0<br>
isBound() = true<br>
isConnected() = true<br>
isInputShutdown() = false<br>
isOutputShutdown() = false<br>
getClass() = class java.net.Socket<br>
<br>
52944 03-11-01 00:36:14 00 0 0 913.5 UTC(NIST) * <br>
</div><br>
<br>ProszÍ sprawdziÊ w dokumentacji znaczenie poszczegÛlnych opcji.<br>
<a name="KlientSerwer.7"></a><h2>
7. Klient SMTP</h2><br>
Dotychczas widzieliúmy programy klienckie dla bardzo prostych protoko≥Ûw.
Zwykle komunikacja z serwerem polega na przesylaniu kolejnych zleceÒ, odczytywaniu
ich wynikÛw i podejmowaniu decyzji co robiÊ dalej w zaleønoúci od wyniku
kolejnego zlecenia. Wszystko to oczywiúcie musi byÊ zgodne z okreúlonym protoko≥em.<br><br>Jako pierwszy przyk≥ad rozpatrzmy protokÛ≥ SMTP (Simple Mail Transfer Protocol) s≥uøπcy do wysy≥ania poczty elektronicznej.<br><br>
Klient posy≥a zlecenia w okreúlonej formie, serwer odpowiada wierszami danych,
w ktÛrych na poczπtku znajdujπ siÍ numeryczne kody, okreúlajπce wynik przetworzenia
zlecenia, a po nich nastÍpujπ werbalne (rÛøne dla rÛønych serwerÛw) informacje
(np. informacja o serwerze, s≥Ûwko "Ok", øe wszystko w porzπdku, lub napis
typu "go ahead"). Oczywiúcie, napisy mogπ byÊ w rÛønych jÍzykach; w przeciwieÒstwie
do numetycznych kodÛw nie sπ one okreúlone przez protokÛ≥ SMTP i kaødy serwer
moøe opisywac wyniki swego dzia≥ania w dowolny sposÛb.<br>
<br>
Waøna jest rÛwnieø kolejnoúÊ zleceÒ i odpowiedzi oraz to, by klient identyfikowa≥
wyniki &nbsp;zleceÒ i odpowiednio do tego reagowa≥ (np. nie ma sensu posy≥ania
poczty, &nbsp;jeøeli serwer zwraca wynik, úwiadczπcy o tym, øe transakcja nie moøe
dojúÊ do skutku).<br><br>
<br>
<b>klient</b>: po≥πczenie przez port 25,<br>
<b>serwer:</b> kod potwierdzenia uzyskania po≥πczenia 220,<br>
<b>klient:</b> inicjacja komunikacji HELO lub EHLO (ESMPTP) + identyfikacja domeny,<br>
<b>serwer:</b> OK? - 250, nie - kody b≥ÍdÛw (np. brak autoryzacji). Odp: wiele wierszy (nie wiadomo ile).<br>
<b>klient:</b> inicjacja transakci - MAIL, RCPT (odbiorcy)<br>
<b>serwer:</b> OK? - 250<br>
<b>klient:</b> posy≥anie danych - polecenie DATA<br>
<b>serwer:</b> 354 (go ahead),<br>
<b>klient:</b> list (koniec listu: jedna kropka w wierszu, sic!)<br>
<b>serwer:</b> odebra≥em? - 250<br>
i dalej nastÍpne zlecenia (inne transakcje pocztowe itp.)<br>
ZamkniÍcie kana≥u przez klienta.<br>
<br><br>
Przyk≥adowy program wysy≥a listy, ktÛrych zawartosÊ pobierana jest z plikÛw.
Przeslanie zleceÒ do serwera - metoda doRequest(String
zlecenie, int checkCode). Zapisuje ona zlecenie do strumienia wyjúciowego
gniazda ≥πczπcego klienta z&nbsp; serwerem SMTP, po czym wywo≥uje
metodÍ readResponse(int checkCode), ktÛra odczytuje odpowiedü serwera. Przekazywany jako argument tej metody
checkCode jest spodziewanym (i wymaganym) kodem wyniku. Przy jego niezgodnoúci
z kodem odczytywanym ze strumienia wejúciowego gniazda (czyli przekazanym
przez serwer) zg≥aszamy wyjπtek IOException z komunikatem "Niespodziewany
kod wyniku".<br>
W obu metodach - doRequest i readResponse - wypisuejmy informacjÍ na konsole,
uzyskujπc w ten sposÛb prezentacjÍ komunikacji pomiÍdzy klientem i serwerem.<br>
<br>
<pre>import java.io.*;
import java.net.*;

public class EmailClient {

  Socket smtpSocket = null;
  PrintWriter sockOut = null;
  InputStream sockIn = null;

  public void connect(String server, String myDomain) {
    try {
      smtpSocket = new Socket(server, 25);
      sockOut = new PrintWriter(
             new OutputStreamWriter(smtpSocket.getOutputStream(), "UTF-8"),
             true);
      sockIn = smtpSocket.getInputStream();

      // Czy po≥πczenie zosta≥o nawiπzane?
      // Musi byÊ kod 220 - wtedy Ok
      // Odczytujπc odpowiedø serwera,
      // sprawdzamy w metodzie readResponse kod 220

      readResponse(220);

      // Przedstawiamy siÍ serwerowi
      // Jeúli nas zaakceptuje - poda kod 250
      doRequest("HELO " + myDomain, 250);


    } catch (UnknownHostException e) {
        System.err.println("Nieznany host: " + server);
        cleanExit(1);
    } catch (IOException exc) {
        System.err.println(exc);
        cleanExit(2);
    }
  }


  // Posy≥anie maila
  public void send(String from, String to, String fname) {
    try {

      // Inicjacja transakcji
      // Kod 250 - jesli OK
      doRequest("MAIL FROM:&lt;" + from + "&gt;", 250);

      // Okreúlenie adresata
      // Kod 250 - jesli OK
      doRequest("RCPT TO:&lt;" + to + "&gt;", 250);

      // Posy≥anie danych listu
      // Odpowiedü serwera - 354 = jestem gotowy na przyjÍcie danych
      doRequest("DATA", 354);

      // Teraz bÍdziemy zapisywaÊ treúÊ listu
      // bezpoúrednio do strumienia wyjúciowego gniazda
      // Najpierw jakieú nag≥Ûwki
      sockOut.println("From: " + from);
      sockOut.println("To: " + to);

      // Czytanie treúci listu z pliku
      // Poniewaø samotna kropka w wierszu koÒczy dane listu
      // to samotnπ kropkÍ w treúci zamieniamy na dwie kropki
      BufferedReader br = new BufferedReader(
                            new FileReader(fname));
      String line;
      while ((line = br.readLine()) != null) {
        if (line.equals(".")) line += ".";
        sockOut.println(line);
      }
      // Sekwencja CRLF.CRLF oznacza koniec treúci listu
      // Drugie CRLF dodane w metodzie doRequest przez println
      doRequest("\\r\\n.", 250);

    } catch (IOException e) {
        System.err.println(e);
        cleanExit(2);
    }
  }

  // ZamkniÍcie po≥πczenia
  public void closeConnection() {
    try {
      doRequest("QUIT", 221);
    } catch (Exception exc) {
      System.err.println(exc);
    }
    cleanExit(0);
  }


  private void doRequest(String req, int checkCode)
              throws IOException {
    sockOut.println(req);
    System.out.println("Klient: " + req);
    readResponse(checkCode);
  }

  // Uwaga: nie powinniúmy tu stosowaÊ buforowania i metody
  // readLine(), poniewaø nie wiadomo ile wierszy zwrÛwci serwer
  // a wywo≥anie readLine jest blokujπce
  // Zak≥πdamy: øe kaøda odpowiedü zmieúci siÍ w 10000 bajtÛw&nbsp;&nbsp;
  private void readResponse(int checkCode) throws IOException {
    byte[] readBytes = new byte[10000];
    int num = sockIn.read(readBytes);
    String resp = new String(readBytes, 0, num);
    System.out.println("Serwer: " + resp);
    if (!resp.startsWith(String.valueOf(checkCode)))
     throw new IOException("Niespodziewany kod wyniku od serwera");
  }

  private void cleanExit(int code) {
    try {
      sockIn.close();
      sockOut.close();
      smtpSocket.close();
    }
    catch (Exception exc) {}
    System.exit(code);
  }

  public static void main(String[] args) {
    String server = "mail.somemailer.net";
    String myDomain = "62.125.12.111";
    String from = "me@somemailer.net";
    String to = "you@anywhere";
    EmailClient email = new EmailClient();
    email.connect(server, myDomain);
    email.send(from, to, "list1");
    email.send(from, to, "list2");
    email.closeConnection();
  }
}
</pre>
<br>
Przyk≥adowy wynik dzia≥ania programu:<br>
<br>
<div class="listing100"><br>
Serwer: 220 mail.somemailer.net ESMTP<br>
<br>
Klient: HELO 62.125.12.111 &nbsp; &nbsp; &nbsp;<br>
Serwer: 250 mail3.somemailer.net<br>
<br>
Klient: MAIL FROM:&lt;me@somemailer.net&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: RCPT TO:&lt;someone@anywhere&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: DATA<br>
Serwer: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;<br>
<br>
Klient: <br>
.<br>
Serwer: 250 Ok: queued as 28F372E815A<br>
<br>
Klient: MAIL FROM:&lt;me@somemailer.net&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: RCPT TO:&lt;someone@anywhere&gt;<br>
Serwer: 250 Ok<br>
<br>
Klient: DATA<br>
Serwer: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;<br>
<br>
Klient: <br>
.<br>
Serwer: 250 Ok: queued as 8FA212E81EC<br>
<br>
Klient: QUIT<br>
Serwer: 221 Bye<br>
</div><br>
<br>
<br>
Ten przyk≥ad oprogramowania klienta ilustruje dwie waøne kwestie:<br>
<ul>
  <li>
potrzebÍ zgodnego z protoko≥em, starannego ustalenia kolejnoúci przesy≥ania zleceÒ i odczytywania odpowiedzi,</li>
  <li>
potrzebÍ uwaønej analizy moøliwych (czÍsto elastycznych) formatÛw odpowiedzi
serwera: tutaj musieliúmy siÍ liczyÊ z wielowierszowymi odpowiedziami serwera,
przy czym liczba wierszy nie jest ustalona - wobec tego przy czytaniu odpowiedzi
serwera nie naleøa≥o stosowaÊ metody readLine (ktÛra - oczywiúcie - jest
blokujπca), a zamiast tego trzeba by≥o czytaÊ ze strumienia bajty.</li>

</ul>
SzczegÛ≥owy opis protoko≥u SMTP zawiera RFC0821, a jego rozszerzeÒ (ESMTP) - RFC1869.<br>



<br> Naturalnie, omÛwiony przyk≥ad nie jest ani uniwersalny ani nazbyt
uøyteczny.&nbsp; Prawdziwe klienckie programy pocztowe mogπ byÊ bardzo rozbudowane
i dostarczaÊ wielu moøliwoúci. W úrodowisku Javy moøemy wykorzystaÊ do ich
budowy (jak rÛwnieø do budowy serwerÛw pocztowych) <b>Java Mail API</b>.
Zestaw klas tego pakietu umoøliwia m.in. pos≥ugiwanie siÍ protokolami SMTP,
POP3, IMAP, prowadzenie folderÛw wiadomoúci, ≥atwπ kompozycjÍ wiadomoúci
(m.in. do≥πczanie do listÛw rÛønego rodzaju plikÛw jako za≥πcznikÛw), a wszystko to bez eksponowania
szczegÛ≥Ûw dotyczπcych niskopoziomowej komunikacji poprzez gniazda. <br>
<hr style="width: 100%; height: 2px;"><a name="KlientSerwer.8"></a><h2>8. Klient DICT

</h2><br>Ciekawym, choÊ ma≥o popularnym protoko≥em jest DICT.<br>
Jest on opisany w RFC2229.<br>Serwery DICT prowadzπ bazy danych definicji rÛønych terminÛw i dostarczajπ - na zlecenie klientÛw - odpowiednich informacji.<br>
Nie bÍdziemy oczywiúcie szczegÛ≥owo omawiaÊ tego protoko≥u. Dla potrzeb demonstracji wystarczy wiedzieÊ, øe:<br>
<ul>
  <li>
polecenie "DEFINE * s≥owo" powoduje, iø serwer przeglπda wszystkie prowadzone
przez niego bazy danych i przesy≥a klientowi wszystkie odnalezione w nich
definicje s≥owa.</li>
  <li>
koniec ciπgu definicji oznaczany jest kodem 250 w nowym wierszu,</li>
  <li>
jeúli brak definicji - zwracany jest wiersz zawierajπcy na poczπtku kod 552.</li>
</ul>


Przyk≥adowy program pokazuje, øe tym razem moøemy spokojnie pos≥ugiwac siÍ
buforowanym czytaniem i metodπ readLine() (serwer zwraca wiersze, a my przy
czytaniu bÍdziemy czatowac na odpowiednie kody). Ponadto - uczynimy nasz
program nieco bardziej przyjaznym dostarczajπc GUI (to dobra idea i krok
naprzÛd - generalnie programy tego typu powinny posiadaÊ odpowiednie wygodne
GUI).<br>
<br>
Program przedstawiono na poniøszym wydruku.<br>
<pre>import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;

public class DictClient extends JFrame
{
   public final static int port = 2628;
   private String server;
   private Socket clientSocket;
   private PrintWriter out;
   private BufferedReader in;
   private String database = "*";  // info ze wszystkich baz

   JTextArea ta = new JTextArea(20, 40);
   Container cp = getContentPane();



   public DictClient (String server, int timeout)   {

     try {
       clientSocket = new Socket (server, port);
       in = new BufferedReader (
                new InputStreamReader(clientSocket.getInputStream(), "UTF8"));
       out = new PrintWriter (
                new OutputStreamWriter(clientSocket.getOutputStream(), "UTF8"),
                             true);

       String resp = in.readLine(); // po≥πczenie nawiπzane - info o tym
       System.out.println(resp);
       if (!resp.startsWith("220")) {
         cleanExit(1); // jeøeli dostÍp niemoøliwy
       }

       // Ustalenie maksymalnego czasu blokowania
       // na operacji czytania ze strumienia gniazda

       clientSocket.setSoTimeout(timeout);


     } catch(UnknownHostException exc) {
         System.err.println("Uknown host " + server);
         System.exit(2);
     } catch(Exception exc) {
         exc.printStackTrace();
         System.exit(3);
     }

     // wszystko posz≥o dobrze - tworzymy i pokazujemy okno wyszukiwania

    Font f = new Font("Dialog", Font.BOLD, 14);
    ta.setFont(f);
    cp.add(new JScrollPane(ta));
    final JTextField tf = new JTextField();
    tf.setFont(f);
    tf.setBorder(BorderFactory.createLineBorder(Color.blue, 2));
    cp.add(tf, "South");

    tf.addActionListener( new ActionListener() {
      public void actionPerformed(ActionEvent e) {
         doSearch(tf.getText());
      }
    });

    addWindowListener( new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        dispose();
        cleanExit(0);
      }
    });

    pack();
    show();

    // Ustalenie fokusu na polu wprowadzania szukanych s≥Ûw
    SwingUtilities.invokeLater( new Runnable() {
      public void run() {
        tf.requestFocus();
      }
    });
  }

  // Wyszukiwanie

  public void doSearch(String word) {
    try {
      String resp = "",
            defin = "Uzyskano nastÍpujπce definicje:\\n";

      // Zlecenie dla serwera
      out.println("DEFINE " + database + " " + word);

      // Czytamy odpowiedü
      // Kod 250 na poczπtku wiersza oznacza koniec definicji
      while (resp != null &amp;&amp; !resp.startsWith("250")) {
        resp = in.readLine();
        defin += resp + "\\n";
        if (resp.startsWith("552")) break;  // s≥owo nie znalezione
      }
      ta.setText(defin);
    } catch(SocketTimeoutException exc) {
       ta.setText("Za d≥ugie oczekiwanie na odpowiedü");
    } catch(Exception exc) {
          exc.printStackTrace();
    }
  }

  private void cleanExit(int code) {
    try {
      out.close();
      in.close();
      clientSocket.close();
    } catch(Exception exc) {}
    System.exit(code);
  }

  public static void main(String[] args) {

    int timeout = 0;
    String server = "dict.org";
    try {
      timeout = Integer.parseInt(args[0]);
      server = args[1];
    } catch(NumberFormatException exc) {
      server = args[0];
    } catch(ArrayIndexOutOfBoundsException exc) {}

    new DictClient(server, timeout);
  }

}
</pre>

Uruchamiajπc program podajemy adres hosta serwera oraz maksymalne oczekiwanie
na odpowiedü (wykorzystamy je pÛüniej w metodzie setSoTimeout(...)). Adresy
rÛønych serwerÛw s≥ownikowych moøna znaleüÊ na stronie www.dict.org. Jesli
nie podamy adresu - domyúlnie zostanie przyjÍty podstawowy (choÊ nie najwiÍkszy
i nie najbardziej wszechstronny) serwer dict.org. <br>
<br>
Po≥πczenie z nim wyprowadzi na konsolÍ:<br>
<div class="listing100"><br>
220 pan.alephnull.com dictd 1.8.0/rf on Linux 2.4.18-14 &lt;auth.mime&gt; &lt;1094327.262<br>
00.1067095370@pan.alephnull.com&gt;</div><br>
<br>
i od tego momentu bÍdziemy mogli w oknie, w polu tekstowym u dolu wprowadzaÊ
szukane s≥owa i poprzez wciúniÍcie ENTER uzyskiwaÊ ich definicje (co pokazujπ
rysunki)<br>
<br>
<img src="images/dict1.jpg" alt="r" height="473" width="491">
<br>
<br>
<br>
<img src="images/dict2.jpg" alt="r" height="172" width="419">
<br>
<br><br>
Programik ten ma jednπ istotnπ wadÍ. Zlecenia obs≥ugiwane sπ synchronicznie.
Nie moøemy np. pisaÊ w edytorze (wielopolu tekstowym w gÛrnej czÍúci okna)
i jednoczeúnie przeszukiwaÊ baz danych serwerÛw s≥ownikowych. Zapewne moglibyúmy
sobie z tym poradziÊ wyodrÍbniajπc w programie wπtek komunikacji z serwerem.
<br>
Zaraz to zrobimy, ale chcielibyúmy rÛwnieø, aby wπtek ten na bieøπco informowa≥
nas o tym co robi i ile czasu mu to zajmuje. Przy normalnym, blokujπcym wejúciu/wyjúciu
taka precyzyjna, na bieøπco podawana informacja nie jest dostÍpna. Jeøeli
wπtek czeka na odczyt danych (jest zablokowany na operacji czytania), to
nie moøe rÛwnoczeúnie przekazywaÊ informacji np. o up≥ywajπcym czasie oczekiwania.<br>
Powinniúmy zatem zastosowac mechanizmy NIO - mianowicie kana≥y gniazd klienckich i nieblokujπce wejúcie/wyjúcie.<br>
<br>
<a name="KlientSerwer.9"></a><h2>9. Kana≥y gniazd klienckich i nieblokujπce wejúcie/wyjúcie </h2>
Mechanizmy
NIO (nowego wejúcia-wyjúcia) w Javie sπ nam juø znane. Przed dalszπ lekturπ niewπtpliwie warto odúwieøyÊ
sobie te informacje.&nbsp; <br>
<br>
W odrÛønieniu od kana≥Ûw plikowych <b>kana≥y gniazd</b> umoøliwiajπ nieblokujπce (asynchroniczne) wejúcie-wyjúcie.<br>
Przy czytaniu z takiego kana≥u za pomoca metody read(...), wπtek nie jest
blokowany, gdy brak danych. Metoda read(...) natychmiast zwraca wynik - liczbÍ
przeczytanych bajtÛw (jeúli nie ma jeszcze danych - to 0). Moøemy zatem w
pÍtli odpytywaÊ kana≥ czy dane juø nadesz≥y, a jeúli nie - wykonywaÊ inne
zadania. Za chwilÍ zobaczymy to na przyk≥adzie zmodyfikowanego klienta DICT.
<br><br>
Innπ, odrÛøniajπcπ i waønπ cechπ <b>kana≥Ûw gniazd</b> jest to, iø moøliwe jest ich <b>multipleksowanie</b> czyli obs≥ugiwanie przez jeden wπtek wielu kana≥Ûw. Klasy kana≥Ûw gniazd (<b>SocketChannel</b> i <b>ServerSocketChannel</b>) pochodzπ bowiem od klasy <b>SelectableChannel</b>, ktÛra pozwala na rejestrowanie kana≥Ûw do uøycia z <b>selektorami</b>
. Te zaú obs≥ugujπ selekcjÍ kana≥u (zdarzenia po≥πczenia, czytania, pisania
...), dziÍki czemu moøemy fragmenty programÛw odpowiedzialne np. za odczytywanie
danych z kanalÛw&nbsp;pisaÊ w konwencji call-back.<br>
W≥aúciwoúÊ tÍ majπ zarÛwno kana≥y gniazd klienckich jak i gniazd serwerowych,
niewπtpliwie jednak prawdziwie przydatna jest ona przy programowaniu serwerÛw,
ktÛre przecieø powinny obs≥ugiwac rÛwnolegle wielu klientÛw. Programy klienckie
zwykle korzystajπ z jednego kana≥u komunikacyjnego, w zwiπzku z tym mechanizm
selektorÛw omÛwiony zostanie w dalszych punktach przy okazji programowania serwerÛw,
teraz natomisat zajmiemy siÍ nieblokujπcym wejúciem-wyjúciem dla kana≥Ûw
klienckich.<br>
<br>
Kana≥y gniazd klienckich tworzymy za pomocπ statycznej metody <b>open() klasy
SocketChannel.</b> <br>
Po stworzeniu&nbsp;kana≥u w &nbsp;ten sposÛb&nbsp; kana≥ jeszcze nie jest
po≥πczony (poprzez gniazdo) z serwerem. <br>
Po≥πczenie uzyskujemy uøywajπc metody
<b>connect</b> z argumentem typu <b>SocketAddress</b> (zwykle bÍdzie to znana nam juø&nbsp;
klasa InetSocketAddress, ktÛrej obiekty specyfikujπ adresy gniazd, czyli
adres hosta + numer portu).<br>
<b><br>
<font color="#ff0000">Uwaga</font><font color="#ff0000">: w obecnej postaci kana≥y gniazd nie sπ wystarczajπcπ abstrakcjπ
dla obs≥ugi po≥πczeÒ. Ustalanie opcji gniazd oraz ich zamykanie odbywa siÍ
nadal za pomocπ klasy Socket (dostÍp do obiektu-gniazda, zwiπzanego z danym
kana≥em uzyskujemy za pomocπ metody socket() z klasy SocketChannel). <br>
</font></b>
<br>
Kana≥y gniazd moøemy skonfigurowaÊ w dwÛch trybach: blokujπcym lub nieblokujπcym.
S≥uøy do tego metoda <b>configureBlocking(true | false)</b>. <br>
<br>
W trybie biokujπcym kaøda operacja I/O
blokuje wπtek, dopÛki nie zostanie zakoÒczona. <br>
<br>
W trybie nieblokujπcym operacja
nie blokuje wπtku (jej wywo≥anie wraca natychmiast) i moøe przekazaÊ mniej
bajtÛw danych niø by≥o wymagane lub nawet wcale.<br>
<br><b><font color="#3333ff">
Dla nieblokujπcych kana≥Ûw metoda connect() &nbsp;nie blokuje wπtku</font></b>, wynik jest
zwracany natychmiast i wskazuje na to czy po≥πczenie zosta≥o nawiπzane (true),
lub, øe jest w trakcie nawiπzywania (false).<br>
&nbsp;Zwykle po≥πczenie nie moøe byÊ
nawiπzane natychmiast (ew. wyjπtkiem sπ po≥πczenia z lokalnym hostem), zatem
potrzebny jest mechanizm uzyskania informacji o tym czy i kiedy po≥πczenie
zosta≥o nawiπzane. S≥uøy temu metoda <b>finishConnect()</b>, ktÛrej wywo≥anie zwraca
true, jesli proces ≥πczenbia zosta≥ zakoÒczony a false w przeciwnym razie.<br>
<br>
Schemat nawiπzania po≥πczenia poprzez kana≥ w trybie nieblokujπcym przedstawiono poniøej.<br>
<br>
<div class="syntax"><br>
&nbsp; &nbsp; &nbsp;SocketChannel channel;<br>
&nbsp;&nbsp; &nbsp; String server = ...; // adres hosta serwera<br>
&nbsp; &nbsp; &nbsp;int port = &nbsp; &nbsp; &nbsp; &nbsp; ...; // numer portu<br>
&nbsp; &nbsp; &nbsp;....&nbsp; <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; try {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; channel = SocketChannel.open();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; channel.configureBlocking(false);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; channel.connect(new InetSocketAddress(server, port));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp; &nbsp; &nbsp; &nbsp; System.out.print("£πcze siÍ ...");<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (!channel.finishConnect()) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// ew. pokazywanie czasu ≥πczenia (np. pasek postÍpu)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// lub wykonywanie jakichú innych (krÛtkotrwa≥ych) dzia≥aÒ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; } catch(UnknownHostException exc) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println("Uknown host " + server);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; } catch(Exception exc) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exc.printStackTrace();<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("\nPo≥aczony");<br>
</div><br>
<br>
SkrÛcowπ formπ utworzenia kana≥u i po≥πczenia jest wywo≥anie metody:<br>
<br>
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>SocketChannel&nbsp; SocketChannel.open(InetSocketAddress)</b><br>
<br><b><font color="#3333ff">
To odwo≥anie jest blokujπce</font></b> (bowiem kana≥y sπ domyúlnie tworzone w trybie
blokujπcym), ale tryb ten moøemy w dowolnym momencie zmieniÊ na nieblokujπcy
za pomocπ metody <b>configureBlocking(...)</b> i od tego momenty wszetkie operacje
we/wy na kanale bÍdπ nieblokujπce.<br>
<br>
Po stworzeniu kana≥u moøemy do niego pisaÊ (przekazywaÊ zlecenia do serwera)
lub z niego czytaÊ (odczytywaÊ dane przekazane przez serwer). &nbsp;<b>W sumie jest
to wygodne, bowiem zamiast dwÛch strumieni zwiπzanych z gniazdem mamy jeden
kana≥</b>. Przy tym jednak musimy pos≥ugiwac siÍ buforami NIO. Przypomnijmy, øe:<br>
<ul>
  <li>czytamy dane z kana≥u do bufora bajtowego (ByteBuffer) za pomocπ metod
<b>read(...)</b>, zapisujemy dane do kana≥u z bufora bajtowego (ByteBuffer) za pomocπ
metody <b>write(...)</b>; moøemy przy tym korzystaÊ z tzw. czytania rozprowadzajπcego
po wielu buforach (<b>scattering read</b>) i gromadzπcego pisania z wielu buforÛw
(<b>gathering write</b>),</li>
  <li>bufory bajtowe muszπ byÊ <b>alokowane</b> za pomocπ metod allocate(...), allocateDirect(...),
albo muszπ <b>opakowywaÊ</b> istniejπce w postaci tablic typu byte[] struktury danych.</li>
  <li>&nbsp;praca z buforami bajtowymi jest specyficzna, wymaga bowiem manipulacji
<b>parametrami </b>(pozycjami) bufora; np. po wczytaniu danych do bufora musimy
go przestawiÊ zapomocπ metody <b><font color="#009900">flip()</font></b>, po to by mÛc z tych dancyh korzystaÊ,</li>
  <li>przekazywanie danych znakowych (tekstÛw) za poúrednictwem kana≥Ûw wymaga
ich <b>kodowania/dekodowania</b> (uøycie klas Charset i CharBuffer).</li>
</ul>Schemat nieblokujπcego czytania.<br>
<br>
<div class="syntax"><br>
<div align="center"><b>Moøliwy schemat nieblokujπcego czytania<br>
z kana≥u gniazda<br>
</b></div>
<br>
<b>SocketChannel channel;</b><br>
<br>
// Utworzenie i po≥πczenie kana≥u<br>
// ...<br>
// Ustalenie trybu nieblokujπcego<br>
<b><br>
channel.configureBlocking(false);</b><br>
// ...<br>
<br>
// Alokowanie bufora bajtowego<br>
// allocateDirect pozwala na wykorzystanie mechanizmÛw sprzÍtowych<br>
// do przyspieszenia operacji we/wy<br>
// Uwaga: taki bufor powinien byÊ alokowany jednokrotnie<br>
// i wielokrotnie wykorzystywany w operacjach we/wy<br>
<b><br>
&nbsp; ByteBuffer inBuf = ByteBuffer.allocateDirect(<i>rozmiar_bufora</i>);</b><br>
<br>
&nbsp; // pÍtla czytania<br>
<b>&nbsp; while (true) { &nbsp; &nbsp; &nbsp;</b><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>inBuf.clear();</b> &nbsp;
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//
oprÛønienie bufora<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>int readBytes = channel.read(inBuf);</b> &nbsp; &nbsp; // czytanie nieblokujπce<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; // natychmiast zwraca liczbÍ<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; // przeczytanych bajtÛw<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>if (readBytes == 0) { </b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// jeszcze nie ma danych<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // jakieú (krÛtkotrwa≥e) dzia≥ania np. info o up≥ywajπcym czasie<br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;</b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (readBytes == -1) { &nbsp;</b> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // kana≥ zamkniÍty po stronie serwera<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;// dalsze czytanie niemoølwe<br>
<b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else { </b>&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// dane dostÍpne w buforze<br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inBuf.flip();</b>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //
przestawienie bufora<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // pobranie danych z bufora<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ew. decyzje o tym czy mamay komplet danych - wtedy break<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // czy teø mamy jeszcze coú do odebrania z serwera - kontynuacja <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp; }<br>
<br>
Uwaga: na schemacie nie pokazano koniecznej obs≥ugi wyjπtkÛw; generalnei
dotyczy ona po≥πczenia i konfiguracji kana≥u a takøe operacji read.<br>
</div><br>
<br>Nowa wersja klienta DICT.<br>
Program bÍdzie sk≥adaÊ siÍ z dwÛch klas:<br>
<ul>

  <li>klasa DictGui utworzy kana≥, skonfiguruje go w trybie nieblokujπcym
i po≥πczy go z serwerem s≥ownikowym; definiuje ona rÛwnieø interfej graficzny, w ktÛrym mamy do dyspozycji
edytor tekstu oraz pole tekstowe, do ktÛrego moøemy wpisaÊ szukany termin;
po wciúniÍciu ENTER na polu tekstowym uruchomioiny zostanie wπtek wyszukiwania
s≥ownikowego (klasa ReadDef), a informacje o postÍpach szukania bÍdπ uwidaczniane
w informacyjnej etykiecie interfejsu graficznego; po skompletowaniu wynikÛw
przyciskiem "Wklej definicje" bÍdziemy mogli wkleiÊ wyniki otrzymane od serwera
s≥ownikowego do edytora w miejscu kursora; klasa ta rÛwnieø (jeszcze przed
utworzeniem GUI)&nbsp;utworzy kana≥, skonfiguruje go w trybie nieblokujπcym i po≥πczy go z serwerem s≥ownikowym;</li>
  <li>klasa ReadDef zapisuje do kana≥u zlecenie dla serwera (podaj definicjÍ
s≥owa przekazanego jako argument kosntruktora) i w sposÛb nieblokujπcy czyta
odpowiedü serwera, pokazujπc w GUI ile czasu serwerowi zajÍ≥o szukanie i
ile porcji danych trzeba by≥o odczytaÊ z kana≥u.</li>
</ul>
Kod programu pokazano na poniøszym wydruku:<br>
<pre>import java.io.*;
import java.net.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;
import java.util.regex.*;


class DictGui extends JFrame implements ActionListener {

  public final static int port = 2628;
  private String server;
  private SocketChannel channel;

  private JTextArea ta = new JTextArea(20, 20);
  private JTextField tf = new JTextField(20);
  private JLabel infoLab = new JLabel("Nie by≥o szukania");
  private JButton paste = new JButton("Wklej definicjÍ");
  private Container cp = getContentPane();
  private ReadDef rd;

  public DictGui(String server) {
    this.server = server;

    // Otwarcie&nbsp;i po≥πczenie kana≥u
    // metoda connect - zdefiniowana u koÒca klasy
    try {
      channel = SocketChannel.open();
      channel.configureBlocking(false);
      connect();
    } catch(UnknownHostException exc) {
        System.err.println("Uknown host " + server);
        System.exit(1);
    } catch(IOException exc) {
        exc.printStackTrace();
        System.exit(2);
    }

    // Konfiguracja GUI
    Font f = new Font("Dialog", Font.BOLD, 14);
    ta.setFont(f);
    tf.setFont(f);
    tf.setBorder(BorderFactory.createLineBorder(Color.orange, 1));
    infoLab.setPreferredSize(new Dimension(200,30));
    JPanel p = new JPanel();
    p.setBorder(BorderFactory.createLineBorder(Color.red, 2));
    p.add(tf);
    p.add(infoLab);
    p.add(paste);
    cp.add(new JScrollPane(ta));
    cp.add(p, "South");

    tf.addActionListener(this);
    paste.addActionListener(this);

    // Przy zamykaniu aplikacji
    // zamykamy kana≥ i gniazdo
    addWindowListener( new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        dispose();
        try {
         channel.close();
         channel.socket().close();
        } catch(Exception exc) {}
        System.exit(0);
      }
    });

    pack();
    show();
  }

  // Obs≥uga akcji
  public void actionPerformed(ActionEvent e) {
    // KlikniÍcie w przycisk "Wklej definicjÍ"
    // definicjÍ przechowuje dla nas obiekr klasy ReadDef
    if (e.getSource() == paste &amp;&amp; rd != null) {
       ta.insert(rd.getResult(), ta.getCaretPosition());
    }
    else {  // ENTER na polu tekstowym tf - start wπtku komuniakcji z serwerem
     if (!channel.isConnected()) try {
       connect();
     } catch(Exception exc) {
        exc.printStackTrace();
        return;
     }
     rd = new ReadDef(this, channel, tf.getText());
     rd.start();
    }
  }

  // £πczenie kana≥u z serwerem
  private void connect() throws UnknownHostException, IOException {
    if (!channel.isOpen()) channel = SocketChannel.open();
    channel.connect(new InetSocketAddress(server, port));
    System.out.print("£πcze siÍ ...");
    while (!channel.finishConnect()) {
      try { Thread.sleep(200); } catch(Exception exc) { return; }
      System.out.print(".");
    }
    System.out.println("\\nPo≥πczony.");
  }

  // Metoda wykorzystywana przez ReadDef
  // do pokazywania postepÛw komuniakcji z serwerem
  public void setInfo(String s) {
    infoLab.setText(s);
  }
}

class ReadDef extends Thread {

  private static Charset charset  = Charset.forName("ISO-8859-2");
  private static ByteBuffer inBuf = ByteBuffer.allocateDirect(1024);
  private static Matcher matchCode =
                 Pattern.compile("(\\n250 ok)|(552 no match)").matcher("");
  private SocketChannel channel;
  private DictGui gui;
  private String word;


  public ReadDef(DictGui gui, SocketChannel ch, String wordToSearch) {
    this.gui = gui;
    channel = ch;
    word = wordToSearch;
  }

  private StringBuffer result;

  public void run() {
    result = new StringBuffer("Wyniki wyszukiwania:\\n");
    int count = 0, rcount = 0;
    try {
      CharBuffer cbuf = CharBuffer.wrap("DEFINE * " + word + "\\n");
      ByteBuffer outBuf = charset.encode(cbuf);
      channel.write(outBuf);

      while (true) {
        inBuf.clear();
        int readBytes = channel.read(inBuf);
        if (readBytes == 0) {
          gui.setInfo("Czekam ... " + ++count);
          Thread.sleep(200);
          continue;
        }
        else if (readBytes == -1) {
          gui.setInfo("Kana≥ zamkniÍty");
          channel.close();
          break;
        }
        else {
          inBuf.flip();
          cbuf = charset.decode(inBuf);
          result.append(cbuf);
          matchCode.reset(cbuf);
          if (matchCode.find()) break;
          else gui.setInfo("Czytam ... " + ++rcount);
        }
      }
    } catch(Exception exc) {
         exc.printStackTrace();
         return;
    }
    gui.setInfo("Czeka≥em: " + count + " / Czyta≥em: " + rcount + ". Gotowe.");
  }

  public String getResult() {
    if (result == null) return "Brak wynikÛw wyszukiwania";
    return result.toString();
  }
}

class Main {
  public static void main(String[] args) {
    String server = "dict.org";
    new DictGui(server);
  }
}
</pre>
Komentarze:<br>
<ul>
  <li>przed utworzeniem i wystartowaniem wπtku ReadDef sprawdzane jest czy
kana≥ nadal jest po≥πczony (isConnected()); jeúli nie to nastÍpuje prÛba
ponownego po≥πczenia;</li>
  <li>przy ≥πczeniu w metodzie connect() sprawdzamy czy kana≥ jest otwarty,
jeúli nie to otwieramy go ponownie; kana≥ moøe byÊ automatycznie zamkniÍty
na skutek utraty po≥πczenia z serwerem.</li>  <li>interakcja pomiÍdzy klasami DictGUI i ReadDef odbywa siÍ za pomocπ
metod: setInfo(...) i getResult(...); metoda klasy DictGUI setInfo(), wywo≥ywana
z klasy ReadDef jest wielowπtkowo bezpieczna, gdyø praktycznie wywo≥uje tylko
wielowπtkowo bezpiecznπ metodÍ setlText(...) z klasy JLabel;</li>
  <li>przy czytaniu/zapisywaniu tekstÛw z/do kana≥u stosujemy dekodowanie/kodowanie za pomocπ klas Charset (teksty mamy w CharBuffer),</li>
  <li>kody zwracane przez serwer wyszukujemy za pomocπ wyraøeÒ regularnych;
wzorzec zastosowany do wyszukiwania nie jest najbardziej uniwersalny, ale
wystarczajπcy dla celÛw ilustracji,</li>
  <li>uøyte w programie rozwiπzanie polegajπce na uruchamianiu nowego wπtku
ReadDef dla kaødego wyszukiwania nie jest najlepsze; ogÛlnie powinien dzia≥aÊ
jeden wπtek ReadDef synchronizowany i koordynowany z DictGUI za pomocπ mechanizmu
wait-notify; tego rozwiπzania nie pokazujÍ, aby nie zaciemniaÊ obrazu, ktÛry
ma jedynie ilustrowaÊ nieblokujπce wejúcie-wyjúcie i uøycie kana≥Ûw gniazd
klienckich.</li>
</ul>
SposÛb dzia≥ania programu ilustruje rysunek.<br>
<img src="images/dict3.jpg" alt="r" height="464" width="592">
<br>
<br>
Widzimy tu (w obszarze etykiety informacyjnej), øe nasz klient czeka≥ ok.
600 ms (3 *200) na uzyskanie pierwszej odpowiedzi serwera na zapytanie o definicjÍ s≥owa "words<br>
, a odpowiedü przeczyta≥ w dwÛch porcjach danych (pierwsza 1024B, druga co najwyøej 1024 bajty).<br>
<a name="KlientSerwer.10"></a><h2>
10. Serwery</h2>

Serwery dostarczajπ - na zlecenie klientÛw - okreúlonych us≥ug (m.in. informacji).<br>
Typowe dzia≥anie serwera polega na:<br>
<ol>
  <li>Utworzeniu gniazda serwera (klasa ServerSocket)</li>
  <li>Zwiπzaniu go z okreúlonym adresem (adres hosta, na ktÛrym dzia≥a serwer + adres portu)</li>
  <li>Oczekiwaniu na po≥πczenie od klienta "na tym" gnieüdzie</li>
  <li>Po zaakceptowaniu po≥πczenia od klienta - utworzeniu ganiazda wymiany
informacji z po≥πczonym klientem (klasa Socket) i obs≥udze zleceÒ tego klienta
posy≥anych poprzez strumieÒ zwiπzany z tym gniazdem.</li>
  <li>Kontynuacji "nas≥uchu" po≥πczeÒ od innych klientÛw na gnieødzie serwera.</li>
</ol>
Poniøszy schemat ilustruje oprogramowanie serwera.<br>
<br>
<div class="syntax"><br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String host = ...;&nbsp; // nazwa hosta<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int port = ...;&nbsp;&nbsp;&nbsp;&nbsp; // numer portu<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; InetSocketAddress isa = new InetSocketAddress(host, port);<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Utworzenie gniazda serwera<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ServerSocket serverSock =&nbsp; new ServerSocket();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Zwiπzanie gniazda serwera z adresem hosta i portu<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serverSock.bind(isa);<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // W pÍtli nastÍpuje akceptacja po≥πczeÒ kolejnych klientÛw<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i obs≥uga ich zleceÒ<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean serverIsRunning = true; &nbsp; &nbsp; &nbsp; &nbsp; // przy zamykaniu serwera<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;// ustalane na false (np. przez inny wπtek)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (serverIsRunning) {&nbsp; <br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // akceptacja po≥πczenia<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // i utworzenie gniazda komunikacji z po≥πczonym klientem<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket connection = serverSock.accept();<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // obs≥uga zleceÒ klienta<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // za poúrednictwem strumieni we/wy zwiπzanych z gniazdem connection<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // po zakoÒczeniu interakcji z klientem<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // - zamkniÍcie strumieni i gniazda<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection.close()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; }<br>
&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;&nbsp; // zamkniÍcie gniazda serwera<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp; serverSock.close();<br>
</div><br>
<br>
Przy tworzenie adresu gniazda (InetSocketAddress) podajemy host serwera oraz
port poprzez ktÛry serwer bÍdzie dostÍpny dla klientÛw.<br>
W naszych eksperymentach domowych jako host moøemy podaÊ "localhost" (lub adres "127.0.0.1").<br>
Specyfikujπc numer portu, naleøy pamiÍtaÊ o tym, øe pierwsze 1024 porty sπ
zarezerwowane (wspominane wczeúniej "dobrze-znane-porty"). Moøemy oczywiúcie
pisaÊ serwer FTP czy HTTP, ale uøycie w≥aúciwych dla nich numerÛw portÛw
wymaga uprawnieÒ administrtora systemu (przy braku takich uprawnieÒ, uøywamy
dostÍpnych numerÛw portÛw, czasem konwencjonalnych np. dla serwera HTTP -
8080).<br>
<br>
<br>
Metoda <b>bind</b>(...) wiπøe gniazdo serwera z podanym adresem. Moøemy podaÊ rÛwnieø
- jako jej drugi argument - maksymalnπ liczbÍ klientÛw oczekujπcych na po≥πczenie
(domyúlnie jest to liczba 50). Wtedy przy wyd≥uøeniu kolejki oczekujπcych
klientÛw poza podanπ liczbÍ, kolejni prÛbujπcy ≥πczyÊ sie z serwerem klienci
bÍdπ uzyskiwaÊ odmowÍ po≥πczenia (wyjπtek "Connection refused").<br>
<br>
Metoda <b>accept()</b> jest blokujπca<b> </b>i wstrzymuje wykonanie wπtku do chwili
zg≥oszenia chÍci po≥πczenia ze strony klienta (klient ≥πczy siÍ z serwerem,
podajπc - czy to w konstruktorze klasy Socket, czy w metodzie connect() host
serwera i numer portu, ktÛry przydzieli≥ sobie serwer).&nbsp; Gdy po≥πczenie jest
akceptowane, metoda accept() zwraca gniazdo (obiekt klasy Socket), poprzez
ktÛre bÍdzie odbywaÊ siÍ interakcja klienta z serwerem. <br>
Metoda accept() zmoøe sygnalizowaÊ m.in. wyjπtek SocketTimeoutException, ktÛry
powstaje, gdy przekroczony zostanie limit czasowy na uzyskanie po≥πczenia.
Dla gniazda serwera moøemy ustaliÊ ten limit za pomocπ metody setSoTimeout().
<br>
<br>
Od gniazda, zwrÛconego przez metodÍ accept() moøna uzyskaÊ strumienie wejúciowy
i wyjúciowy i za ich pomocπ "rozmawiaÊ" z klientem.<br>
<br>
Piszπc w≥asny serwer naleøy przemyúleÊ i ustaliÊ protokÛ≥ komunikacji. Oczywiúcie,
moøemy skorzystaÊ z gotowych protoko≥Ûw (np. HTTP czy FTP). Takie serwery
sπ jednak juø gotowe - celowoúÊ pisania w≥asnych serwerÛw HTTP czy FTP jest
uzasadniona tylko w przypadkach jakiegoú testowania czy teø specjalnego dostosowywania
tych protoko≥Ûw. NajczÍúciej zatem bÍdziemy tworzyÊ ca≥kiem nowy, w≥asny protokÛ≥.<br>
<br> Zilustruje to przyk≥ad serwera - ksiπøki telefonicznej. Serwer ma dostÍp
do "bazy" numerÛw telefonÛw. Dla prostoty wykorzystamy mapÍ, w ktÛrej osobom-kluczom
bÍdπ przypisane numery telefonÛw - wartoúci, a dostÍp do niej zrealizujemy
poprzez klasÍ PhoneDirectory.<br>
<pre>import java.util.*;
import java.io.*;

public class PhoneDirectory {

  private Map pbMap = new HashMap();

  public PhoneDirectory(String fileName) {
    // Inicjalna zawartoúÊ ksiπøki telefonicznej
    // jest wczytywana z pliku o formacie
    //  imiÍ  numer_telefonu
    try {
      BufferedReader br = new BufferedReader(
                             new FileReader(fileName));
      String line;
      while ((line = br.readLine()) != null) {
        String[] info = line.split(" +", 2);
        pbMap.put(info[0], info[1]);
      }
    } catch (Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }

  // Zwraca numer telefonu dla podanej osoby
  public String getPhoneNumber(String name) {
    return (String) pbMap.get(name);
  }

  // Dodaje nowπ osobÍ do ksiπøki
  // Wynik:
  // - true - dodana
  // - false - nie (przy prÛbie dodania osoby zapisanej juø w ksiπøce)
  public boolean addPhoneNumber(String name, String num) {
    if (pbMap.containsKey(name)) return false;
    pbMap.put(name, num);
    return true;
  }

  // ZastÍpuje numer podanej osoby nowym
  // Wynik:
  // - true (numer zastπpiony)
  // - false (nie - prÛba podania nowegu numeru nieistniejπcej osoby)
  public boolean replacePhoneNumber(String name, String num) {
    if (!pbMap.containsKey(name)) return false;
    pbMap.put(name, num);
    return true;
  }

}&nbsp; </pre>
<br>
Serwer obs≥uguje zlecenia klientÛw: <br>
<ul>
  <li><b>get imiÍ</b> (podaj numer telefonu dla wskazanej osoby),</li>
  <li><b>add imiÍ numer</b> (dopisz do ksiπøki osobÍ i jej numer telefoniczny),</li>
  <li><b>replace imiÍ numer</b> (zastπp w ksiπøece numer telefony pdoanej osoby nowym numerem).</li>
  <li><b>bye</b> ( zakoÒczenie komunikacji)<br>
  </li>
</ul>
Na kaøde zlecenie klienta serwer odpowiada posy≥ajπc (jako jeden wiersz)
kod numeryczny wyniku przetworzenia zlecenia oraz opis tego wyniku. Przy
zleceniu get posy≥any jest w odpowiedzi dodatkowy, kolejny wiersz zawierajπcy
numer telefonu.<br>
Ustalimy nastÍpujπce kody:<br>
0 - zlecenie wykonane (Ok)<br>
1 - b≥Ídna sk≥adnia zlecenia lub nieznane zlecenie (Invalid request)<br>
2 - nie znaleziono numeru dla podanej osoby, dotyczy tylko zlecenia get (Not found)<br>
3 - b≥πd w zleceniu add - prÛba dodania osoby-numeru, ktÛra juø istnieje w ksiπøce<br>
4 - b≥πd w zleceniu replace - prÛba podania nowego numeru dla nie istniejπcej osoby<br>
<br>
Program serwera podano na wydruku.<br>
<br>
<pre>import java.net.*;
import java.io.*;
import java.util.regex.*;

public class PhoneBookServer1  {

  private PhoneDirectory pd = null;  // mapa osoby-numery tel.
  private ServerSocket ss = null;
  private BufferedReader in = null;  // strumienie gniazda
  private PrintWriter out = null;    // komunikacji z klientem

  public PhoneBookServer1(PhoneDirectory pd, ServerSocket ss) {
    this.pd = pd;
    this.ss = ss;
    System.out.println("Server started");
    System.out.println("at port: " + ss.getLocalPort());
    System.out.println("bind address: " + ss.getInetAddress());

    serviceConnections();  // nas≥uchiwanie po≥πczeÒ
  }

  // Metoda nas≥uchuje po≥πczeÒ od klientÛw
  // po zaakceptowaniu po≥πczenia - tworzy gniazdo komunikacyjne
  // i przekazuje obs≥ugÍ zleceÒ metdodzie serviceRequest

  private void serviceConnections() {
    boolean serverRunning = true;   // serwer dzia≥a ciπgle
    while (serverRunning) {
      try {
        Socket conn = ss.accept();  // nas≥uch i akceptaccja po≥πczeÒ

        System.out.println("Connection established");

        serviceRequests(conn);      // obs≥uga zleceÒ dla tego po≥πczenia

      } catch (Exception exc) {
          exc.printStackTrace();
      }
    }                               // zamkniÍcie gniazda serwera
    try { ss.close(); } catch (Exception exc) {}
  }

  // wzorzec do rozbioru zlecenia (maks. trzy "s≥owa" rozdzielone spacjami)
  private static Pattern reqPatt = Pattern.compile(" +", 3);

  // S≥owne komunikaty serwera
  // odpowidajπce im indeksy tablicy - kody wyniku
  private static String msg[] = { "Ok", "Invalid request", "Not found",
                                  "Couldn't add - entry already exists",
                                  "Couldn't replace non-existing entry",
                                  };


  // Obs≥uga zleceÒ od klienta
  private void serviceRequests(Socket connection)
                              throws IOException {
    try {
      in = new BufferedReader(                   // utworzenie strumieni
               new InputStreamReader(
                   connection.getInputStream()));
      out = new PrintWriter(
                connection.getOutputStream(), true);

      // Odczytywanie zleceÒ (line zawiera kolejne zlecenie)
      for (String line; (line = in.readLine()) != null; ) {

        String resp;                           // odpowiedü
        String[] req = reqPatt.split(line, 3); // rozbiÛr zlecenia
        String cmd = req[0];                   // pierwsze s≥owo - polecenie

        if (cmd.equals("bye")) {        // zlecenie "bye" - koniec komunikacji
          writeResp(0, null);
          break;
        }
        else if (cmd.equals("get")) {   // "get" - klient chce dostaÊ nr tel.
          if (req.length != 2) writeResp(1, null);
          else {
            String phNum = (String) pd.getPhoneNumber(req[1]); // pobranie
            if (phNum == null) writeResp(2, null);             // numeru tel.
            else writeResp(0, phNum);                          // i zapis
          }
        }
        else if (cmd.equals("add"))  {  // "add" - klient chce dodaÊ numer
          if (req.length != 3) writeResp(1, null);
          else {
            boolean added = pd.addPhoneNumber(req[1], req[2]); // dodany?
            if (added) writeResp(0, null);                     // tak - ok
            else writeResp(3, null);                           // nie
          }
        }
        else if (cmd.equals("replace"))  {  // klient chce zmieniÊ nr tel.
          if (req.length != 3) writeResp(1, null);
          else {
            boolean replaced = pd.replacePhoneNumber(req[1], req[2]);
            if (replaced) writeResp(0, null);
            else writeResp(4, null);
          }
        }
        else writeResp(1, null);             // nieznane zlecenie
      }
    } catch (Exception exc) {
        exc.printStackTrace();

    } finally {
        try {                                // zamkniÍcie strumieni
          in.close();                        // i gniazda
          out.close();
          connection.close();
          connection = null;
        } catch (Exception exc) { }
    }
  }


  // Przekazanie odpowiedzi klientowi poprzez zapis do strumienia
  // gniazda komuniakcyjnego
  private void writeResp(int rc, String addMsg)
               throws IOException {
    out.println(rc + " " + msg[rc]);
    if (addMsg != null) out.println(addMsg);
  }

  public static void main(String[] args) {
    PhoneDirectory pd = null;
    ServerSocket ss = null;
    try {
      String phdFileName = args[0];
      String host = args[1];
      int port = Integer.parseInt(args[2]);

      pd = new PhoneDirectory(phdFileName); // utworzenie mapy numerÛw z pliku

      InetSocketAddress isa = new InetSocketAddress(host, port);

      ss =  new ServerSocket();             // Utworzenie gniazda serwera
      ss.bind(isa);                         // i zwiπzanie go z adresem

    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
    new PhoneBookServer1(pd, ss);
  }

}
</pre>
<br>
Przyk≥adowy klient, ktÛry wykonuje szereg testujπcych operacji moøe wyglπdaÊ tak jak na poniøszym wydruku.<br>
<br>
<pre>import java.net.*;
import java.io.*;

public class PhoneBookClient {

  private Socket sock = null;
  private PrintWriter out = null;
  private BufferedReader in = null;

  public PhoneBookClient(String host, int port) {
    try {
      sock = new Socket(host, port);
      out = new PrintWriter(sock.getOutputStream(), true);
      in = new BufferedReader(
               new InputStreamReader(
                   sock.getInputStream()));

      makeRequest("get Asia");
      makeRequest("get Alicja");
      makeRequest("add Adam 77777");
      makeRequest("add Adam");
      makeRequest("get Adam");
      makeRequest("add Adam 333333");
      makeRequest("replace Adam 333333");
      makeRequest("replace Alicja 202020");
      makeRequest("get Adam");
      makeRequest("add");
      makeRequest("");
      makeRequest("bye");
      in.close();
      out.close();
      sock.close();
    } catch (UnknownHostException e) {
        System.err.println("Nieznany host: "+host);
        System.exit(2);
    } catch (IOException e) {
        System.err.println("I/O err dla");
        System.exit(3);
    } catch (Exception exc) {
        exc.printStackTrace();
        System.exit(4);
    }
  }

  private boolean makeRequest(String req) throws IOException {
    System.out.println("Request: " + req);
    out.println(req);
    String resp = in.readLine();
    System.out.println(resp);
    boolean ok = resp.startsWith("0");
    if (req.startsWith("get") &amp;&amp; ok)
       System.out.println(in.readLine());
    return ok;
  }

  public static void main(String[] args) {
    new PhoneBookClient(args[0], Integer.parseInt(args[1]));
  }
}
</pre>
<br>
Po kompilacji programÛw, uruchamiamy serwer&nbsp;w sesji znakowej poleceniem i otrzymujemy potwierdzenie uruchomienia serwera:<br>
<br>
<div class="listing100"><br>
&gt;java PhoneBookServer1 Book.txt localhost 2300<br>
<br>
Server started<br>

at port: 2300<br>

bind address: localhost/127.0.0.1<br>
</div><br>
<br>
Wybraliúmy tu&nbsp; port 2300 i wszyscy klienci ≥πczπcy siÍ z tym serwerem bÍdπ musieli korzystaÊ z tego portu.<br>
Klienta uruchamiamy w innej sesji znakowej (jako odrÍbny proces):<br>
<br>
<div class="listing100"><br>
&gt;java PhoneBookClient localhost 2300<br>
</div><br>
<br>
Po uruchomieniu, klient podejmie prÛbÍ po≥πczenia z serwerem, nas≥uchujπca
metoda accept() serwera przyjmie po≥πczenie, a nasz program serwera wypisze
inforrmacjÍ o ustanowieniu po≥πczenia:<br>
<br>
<div class="listing100"><br>
Connection established<br>
</div><br>
<br>
<br>
Od tego momentu zacznie siÍ interakcja klienta i serwera. Klient bÍdzie posy≥a≥
kolejne polecenia (zapisanie w programie przykaπdowym), a serwer je realizowa≥
i odpowiada≥ klientowi podajπc wynik przetworzenia zlecenia oraz (ew.) dodatkowπ
informacjÍ (numery telefonÛw). W programie klienta zapewniono wypisywanie
na konsoli kolejnych krokÛw tej komunikacji. Wyglπda to tak.<br>
<div class="listing100"><br>
Request: get Asia<br>
0 Ok<br>
171717<br>
Request: get Alicja<br>
2 Not found<br>
Request: add Adam 77777<br>
0 Ok<br>
Request: add Adam<br>
1 Invalid request<br>
Request: get Adam<br>
0 Ok<br>
77777<br>
Request: add Adam 333333<br>
3 Couldn't add - entry already exists<br>
Request: replace Adam 333333<br>
0 Ok<br>
Request: replace Alicja 202020<br>
4 Couldn't replace non-existing entry<br>
Request: get Adam<br>
0 Ok<br>
333333<br>
Request: add<br>
1 Invalid request<br>
Request: <br>
1 Invalid request<br>
Request: bye<br>
0 Ok<br>
</div> <br>
<br>
Opisywany serwer "telefoniczny" ma jednπ bardzo istotnπ wadÍ: nie jest przygotowany
do tego by rÛwnolegle obs≥ugiwaÊ wielu klientÛw. <br><br>
Ilustruje to fragmencik programu,&nbsp; tworzπcy trzech klientÛw naszej ksiπøki
telefonicznej (dzia≥ajπcych jako wπtki). Kaødy z klientÛw kilkakrotnie pyta
o numer telefonu wlaúciwiej dla niego osoby, nie zaw≥aszczajπc przy tym ca≥kowicie procesora
(uøycie Thread.sleep). <br>
<br>
<pre>import java.net.*;
import java.io.*;

public class PhoneBookClients extends Thread {

  private Socket sock = null;
  private PrintWriter out = null;
  private BufferedReader in = null;
  private String nameToSearch;

  public PhoneBookClients(String host, int port, String name ) {
    try {
      sock = new Socket(host, port);
      out = new PrintWriter(sock.getOutputStream(), true);
      in = new BufferedReader(
               new InputStreamReader(
                   sock.getInputStream()));

      nameToSearch = name;

    } catch (Exception exc) {
        exc.printStackTrace();
        System.exit(4);
    }
    start();
  }

  public void run() {
    try {
      for (int i=1; i &lt;= 5; i++) {
        find(nameToSearch);
        Thread.sleep(500);
      }
      out.println("bye");
    } catch (Exception exc) {
        exc.printStackTrace();
    }
  }

  private void find(String name) throws IOException {
    out.println("get " + name);
    String resp = in.readLine();
    boolean ok = resp.startsWith("0");
    String tel = ok ? in.readLine() : " - not found";
    System.out.println(name + " - tel. " + tel);
  }

  public static void main(String[] args) {
    String host = args[0];
    int port = Integer.parseInt(args[1]);
    String[] names = { "Asia", "Adam", "Jacek" };
    for (int i=0; i&lt;names.length; i++)
      new PhoneBookClients(host, port, names[i]);
  }
}
</pre>
<br>
Zatem kaødy klient jest wyw≥aszczany i wtedy o nuner telefonu ma szansÍ zapytaÊ inny klient.<br>
Nic takiego siÍ jednak nie dzieje, bowiem&nbsp; nasz serwer nie potrafi rÛwnolegle
obs≥ugiwaÊ wielu klientÛw i musi zawsze zakoÒczyÊ rozpoczetπ komunikacjÍ.
W efekcie klienci obs≥ugiwani sπ po kolei (a nie rownolegle) co obrazuje
wynik dzia≥ania programu.<br>
<br>
<div class="listing100"><br>
&gt;java PhoneBookClients localhost 2300<br>
<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Asia - tel. 171717<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Adam - tel. 333333<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
Jacek - tel. 111111<br>
</div><br>
<br>
Serwery dzia≥ajπce w ten sposÛb noszπ nazwÍ <b>serwerÛw sekwencyjnych</b>.<br>
Ich uøytecznoúÊ jest ograniczona: zwykle wymaga siÍ bowiem by serwer obs≥ugiwa≥ rÛwnolegle wielu klientÛw.<br>
&nbsp;<br>
<br>
<br>
<a name="KlientSerwer.11"></a><h2>
11. Serwery wielowπtkowe</h2>

Klasycznym rozwiπzaniem wspomnianego przed chwilπ problemu jest zastosowanie wspÛ≥bieønoúci w programowaniu serwerÛw.<br>
<br>
Jednym z moøliwych podejúÊ jest:<br>
<ul>
  <li>utworzenie gniazda serwera (ServerSocket) i zwiπzanie go z adresem (bind),</li>
  <li>po czym uruchomienie wielu wπtkÛw serwera, kaødy z ktÛrych bÍdzie rownolegle&nbsp;
nas≥uchiwa≥ i akceptowa≥ po≥πczenia na tym gnieüdzie i obs≥ugiwa≥ akceptowane
po≥πczenia.</li>
</ul><br>
Przyjrzyjmy siÍ temu rozwiπzaniu w praktyce na przyk≥adzie zmodyfikowanego
serwera "ksiπzki telefonicznej", ktÛry teraz uczynimy wielowπtkowym.<br>
<br>
<pre>import java.net.*;
import java.io.*;
import java.util.regex.*;

public class PhoneBookServerMT1 extends Thread {

  private PhoneDirectory pd = null;
  private ServerSocket ss = null;
  private BufferedReader in = null;
  private PrintWriter out = null;

  private volatile boolean serverRunning = true; // moøna zakoÒczyÊ wπtek
                                         // metodπ ustalajπcπ
                                         // wartoúÊ tej zmiennej na false

  private String serverTID;              // identyfikator wπtku

  public PhoneBookServerMT1(String serverTID, PhoneDirectory pd,
                          ServerSocket ss) {
    this.serverTID = serverTID;
    this.pd = pd;
    this.ss = ss;
    System.out.println("Server " + serverTID + " started");
    System.out.println("listening at port: " + ss.getLocalPort());
    System.out.println("bind address: " + ss.getInetAddress());

    start();    // uruchomienie wπtku
  }


  public void run() {
    while (serverRunning) {
      try {
        Socket conn = ss.accept();

        System.out.println("Connection established by " + serverTID);

        serviceRequests(conn);

      } catch (Exception exc) {
          exc.printStackTrace();
      }
    }                               // zamkniÍcie gniazda serwera
    try { ss.close(); } catch (Exception exc) {}
  }

  // Pozoate≥e metody&nbsp;m.in.serviceRequest jak w poprzednio pokazanej klaeie

  private void serviceRequests(Socket connection) {
     // ...
  }

  private void writeResp(int rc, String addMsg)
               throws IOException {
     // ...
  }

  public static void main(String[] args) {
    final int SERVERS_NUM = 4;   // liczba serwerÛw
    PhoneDirectory pd = null;
    ServerSocket ss = null;
    try {
      String phdFileName = args[0];
      String host = args[1];
      int port = Integer.parseInt(args[2]);
      pd = new PhoneDirectory(phdFileName);
      InetSocketAddress isa = new InetSocketAddress(host, port);
      ss =  new ServerSocket();
      ss.bind(isa);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    // Start wielu wπtkÛw (serwerow) dzialajπcych rÛwnolegle
    // na tym samym gnieødzie serwera

    for (int i=1; i &lt;= SERVERS_NUM; i++) {
      new PhoneBookServerMT1("serv thread " + i, pd, ss);
    }
  }

}
</pre>
Tym razem nasza klasa serwera dziedziczy Thread, a jej obiekty-wπtki sπ uruchamiane
metodπ start() z konstruktora. Akceptacja i obs≥uga po≥πczeÒ (przekazywana
metodzie serviceRequests) jest zapisana w metodzie run(). Zatem kaødy z uruchomionych
wπtkÛw-serwerÛw jest zdolny do rÛwnoleg≥ej z innymi wπtkami-serwerami obs≥ugi
po≥πczeÒ od klientÛw.<br>
<br>
W metodzie main() tworzymy kilka egzemplarzy serwerÛw. Po uruchomieniu programu uzyskamy nastÍpujπce komunikaty:<br>
<div class="listing100"><br>
&gt;java PhoneBookServerMT1 Book.txt localhost 2300<br>
<br>
Server serv thread 1 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
Server serv thread 2 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
Server serv thread 3 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
Server serv thread 4 started<br>
listening at port: 2300<br>
bind address: localhost/127.0.0.1<br>
</div><br>
<br>
Cztery serwery czekajπ tu na po≥πczenia klientÛw. Kaødy z nich moøe je zaakceptowaÊ i obs≥uøyÊ zlecenia.<br>
<br>
Teraz nasz poprzedni program testujπcy, w ktÛrym trzy wπtki klienckic pyta≥y
po kilka razy o telefony (jeden - do Asi, drugi - do Adama, trzeci - do Jacka)
bÍdzie siÍ wykonywa≥ jak trzeba: &nbsp;klienci &nbsp;bÍdπ mieli praktycznie rÛwnoleg≥y
dostÍp do serwera.<br>
Pokazuje to wydruk dzia≥ania programu.<br>
<div class="listing100"><br>
&gt;java PhoneBookClients localhost 2300<br>
Adam - tel. 333333<br>
Jacek - tel. 111111<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
Jacek - tel. 111111<br>
Adam - tel. 333333<br>
Asia - tel. 171717<br>
</div><br>
<br>
Widzimy tu, øe øaden z wπtkÛw klienckich nie blokuje innym dostÍpu do serwera
(w trakcie obs≥ugi zleceÒ jednego klienta, obs≥ugiwane sπ rÛwnieø - przez
inny egzemplarz serwera - zlecenia innego klienta).<br>
<br>
Innπ moølwoúciπ zapewnienia wspÛ≥bieønej obs≥ugi wielu klientÛw jest <b>wyodrÍbnienie
wπtkÛw obs≥ugi zleceÒ</b>. <br>
<br>
IdeÍ tπ moøna zrealizowaÊ na wiele sposobÛw skladniowych. Tutaj pokazany
zostanie przyk≥ad, w ktorym obs≥ugiwaÊ zlecenia klientÛw bÍdπ obiekty-wπtki
klasy RequestHandler (dziedziczπcej Thread). <br>
Zobaczmy najpierw co - w tej sytuacji - robi g≥Ûwny fragment serwera.<br>
<pre>import java.net.*;
import java.io.*;

public class PhoneBookServerMT2  {

  private PhoneDirectory pd = null;
  private ServerSocket ss = null;

  public PhoneBookServerMT2(PhoneDirectory pd,ServerSocket ss) {
    this.pd = pd;
    this.ss = ss;
    System.out.println("Server started");
    System.out.println("listening at port: " + ss.getLocalPort());
    System.out.println("bind address: " + ss.getInetAddress());

    serviceConnections();
  }


  private void serviceConnections() {
    boolean serverRunning = true;
    while (serverRunning) {
      try {
        Socket conn = ss.accept();
        System.out.println("Connection established");

        <b>// start wπtku obs≥ugi zleceÒ
        new RequestHandler(pd, conn).start();</b>

      } catch (Exception exc) {
          exc.printStackTrace();
      }
    }
    try { ss.close(); } catch (Exception exc) {}
  }

//...

}
</pre>
<br>
KlasÍ obs≥ugi zleceÒ (RequestHandler) pokazuje poniøszy wydruk.<br>
<br>
<pre>import java.net.*;
import java.io.*;
import java.util.regex.*;

class RequestHandler extends Thread {

  private PhoneDirectory pd = null;
  private Socket connection = null;
  private BufferedReader in = null;
  private PrintWriter out = null;

  private static Pattern reqPatt = Pattern.compile(" +", 3);

  private static String msg[] = { "Ok", "Invalid request", "Not found",
                                  "Couldn't add - entry already exists",
                                  "Couldn't replace non-existing entry",
                                  };

  public RequestHandler(PhoneDirectory pd, Socket connection) {
    this.pd = pd;
    this.connection = connection;
    try {
      in = new BufferedReader(
               new InputStreamReader(
                   connection.getInputStream()));
      out = new PrintWriter(
                connection.getOutputStream(), true);
    } catch (Exception exc) {
        exc.printStackTrace();
        try { connection.close(); } catch(Exception e) {}
        return;
    }
  }

  public void run() {
    try {
      for (String line; (line = in.readLine()) != null; ) {
        String resp;
        String[] req = reqPatt.split(line, 3);
        String cmd = req[0];
        if (cmd.equals("bye")) {
          writeResp(0, null);
          break;
        }
        else if (cmd.equals("get")) {
          if (req.length != 2) writeResp(1, null);
          else {
            String phNum = (String) pd.getPhoneNumber(req[1]);
            if (phNum == null) writeResp(2, null);
            else writeResp(0, phNum);
          }
        }
        else if (cmd.equals("add"))  {
          if (req.length != 3) writeResp(1, null);
          else {
            boolean added = pd.addPhoneNumber(req[1], req[2]);
            if (added) writeResp(0, null);
            else writeResp(3, null);
          }
        }
        else if (cmd.equals("replace"))  {
          if (req.length != 3) writeResp(1, null);
          else {
            boolean replaced = pd.replacePhoneNumber(req[1], req[2]);
            if (replaced) writeResp(0, null);
            else writeResp(4, null);
          }
        }
        else writeResp(1, null);
      }
    } catch (Exception exc) {
        exc.printStackTrace();

    } finally {
        try {                  // by nie byÊ zbyt drobiazgowym:
          connection.close();  // przy zamkniÍciu gniazda
          connection = null;   // strumienie sπ zamykane automatycznie
        } catch (Exception exc) { }
    }
  }

  private void writeResp(int rc, String addMsg)
               throws IOException {
    out.println(rc + " " + msg[rc]);
    if (addMsg != null) out.println(addMsg);
  }
}
</pre>
<br>Przy programowaniu serwerÛw wielowπtkowych musimy zadbaÊ o w≥aúciwπ synchronizacjÍ dostÍpu do wspÛldzielonych zasobÛw.<br>
W przypadku omawianych tu serwerÛw "ksiπøki telefonicznej" takim zasobem jest mapa zdefiniowana w klasie PhoneDirectory.<br>
Nie jest ona synchronizowana, ale moøemy ( i powinniúmy) zastπpiÊ jπ wersjπ synchronizowanπ:<br>
<br>
<pre>public class PhoneDirectory {

  private Map pbMap = Collections.synchronizedMap(new HashMap());
  // ...
}
</pre><b><font color="#ff0000">Uwaga:</font></b> to rozwiπzanie nie zapewnia synchronizacji dostÍpu do wiÍkszych fragmentÛw mapy (np. operacje zbiorcze lub iterowanie).<br>
<br>
Ale synchronizacja zmniejsza efektywnoúÊ dzialania (przypomnijmy&nbsp; programowanie
wspÛlbieøne). Przy tym,&nbsp; wszystkie rodzaje dostÍpu bÍdπ synchronizowane,&nbsp;
a przecieø nie jest to konieczne przy dostÍpie "tylko do odczytu" (pobieraniu
numerÛw telefonÛw).<br>
Moøe wiÍc moglibyúmy zrobiÊ tak: nie synchronizowac mapy, a jedynie te metody
w klasie PhoneDirectory, ktÛre modyfikujπ jej zawartoúÊ. Niestety, to nie
jest dobry pomys≥.<br>
Przecieø, jeúli nie zsynchronizujemy rÛwnieø metody odczytujπcej numer telefonu,
to jej wyniki mogπ byÊ niespÛjne z aktualnym stanem mapy (odczyt moøe pokazaÊ
np. brak numeru, ktÛry by≥ akurat zapisywany przez wyw≥aszczony wπtek).<br><br>
Rozwiπzaniem tego dylematu sπ tzw. <b>read-write locks</b>, semafory, ktÛre pozwalajπ
wπtkom czytajπcym pobieraÊ informacje bez narzutu synchronizacji (o ile akurat
zasÛb nie jest zajÍty przez wπtek modyfikujπcy). KrÛtkie wprowadznie do tej
problematyki moøna znaleüÊ w artukule&nbsp;Amandeep Singha "Implementig Read/Write
Locks in Java" (http://www.asingh.net/technical/rwlocks.html).<br>
<br>
<b style="color: rgb(0, 0, 0);">Poczynajπc od Javy 1.5 mamy w pakiecie java.util.concurrent
interfejs ReadWriteLock oraz jefo implementacjÍ w klasie ReentrantReadWriteLock.<br>
</b><br><hr style="width: 100%; height: 2px;"><br>
<a name="KlientSerwer.12"></a><h2>
12. Nieblokujπce kana≥y i &nbsp;uøycie selektorÛw przy programowaniu serwerÛw</h2>

Oba przedstawione w poprzednim punkcie rozwiπzania serwerÛw wielowπtkowych majπ swoje
wady. <br>
<br>
Pierwsze (wiele egzemplarzy serwera) jest praktycznie <b>nieskalowalne</b>
(uruchamiamy zadanπ liczbÍ wπtkÛw-serwerÛw i nie wiadomo czy jest to liczba
za duøa czy za ma≥a wobec nie znanych a priori, dynamicznie zmieniajπcych
sie, potrzeb).<br><br>
W drugim rozwiπzaniu - po akceptacji po≥πczenia z klientem - uruchamiamy
odrÍbny dla kaødego klienta wπtek obs≥ugi zleceÒ. Przy bardzo duøej liczbie
klientÛw, <b>≥πczπcych siÍ i koÒczπcych po≥πczenia z duøπ czestotliwoúciπ, powstaje
bardzo duøo wπtkÛw i bardzo duøo wπtkÛw koÒczy dzia≥anie. Maszyna wirtualna
Java moøe nie nadπøaÊ w tej sytuacji z odúmiecaniem pamiÍci. </b><br><br>
Z problemami skali - czÍúciowo - moøna radziÊ sobie&nbsp; prowadzπc <b>dynamicznπ pulÍ wπtkÛw-po≥πczeÒ</b>.<br>I tu mozna wykorzystaÊ gotowe rozwiπzania z pakietu java.util.concurrent (przypomnÍ pojÍcie: <span style="font-weight: bold;">Wykonawcy</span>).<br>
W kaødym przypadku jednak bÍdziemy mieli do czynienia z <b>pelnowymiarowymi
problemami synchronizacji dostÍpu do wspÛlnych zasobÛw</b>, ktÛre to problemy
nie tylko utrudniajπ programowanie, ale czÍsto obniøajπ efektywnoúÊ dzia≥ania
serwera.<br>
<br>
Pewnym rozwiπzaniem i u≥atwieniem jest uøycie nieblokujπcych kana≥Ûw gniazd
(zob. teø punkt 9 tego wyk≥adu oraz - ogÛlnie o NIO).<br><br>
Dla nieblokujacych kana≥Ûw moøliwe jest ich <b>multipleksowanie</b> czyli obs≥ugiwanie przez jeden wπtek wielu kana≥Ûw, bowiem klasy kana≥Ûw gniazd (<b>SocketChannel</b> i <b>ServerSocketChannel</b>) pochodzπ od klasy <b>SelectableChannel</b>, ktÛra pozwala na rejestrowanie kana≥Ûw do monitorowania przez <b>selektory</b>.<br>
<br>
<div class="def"><b>Selektor</b> jest obiektem monitorujπcym zarejestrowane kana≥y, reagujπcym
na zlecenia przychodzπce od klientÛw przez te kana≥y i przekazujπcym serwerowi
sygna≥y o gotowoúci do wykonania konkretnych operacji na poszczegÛlnych kana≥ach</div><br>
<br>
"Sygna≥y gotowoúci" sπ przekazywane w <b>kluczach selekcji</b> (obiektach
klasy SelectionKey). Obiekty te zawierajπ informacjÍ o kanale i o rodzaju
operacji, ktÛra aktualnie moøe byÊ na kanale wykonana (jest "gotowa do wykonania").<br>
<br>Ideowy schemat dzia≥ania slektora przedstawia poniøszy rysunek.<br>
<img src="images/selektor1.jpg" alt="r" border="1" height="392" width="503">
<br>
<br>
&nbsp;
<br>
<ol>
  <li>Najpierw kana≥y sπ rejestrowane do monitorowania przez selektor (obiekt
klasy Selector). Rejestracja kana≥u tworzy klucz selekcji dla tego kana≥u
(obiekt klasy SelectionKey). </li>
  <li>W kluczach zapisywane sπ stany gotowoúci kana≥Ûw
do wykonania okreúlonych operacji.</li>
  <li>
Selektor reaguje na zmiany stanÛw kana≥Ûw, wynikajπce z øπdaÒ klientÛw. </li>
  <li>Gdy
jakiú klient ≥πczy siÍ z serwerem przez kana≥, zwiπzany z gniazdem serwera,
selektor ustala stan gotowoúci klucza identyfikujπcego ten kana≥, tak by
klucz wskazywa≥ , øe istnieje po≥πczenie gotowe do zaakceptowania przez serwer.
</li>
  <li>Gdy klient pisze do kana≥u komunikacyjnego, selektor ustala stan gotowoúci
klucza&nbsp; identyfikujπcego ten kana≥, tak by wskazywa≥ na &nbsp;to, øe w kanale
sπ gotowe dane do odczytania &nbsp;&nbsp;</li>
</ol>
Wkaødym momencie moøe byÊ dostÍpnych wiele kluczy w zbiorze kluczy, opisujπcych gotowe do wykonania operacje. <br>
<b>Serwer przeglπda
ten (zmieniajπcy siÍ) zbiÛr kluczy i odpowiednio do rodzaju gotowych do wykonania operacji wykonuje
je na identyfikowanych przez klucze kanalach. <font color="#ff0000">Poniewaø kana≥y sπ w trybie nieblokujπcym,
to operacje kana≥owe nie blokujπ wπtku</font>. <br>
</b><br>
W tej sytuacji obs≥uga zleceÒ klientÛw moøe byÊ wykonywana <b>synchronicznie</b> <b>(!!!)</b>. <br>
W przeciwieÒstwie
do takøe synchronicznie dzialajπcego serwera sekwencyjnego uzyskujemy przy
tym efekt rownoleg≥ej obs≥ugi klientÛw (o ile obs≥uga zlecenia nie trwa d≥ugo).
<br>
Serwer sekwencyjny musia≥ bowiem obs≥uøyÊ jednego klienta niejako "od poczπtku
do koÒca" (w naszym przypadku serwera telefonicznego od po≥πczenia, poprzez
wszystkie zlecenia odczytywania czy zapisywania ksiπøki telefonicznej, aø
do koÒczπcego komunikacjÍ zlecenia "bye"). <br>
Natomiast przy nieblokujπcych
kana≥ach selektory rozbijajπ komunikacjÍ na pojedyÒcze zlecenia (np. odczytu
konkretnego numeru telefonu) i kaøde takie zlecenie (przychodzπce od rÛønych
klientÛw przez rÛøne kana≥y) jest obs≥ugiwane przez serwer niezaleønie od
innych.<br>
<br><b>Przyk≥adowy schemat programowaniu serwerÛw z uøyciem
selektorÛw </b><br>
&nbsp;<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td rowspan="3" colspan="1" align="center" valign="middle" width="10%"><h3>1</h3></td><td valign="top"><div align="center"><b>Utworzenie kana≥u gniazda serwera<br>
i zwiπzanie go z konkretnym adresem (host+port)</b><br></div></td></tr><tr><td valign="top"><br>
String host = ...;<br>
int port = ...;<br>
ServerSocketChannel serverChannel = ServerSocketChannel.open();<br>
serverChannel.socket().bind(new InetSocketAddress(host, port));<br>
<br></td></tr><tr><td valign="top">Uwaga: metoda socket() z klasy ServerSocketChannel
zwraca skojarzone z kana≥em gniazdo klasy ServerSocket. Uøywamy tu jednej
z wersji metody bind tej klasy.<br></td></tr></tbody>
</table>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td rowspan="3" colspan="1" align="center" valign="middle" width="10%"><br>
<h3>2</h3></td><td valign="top"><div align="center"><b>Ustalenie trybu nieblokujπcego <br>
dla kana≥u serwera gniazda</b><br></div></td></tr><tr><td valign="top"><br>
serverChannel.configureBlocking(false);<br>
<br></td></tr><tr><td valign="top">Uwaga: kana≥y rejestrowane z selektorami
(a wiÍc przeznaczone do multipleksowania) muszπ byÊ skonfigurowane w trybie
nieblokujπcym i nie moøna zmieniÊ tego trybu na blokujπcy, zanim kana≥ nie zostanie wyrejestrowany.<br></td></tr></tbody>
</table>
<br>
.<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td rowspan="3" colspan="1" align="center" valign="middle" width="10%"><br>
<h3>3</h3></td><td valign="top">
      <div align="center"><b>Utworzenie selektora</b><br>
      </div>
</td></tr><tr><td valign="top"><br>
Selector selector = Selector.open();<br>
<br></td></tr><tr><td valign="top">Statyczna metoda open() z klasy Selector
zwraca refencjÍ do obiektu-selektora, ktÛry jest tworzony przez domyúlnego,
systemowego kreatora selektorÛw. Moøna jednak&nbsp; stworzyÊ w≥asnπ klasÍ "dostawcy
selektorÛw" dostarczajπcπ selektory niejako "w≥asnej konstrukcji".<br></td></tr></tbody>
</table>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td rowspan="3" colspan="1" align="center" valign="middle" width="10%">
      <h3>4</h3>
</td><td valign="top"><div align="center"><b>Rejestracja kana≥u gniazda serwera u selektora</b><br></div></td></tr><tr><td valign="top"><br>
SelectionKey sscKey = serverChannel.register(selector, &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SelectionKey.OP_ACCEPT);<br>
<br></td></tr><tr><td valign="top">Drugi argument wywolania okreúla rodzaje
operacji na danym kanale, ktÛrymi jesteúmy zainteresowani przy wykorzystaniu
tego selektora do wyboru operacji. <br>
Rodzaje operacji sπ okreúlane przez bity liczby ca≥kowitej i moøemy je podawaÊ
jako bitowπ alternatywÍ nastÍpujπcych sta≥ych statycznych typu int z klasy
SelectionKey:<br>
      <table border="1" cellpadding="3" cellspacing="0" width="100%">
<tbody><tr class="TableRowColor" bgcolor="white"><td><code><b>OP_ACCEPT</b></code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Akceptacja po≥aczenia.</td></tr><tr class="TableRowColor" bgcolor="white"><td><code><b>OP_CONNECT</b></code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operacja ≥πczenie (kana≥y gniazd klienckich).</td></tr><tr class="TableRowColor" bgcolor="white"><td><code><b>OP_READ</b></code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operacja czytania</td></tr><tr class="TableRowColor" bgcolor="white"><td><code><b>OP_WRITE</b></code><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operacja pisania</td></tr></tbody>
      </table>
Na kanale gniazda serwera interesujπ nas tylko gotowe do zaakceptowania po≥πczenia - dlatego podajemy SelectionKey.OP_ACCEPT.<br>
Uwaga: moøna specyfikowaÊ tylko operacje w≥aúciwe dla danego rodzaju kana≥u.
Dopuszczalen operacje moøemy uzyskaÊ od kana≥u za pomocπ metody validOps().
Rodzaje operacji sπ w≥aúciwosciπ tworzonego przez rejestracjÍ klucza. Moøemy
je w kaødej chwili zmieniÊ za pomocπ metody interestOps(int) z klasy SelectionKey.<br>
      <br>
Metoda zwraca klucz selekcji dla zarejestrowanego kana≥u.<br>
      <br>
Kana≥ zostaje wyrejestrowany, gdy wobec klucza reprezentujπcego jego rejestracjÍ
(zwrÛconego przez metodÍ register) zastosujemy odwo≥anie cancel, lub gdy
kana≥ zostanie zamkniÍty. <br></td></tr></tbody>
</table>
<br>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr><td rowspan="2" colspan="1" align="center" valign="middle" width="10%"><h3>5</h3></td><td valign="top"><div align="center"><b>Selekcja gotowych operacji do wykonania i ich obs≥uga<br>
w pÍtli dzialania serwera</b><br></div></td></tr><tr><td valign="top">for(;;)
{ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // NieskoÒczona
pÍtla dzia≥ania serwera<br>
      <br>
      <i>&nbsp; // Selekcja gotowej operacji<br>
&nbsp; // To wywolanie jest blokujπce<br>
&nbsp; // Czeka aø selektor powiadomi <br>
&nbsp; // o gotowoúci jakiejú operacji na jakimú kanale<br>
      </i><b>&nbsp; selector.select();</b><br>
&nbsp; <br>
      <b><i>&nbsp; </i></b><i>// Teraz jakieú operacje sπ gotowe do wykonania<br>
&nbsp; // ZbiÛr kluczy opisuje te operacje (i kana≥y</i><i>)</i><b><i><br>
      </i>&nbsp; Set keys = selector.selectedKeys();</b><br>
&nbsp; <br>
      <i>&nbsp; // Przeglπdamy "gotowe" klucze</i><br>
      <b>&nbsp; Iterator iter = keys.iterator();<br>
&nbsp; while(iter.hasNext()) {&nbsp;&nbsp; <br>
      </b>&nbsp; &nbsp;&nbsp;<i>// pobranie klucza</i> <br>
&nbsp;&nbsp;&nbsp; <b>SelectionKey key = (SelectionKey) iter.next();</b> <br>
      <i>&nbsp; &nbsp; // musi byÊ usuniÍty ze zbioru (nie ma autonatycznego usuwania)<br>
&nbsp; &nbsp; // w przeciwnym razie w kolejnym kroku pÍtli "obs≥uøony" klucz<br>
&nbsp; &nbsp; // dostalibyúmy do ponownej obs≥ugi<br>
      </i>&nbsp;&nbsp;&nbsp; <b>iter.remove();</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
      <i>&nbsp; &nbsp; // Wykonanie operacji opisywanej przez klucz</i><br>
&nbsp;&nbsp;&nbsp; <b>if (key.isAcceptable()) {</b> <i>// po≥aczenie klienta gotowe do akceptacji</i><br>
      <i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Uzyskanie kana≥u do komunikacji z klientem<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accept jest nieblokujπce, bo juø klient czeka<br>
      </i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>SocketChannel cc = serverChannel.accept();</b><br>
      <i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Kana≥ nieblokujπcy, bo bÍdzie rejestrowany u selektora</i><br>
      <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc.configureBlocking(false);</b><br>
      <i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // rejestrujemy kana≥ komunikacji z klientem<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do monitorowania <font color="#ff0000"><b>przez ten sam</b></font> selektor<br>
      </i><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cc.register(selector, SelectionKey.OP_READ | OP_WRITE);</b><br>
      <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
&nbsp;&nbsp;&nbsp; }</b><br>
&nbsp;&nbsp;&nbsp; <b>if (key.isReadable()) {</b>&nbsp; <i>// ktÛryú z kana≥Ûw gotowy do czytania</i><br>
      <i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Uzyskanie kana≥u na ktÛrym czekajπ dane do odczytania</i><br>
      <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SocketChannel cc = (SocketChannel) key.channel();<br>
      </b><i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // obs≥uga zleceÒ klienta<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...<br>
      </i><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;</b><br>
      <b>&nbsp;&nbsp;&nbsp; }</b><br>
      <b>&nbsp;&nbsp;&nbsp; if (key.isWriteable())</b> {&nbsp; // ktÛryú z kana≥Ûw gotowy do pisania<br>
      <i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Uzyskanie kana≥u </i><br>
      <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SocketChannel cc = (SocketChannel) key.channel();</b><br>
      <i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // pisanie do kana≥u<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...</i><br>
      <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br>
&nbsp;&nbsp;&nbsp; }<br>
&nbsp; }<br>
}</b> <br></td></tr></tbody>
</table>
<br>
Pokazanπ pÍtlÍ dzia≥ania serwera moøna bliøej wyjasniÊ w nastÍpujπcy sposÛb..<br>
Metoda select() wstrzymuje dzialanie pÍtli dopÛki selektor moniturajπcy zarejestrowane
u niego kana≥y nie okreúli gotowych do wykonania operacji. Gotowe operacje
sπ reprezentowane przez podzbiÛr wszystkich kluczy (tzw. selected-keys set)
i podzbiÛr ten przy kaødorazowym wywo≥aniu select() jest przez selektor modyfikowany
zgodnie z aktualnym stanem kana≥Ûw. W kaødym kroku pÍtli przeglπdany jest
aktualny zbiÛr "selected-keys" (metoda selectedKeys()) i dla kaødego klucza
z tego zbioru wykonywane sπ na kanale identyfikowanym przez ten klucz (kana≥
uzyskujemy od klucza za pomocπ metody channel()) okreúlone przez klucz operacje
(rodzaj operacji uzyskujemy wo≥ajπc metody isAccepteble(), isReadable(),
isWriteable()). <br>
SczegÛlnπ operacjπ jest akceptacja po≥πczenia nowego klienta. Jak wspomniano
na schemacie wywolanie metody accept() tym razem nie jest blokujπce (bo selektor
juø okreúli≥, øe na kanale gniazda serwera czeka kolejny klient). Wywo≥ujπc
metodÍ accept() natychmiast wiÍc tworzymy kana≥ komunikacji z klientem (SocketChannel).
Ten kana≥ rejestrujemy u tego samego selektora ktÛry monitoruje kana≥ gniazda
serwera i inne kana≥y klienckie (zwrÛcmy uwagÍ - mamy tu jeden selektor).
W ten sposÛb ta sama pÍtla, w sposÛb jednolity, obs≥uguje wszystkie zlecenia.<br>
<br>
TÍ w≥aúciwoúÊ pokazanego podejúcia ilustruje poniøszy rysunek.<br>
<img src="images/selektor2.jpg" alt="r" border="1" height="451" width="593">
<br>
<br>
Mamy juø teraz wystarczajπce wiadomoúci, aby napisaÊ omawiany w poprzednich
punktach serwer "ksiπøki telefonicznej" w konwencji nieblokujπcego we/wy
i selektorÛw.<br>
Jego kod moøe wyglπdaÊ tak.<br>
<pre>import java.net.*;
import java.io.*;
import java.util.*;
import java.util.regex.*;
import java.nio.*;
import java.nio.channels.*;
import java.nio.charset.*;

public class PhoneBookServerNB {

  private PhoneDirectory pd = null;
  private ServerSocketChannel ssc = null;
  private Selector selector = null;

  public PhoneBookServerNB(PhoneDirectory pd, String host, int port ) {
    this.pd = pd;
    try {
      // Utworzenie kana≥u dla gniazda serwera
      ssc = ServerSocketChannel.open();

      // Tryb nieblokujπcy
      ssc.configureBlocking(false);

      // Ustalenie adresu (host+port) gniazda kana≥u
      ssc.socket().bind(new InetSocketAddress(host, port));

      // Utworzenie selektora
      selector = Selector.open();

      // Zarejestrowanie kana≥u do obs≥ugi przez selektor
      // dla tego kana≥u interesuje nas tylko nawiπzywanie po≥πczeÒ
      // tryb - OP_ACCEPT
      ssc.register(selector,SelectionKey.OP_ACCEPT);

    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
    System.out.println("Server started and ready for handling requests");
    serviceConnections();
  }

  private void serviceConnections() {
    boolean serverIsRunning = true;

    while(serverIsRunning) {
      try {
        // Wywo≥anie blokujπce
        // czeka na zajúcie  zdarzenia zwiπzanego z kana≥ami
        // zarejestrowanymi do obslugi przez selektor
        selector.select();

        // Coú siÍ wydarzy≥o na kana≥ach
        // ZbiÛr kluczy opisuje zdarzenia
        Set keys = selector.selectedKeys();

        Iterator iter = keys.iterator();
        while(iter.hasNext()) {   // dla kaødego klucza

          SelectionKey key = (SelectionKey) iter.next(); // pobranie klucza
          iter.remove();                                 // usuwamy, bo juø
                                                         // go zaraz obs≥uøymy

          if (key.isAcceptable()) { // jakiú klient chce siÍ po≥πczyÊ

            // Uzyskanie kana≥u do komunikacji z klientem
            // accept jest nieblokujπce, bo juø klient siÍ zg≥osi≥
            SocketChannel cc = ssc.accept();

            // Komunikacja z klientem - nieblokujπce we/wy
            cc.configureBlocking(false);

            // rejestrujemy kana≥ komunikacji z klientem
            // do obs≥ugi przez selektor
            // - typ zdarzenia - dane gotowe do czytania przez serwer
            cc.register(selector, SelectionKey.OP_READ);
            continue;
          }

          if (key.isReadable()) {  // ktÛryú z kana≥Ûw gotowy do czytania
            // Uzyskanie kana≥u na ktÛrym czekajπ dane do odczytania
            SocketChannel cc = (SocketChannel) key.channel();
            serviceRequest(cc);    // obsluga zlecenia
            continue;
          }
        }
      } catch(Exception exc) {
          exc.printStackTrace();
          continue;
      }
    }
  }

  private static Pattern reqPatt = Pattern.compile(" +", 3);

  private static String msg[] = { "Ok", "Invalid request", "Not found",
                                  "Couldn't add - entry already exists",
                                  "Couldn't replace non-existing entry",
                                  };

  // Strona kodowa do kodowania/dekodowania buforÛw
  private static Charset charset  = Charset.forName("ISO-8859-2");
  private static final int BSIZE = 1024;

  // Bufor bajtowy - do niego sπ wczytywane dane z kana≥u
  private ByteBuffer bbuf = ByteBuffer.allocate(BSIZE);

  // Tu bÍdzie zlecenie do pezetworzenia
  private StringBuffer reqString = new StringBuffer();

  // Obs≥uga (JEDNEGO) zlecania
  private void serviceRequest(SocketChannel sc) {
    if (!sc.isOpen()) return; // jeøeli kana≥ zamkniÍty - nie ma nic do roboty

    // Odczytanie zlecenia
    reqString.setLength(0);
    bbuf.clear();
    try {
      readLoop:                    // Czytanie jest nieblokujπce
      while (true) {               // kontynujemy je dopÛki
        int n = sc.read(bbuf);     // nie natrafimy na koniec wiersza
        if (n &gt; 0) {
          bbuf.flip();
          CharBuffer cbuf = charset.decode(bbuf);
          while(cbuf.hasRemaining()) {
            char c = cbuf.get();
            if (c == '\\r' || c == '\\n') break readLoop;
            reqString.append(c);
          }
        }
      }
      // Analiza zlecenia (jak poprzednio) i wo≥anie nowej metody
      // writeResp zapisujπcej odpowiedü do kana≥u
      String[] req = reqPatt.split(reqString, 3);
      String cmd = req[0];

      if (cmd.equals("bye")) {             // koniec komunikacji
          writeResp(sc, 0, null);          // - zamkniÍcie kana≥u
          sc.close();                      // i gniazda
          sc.socket().close();
      }
      else if (cmd.equals("get")) {
        if (req.length != 2) writeResp(sc, 1, null);
        else {
          String phNum = (String) pd.getPhoneNumber(req[1]);
          if (phNum == null) writeResp(sc, 2, null);
          else writeResp(sc, 0, phNum);
        }
      }
      else if (cmd.equals("add"))  {
        if (req.length != 3) writeResp(sc, 1, null);
        else {
          boolean added = pd.addPhoneNumber(req[1], req[2]);
          if (added) writeResp(sc, 0, null);
          else writeResp(sc, 3, null);
        }
      }
      else if (cmd.equals("replace"))  {
        if (req.length != 3) writeResp(sc, 1, null);
        else {
          boolean replaced = pd.replacePhoneNumber(req[1], req[2]);
          if (replaced) writeResp(sc, 0, null);
          else writeResp(sc, 4, null);
        }
      }
      else writeResp(sc, 1, null);             // nieznane zlecenie

    } catch (Exception exc) {                  // przerwane polπczenie?
        exc.printStackTrace();
        try { sc.close();
              sc.socket().close();
        } catch (Exception e) {}
    }
  }

  private StringBuffer remsg = new StringBuffer(); // Odpowiedü

  private void writeResp(SocketChannel sc, int rc, String addMsg)
                         throws IOException {
    remsg.setLength(0);
    remsg.append(rc);
    remsg.append(' ');
    remsg.append(msg[rc]);
    remsg.append('\\n');
    if (addMsg != null) {
      remsg.append(addMsg);
      remsg.append('\\n');
    }
    ByteBuffer buf = charset.encode(CharBuffer.wrap(remsg));
    sc.write(buf);
  }

  public static void main(String[] args) {
    try {
      String phdFileName = args[0];
      String host = args[1];
      int port = Integer.parseInt(args[2]);

      PhoneDirectory pd = new PhoneDirectory(phdFileName);
      new PhoneBookServerNB(pd, host, port);
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }
  }

}
</pre>
W programie tym warto zwrÛciÊ uwagÍ na zastosowanie buforÛw&nbsp; i na sposÛb radzenia sobie z niepewnoúciπ
co do liczby odczytanych w jednej operacji read() bajtÛw przy nieblokujπcym
wejúciu-wyjúciu. Na uwagÍ zas≥uguje rÛwnieø staranie by nie tworzyÊ zbyt
wielkiej liczby obiektÛw. Dlatego bufor bajtowy, wykorzystywany do czytania
z kana≥u utworzono i alokowano jednorazowo na poziomie pÛl klasy. Takie podejúcie
jest uzasadnione, gdy nie ma wielu wπtkÛw, ktÛre mog≥yby dzieliÊ ten zasÛb.
<br>
No, w≥aúnie, nasza nowy serwer w ogÛle nie wykorzystuje wπtkÛw i nie mamy
rownieø problemÛw z synchronizacjπ odwo≥aÒ do klasy PhoneDirectory (bowiem
wszystkie operacje na zawartej w niej mapie sπ wykonywane synchronicznie,
kolejno).<br>
A jego dzia≥anie jest tak samo efektywne przy rÛwnoleg≥ej obs≥udze wielu
klientÛw, jak dzia≥anie serwerÛw wielowπtkowych (<i><b>ale: z mutexami, w úrodowiskach jednoprocesorowych</b></i>). <br>
<br>
Trzeba jednak wyraünie podkreúliÊ, øe w praktycznym programowaniu "powaønych"
serwerÛw stosowane sπ zarÛwno selektory jak i wspÛlbieønoúÊ (pule wπtkÛw).
Tylko w ten sposÛb moøna uzyskaÊ wymaganπ efektywnoúÊ dzia≥ania, a zastosowanie
nieblokujπcego wejúcia-wyjúcia i selektorÛw pomaga przy tym rozwiπzywaÊ problemy
skalowalnoúci i syncjronizacji.<br>
W takich zastosowanich uøywane sπ jeszcze inne úrodki klas SelectableChannel,&nbsp;
Selector i SelectionKey. Na koniec wiÍc krÛtko o nich:<br>
<br>
<ul>
  <li>istnieje wersja metody register(...) z klasy SelectableChannel, pozwalajπca
podaÊ - jako trzeci argument - dowolny obiekt, ktÛry bÍdzie zwiπzany z utworzonym
przy rejestracji kluczem. Moøemy teø zwiπzaÊ obiekt z kluczem juø po rejestracji
za pomocπ metody <b>attach(Object)</b> z klasy SelctionKey. Obiekt ten pÛøniej -
w fazie selekcji gotowych do wykonania operacji - bÍdziemy mogli uzyskaÊ
od klucza za pomocπ metody attachment() i wykorzystaÊ np. do wykonania wybranej
operacji. Pozwala to nie tylko na lepszπ strukturyzacjÍ kodu, ale jest jednym
ze sposobÛw uruchamiania wπtkÛw obs≥ugi zleceÒ;</li>
  <li>oprÛcz blokujπcej metody select() w klasie Selector mamy do dyspozycji
dwie inne&nbsp; wersje tej metody: select(long) blokuje, ale nie d≥uøej niø podany
jako arguemnt czas, selectNow() jest wywo≥aniem nieblokujπcym (zatem przy
braku gotowosci kana≥Ûw i operacji nasz serwer moøe wykonywac inne czynnoúci,
sprawdzajπc tÍ gotowoúc co jakiú czas np. 300 ms);</li>
  <li>metoda wakeup() z klasy Selector przerywa blokowanie na select(..);
jest intensywnie uøywana przy ≥πczeniu "duøej dozy" wspÛ≥bieønoúci z mechanizmem
selekcji.</li>
</ul>
<br>
<a name="KlientSerwer.13"></a><h2>13. Klasy Javy wspomagajπce programowanie aplikacji klienckich</h2>Tworzπc programy klienckie nie zawsze musimy siÍgaÊ do programownaia na poziomie gniazd.<br>
W Javie istniejπ zestawy klas, ktÛre ukrywajπ przed programistπ szczegÛ≥y
komunikacji poprzez gniazda. O jednym takim zestawie juø wspominano -&nbsp; jest
nim bogato oprzyrzπdowany pakiet Java Mail API.<br>
Inne to: <br>
<ul>
  <li>(niestandardowy) pakiet sun.net.ftp, s≥uøπcy do programowania klientÛw
FTP (a takøe liczne, publicznie dostÍpne pakiety klientÛw FTP dostÍpne w
Sieci),</li>
  <li>zestaw klas pozwalajacych na po≥πczenia i komuniakcjÍ z zasobami sieciowymi, w szczegÛlnoúci przy wykorzystaniu protoko≥u HTTP.</li>
</ul>Poniøszy program ≥πczy sie z &nbsp;serwerem FTP, w kolejnych dialogach wejúciowych
pyta uøytkownika o pliki do pobrania i zapisuje je na lokalnym dysku.<br>
<pre>import java.io.*;
import sun.net.ftp.FtpClient;    // podstawowa klasa pakietu sun.net.ftp
import java.text.*;

import javax.swing.*;

public class FtpFileRetriever {

  public static void main(String args[]) {
    FtpClient client = null;
    String userName = null;
    try {
     String host = args[0];
     userName = args[1];
     String password = args[2];
     client = new FtpClient(host);
     client.login(userName, password);  // logowanie
     client.binary();                   // tryb transmisji - binarny
    } catch(Exception exc) {
        exc.printStackTrace();
        System.exit(1);
    }

    String dir = null;
    String file = "";
    String dialogMsg = "Podaj nazwÍ pliku do pobrania:";
    while((file = JOptionPane.showInputDialog(dialogMsg)) != null) {
      try {
        String fileName = file;
        int lastSlash = file.lastIndexOf('/');

        // jeøeli w podanej nazwie pliku wystÍpuje úcieøka katalogowa
        // zmieniamy biezπcy katalog, jesli nie - pobierany jest plik
        // z aktualnego bieøπcego katalogu
        if (lastSlash != -1) {
           fileName = file.substring(lastSlash+1);
           dir = file.substring(0,lastSlash);
           client.cd(dir);                     // zmiana biezπcego katalogu
        }
        BufferedInputStream in = new BufferedInputStream(
                                  client.get(fileName)  // zwraca strumieÒ
                                 );                     // do czytania pliku

        BufferedOutputStream out = new BufferedOutputStream(
                                     new FileOutputStream(fileName)
                                   );
        System.out.println("Pobieram: " + fileName);

        byte[] data = new byte[1024];
        int bytesRead, totalBytes = 0;
        long start = System.currentTimeMillis();
        while( (bytesRead = in.read(data)) &gt; 0) {
          out.write(data, 0, bytesRead);
          totalBytes += bytesRead;
          System.out.print("\\r... " + totalBytes);
        }
        out.close();
        double sec = (System.currentTimeMillis() - start)/1000.0;
        double kb =   totalBytes/1024.0;
        double kbps = kb/sec;
        DecimalFormat dn = new DecimalFormat("#.#");
        System.out.println("\\nPobieranie ukonczone");
        System.out.println("Pobrano " + dn.format(kb) + "KB" +
                            " - " + dn.format(kbps) + " KB/sek.");
      } catch (IOException exc) {
         exc.printStackTrace();
      }
      dialogMsg = "Ostatnio pobrany plik: " + file +'\\n' +
                  "Podaj nazwÍ pliku do pobrania:";
    }
    // Zamkniecie po≥aczenia
    try {client.closeServer(); } catch(Exception exc) {}
    System.exit(1);
  }
}
</pre>
Dzia≥anie tego programiku ilustruje rysunek.<br>
<br>
<img src="images/ftp1.jpg" alt="r" height="229" width="526">
<br>
<br>
<br>
Jak wspomniano, pakiet sun.net.ftp nie naleøy do standardu Javy.<br>
W pakiecie java.net znajdziemy natomiast <b>standardowe</b> klasy przeznaczone
do pracy z zasobami sieciowymi, m.in.&nbsp; klasy URL i URI oraz&nbsp; URLConnection i HttpURLConnection.<br>
<br>
Obiekty klasy URL (Uniform Resource Locator) reprezentujπ - dobrze chyba
znane wszystkim - adresy zasobÛw sieciowych (jednolite lokalizatory zasobÛw).<br>
Sk≥adniowo lokalizator taki sk≥ada siÍ z kilku czÍúci, m.in.:<br>
<ul>
  <li>opisu protoko≥u (np. http, ftp, gopher, file)</li>
  <li>nazwy hosta (np. www.ibm.com)</li>
  <li>odniesienia do konkretnego zasobu &nbsp;(np. úcieøki dostÍpu do pliku i jego nazwy).</li>
</ul>
Przyk≥ad:<br>
http://www.java.sun.con/j2ee/index.html<br>
<br>
Konkretne znaczenie treúci zasobu zaleøy od protoko≥u i hosta (np. http://www.java.sun.com/j2ee/index.html
moøe oznaczac konkretny dokument lub treúÊ dokumentu generowanπ dynamicznie).
Zasoby sieciowe - to nie tylko pliki czy katalogi. mogπ oznaczaÊ rÛwnieø
inne rodzaje informacji (np. wynik zapytania kierowanego do bazy danych).<br>
<br>
O lokalizatorach zasobÛw sieciowych bedziemy czasem mÛwiÊ krÛtko: url.<br>
<br><b>
URI (Uniform Resource Identifier)</b> jest uogÛlnieniem pojÍcia URL - opisuje
dowolne (fizyczne i abstrakcyjne) zasoby w sieci, ktÛre mogπ byÊ w jakikolwiek
sposÛb zidentyfikowane.<br>
Lokalizatory (URLe) sπ podzbiorem identyfikatorÛw (URI).<br>
&nbsp;O ile lokalizator (url) opisuje zasÛb w &nbsp;taki sposÛb, øe jednoznaczny jest
mechanizm dostÍpu do niego (np. po≥oøenie pliku w sieci i protokÛ≥), to identyfikator
(URI) moøe oznaczaÊ zasÛb o nieznanej lub niejednoznacznej konkretnej lokalizacji
i mechanizmie dostÍpu, charakteryzujπcy sie jedynie unikalnπ, jednoznacznπ
nazwπ (Uniform Resource Name - URN).<br>
<br>
WiÍcej informacji na ten temat moøna znaleüÊ w dokumencie &nbsp;RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax.<br>
<br>
<b>URI - identyfikacja, parsowanie<br>
URL - fizyczny dostÍp<br></b><br>
Klasa URI w Javie nie dostarcza metod dostÍpu do zasobÛw (znajdziemy tu
g≥Ûwnie metody s≥uøπce do rozbioru identyfikatorÛw na czÍúci sk≥adowe, normalizacji,
relatywizacji i rozwik≥ywania idnetyfikatorÛw - o rozwik≥ywaniu zob. w nastÍpnym
przyk≥adowym programie).<br>
<br>
Natomiast poprzez obiekty klasy URL moøemy uzyskaÊ dostÍp do zasobÛw sieciowych i to co najmniej na dwa sposoby.<br>
<br>
Najprostszy sposÛb (zarazem jednak najmniej elastyczny) uzyskiwania dostÍpu
do zasobow sieciowych polega na wykorzystaniu strumienia wejúciowego, zwiπzanego
z lokalizatorem zasobu (URLem - obiektem klasy URL).<br>
<br>
Kolejne kroki sπ nastÍpujπce:<br>
<ul>
  <li>
stworzyÊ URL za pomocπ jednego z konstruktorÛw klasy URL (jÍsli podamy b≥Ídny adres powstanie wyjπtek MalformedURLException),</li>
  <li>
uzyskaÊ od niego strumieÒ wejúciowy za pomocπ metody getInputStream(),</li>
  <li>
odczytaÊ treúÊ zasobu ze strumienia.</li>
</ul>

 Przyk≥adowy program wykorzystujπcy ten sposÛb wczytuje podanπ stronÍ WWW
i dokonuje jej analizy sk≥adniowej w celu wyrÛønia znajdujπcych siÍ na stronie
plikÛw graficznych, po czym ≥aduje te pliki i pokazuje w "przeglπdarce obrazkÛw",
zbudowanej jako w≥asna klasa ImageViewer.<br>
<br>
<pre>import java.net.*;
import java.io.*;
import java.util.*;
import java.util.regex.*;

public class SimpleGet {

  public SimpleGet(String urlString) {
    try {
      URL url = new URL(urlString);
      BufferedReader in = new BufferedReader(
                          new InputStreamReader(
                               url.openStream() // zwraca InputStream
                                                // zwiπzany z URLem
                          ));
      // CzÍsci URL-a
      String protocol = url.getProtocol();
      String host = url.getHost();
      String file = url.getFile();
      System.out.println("Protocol: " + protocol);
      System.out.println("Host: " + host);
      System.out.println("File: " + file);

      // Zapiszemy dokument za pomocπ strumienia StringWriter
      StringWriter sw = new StringWriter(10240);
      String line;
      while ((line = in.readLine()) != null) {
         sw.write(line);
      }
      in.close();

      // Matcher do wyodrebniania referencji do plikÛw graficznych na stronie
      Matcher matcher = Pattern.compile("img src=\\"(.+?)\\"",
                            Pattern.CASE_INSENSITIVE).matcher(sw.toString());

      // Obrazy bÍdziemy przechosywaÊ na liúcie
      java.util.List imgList = new ArrayList();

      while (matcher.find()) {
        String imgRef = matcher.group(1); // wyodrÍbniamy zapisany na stronie
                                          // url obrazka
        // zwykle bÍdzie relatywny
        // za pomocπ konstruktora URL(kontekst, referencja)
        // uzyskamy w≥aúciwy lokalizator wskazujπcy zasÛb
        URL imgUrl = new URL(url, imgRef);
        System.out.println(imgRef + " ==&gt; " + imgUrl);
        // utworzenie obiektu Image i dodanie do listy
        imgList.add(Toolkit.getDefaultToolkit().createImage(imgUrl));
      }
      System.out.println("Preparation complete... wait for viewer init");

      // ListÍ obrazÛw przekaøemy utworzonemu obiektowi przeglπdarki obrazkÛw
      new ImageViewer(imgList);

    } catch (MalformedURLException exc) {
        exc.printStackTrace();
        System.exit(1);
    } catch (Exception exc) {
        exc.printStackTrace();
    }

  }

  public static void main(String[] args) {
    String url = JOptionPane.showInputDialog("Adres");
    new SimpleGet(url);
  }
}
</pre>
W programie wczytujemy stronÍ, ktÛrej adres podano w dialogu i wyodrÍbniamy
na niej wszystkie zapisane w znacznikach &lt;img src ... &gt; odniesienia
do obrazkÛw.<br>
Takie odniesienie moøe byÊ relatywne (w stosunku do lokalizacji wczytanej
strony). Dlatego urle obrazkÛw tworzymy za pomoca konstruktora <b>URL(URL context, String spec)</b>. Konstruktor ten potrafi: <br>
<ul>
  <li><b>rozwik≥aÊ</b> relatywne adresy, czyli skomponowaÊ url, w ktÛrym brakujπce w <i><b>spec</b></i> sk≥adniki sπ brane z <b>context</b> (urla dokumentu bazowego - czyli adresu wczytanej strony),</li>
  <li><b>znormalizowaÊ </b>rozwik≥ane adresy, czyli odpowiednio usunπÊ wszystkie
niepotrzebne "." i ".." (oznaczajπce w symboliczny sposÛb: katalog bieøπcy
i katalog nadrzÍdny) ze úcieøki opisujπcej dostep do zasobu.</li>
</ul>
Przyk≥adowo, jezeli nasz program uruchomimy podajπc jako adres:<br>
<br>
http://bugbog.com/beaches/beach_pictures_thailand/beach_pictures_ko%20samet_4.html;<br>
<br>
to na konsoli uzyskamy najpierw wydruk sk≥adnikÛw urla (ilustracja metod get... pobierajπcych rÛøne czeúci lokalizatora);<br>
<div class="listing100"><br>
Protocol: http<br>
Host: bugbog.com<br>
File: /beaches/beach_pictures_thailand/beach_pictures_ko%20samet_4.html<br>
</div><br>
<br>
a&nbsp; z czÍúci programu wyodrÍbniajπcj adresy obrazkÛw uzyskamy wydruk tych
adresÛw&nbsp; w literalnie zapisanej na stronie postaci, z nastÍpujπcym po znakach
==&gt; adresem rozwik≥anym i znormalizowanym przez konstruktor URL(URL context,
String spec):<br>
<br>
<div class="listingful"><br>
../../images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_9.jpg
==&gt; http://bugbog.com/images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_9.jpg<br>
<br>
../../images/bugbog/bugbog.gif ==&gt; http://bugbog.com/images/bugbog/bugbog.gif<br>
<br>
../../images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_7.jpg
==&gt; http://bugbog.com/images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_7.jpg<br>
<br>
../../images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_8.jpg
==&gt; http://bugbog.com/images/beaches/thailand_beaches_west/thailand_beaches_ko_samet_8.jpg<br>
<br>
../../images/bugbog/line.gif ==&gt; http://bugbog.com/images/bugbog/line.gif<br>
</div><br>
<br>
Program z uzyskanych urli obrazkÛw za pomocπ metody createImage z klasy Toolkit
tworzy obiekty klasy Image i dodaje je do listy. Ta lista jesr przekazywana
przeglπdarce obrazkÛw - ImageViewer.<br>
<br> Klasy ImageViewer i wykorzystaywana przez niπ ImagePanel (stanowiπca
obszar prezentacji obrazu z pliku) przedstawiono - dla porzπdku -&nbsp; na poniøszym
wydruku (warto na nie spojrzeÊ choÊby dla przypomnienia wiadomoúci o kolekcjach
i programowaniu GUI):<br>
<pre>import java.util.*;
import java.util.regex.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

class ImagePanel extends JPanel {

  private Image img;
  private boolean correct;
  private Dimension defd = new Dimension(200,200);
  private String msg;

  public ImagePanel(String msg) {
    this.msg = msg;
    setPreferredSize(defd);
    setBorder(BorderFactory.createLineBorder(Color.blue, 2));
  }

  public void setImage(Image img) {
    this.img = img;
    int w = img.getWidth(this);       // szerokoúÊ obrazka
    int h = img. getHeight(this);     // wysokoúÊ obrazka
    if (w != -1 &amp;&amp; w != 0 &amp;&amp; h != -1 &amp;&amp; h != 0) {
      correct = true;
      setPreferredSize(new Dimension(w, h));
    }
    else setPreferredSize(defd);
    repaint();
  }

  public void paintComponent(Graphics g) {
    super.paintComponent(g);
    if (img != null &amp;&amp; correct)
      g.drawImage(img, 0, 0, getWidth(), getHeight(), this);
    else
      g.drawString(msg, 10, 10);
  }

}

class ImageViewer extends JFrame implements ActionListener {

  private ListIterator lit;
  private ImagePanel imagePanel = new ImagePanel("Loading images ...");
  private JButton left = new JButton(new ImageIcon("arrow1.gif"));
  private  JButton right = new JButton(new ImageIcon("arrow2.gif"));
  private JButton os = new JButton("&lt;html&gt;&lt;b&gt;Oryginalna&lt;br&gt;skala&lt;/b&gt;&lt;/html&gt;");

  public ImageViewer(java.util.List imgList) {

    lit = imgList.listIterator();

    getContentPane().add(imagePanel);
    JPanel p = new JPanel(new FlowLayout(FlowLayout.CENTER));
    left.addActionListener(this);
    right.addActionListener(this);
    os.addActionListener(this);
    p.add(left); p.add(right); p.add(os);
    getContentPane().add(p, "South");
    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    pack();
    show();


    MediaTracker mt = new MediaTracker(this);
    int i=0;
    while(lit.hasNext()) mt.addImage((Image) lit.next(), ++i);
    try {
      mt.waitForAll();
    } catch (InterruptedException exc) { }
    System.out.println("Image viewer ready");

    SwingUtilities.invokeLater(new Runnable() {
      public void run() { getNext(); }
    });
  }

  public void actionPerformed(ActionEvent e) {
    Object src = e.getSource();
    if (src == right) getNext();
    else if (src == left) getPrevious();
    else pack();
  }

  private boolean lastOperWasNext = true;

  private void getNext() {
    if (!lastOperWasNext) lit.next();
    if (!lit.hasNext()) while (lit.hasPrevious()) lit.previous();
    imagePanel.setImage( (Image) lit.next() );
    lastOperWasNext = true;
  }

  private void getPrevious() {
    if (lastOperWasNext) lit.previous();
    if (!lit.hasPrevious()) while (lit.hasNext()) lit.next();
    imagePanel.setImage( (Image) lit.previous() );
    lastOperWasNext = false;
  }

}

</pre>
 Wynik dzialania programu ilustruje rysunek (dwa przyciski - strza≥ki, w
programie oznaczane jako left i right) s≥uøπ do przechodzenia do kolejnych
obrazkÛw; warto przy okazji zwrÛciÊ uwage na zastosowanie w tym celu iteratora
listowego).<br>
<br>
<img src="images/Http1.jpg" alt="r" height="329" width="398">
<br>
<br>
<br>
Przedstawiony bardzo prosty sposÛb pobierania zasobÛw (za pomocπ strumienia uzyskanego do URLa) ma jednak co najmniej dwie wady:<br>
<ul>
  <li>nie pozwala na odczytanie i interpretacjÍ nag≥ÛwkÛw odpowiedzi serwera HTTP,</li>
  <li>nie pozwala na uzyskanie przekazywanych przez serwer kodÛw b≥ÍdÛw&nbsp; HTTP i zwiπzanych z nimi komunikatÛw. </li>
</ul>
Klasa URLConnection i pochodna od niej HttpURLConnection usuwajπ te wady,
a co wiÍcej pozwalajπ nie tylko na odczytywanie treúci zasobÛw, ale rÛwnieø
na posy≥anie do serwera innych zleceÒ HTTP.<br>
<br>
No, w≥aúnie - jak w kaødym protokole - komunikacja pomiÍdzy klientem i serwerem
HTTP polega na wymianie zleceÒ (od klienta) i odpowiedzi (od serwera). &nbsp;Rodzaje
zleceÒ HTTP podaje poniøsza tabela.<br>
<br><br>
<table border="1" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td valign="top" width="20%">
      <div align="center"><b>Zlecenie </b><br>
      <b>(request method)</b><br>
      </div>
</td><td valign="top" width="60%">
      <div align="center"><b>Znaczenie</b><br>
      </div>
</td></tr><tr><td valign="top" width="20%"><font face="times new roman, times">GET&nbsp;</font></td><td valign="top" width="60%">uzyskanie zasobu identyfikowanego przez URL (odczytanie treúci zasobu)<br></td></tr><!--msthemelist--><tr><td valign="top" width="20%"><font face="times new roman, times">HEAD&nbsp;</font></td><td valign="top" width="60%">Uzyskanie nag≥ÛwkÛw <br></td></tr><!--msthemelist--><tr><td valign="top" width="20%"><font face="times new roman, times">POST&nbsp;</font></td><td valign="top" width="60%">Wys≥anie danych o nielimiotowanej d≥ugoúci <br></td></tr><!--msthemelist--><tr><td valign="top" width="20%"><font face="times new roman, times">PUT&nbsp;</font></td><td valign="top" width="60%">Zapisanie zasobu <br></td></tr><!--msthemelist--><tr><td valign="top" width="20%"><font face="times new roman, times">DELETE&nbsp;</font></td><td valign="top" width="60%">UsuniÍcie zasobu<br></td></tr><!--msthemelist--><tr><td valign="top" width="20%"><font face="times new roman, times">OPTIONS&nbsp;</font></td><td valign="top" width="60%">Zwraca metody HTTP podtrzymywane przez serwer<br></td></tr><!--msthemelist--><tr><td valign="top" width="20%"><font face="times new roman, times">TRACE</font></td><td valign="top" width="60%">Zwraca nag≥Ûwki wys≥ane z
leceniem TRACE (do celÛw testowania_<br></td></tr></tbody>
</table>
<br>
Kaøde zlecenie sk≥ada siÍ m.in. z
<ul>
<li>nazwy metody zlecenia ,</li><li>nag≥ÛwkÛw HTTP zlecenia ,</li><li>treúci.&nbsp;</li>
</ul> W odpowiedzi serwera rÛwnieø wystÍpujπ nag≥Ûwki, opisujπce "parametry"
treúci odpowiedzi ( np. wielkoúc, datÍ modyfikacji, typ treúci)<br>
<br>
W odrÛønieniu od komunikacji z serwerem HTTP za pomocπ gniazd, gdzie do/z
strumieni gniazda zapisuje siÍ/czyta ca≥π wymaganπ przez protokÛ≥ informacjÍ
&nbsp; przy zastosowaniu klas URL i URLConnection nag≥Ûwki nie mogπ byÊ zapisywane
do strumieni i nie mogπ byÊ z tych strumieni odczytane.<br>AnalizÍ
nag≥ÛwkÛw
odpowiedzi serwera umoøliwjπ metody klasy URLConnection. Klasa ta (wraz
z pochodnπ od niej HttpURLConnection)&nbsp;
pozwala&nbsp;rÛwnieø na wysy≥anie&nbsp;do serwera innych od
najprostszego GET zleceÒ HTTP&nbsp; i ustalanie nag≥ÛwkÛw tych zleceÒ.<br>
<br>KomunikacjÍ z serwerem HTTP za pomocπ klasy URLConnection moøna przedstawiÊ w nastepujπcych krokach.<br>
<br>
<table border="1" cellpadding="2" cellspacing="2" width="100%">
  <tbody>
    <tr>
      <td valign="top" width="10%">1<br>
      </td>
      <td valign="top">
Tworzymy obiekt klasy URLConnection, wiπøπc go z podanym URLem:<br>
      <b>URL url = new URL(...);<br>
URLConenction conn = URLConnection.open(url);</b><br>
      </td>
    </tr>
    <tr>
      <td valign="top" width="10%">2<br>
      </td>
      <td valign="top">Opcjonalnie: <br>
      <ul>
        <li>Za pomocπ metody <b>setRequestProperty(String key, String value)</b> ustalamy zawartoúÊ nag≥ÛwkÛw zlecenia (np. nag≥Ûwek "accept-language")</li>
        <li>Za pomocπ wywolania&nbsp;metody <b>conn.doOutput()</b> ustalamy, øe
zlecenie bÍdzie zleceniem POST, s≥uøπcym do przesy≥ania do serwera&nbsp; dowolnych
danych, najczÍúciej danych formularza HTTP, zapisanych jako parametry zlecenia.</li>
      </ul>
Domyúlnie zlecnie jest typu GET (a do ustalenia tego trybu s≥uøy metoda doInput). </td>
    </tr>
    <tr>
      <td valign="top" width="10%">3<br>
      </td>
      <td valign="top">Nawiπzujemy po≥πczenie:<br>
      <b>conn.connect()</b><br>
      </td>
    </tr>
    <tr>
      <td valign="top" width="10%">4<br>
      </td>
      <td valign="top">Moøemy teraz - jeúli tego potrzebujemy - odczytaÊ
nag≥Ûwki przes≥ane przez serwer za pomocπ metod getHeader(...), getHeaders(...)
oraz metod przeznaczonych do odczytywania czÍsto uøywanych nag≥ÛwkÛw (np.
getContentType()).<br>
      </td>
    </tr>
    <tr>
      <td valign="top" width="10%">5<br>
      </td>
      <td valign="top">Jeøeli zlecenie jest typu POST (ustalone metodπ doOutput()) to za pomoca metody <b>conn.getOutputStream()</b> uzyskujemy dostÍp do strumienia wyjúciowego po≥πczenia i zapisujemy do niego treúc zlecenia (np. parametry formularza)<br>
      </td>
    </tr>
    <tr>
      <td valign="top">6<br>
      </td>
      <td valign="top">Uzyskujemy strumieÒ wejúciowy do czytania odpowiedzi serwera (<b>conn.getInputStream()</b>) i za jego pomoca czytamy tÍ odpowiedü<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>SpÛjrzmy najpierw na bardzo prosty program, odczytujπcy z serwera dokument
HTML za pomocπ obiektu klasy URLConnection (domyúlnie posy≥ane zlecenie jest
typu GET).<br>
Przy okazji zapoznamy sie ze sposobem uzyskiwania ca≥ego zestawu nag≥ÛwkÛw
odpowiedzi (w mapie zawierajacej jako klucze nazwy nag≥ÛwkÛw a jako wartoúci
- ich zawartoúÊ). Dla czÍsto uøywanych nag≥ÛwkÛw (np. contnet-type, content-length)
istniejπ dodatkowe odrÍbne metody pobierania (np. getContentType(), getVontentLength()).<br>
<br>
<pre>import java.net.*;
import java.io.*;
import java.util.*;
import javax.swing.*;

public class Connection1 {

  public Connection1(String urlString) {
    try {
      URL url = new URL(urlString);
      URLConnection conn = url.openConnection();
      conn.setUseCaches(false);
      conn.connect();

      Map map = conn.getHeaderFields();
      for (Iterator it = map.keySet().iterator(); it.hasNext(); ) {
        String header = (String) it.next();
        System.out.println(header + ":" + map.get(header));
      }

      BufferedReader in = new BufferedReader(
                           new InputStreamReader(
                            conn.getInputStream() ) );

      for ( String line; (line = in.readLine()) != null; ) {
        System.out.println(line);
      }
      in.close();
    } catch (MalformedURLException exc) {
        exc.printStackTrace();
        System.exit(1);
    } catch (FileNotFoundException exc) {
        System.out.println("Podanego zasobu nie ma na serwerze");
        System.exit(2);
    } catch (Exception exc) {
        exc.printStackTrace();
    }
  }

  public static void main(String[] args) {
    String url = JOptionPane.showInputDialog("Adres");
    new Connection1(url);
  }
}
</pre>

<br>Po wprowaddzeniu jakiegoú (prawid≥owego) adresu dokumnetu na poczπtku wydruku uzyskamy nag≥Ûwki np.<br>
<div class="listing100"><br>
null:[HTTP/1.1 200 OK]<br>
Content-Language:[pl]<br>
Date:[Mon, 17 Nov 2003 02:29:38 GMT]<br>
Accept-Ranges:[bytes]<br>
Server:[Apache]<br>
Content-Type:[text/html; charset=iso-8859-2]<br>
Transfer-Encoding:[chunked]<br>
...<br>
// dalej treúc dokumentu html<br>
</div><br>
<br>
ZwrÛÊmy uwagÍ, interpretacja nag≥ÛwkÛw moøe sie nam przydaÊ do prawid≥owego
kodowania treúci dokumentu (nag≥Ûwek Content-Type bÍdzie czÍsto, choÊ nie
zawsze, podawa≥ stronÍ kodowπ).<br>
Zauwaømy teø, øe w pierwszesj linii wydruku podany jest kod odpowiedzi serwera
(200) i zwiπzany z nim komunikat (OK - zlecenie by≥o poprawne i uzyskaliúmy
odpowiedü).<br>
Gdyby np. podaÊ nieistniejπcy plik, to uzyskalibyúmy nag≥Ûwki np.:<br>
<div class="listing100"><br>
null:[HTTP/1.1 404 Not Found]<br>
Connection:[Keep-Alive]<br>
Expires:[Tue, 01 Jan 1980 12:00:00 GMT]<br>
Date:[Mon, 17 Nov 2003 02:39:46 GMT]<br>
Keep-Alive:[timeout=15, max=100]<br>
Pragma:[no-cache]<br>
Server:[Apache]<br>
Content-Type:[text/html]<br>
Last-Modified:[Thu, 01 Jan 1970 00:00:00 GMT]<br>
Transfer-Encoding:[chunked]<br>
Cache-control:[no-cache, must-revalidate]<br>
</div><br>
<br>
ale przy czytaniu treúci odpowiedzi wystπpi≥by wyjπtek FileNotFoundException.<br>
<br>
Na marginesie nalezy dodaÊ tu, øe wygodniejszym i &nbsp;bardziej szczegÛ≥owym
sposobem identyfikacji wyniku zlecenia jest uøycie metod getResponseCode()
i getResponseMessage() z klasy HttpURLConnection (obiekt tej klasy dla URLi
z protoko≥em HTTP jest zwracany z metody URLConnection.openConnectuin(),
musimy tylko dokonaÊ zawÍøajacej konwesrji referencyjnej z formalnego typu
URLConncetion do&nbsp; HttpURLConnection).<br>
<br>
Drugi przykladowy programik kliencki, uøywajπcy klasy URLConenction jest
nieco ciekawszy, pokazuje bowiem jak zapisywaÊ zlecenie typu POST. W tym
celu ustalamy w≥aúciwoúÊ po≥πczenia jako "do pisania" - metodπ doOutput().
Moøemy takøe ustaliÊ nag≥Ûwki naszego zlecenia. Ustalimy tu jÍzyk, dziÍki
czemu aplikacje dzialajace po stronie serwera bedπ mog≥y wykorzystaÊ informacje
o lokalizacji (np. przesy≥aÊ informacje po polsku). <br>
Nastepnie piszemy treúÊ zlecenia do strumienia wyjúciowego. Moøe to byÊ dowolna
informacja, ktÛrπ umiejπ przetworzyÊ aplikacje serwerowe. Najczeúciej bÍdziemy
tu zapisywaÊ parametry formularzy HTTP w formie: nazwa_parametru=wartoúc_
parametru. Poniewaø przy przekazywaniu parametrÛw przyjÍto konwencje, øe
muszπ one byÊ specjalnie kodowane (tzw. url-kodowanie), to parametry bÍdziemy
kodowaÊ za pomocπ klasy URLEncoder (o sczegÛ≥ach url-kodowania zobacz w dokumentacji
tej klasy).<br>
Po przekazaniu parametrÛw odczytujemy odpowiedü serwera. UmÛwimy siÍ, øe&nbsp;&nbsp;
aplikacja obs≥ugujπca&nbsp;po stronie serwera zlecenia naszego przyk≥adowego klienta&nbsp;
zwraca informacje tekstowπ o rodzaju zlecenia, lokalizacji, kodowaniu,&nbsp; jego
nag≥Ûwkach oraz przekazanych wartoúciach parametrÛw.<br>
Klient wypisze te informacje na konsoli.<br>
<br>
<pre>import java.io.*;
import java.net.*;

public class Client1 {

    public static void main(String[] args) throws Exception {

     // Z tego pliku przeczytamy zlecnie do pos≥ania
     // bedπ to pary "nazwa_parametru=wartoúÊ"
      BufferedReader br = new BufferedReader(
                              new FileReader(args[0])
                            );

      URL url = new URL("http://....");                // adres aplikacji
                                                       // po stronie serwera
                                                       // obs≥ugujπcej klienta
      URLConnection connection = url.openConnection();

      // Ustalenie nag≥Ûwka "accept-language" zlecenia
      // Po stronie serwera da to informacjÍ o lokalizacji
      // Tutaj jej nie uøywamy, ale moøe sie przydac w innych okolicznoúciach &nbsp;
      connection.setRequestProperty("accept-language", "pl");

      // BÍdziemy pisaÊ treúÊ zlecenia
      connection.setDoOutput(true);

      String charset = "UTF-8";          // kodowanie treúci
      PrintWriter out = new PrintWriter(
                             new OutputStreamWriter(
                              connection.getOutputStream(), charset)
                           );
      // Czytamy z pliku i zapisujemy jako treúÊ zlecenia
      // pary: nazwa_parametru=wartoúc parametru
      String line;
      while ((line = br.readLine()) != null)
       out.println(URLEncoder.encode(line, "UTF-8"));
      br.close();
      out.close();

      System.out.println("Zapis dokonany");

      // Odczytujemy odpowiedü serwera
      BufferedReader in = new BufferedReader(
                            new InputStreamReader(
                              connection.getInputStream(), charset));

      while ((line = in.readLine()) != null)
        System.out.println(line);

      in.close();
   }


}
</pre>
Jesli w pliku podanym jako argument znajdujπ siÍ zapisy:<br>
parametr1=Pies<br>

parametr2=Kot<br>

parametr3=WrÛbel Êwierkajπcy &gt; 20 <br>
<br>
to program wyprowadzi na konsoli:<br>
<br>
<div class="listing100"><br>
Zapis dokonany<br>
Klient wys≥a≥ zlecenie<br>
Metoda: POST &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <br>
Locale: pl<br>
Character encoding: UTF-8<br>
<br>
Nag≥Ûwki:<br>
accept-language: pl<br>
user-agent: Java/1.4.2<br>
host: localhost:8080<br>
accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2<br>
connection: keep-alive<br>
content-type: application/x-www-form-urlencoded<br>
content-length: 90<br>
<br>
Parametry:<br>
parametr1=Pies<br>
parametr2=Kot<br>
parametr3=WrÛbel Êwierkajπcy &gt; 20 <br>
</div><br>
<br>
Warto zauwaøyÊ, øe do url-kodowania przyjÍliúmy bezpiecznπ stronÍ kodowπ
UTF-8. W zwiπzku z tym i treúci kodujemy w tej stronie kodowej.<br>
<br> Oczywiúcie, tajemnicze jest nieco skπd akurat bierze sie taka odpowiedü
serwera. Napisano, øe tworzy jπ aplikacja dzialajπca po stronie serwera.
Pora wiÍc na zapoznanie siÍ z takimi aplikacjami i temu poúwiÍcony bÍdzie
nastÍpny wyk≥ad. Jednoczeúnie moøna tam znaleüÊ dodatkowe infomacje o protokole
HTTP, zleceniach i ich obs≥udze, a takøe kwestiach zwiπzanych z formularzami
HTTP&nbsp; i ich parametrami.<br>
<br>
<br>
<br>


</body></html>