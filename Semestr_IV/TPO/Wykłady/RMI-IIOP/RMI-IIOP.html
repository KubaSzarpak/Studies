<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 transitional//EN">
<html
 lang="pl"><head rel="stylesheet" type="text/css"
 href="../style/common.css"> <meta http-equiv="Content-Type"
 content="text/html; charset=windows-1250"> <title>RMI-IIOP</title><link
 rel="stylesheet" type="text/css" href="../style/common.css"><meta
 content="Krzysztof Barteczko" name="author"></head>
<body><div align="center"><br>
<a name="RMI-IIOP"></a><h1>Identyfikacja zasobÛw (JNDI) i protokÛ≥ RMI-IIOP</h1>
</div><hr><p><i>W tym punkcie poruszymy waøny temat lokalizacji zasobÛw
w
úrodowiskach rozproszonych. Bardzo dobrze bÍdzie widoczne jego
znaczenie przy omawianiu protoko≥u RMI-IIOP. Ten zaú jest podstawπ
interakcji w serwerach JEE.</i><br>
</p><hr><a name="W11.1"></a><a name="RMI-IIOP.1"></a><h2>1. Serwisy
nazw i katalogÛw </h2>
Koncepcja<!----> <a name="ind.11.1"></a>serwisÛw nazw i katalogÛw
(naming&nbsp;and
directory services) polega ogÛlnie na tym, aby w sposÛb
zunifikowany, niezaleøny od fizycznych w≥aúciwoúci danego zasobu i bez
koniecznoúci znajomoúci jego fizycznej lokalizacji mÛc uzyskaÊ
do niego dostÍp.<!----> Zasoby mogπ mieÊ dowolnπ naturÍ - np. mogπ to
byÊ
obiekty, drukarki, komputery itp.<br>
<br><span style="font-weight: bold;">Serwisy nazw</span> wiπøπ zasoby z
identyfikatorami (nazwami).<br>
Np. system plikowy jest swoistym serwisem nazw, ktÛry pozwala nam po
nazwach odwo≥ywaÊ siÍ do plikÛw.<br>
Przyk≥adem innego serwisu nazw jest DNS.<br>
<br><div class="def"><!----><a name="ind.11.2"></a>ZbiÛr par powiπzaÒ
pomiÍdzy nazwami a zasobami oznaczanym przez te nazwy nazywa siÍ <span
 style="font-weight: bold;">kontekstem<!----></span></div><br>
<br>Konteksty sπ zazwyczaj zorganizowane w hierarchiczne struktury,
zaczynajπce sie od tzw. inicjalnego kontekstu (<span
 style="font-style: italic; font-weight: bold;">initial context</span>).
&nbsp;Ten kontekst - w≥aúciwy dla danego serwisu - okreúla konwencje
nazewnicze i zawiera okreúlone podkonteksty.<br>
W kaødym kontekúcie mogπ byÊ zawarte podkonteksty.<br>
<br>Przyk≥ad: system plikowy. Inicjalny kontekst /, podkontekst /usr
itd.<br>
<br>W ramach kontekstu moøliwe sπ okreúlone operacje, np. zwiπzania
nazwy z zasobem, uzyskanie dostÍpu do zasobu po jego nazwie.<br>
<br>Serwisy s≥ownikowe poszerzajπ te koncepcje o moøliwoúci nadawania
zasobom nie tylko nazw, ale i atrybutÛw i odpowiednie operacje
(m.in. wyszukiwania).
<hr><a name="W11.2"></a><a name="RMI-IIOP.2"></a><h2>2. JNDI -
koncepcja i architektura </h2>
W Javie dostÍpny jest<!----> <a name="ind.11.3"></a>Java Naming and
Directory Interface (JNDI) -
specjalne API pozwalajπce uzyskiwaÊ dostÍp do serwisÛw nazw i
katalogÛw.<!----><br>
<br>Operowanie na zasobach za pomocπ serwisÛw nazw i katalogÛw wymaga
okreúlonych krokÛw:<br>
<ol> <li>Uruchomienie odpowiedniego serwera nazw, dostarczajπcego
wymaganego serwisu (zazwyczaj)</li> <li>Uzyskanie inicjalnego
kontekstu dla tego serwisu (<span
 style="color: rgb(102, 102, 204); font-weight: bold;">Context ctx =
new InitialContext(...)</span>)</li> <li>Ew. dodawanie lub
wyszukiwanie podkontekstÛw (przechodzenie do podkontekstÛw - <span
 style="color: rgb(102, 102, 204); font-weight: bold;">ctx.lookup(podkontekst)</span>)
</li> <li>Odnajdywanie zasobu po nazwie (<span
 style="color: rgb(102, 102, 204); font-weight: bold;">ctx.lookup("NazwaZasobu")</span>)
lub wiπzanie nazwy z zasobem w danym kontekúcie (<span
 style="color: rgb(102, 102, 204); font-weight: bold;">ctx.bind("NazwaZasobu",
refDoZasobu)</span> lub <span
 style="color: rgb(102, 102, 204); font-weight: bold;">ctx.rebind("NazwaZasobu",
refDoZasobu)</span>).</li>
</ol><!----><a name="ind.11.4"></a>Architektura JNDI<!----> jest
pomyúlana na zasadzie "plugins". Odpowiednie
≥πczniki do okreúlonych serwisÛw sπ instalowane dynamicznie w
postaci tzw. service provider implementation (SPI). Implementujπ one
inicjalne konteksty odpowiednie dla danego rodzaju serwisu. <br>
<br><img style="border: 1px solid ; width: 575px; height: 359px;"
 alt="r" src="images/jndiarch.jpeg"><br><br>ürÛd≥o: JNDI Tutorial.<br>
<br>W standardowej dystrybucji Javy znajdujπ siÍ nastÍpujace gotowe
implementacje&nbsp;SPI:<br>
<ul> <li>LDAP (LightWeight Directory Access Protocol),</li> <li>RMI -
(rejestr RMI)&nbsp;</li> <li>CORBA - Common Object Services (COS)
name service,</li> <li>DNS.</li>
</ul>Inne mogπ byÊ uzyskane z Internetu (m.in. ze strony JNDI, np.
filesystem service provider, umoøliwiajπcy stosowanie JNDI do systemu
plikowego, albo Windows Registry Service Provider - do dzialania na
rejestrze Windows (wersje komercyjne). Odpowiednie serwery (np. orb czy
serwer jms) mogπ dostarczaÊ swoich inicjallnych kontekstÛw.
Serwery aplikacji - ≥πczπ w sobie rÛøne serwisy i dajπ w≥asne
inicjalne konteksty dla rÛønych przypadkÛw.
<hr><br><a name="W11.3"></a><a name="RMI-IIOP.3"></a><h2>3. JNDI -
praktyczne przyk≥ady</h2>
Aby uzyskaÊ inicjalny kontekst stosujemy konstruktor InitialContext().<br>
Uzyskanie inicjalnego kontekstu wymaga dostarczenia parametrÛw m.in.<br>
<ul> <li>nazwy klasy - fabryki wytwarzajπcej inicjalny kontekst
(inicjalny kontekst bÍdzie obiektem tej klasy),</li> <li>URLa dostawcy
serwisu (service provider) dla tego inicjalnego kontekstu,</li>
</ul>Moøemy teø (a czasem musimy) podaÊ parametry zwiπzane z
bezpieczeÒstwem (np. protokÛ≥) czy preferowanym jÍzykiem serwisu.<br>
<br>Wszystkie te parametry okreúlane sπ jako w≥aúciwoúci (properties).
Przy czym mogπ to byÊ:<br>
<ul> <li>w≥aúciwoúci aplikacji, dostarczone w pliku jndi.properties,</li>
<li>w≥aúciwoúci úrodowiskowe, dostarczone jako tablica asocjacyjna
(Hashtable),</li> <li>w≥aúciwoúci systemowe, okreúlone jako argumenty
wywo≥ania JVM (opcja -D).</li>
</ul><br>W≥aúciwoúci majπ swoje nazwy np.:<br>
fabryka inicjalnego kontekstu - <tt><span style="font-weight: bold;">java.naming.factory.initial</span><br>
</tt>URL dostawcy serwisu -&nbsp;<tt style="font-weight: bold;">java.naming.provider.url</tt>
<br><br>Zobaczmy to na przyk≥adach.<br>
Niech dostawcπ serwisu bÍdzie filesystem service provider (JNDI w
uøyciu do systemu plikowego - trzeba úciπgnπÊ pakiet ze strony JNDI).<br>
<br><span style="text-decoration: underline;">Zastosowanie w≥aúciwoúci
úrodowiskowych</span><br>
<pre><a>Hashtable env = new Hashtable(11);
env.put(Context.INITIAL_CONTEXT_FACTORY,
        "com.sun.jndi.fscontext.RefFSContextFactory");
Context initCtx = new InitialContext(env);

// Metoda lookup pozwala na odnalezienie zasobu:

Object obj = initCtx.lookup("e:/temp");

</a></pre><span
 style="text-decoration: underline;">Zastosowanie w≥aúciwoúci aplikacji</span><br>
Plik jndi.properties<br>
<pre>java.naming.factory.initial=com.sun.jndi.fscontext.RefFSContextFactory</pre>Fragment
programu:<br>
<pre><a>Context initCtx = new InitialContext();  // konstruktor bezparametrowy

// Metoda lookup pozwala na odnalezienie zasobu:

Object obj = initCtx.lookup("e:/temp");
</a></pre><br><span
 style="text-decoration: underline;">Zastosowanie w≥aúciwoúci
systemowych</span><br>
<br>Program jest taki sam jak poprzednio (uøywamy konstruktora
bezparametrowego), ale JVM wywo≥ujemy z odpowiednimi argumentami:<br>
<br><pre>java -Djava.naming.factory.initial=com.sun.jndi.fscontext.RefFSContextFactory Prg</pre>(Prg
jest przyk≥adowπ nazwπ klasy programu).<br>
<br>Te trzy ürÛd≥a identyfikacji SPI (w≥aúciwoúci
úrodowiskowe,&nbsp; systemowe i w≥aúciwoúci aplikacji &nbsp;z
jndi.properties) sπ uøywane i ze sobπ ≥πczone (w wymienionej
kolejnoúci).<br>
<br><br><br>Oczywiúcie, w realnych aplikacjach rozproszonych serwery
nazw
zajmujπ&nbsp;siÍ kontekstami, a klienci - uzyskujπ dostÍp do
zasobÛw po nazwach.<br>
<br>Generalna procedura jest nastÍpujπca:<br>
<ul> <li>uruchomiÊ odpowiedni serwer (np. ORB lub JMX), specyfikujπc
host i port na ktÛrym dzia≥a,</li> <li>w programie A zerejestrowaÊ
zasoby w inicjalnym kontekúcie
w≥aúciwym dla danego serwera za pomocπ metody ctx.bind("NazwaZasobu")
lub ctx.rebind("NazwaZasobu")</li> <li>w programie B (ktÛry ma mieÊ
dostÍp do rozproszonych zasobÛw) wykonaÊ ctx.lookup("NazwaZasobu")</li>
</ul><br>Za chwilÍ zobaczymy to w praktycznym dzia≥aniu.<br>
<br><span style="font-weight: bold;">Jednak</span> <span
 style="font-weight: bold;">serwery aplikacji</span>
dostarczajπ niejako gotowych&nbsp; kontekstÛw, do ktorych moøemy
mieÊ dostÍp z inicjalnego kontekstu (o ktÛry specjalnie nie
musimy siÍ martwiÊ), a <span style="font-weight: bold;">wiπzanie nazw
z zasobami (bind) od≥oøone jest do fazy wdroøeniowej (deskryptory
wdroøenia)</span>. Za to wiπzanie odpowiedzialne sπ <span
 style="font-weight: bold;">kontenery</span>.<br>
<span style="color: rgb(255, 0, 0); font-weight: bold;">DziÍki temu
uzyskuje siÍ izolacjÍ kodÛw od konkretnych warunkÛw i konfiguracji
wdroøeniowych.</span><br>
<br><br>Np. znany nam juø z "Metod Programowania" sposÛb programowania
po≥πczeÒ bazodanowych w úrodowisku Tomcata (dajπcy pooling po≥πczeÒ):<br>
<pre>  DataSource dataSource;  // ürod≥o danych

  public void init() throws ServletException {
    try {
      Context init = new InitialContext();
      Context contx = (Context) init.lookup("java:comp/env");
      dataSource = (DataSource) contx.lookup("jdbc/ksidb");
     } catch (NamingException exc) {
        throw new ServletException(
          "Nie mogÍ uzyskaÊ ürÛd≥a java:comp/env/jdbc/ksidb", exc);
     }
  }</pre>W
deskryptorze kontekstu&nbsp; (faza wdroøeniowa, plik nazywany zwykle
plik context.xml) podajemy np:<br>
<br><pre>  &lt;Resource name="jdbc/ksidb" auth="Container"
            type="javax.sql.DataSource"
            description="Baza danych ksiazek"
            driverClassName="com.mysql.jdbc.Driver"
            url="jdbc:mysql://localhost/ksidb"
            username="admin"
            password="admin"
            maxActive="20" /&gt;
</pre><br><br>
ZwrÛÊmy uwagÍ, øe ogÛlnie serwery J2EE dostarczajπ standardowego
kontekstu <span style="font-weight: bold;">java:comp/env</span>,
z ktÛrego moøemy mieÊ dostÍp do rÛønych
podkontekstÛw. Np. serwer Sun Application Serwer dostarcza
nastÍpujπcych podkontekstÛw:<br>
<br><table summary="JNDI Subcontexts for Connection Factories"
 id="wp81905" border="1"> <tbody> <tr align="center"> <th> <div
 class="pCellHeading">Rodzaj zasobu </div> </th> <th> <div
 class="pCellHeading">
Typ zasobu </div> </th> <th> <div class="pCellHeading">
Podkontekst JNDI&nbsp; </div> </th> </tr> <tr align="left"> <td> <div
 class="pCellBody">
JDBC </div> </td> <td> <div class="pCellBody"> <code class="cCode">javax.sql.DataSource</code>
</div> </td> <td> <div class="pCellBody"> <code class="cCode">java:comp/env/jdbc</code>
</div> </td> </tr> <tr align="left"> <td> <div class="pCellBody">JMS
</div> </td> <td> <div class="pCellBody"> <code class="cCode">javax.jms.TopicConnectionFactory</code>
</div> <div class="pCellBody"> <code class="cCode">javax.jms.QueueConnectionFactory</code>
</div> </td> <td> <div class="pCellBody"> <code class="cCode">java:comp/env/jms</code>
</div> </td> </tr> <tr align="left"> <td> <div class="pCellBody">JavaMail
</div> </td> <td> <div class="pCellBody"> <code class="cCode">javax.mail.Session</code>
</div> </td> <td> <div class="pCellBody"> <code class="cCode">java:comp/env/mail</code>
</div>
</td> </tr> <tr align="left"> <td> <div class="pCellBody">URL </div>
</td> <td> <div class="pCellBody"> <code class="cCode">java.net.URL</code>
</div> </td> <td> <div class="pCellBody"> <code class="cCode">java:comp/env/url</code>
</div> </td> </tr> <tr align="left"> <td> <div class="pCellBody">Connector
</div> </td> <td> <div class="pCellBody"> <code class="cCode">javax.resource.cci.ConnectionFactory</code>
</div> </td>
<td> <div class="pCellBody"> <code class="cCode">java:comp/env/eis</code>
</div> </td> </tr> <tr align="left"> <td> <div class="pCellBody">JAXR
Resource Adapter </div> </td> <td> <div class="pCellBody"> <code
 class="cCode">javax.xml.registry.ConnectionFactory</code> </div> </td>
<td> <div class="pCellBody"> <code class="cCode">java:comp/env/eis/JAXR</code>
</div> </td> </tr> </tbody></table>èrÛd≥o: J2EE Tutorial<br>
<br>W úrodowisku serwerÛw aplikacji poprzez JNDI mamy teø dostÍp do
prostych w≥aúciwoúci, obiektÛw EJB, konektorÛw itp. <br>
Np.&nbsp; do prostych w≥aúciwoúci (wartoúci typÛw opakowujπcych
typy pierwotne oraz typu String), specyfikowanych w deskryptorach
wdroøenia jako env-entry jest bardzo prosty:<br>
<br>Fragment deskryptora wdroøenia:<br>
<pre>    &lt;env-entry&gt;
      &lt;description&gt;Maksymalna temperatura&lt;/description&gt;
      &lt;env-entry-name&gt;maxTemp&lt;/env-entry-name&gt;
      &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt;
      &lt;env-entry-value&gt;37&lt;/env-entry-value&gt;
    &lt;/env-entry&gt;
</pre>i
kod programu:<br>
<br><pre>InitialContext iniCtx = new InitialContext();
Context envCtx = (Context) iniCtx.lookup("java:comp/env");
Integer maxExemptions = (Integer) envCtx.lookup("maxTemp");</pre>To
samo dotyczy dostÍpu do Enterprise Java Beans (o czym dalej).<br>
<br><div class="important"><span style="font-weight: bold;">Podsumowujπc:
w úrodowisku
rozproszonych aplikacji biznesowych JNDI jest podstawowym sposobem
identyfikacji zasobÛw (baz danych, obiektÛw EJB itd.)
oraz dostÍpu do nich</span>. <span style="font-weight: bold;">DziÍki
temu kody aplikacji mogπ byÊ odizolowane od konkretnych warunkÛw i
konfiguracji wdroøeniowych</span>.</div><br>
<br><hr style="width: 100%; height: 2px;"><br><a name="W11.4"></a><a
 name="RMI-IIOP.4"></a><a name="RMI-IIOP.4"></a><h2>4. Zdalne wywo≥anie metod - RMI-IIOP</h2>
<div class="def"><span style="font-weight: bold;"><!----><a
 name="ind.11.5"></a>Remote Method Invocation over Internet Inter-ORB
Protocol</span> <span style="font-weight: bold;">(RMI-IIOP)</span>-
jest wersjπ RMI:<br>
<ul> <li>zgodnπ z CORBπ,</li> <li>stosujπcπ protokÛ≥ transportowy
IIOP-TCP/IP</li> <li>uøywanπ m.in. przy rozproszonej komunikacji z EJB<!----></li>
</ul></div><br><br><table style="text-align: left; width: 100%;"
 border="1" cellpadding="2" cellspacing="2"> <tbody> <tr
 align="center"> <td colspan="3" rowspan="1">RMI</td> </tr> <tr> <td>transport:</td>
<td>&nbsp;JRMP
(Java Remote Method Protocol)</td> <td>&nbsp;IIOP - TCP/IP</td> </tr>
<tr> <td></td> <td>Znany z wyk≥adÛw "Metody programowania"<br>
(tylko Java - i to jest ograniczenie)</td> <td>Umoøliwia komunikacjÍ
obiektÛw spe≥niajπych standard
CORBA (a wiÍc nie tylko napisanych w Javie) ze zdalnymi obiektami Javy<br>
W&nbsp;stosunku do JRMP:<br> <ul> <li>
brak dynamicznych &nbsp;class-loaderÛw,</li> <li>
nie ma rozproszonego automatycznego odúmiecania,</li> <li>
do identyfikacji obiektÛw nie stosujemy rejestru RMI, ale JNDI
realizowane przez serwis COSnaming.</li> </ul> </td> </tr> </tbody>
</table><br><br>WystÍpujπ dwa podstawowe problemy przy interakcji
pomiÍdzy
obiektami w úrodowiskach rozproszonych:<br>
<br><ul> <li><span style="font-weight: bold;"><!----><a name="ind.11.6"></a>marshalling/unmarshalling
</span>(szeregowanie/rozszeregowanie)
- operacje konieczne, by argument wywo≥ania zdalnej metody by≥ w
úrodowisku zdalnej&nbsp;metody w≥aúciwie zinterpretowany (np. jak
uzyskaÊ dostÍp do obiektu, gdy do innej JVM przekazywana jest
referencja do niego - jako argument zdalnego wywo≥ania - a sam obiekt
na tej zdalnej JVM nie istnieje)<!----></li> <li><span
 style="font-weight: bold;">uwzglÍdnienie niestabilnoúci sieciowych</span>
&nbsp;- &nbsp;aplikacja rozproszona musi byÊ przygotowana na
niestabilnoúci sieciowe.</li>
</ul><br>Stπd szereg niezbÍdnych<!----> <a name="ind.11.7"></a>regu≥
przy
programowaniu w RMI-IIOP<!---->:<br>
<br><ol> <li>Wywo≥ania metod na rzecz&nbsp;obiektÛw zdalnych odbywajπ
siÍ wy≥πcznie w kategoriach interfejsÛw. Czyli klasa naszego
zdalnego obiektu musi koniecznie implementowaÊ interfejs, w
ktÛrym wyszczegÛlnione zosta≥y zdalne metody.</li> <li>Ten interfejs
musi rozszerzaÊ interfejs <span style="font-weight: bold;">java.rmi.Remote</span>.</li>
<li>Metody tego interfejsu winny byÊ deklarowane jako zg≥aszajπce
wyjπtek <span style="font-weight: bold;">java.rmi.RemoteException</span>
(poniewaø przy ich zdalnym wywo≥aniu moøe nastπpiÊ jakiú b≥πd
komunikacji sieciowej, skutkujπcy powstaniem w≥aúnie takiego wyjπtku).</li>
<li>Klasa zdalnego obiektu oprÛcz implementacji zdalnego
interfejsu winna "eksportowaÊ" zdalny obiekt - czyli uczyniÊ go zdolnym
do przyjmowania "zleceÒ" - zdalnych wywo≥aÒ metod. Moøna to zrobiÊ
poprzez&nbsp; &nbsp; odziedziczenie klasy&nbsp;<span
 style="font-weight: bold;"> javax.rmi.PortableRemoteObject</span>
(zapewniajπc &nbsp;aby przy tworzeniu&nbsp;jej obiektÛw by≥
wywo≥ywany konstruktor nadklasy) albo&nbsp; eksportowaÊ zdalny obiekt
za pomocπ statycznej metody exportObject() z klasy
PortableRemoteObject. Eksportowanie obiektu oznacza jego interakcjÍ z
us≥ugami sieciowego, dlatego zarÛwno wywo≥anie (jawne lub
niejawne) konstruktora nadklasy jak i exportObject moøe - np. w
przypadku awarii sieci - powodowaÊ powstanie wyjπtku RemoteException.
Dlatego sygnatura konstruktora klasy zdalnej musi uwzglÍdniaÊ ten
wyjπtek.</li>
</ol><br>Przyk≥ad:<br>
<br><pre>import java.rmi.*;
import javax.rmi.*;

// Interfejs

public interface AddressInfoInterface extends Remote {

   public String getAddress(String name) throws RemoteException;

}

// Implementacja

public class AddressInfo extends PortableRemoteObject
                         implements AddressInfoInterface {

   public AddressInfo(....)  throws RemoteException {
     <span
 style="font-weight: bold;">super();  // bÍdzie wo≥any automatycznie, ale specjalnie zaznaczam!</span>
     //.....
   }

   public String getAddress(String name) throws RemoteException {
     // ...
   }
}

</pre><span style="font-style: italic;">Uwaga: PortableRemoteObject
pochodzi
z pakietu javax.rmi</span><br>
<br>W ten sposÛb mamy klasÍ realizujπcπ "zdalne obiekty". Do
obiektÛw tej klasy moøna sie odwo≥ywaÊ w úrodowiskach
rozproszonych. Ale trzeba powiedzieÊ o jaki obiekt chodzi!!!<br>
<br>I tu na pomoc przychodzi JNDI i serwisy nazw - w szczegÛlnoúci COS
naming.<br>
Po utworzeniu obiektu powinniúmy zarejestrowaÊ go pod jakπú nazwÍ w
JNDI. Zwykle bÍdzie tego dokonywa≥ odrÍbny program - coú jakby serwer,
udostÍpniajπcy zdalne obiekty na zewnπtrz (tak naprawdÍ bÍdzie on nie
tyle serwerem, co poúrednikiem w komunikacji z jakimú prawdziwym
serwerem nazw). Np.<br>
<br><pre>import javax.naming.*;

public class AddressInfoServer {

    public static void main(String[] args) {
        try {
            // Utworzenie zdalnego obiektu
            AddressInfo ref =
                  new AddressInfo(...);

            // Rejestracja obiektu w serwisie nazw pod nazwπ
            // AddressInfoService
            // Uwaga: konkretny inicjalny kontekst okreúlπ w≥aúciwoúci systemowe

            Context ctx = new InitialContext();
            ctx.rebind("AddressInfoService", ref );

         } catch (Exception exc) {
            e.printStackTrace();
         }
     }
}</pre><br>Z
kolei zdalne wywo≥anie metod po stronie klienta wymaga:<br>
<ul> <li>odszukania obiektu za pomocπ JNDI (od serwera nazw dostaniemy
referencjÍ typu&nbsp;Object),</li> <li>dokonania zawÍøajπcej konwersji
do typu interfejsu zdalnego obiektu - za pomocπ specjalnej metody klasy
PortableRemoteObject</li>
</ul>po czym moøemy - za poúrednictwem interfejsu - wo≥aÊ metody na
rzecz zdalnego obiektu.<br>
<br>Np.<br>
<pre>import javax.rmi.*;
import javax.naming.*;

public class AddressInfoClient {

    public static void  main( String args[] ) {

        try {
            Context ctx = new InitialContext();

            Object objref = ctx.lookup("AddressInfoService");

            AddressInfoInterface aif; // <span
 style="color: rgb(255, 0, 0); font-weight: bold;">uwaga: zawsze interfejs!</span>
            aif = (AddressInfoInterface) PortableRemoteObject.narrow(
                                   objref, AddressInfoInterface.class);

        // zdalne wywolanie metod
        String name = "Kowalski Jan";
        String adres = aif.getAddress(name);
        System.out.println(name + " - adres: " + adres);


        } catch( Exception e ) {
            e.printStackTrace( );
        }
    }
}</pre><br>Tak
to wyglπda z punktu widzenia programisty. <br>
Ale jak to jest moøliwe, øe metody sπ wo≥ane&nbsp; - przecieø zdalny
obiekt&nbsp; nie istnieje po stronie klienta, a wiec na rzecz jakiego
obiektu wo≥amy metody?<br>
<hr style="width: 100%; height: 2px;"><br><a name="W11.5"></a><a
 name="RMI-IIOP.5"></a><a name="RMI-IIOP.5"></a><h2>5.
RMI-IIOP od úrodka</h2>
RolÍ odbiorcy naszych komunikatÛw bierze na siebie tzw. <span
 style="font-weight: bold;"><!----><a name="ind.11.8"></a>namiastka (<span
 style="font-style: italic;">stub</span>)<!---->. </span>Programista
- twÛrca zdalnego obiektu musi takπ namiastkÍ utworzyÊ i
zapewniÊ, øe bÍdzie ona dostÍpna po stronie klienta. Na
szczÍúcie&nbsp;jest to ≥atwe - namiastka jest tworzona automatycznie
przez kompilator <span style="font-weight: bold;">rmic</span> (z opcjπ
-iiop). Kompilator ten tworzy - jako namiastkÍ - klasÍ o nazwie <span
 style="font-weight: bold; font-style: italic;">_nazwaInterfejsu_</span><span
 style="font-weight: bold;">Stub </span>(w naszym przyk≥adzie
_AddressInfoInterface_Stub).<br>
<br>£atwo siÍ o tym przekonaÊ, dodajπc od kodu klienta wydruk nazwy
klasy obiektu otrzymanego z &nbsp;JNDI:<br>
<br><pre>            Object objref = ctx.lookup("AddressInfoService");
            System.out.println(objref.getClass().getName());
</pre>Uzyskamy:<br>
<div class="listing25l"><br>_AddressInfoInterface_Stub<br>
</div><br><br><br><br>
Czyli po stronie klienta odwo≥ania idπ do namiastki. A co robi
namiastka?<br>
Moøemy podejrzeÊ. Oto zdekompilowany kod:<br>
<br><pre>import java.rmi.RemoteException;
import java.rmi.UnexpectedException;
import javax.rmi.CORBA.Stub;
import javax.rmi.CORBA.Util;
import org.omg.CORBA.SystemException;
import org.omg.CORBA.portable.ApplicationException;
import org.omg.CORBA.portable.InputStream;
import org.omg.CORBA.portable.ObjectImpl;
import org.omg.CORBA.portable.RemarshalException;
import org.omg.CORBA.portable.ServantObject;
import org.omg.CORBA_2_3.portable.OutputStream;

public class _AddressInfoInterface_Stub extends Stub
    implements AddressInfoInterface
{

    public _AddressInfoInterface_Stub()
    {
    }

    public String[] _ids()
    {
        return _type_ids;
    }

    static Class _mthclass\\\$(String s)
    {
        try
        {
            return Class.forName(s);
        }
        catch(ClassNotFoundException classnotfoundexception)
        {
            throw new NoClassDefFoundError(classnotfoundexception.getMessage());
        }
    }

    public String getAddress(String s)
        throws RemoteException
    {
        if(!Util.isLocal(this))
            try
            {
                org.omg.CORBA_2_3.portable.InputStream inputstream = null;
                try
                {
                    String s2;
                    try
                    {
                        OutputStream outputstream = (OutputStream)_request("getAddress", true);
                        outputstream.write_value(s, java.lang.String.class);
                        inputstream = (org.omg.CORBA_2_3.portable.InputStream)_invoke(outputstream);
                        String s1 = (String)inputstream.read_value(java.lang.String.class);
                        return s1;
                    }
                    catch(ApplicationException applicationexception)
                    {
                        inputstream = (org.omg.CORBA_2_3.portable.InputStream)applicationexception.getInputStream();
                        String s4 = inputstream.read_string();
                        throw new UnexpectedException(s4);
                    }
                    catch(RemarshalException _ex)
                    {
                        s2 = getAddress(s);
                    }
                    return s2;
                }
                finally
                {
                    _releaseReply(inputstream);
                }
            }
            catch(SystemException systemexception)
            {
                throw Util.mapSystemException(systemexception);
            }
        ServantObject servantobject = _servant_preinvoke("getAddress", AddressInfoInterface.class);
        if(servantobject == null)
            return getAddress(s);
        try
        {
            Throwable throwable1;
            try
            {
                String s3 = ((AddressInfoInterface)servantobject.servant).getAddress(s);
                return s3;
            }
            catch(Throwable throwable)
            {
                throwable1 = (Throwable)Util.copyObject(throwable, _orb());
            }
            throw Util.wrapException(throwable1);
        }
        finally
        {
            _servant_postinvoke(servantobject);
        }
    }

    private static final String _type_ids[] = {
        "RMI:AddressInfoInterface:0000000000000000"
    };

}</pre><br><br>
Nie wchodzπc w szczegÛ≥y widaÊ wyraünie, øe komunikacja sieciowa
odbywa siÍ za pomocπ strumieni (na niskim poziomie sπ to strumienie
zwiπzane z gniazdami), po ktÛrych przep≥ywajπ dane uformowane wg
okreúlonych regu≥ (protoko≥u). Nie ma w tym nic tajemniczego - sami
byúmy zrobili podobnie.<br>
<br>Po stronie serwera udostÍpniajπcego obiekt zdalny te - symboliczne
w
istocie - zapisy oraz serializowane obiekty- argumenty muszπ byÊ przez
coú odczytane, zinterpretowane i "przerobione" na faktyczne odwo≥ania
do znajdujπcego siÍ tam zdalnego obiektu. TÍ rolÍ pe≥ni<!----> <a
 name="ind.11.9"></a><span style="font-weight: bold;">≥πcznik (<span
 style="font-style: italic;">tie</span>)</span><!---->, rÛwnieø
generowany przez <span style="font-weight: bold;">rmic</span>.<br>
<br>Zobaczmy co robi ≥πcznik.<br>
<br><pre>import java.rmi.Remote;
import javax.rmi.CORBA.Tie;
import org.omg.CORBA.BAD_OPERATION;
import org.omg.CORBA.ORB;
import org.omg.CORBA.Object;
import org.omg.CORBA.SystemException;
import org.omg.CORBA.portable.ResponseHandler;
import org.omg.CORBA.portable.UnknownException;
import org.omg.CORBA_2_3.portable.InputStream;
import org.omg.CORBA_2_3.portable.ObjectImpl;
import org.omg.CORBA_2_3.portable.OutputStream;

public class _AddressInfo_Tie extends ObjectImpl
    implements Tie
{

    public _AddressInfo_Tie()
    {
        target = null;
    }

    public String[] _ids()
    {
        return _type_ids;
    }

    public org.omg.CORBA.portable.OutputStream _invoke(String s, org.omg.CORBA.portable.InputStream inputstream, ResponseHandler responsehandler)
        throws SystemException
    {
        try
        {
            InputStream inputstream1 = (InputStream)inputstream;
            if(s.equals("getAddress"))
            {
                String s1 = (String)inputstream1.read_value(java.lang.String.class);
                String s2 = target.getAddress(s1);
                OutputStream outputstream = (OutputStream)responsehandler.createReply();
                outputstream.write_value(s2, java.lang.String.class);
                return outputstream;
            } else
            {
                throw new BAD_OPERATION();
            }
        }
        catch(SystemException systemexception)
        {
            throw systemexception;
        }
        catch(Throwable throwable)
        {
            throw new UnknownException(throwable);
        }
    }

    public void deactivate()
    {
        _orb().disconnect(this);
        _set_delegate(null);
        target = null;
    }

    public Remote getTarget()
    {
        return target;
    }

    public ORB orb()
    {
        return _orb();
    }

    public void orb(ORB orb1)
    {
        orb1.connect(this);
    }

    public void setTarget(Remote remote)
    {
        target = (AddressInfo)remote;
    }

    public org.omg.CORBA.Object thisObject()
    {
        return this;
    }

    private AddressInfo target;
    private static final String _type_ids[] = {
        "RMI:AddressInfoInterface:0000000000000000"
    };

}</pre>Aha,
otrzymuje zlecenie - niemal jak zwyk≥y serwer, ktÛry
moglibyúmy napisaÊ na gniazdach. Aha - deserializuje obiekty-argumenty.
I najwaøniejsze: wywo≥uje metody na rzecz prawdziwego obiektu:
<pre>String s2 = target.getAddress(s1);</pre>oraz zapisuje z powrotem
wyniki.<br>
<br><br>Zatem komunikacja wyglπda tak:<br>
<br><img style="border: 1px solid ; width: 362px; height: 256px;"
 alt="r" src="images/rmiIIOP.gif"><br><br><br>
To wszakøe nie znaczy, øe po stronie serwera nie jest potrzebna
namiastka. ZwrÛÊmy uwagÍ od serwisu nazw klient - po nazwie -
uzyskuje referencjÍ w≥aúnie do namiastki. Zatem&nbsp; namiastka musi
byÊ przez serwer zarejestrowana pod okreúlonπ nazwπ - przez
context.bind(..) czy teø rebind(). Zatem nie tylko ≥πcznik (tie), ale i
klasa namiastki musi istnieÊ po stronie serwera<br>
PamiÍtajmy teø øe po stronie klienta potrzebny&nbsp;jest interfejs.<br>
<br><hr style="width: 100%; height: 2px;"><br><a name="W11.6"></a><a
 name="RMI-IIOP.6"></a><a name="RMI-IIOP.6"></a><h2>6. Uruchomienie przyk≥adowej aplikacji</h2>
<br><span style="text-decoration: underline; font-weight: bold;">Kolejne
kroki w budowie i uruchomieniu przyk≥adowej aplikacji:</span><br>
<br><ol> <li>StworzyÊ interfejs (rozszerzajπcy Remote) i okreúliÊ
metody zdalne (muszπ deklarowaÊ sygnalizacjÍ wyjπtku RemoteException)</li>
<li>ImplementowaÊ interfejs w klasie zdalnego obiektu</li> <li>ZapewniÊ
eksport zdalnego obiektu (czy to przez dziedziczenie czy przez uøycie
metody exportObject w tej czy innej klasie)</li> <li>SkompilowaÊ
interfejs i&nbsp; implementacjÍ (AddressInfoInterface,java i
AddressInfo.java)</li> <li>UøyÊ rmic z opcjπ -iiop i argumentem -
klasπ implementacji do
wyprodukowania klas namiastki (powstanie
_AddressInfoInterface_Stub.class) i ≥πcznika (powstanie:
_AddressInfo_Tie.class)</li>
</ol><pre><span style="font-weight: bold;">rmic -iiop AddressInfo</span></pre><ol
 start="6"> <li>NapisaÊ i skompilowaÊ "serwer" tworzπcy i
rejestrujπcy w JNDI
zdalny obiekt (zob. poprzedni wydruk AddressInfoServer.java). To tutaj
zwykle nastÍpuje eksport (przez wywo≥anie konstruktora lub metody
exportObject) no i nadanie nazwy obiektowi.</li> <li>NapisaÊ i
skompilowaÊ oprogramowanie wywo≥ujπce zdalnie metody obiektu
(AddressInfoClient).</li> <li>Po stronie serwera umieúciÊ:</li> <ul> <li>AddressInfo.class</li>
<li>AddressInfoInterface.class</li> <li>_AddressInfoInterface_Stub.class</li>
<li>_AddressInfo_Tie.class</li> <li>AddressInfoServer.class</li> </ul>
<li>Po stronie klienta umieúciÊ:</li> <ul> <li>AddressInfoInterface.class</li>
<li>_AddressInfoInterface_Stub.class</li> <li>AddresInfoClient.class</li>
</ul> <li>UruchomiÊ serwer ORB (orbd.exe), ktÛry m.in. dostarcza
serwisu nazw COS naming (jako argument naleøy podaÊ wybrany port -
najlepiej jakiú wysoki numer; moøna teø wyspecyfikowac host, domyúlnie
mamy localhost)</li>
</ol><pre><span style="font-weight: bold;">start orbd -ORBInitialPort 3333</span></pre><ol
 start="11"> <li>UruchomiÊ serwer, definiujπc przy tym konfiguracjÍ
JNDI (kto jest
dostarczycielem inicjalnego kontekstu i jak jest dostÍpny serwer nazw).
Moøemy tÍ konfiguracjÍ podaÊ w pliku jndi.properties lub jako
w≥aúciwoúci systemowe przy uruchamianiu wirtualnej maszyny Javy: java
-D... (uwaga: provider to&nbsp; serwer ORB, zatem i host i port
powinien byÊ taki sam jak przy starcie serwera ORB):</li>
</ol><pre>java.naming.factory.initial=com.sun.jndi.cosnaming.CNCtxFactory
java.naming.provider.url=iiop://localhost:3333 </pre><ol
 start="12"> <li>&nbsp;UruchomiÊ klienta, podajπc takπ samπ
konfiguracjÍ JNDI.</li>
</ol><br><a href="mm/w11p1/w11p1.html"><img
 style="border: 0px solid ; width: 100px; height: 80px;" alt=""
 src="../STYLE/video2.gif"></a><a style="font-weight: bold;"
 href="mm/w11p1/w11p1.html" target="_blank">Zobacz prezentacjÍ
omÛwionych krokÛw.</a><br>
<br>Warto wiedzieÊ, øe w RMI-IIOP argumenty mogπ byÊ przekazywane przez
wartoúÊ i przez referencjÍ. <br>
W przypadku przekazywania przez wartoúÊ (to jest domyúlny tryb) obiekty
sπ serializowane i kopiowane przez sieÊ - zatem ew. zmiany
stanÛw obiektu-argumentu dokonujπ siÍ&nbsp;na kopii i nie
dotyczπ orygina≥u.<br>
<br>Przekazywanie argumentÛw przez referencjÍ wymaga aby
obiekty-argumenty by≥y same obiektami zdalnymi (czyli implementowa≥y
Remote itd.). &nbsp;DziÍki temu moøemy odnosiÊ siÍ nie do kopii, a do
orygina≥u - bo zdalne wywo≥anie metod na jego rzecz staje siÍ moøliwe.<br>
W ten sposÛb zdalny obiekt na rzecz ktÛrego wywo≥ano
metodÍ z argumentem-zdalnym obiektem moøe na rzecz argumentu zdalnie
wywo≥ywaÊ metody. Oczywiúcie, potrzebne sπ odpowiednie namiastki i
≥πczniki, a úrodowisko staje siÍ bardziej symetryczne: po trochu kaødy
jest tu i serwerem i klientem.<br><br>
<br></body></html>