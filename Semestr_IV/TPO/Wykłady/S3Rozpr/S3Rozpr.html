<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
		<meta name="author" content="Artur Stanek">
		<meta name="description" content="Scala - techniki rozproszone">
		<meta name="copyright" content="(c) autor PJWSTK 2010">
		<link rel="stylesheet" type="text/css" href="../STYLE/common.css">
		
		<title>Scala - techniki rozproszone - WYK£AD 3</title>
		
	</head>

	<body>

		<div align="center">
			<a name="S3Rozpr"></a><h1>Scala - techniki rozproszone - WYK£AD 3</h1>
		</div>
		
		<hr><br>
		
		<i>
			Ci¹g wyk³adów dotycz¹cy technik rozproszonych realizowanych za pomoc¹ Scali poprzedzony zdobyciem wiedzy o tym jêzyku programowania. 
			
			<br><br>
			
			Wyk³ad 3 : techniki rozproszone		
		</i>
		
		<br><hr>
		
		<a name="S3Rozpr.1"></a><h2>1. Aktorzy</h2>
		
		<font class="chapter">
		
			W tym rozdziale zapoznamy siê z ró¿nymi implementacjami aktorów. Wiedza zdobyta o Scali w poprzednich dwóch wyk³adach jest niezbêdna.
			
			<br><br>
			
			Aktorzy zostali opracowani w 1963 roku przez Carla Hewitta, a spopularyzowane zosta³y przez jêzyk programowania Erlang w latach 80tych. Jêzyk ten pocz¹tkowo nale¿a³ do Ericssona, a w roku 1998 zosta³ otwarty i udostêpniony. Ericsson wykorzystywa³ go z sukcesem buduj¹c systemy wspó³bie¿ne o wysokim czasie niezawodnoœci (99,9999999% dostêpnoœci - 31ms niedostêpnoœci na rok).
			
			<br><br>
			
			Aktorzy pozwalaj¹ zdekomponowaæ ca³y program do ma³ych i ³atwych komponentów. Ka¿dy z nich wystawia swoje funkcjonalnoœci w postaci API - w tym jednak wypadku nie s¹ to metody, a wiadomoœci. Do aktora mo¿emy wys³aæ wiadomoœci i odebraæ je od niego.
			
			<br><br>
			
			Praca nad programem mo¿e polegaæ tylko na skupieniu siê i opracowaniu szeregu aktorów. W pierwszej linii powinny byæ to aktorzy najbardziej podstawowi - czyli nie wymagaj¹cy do swojej pracy innych aktorów. Po ich wytworzeniu i przetestowaniu mo¿na napisaæ aktorów, którzy podczas swojej pracy polegaj¹ na aktorach podstawowych. W ten sposób mo¿e narosn¹æ ca³y program. Interakcje pomiêdzy aktorami mo¿na ³atwo opisaæ podczas projektowania aplikacji.
			
			<br><br>
			
			Dziêki swej naturalnej konstrukcji aktorzy wydajnie wykorzystuj¹ wszystkie dostêpne rdzenie w komputerze i to praktycznie bez naszej wiedzy ani zaanga¿owania. Jeœli w przysz³oœci przeniesiemy program na maszynê o wiêkszej iloœci procesorów/rdzeni - program zrobi z nich u¿ytek bez ¿adnych modyfikacji. Jeœli nasz program jest aplikacj¹ instalowan¹ przez klientów na nieznanych nam komputerach wybór aktorów zapewnia wydajne wykorzystanie dostêpnych zasobów.
			
			<br><br>
			
			Warto zauwa¿yæ, i¿ napisany w stylu 'aktorowym' ma³y program niczym siê nie ró¿ni od du¿ego. Kiedy ze œrodowiska twórców (zespó³ programistów) program przejdzie do wielkiej firmy (setki u¿ytkowników) to zwiêkszy siê w nim iloœæ generowanych i przetwarzanych wiadomoœci. Jeœli zacznie brakowaæ mocy obliczeniowej wystarczy tylko 'w³o¿yæ wiêcej procesorów i pamiêci'. Jeœli program z sukcesem bêdzie obs³ugiwa³ coraz wiêksz¹ iloœæ klientów i mocy znów zacznie brakowaæ mo¿na go zdekomponowaæ. To znaczy, i¿ nie musi on (jako program) pracowaæ fizycznie na jednej maszynie. Mo¿emy czêœæ jego aktorów zostawiæ na jednym komputerze, a inn¹ czêœæ (np. t¹ wymagaj¹cej du¿ej mocy obliczeniowej) przenieœæ na specjalnie do tego celu przygotowan¹ maszynê. Aby to uczynic modyfikacje w programie bêda znikome (lub ¿adne jeœli od razu dopuszczaliœmy tak¹ mo¿liwoœæ). Jeœli znów zacznie brakowaæ mocy obliczeniowej mo¿emy bez problemu umieœciæ ka¿dy jeden aktor na innej maszynie.
			Aktorów pracuj¹cych na ró¿nych komputerach ³atwo mo¿na rozwijaæ i podmieniaæ w trakcie pracy programu jako ca³oœci. W koñcu s¹ to oddzielne JVM. Specjalny zespó³ programistów mo¿e pracowaæ nad usprawnieniami pewnego aktora po czym zgasiæ JVM i zapaliæ z nowsz¹ wersj¹ aktora (oczywiœcie inni aktorzy bêd¹ musieli ponownie nawi¹zaæ po³¹czenia z tym aktorem).
					
		</font>

		<a name="S3Rozpr.2"></a><h2>1.1. Aktorzy w Scali</h2>
		
		<font class="chapter">

			W paczce <font class="code">scala.actors</font> standardowej dystrybucji Scali znajduje siê implementacja aktorów.
			
			<br><br>
			
			Jest to jedna z najciekawszych funkcjonalnoœci Scali ! Pozwala w ³atwy i przejrzysty sposób pisaæ programy 'wielow¹tkowe' - a jednoczeœnie ca³y czas byæ odseparowanym od w¹tków. Aktorzy pozwalaj¹ zapomnieæ co oznacza s³ówko <font class="chapter">Thread</font>. Co ciekawsze, aktorzy robi¹ wspania³y u¿ytek z niezmiennych struktur danych pozwalaj¹c zredukowaæ do minimum u¿ywanie <font class="chapter">synchronized</font> !
			
			<br><br>
			
			W pewnym sensie aktorów mo¿na porównaæ do wzorca Active Object, a wiêc klas, które w swoim wntêtrzu maj¹ w¹tek. Ka¿de wywo³anie metody powoduje przygotowanie odpowiedniego tasku i przes³anie go do wykonania na w¹tek. Wszystkie zadania przetwarzane s¹ szeregowo. Kiedy w¹tek wykona zadanie zwrot jest dostarczany do metody i zwracany jako jej zwrot. Zadania przetwarzane szeregowo powoduj¹, i¿ wewnêtrzny stan modyfikowany jest tylko przez jeden w¹tek (w¹tek wewnêtrzny) w jednym momencie i nie ma potrzeby synchronizacji danych (oczywiœcie mówimy o danych, czyli polach prywatnych klasy, a nie o danych wspó³dzielony pomiêdzy wieloma takimi aktywnymi obiektami).
			<br>
			Aktorzy w odró¿nieniu od ActiveObjects nie musz¹ posiadaæ metod (chocia¿ mog¹). Komunikujemy siê z nimi za pomoc¹ przesy³anych wiadomoœci. Wiadomoœæ mo¿emy wys³aæ asynchronicznie - czyli wys³aæ-i-zapomnieæ. Mo¿emy tak¿e (jeœli wymaga tego nasza logika) poczekaæ na odpowiedŸ (w tym przypadku jest to bardzo zbli¿one do czekania na wynik wykonania metody w Active Object).
			
			<br><br>
			
			Czekaj¹c na odpowiedŸ mo¿emy u¿yæ regu³y ograniczonego zaufania i ustawiæ timeout dla przypadku jeœli odpowiedŸ nie przysz³aby w spodziewanym przedziale czasu. Przekroczenie za³o¿onego limitu czasowego obs³ugujemy tak jakby przyszla do nas pewna specjalistyczna odpowiedŸ (wiadomoœæ <font class="chapter">TIMEOUT</font>).
			
			<br><br>
			
			Oddzielenie nas (programistów) od w¹tków daje systemowi dodatkowe mo¿liwoœci. Na przyk³ad kiedy aktor pierwszy A1 przesy³a do drugiego (A2) wiadomoœæ i zaczyna czekaæ na odpowiedŸ jego w¹tek (wypo¿yczony chwilowo przez system dla A1) mo¿e zostaæ u¿yty w A2. W¹tek nie jest usypiany, tylko wraca do puli lub pod¹¿a za zadaniem (dok³adniej za wiadomoœci¹) do wykonania. Mamy wiêc wydajne wykorzystywanie w¹tków.
			
			<br><br>
			
			Rozwiejmy kilka naturalnych w¹tpliwoœci : aktorów nie nale¿y ich postrzegaæ jako jak¹œ oddzieln¹ bibliotekê, jest to stadnartowy zbiór klas w paczce <font class="chapter">scala.actors</font>. Aktorzy nie robi¹ tak¿e ¿adnych 'magicznych' rzeczy - wszystko co siê w nich dzieje jest jest mo¿liwe do napisania przez ka¿dego z nas.

		</font>

		<a name="S3Rozpr.3"></a><h2>1.1.1. Aktorzy i w¹tki</h2>
		
		<font class="chapter">

			Aktor nie równa siê w¹tek (actor != thread). Aktor, kiedy nie ma nic do roboty przechowywany jest w pamiêci jak ka¿da inna, normalna klasa. Dopiero w momencie kiedy przyjdzie do niego jakaœ wiadomoœæ system (wewnêtrzny system aktorów) przydziela aktorowi w¹tek. Po wykonanej pracy (przetworzenie wiadomoœci) sprawdzane jest czy s¹ kolejne wiadomoœci. Po przetworzeniu wszystkich wiadomoœci w¹tek jest odbierany aktorowi i wraca do puli. Dziêki temu mo¿e byæ ponownie wykorzystany przez jakiegoœ innego aktora.
			
			<br><br>
			
			Tak wiêc aktor mo¿e mieæ przydzielony w¹tek ale nie musi i nie nale¿y go z nim uto¿samiaæ.
			
			<br><br>
			
			(Aczkolwiek istnieje mo¿liwoœæ stworzenia aktora, który bêdzie posiada³ w¹tek na sta³e. Mo¿na to uzyskaæ wykorzystuj¹c do odbioru wiadomoœci metodê <font class="code">receive()</font>. Jest to jednak droga niepolecana przez twórców Scali. U¿ywanie jej nie czyni programu potrafi¹cym wykorzystywaæ dynamicznie dostêpne zasoby sprzêtowe. Taki aktor praktycznie niewiele ró¿ni siê od w¹tku.)

		</font>

		<a name="S3Rozpr.4"></a><h2>1.1.2. Wysy³anie wiadomoœci</h2>
		
		<font class="chapter">

			Trait <font class="code">scala.actors.Actor</font> posiada dwie metody pozwalaj¹ce wys³aæ wiadomoœæ do aktora : <font class="code">send()</font> oraz <font class="code">!</font>.
			
			<br><br>
			
			Metoda <font class="code">send( message : Any , sender : OutputChannel[ Any ] )</font> jako swoje argumenty pobiera wiadomoœæ do wys³ania oraz nadawcê (nadawca to <font class="code">OutputChannel[ Any ]</font>, a ten trait implementuje <font class="code">Actor</font>).
			
			<br>
			
			<font class="code">
val przykladowyAktor = new PrzykladowyAktor

przykladowyAktor.send( 15 , this )
	// wyslanie Int ze srodka innego aktora (this jako sender)
	
przykladowyAktor.send( "tekst" , aktorNadawca )
	// wyslanie String, jako nadawca jest przekazany aktorNadawca
	
przykladowyAktor.send( new java.awt.Point( 10 , 10 ) , aktorNadawca )
	// wyslanie nowej instancji java.awt.Point
			</font>
			
			<br>
			
			Przyjemniejsz¹ metod¹ jest <font class="code">!( message : Any )</font> potocznie zwana jako 'bang'. Jako argument pobiera tylko wiadomoœæ do wys³ania, zaœ sama ustala nadawce, poczym wywo³uje metodê <font class="code">send()</font>.
			
			<br>
			
			Jak mo¿na ustaliæ nadawcê ? Otó¿ sprawdza ona w systemie aktorów czy obecny w¹tek nie jest przypadkiem czasowo wypo¿yczony jakiemuœ aktorowi. Jeœli jest to jest on nadawc¹. Jeœli zaœ nie, to jest tworzony anonimowy aktor - tylko na potrzeby formalnego spelnienia tego warunku.
			
			<br>
			
			<font class="code">
przykladowyAktor ! 15 // wyslanie Int
przykladowyAktor ! "tekst" // wyslanie String
przykladowyAktor ! new java.awt.Point( 10 , 10 ) // wyslanie nowej instancji java.awt.Point
			</font>

		</font>

		<a name="S3Rozpr.5"></a><h2>1.1.3. Wiadomoœci</h2>
		
		<font class="chapter">

			Wymieniane pomiêdzy aktorami wiadomoœci nie maj¹ narzuconego jakiegoœ specjalnego formatu oraz nie s¹ zmuszone dziedziczyæ z jakiejœ wyznaczonej klasy. Wiadomoœci mog¹ byæ dowolnymi instancjami klas, a jedynym obostrzenem jest przypadek kiedy przysy³amy wiadomoœæ do aktora zdalnego. Wtedy musi byæ ona serializowalna.
			
			<br>
			
			<font class="code">
class WiadomoscZTekstem( tekst : String )
class WiadomoscZLiczba( liczba : Int )

val aktor = new PrzykladowyAktor

val wzt = new WiadomoscZTekstem( "Ala ma kota" )

aktor ! wzt
aktor ! new WiadomoscZLiczba( 256 )
			</font>
			
			<br>
			
			W wiêkszoœci przypadków wiadomoœci s¹ to <i>case class</i> ze wzglêdu na ³atwoœæ odbierania tego typu message w aktorze :
			
			<br>
			
			<font class="code">
case class DeleteUser( userId : Int )

aktor ! new DeleteUser( 123 )

// kod z wnetrza aktora (metoda act()) odbierajaca case class DeleteUser :
react
{
    case DeleteUser( userToDeleteId ) =>
    {
    	println( "odebralem DeleteUser aby skasowac uzytkowanika o id " + userToDeleteId )
    	// latwosc pobrania parametru z jakim zostala stworzona instancja klasy DeleteUser
    }
    
    case m => println( "nierozpoznana wiadomosc " + m )
}
			</font>

		</font>

		<a name="S3Rozpr.6"></a><h2>1.1.4. Skrzynka z wiadomoœciami (mailbox)</h2>
		
		<font class="chapter">

			Wiadomoœci przys³ane do aktora oczekuj¹ na przetworzenie w jego skrzynce - mailbox. Jest to kolejka FIFO, tak wiêc pierwsza wiadomoœæ, która nap³ynê³a, zostanie przetworzona jako pierwsza. Kiedy skoñczy siê jej przetwarzanie z mailbox zostanie pobrana wiadomoœæ, którza przysz³a jako druga.

		</font>

		<a name="S3Rozpr.7"></a><h2>1.1.5. Konstrukcja aktora </h2>
		
		<font class="chapter">

			Stworzenie aktora jest bardzo proste i przejrzyste. Wystarczy tylko zaimplementowaæ (tak naprawdê to domiksowaæ) <font class="code">trait scala.actors.Actor</font> i wype³niæ jego metodê abstrakcyjna <font class="code">act()</font>.

			<br>

			<font class="code">
class MojAktor extends scala.actors.Actor
{
    def act
    {
        // i  to wszystko, prawda, ze proste ? :)
    }
}
			</font>
			
		</font>

		<a name="S3Rozpr.8"></a><h2>1.1.6. start() i stop()</h2>
		
		<font class="chapter">

			Trait Actor posiada dwie u¿yteczne metody : <font class="code">start()</font> oraz <font class="code">stop()</font>.
			
			<br><br>
			
			Dziêki <font class="code">start()</font> mo¿emy zg³osiæ aktora do puli aktorów aktywnych. Ka¿da odebrana wiadomoœæ bêdzie skutkowa³a chwilowym przypisaniem w¹tku wykonawczego.
			
			<br><br>
			
			Jeœli chcemy wycofac aktora z puli aktywnych musimy u¿yæ <font class="code">stop()</font>.
			
			<br><br>
			
			Zapominanie o wywo³aniu <font class="code">start()</font> jest czêstym b³êdem wystêpuj¹cym u pocz¹tkuj¹cych.
			
			<br><br>
			
			(Uwaga : metoda <font class="code">start()</font> w ¿adnym wypadku nie jest podobna do metody <font class="code">Thread.start()</font> !!!!)

		</font>

		<a name="S3Rozpr.9"></a><h2>1.1.7. Odbieranie wiadomoœci</h2>
		
		<font class="chapter">
		
			Wewn¹trz metody <font class="code">act()</font> powinniœmy odbieraæ wiadomoœci, które przysz³y do aktora. S³u¿¹ do tego metody <font class="code">receive()</font> oraz <font class="code">react()</font> umieszczone w obiekcie <font class="code">scala.actors.Actor</font> (w obiekcie, a nie w domiksowanym traitsie (!) dlatego aby mieæ do nich dostêp warto zaimportowaæ : <font class="code">import scala.actors.Actor._</font>).
			
			<br><br>
			
			<b>Sposób 1)</b> to u¿ywanie metody <font class="code">receive()</font> :
			
			<br>
			
			<font class="code">
receive
{
    case 15 => println( "odebralem Int 15" )
    case "Ala" => println( "odebralem String 'Ala'" )
    case s : String => println( "odebralem String : " + s )
}
			</font>
			
			<br>
			
			Metoda ta blokuje jednak na sta³e jeden w¹tek. Jest on na zawsze przypisany do tego aktora i nigdy nie jest zwracany do puli - tak wiêc nie ma mo¿liwoœci 'odzyskania' go w momencie kiedy aktor nie bêdzie mia³ nic do roboty (czasami nawet przez bardzo d³ugie okresy czasu).
			
			<br><br>
			
			Po udanym odebraniu (dopasowaniu wzorca) jednej wiadomoœci metoda ta opuszcza blok co doprowadzi³oby do skoñczenia siê aktora. Jeœli nie chcemy aby to nast¹pi³o warto umieœciæ j¹ w pêtli (np. <font class="code">scala.actors.Actor.loop</font>) :
			
			<br>
			
			<font class="code">
loop
{
    receive
    {
        case message => ...
    }
}
			</font>
			
			<br>
			
			Nieodebrane wiadomoœci (te, których wzorzec nie pasowa³ do ¿adnej alternatywy w bloku pattern matching) zawsze przebywaj¹ w skrzynce. Nie chc¹c zbyt d³ugo przetrzymywaæ (byæ mo¿e b³êdnie przes³anych wiadomoœci) watro wiêc zawsze na koñcu stworzyæ alternatywê odbieraj¹c¹ wszystko. Przydatne tak¿e jest zaraportowanie tego faktu aby w przysz³oœci do aktora nie przesy³aæ tego, czego siê on nie spodziewa :
			
			<br><br>
			
			<font class="code">case unknownMessage => println( "odebrano wiadomosc nierozpoznana, " + unknownMessage )</font>
			
			<br><br>
			
			<b>Sposób 2)</b> to u¿ywanie metody <font class="code">react()</font> :
			
			<br>
			
			<font class="code">
receive
{
    case 15 => println( "odebralem Int 15" )
    case "ala" => println( "odebralem String 'ala'" )
    case s : String => println( "odebralem String : " + s )
}
			</font>
			
			<br>
			
			Jak widaæ w niczym nie ró¿ni siê ona sk³adniowo od <font class="code">receive()</font> poza kilkoma ró¿nicami w zachowaniu :
			
			<br>
			
			- kiedy aktor nie ma nic do przetwarzania w¹tek wraca do puli (i jest wypo¿yczany innym aktorom kiedy przyjdzie do nich wiadomoœæ - o ile oczywiœcie bêdzie jakiœ wolny)
			
			<br>
			
			- blok ten nigdy siê nie koñczy, tak wiêc ¿adna linia kodu postawiona po nim nie zostanie wykonana - jednak¿e aby odbiera³ ka¿d¹ nastêpn¹ wiadomoœæ powinien byæ tak¿e umiejsowiony w pêtli (np. <font class="code">scala.actors.Actor.loop</font>)
			
			<br><br>
			
			Jeœli wszyscy aktorzy w progamie u¿ywaliby <font class="code">react()</font> to wystarczy³by tylko jeden w¹tek aby je wszystkie obs³u¿yæ.
						
		</font>
		
		<a name="S3Rozpr.10"></a><h2>1.1.8. Odbieranie wiadomoœci z wykrywaniem bezczynnoœci</h2>
		
		<font class="chapter">
		
			W przypadku jeœli 'wieczne' oczekiwanie na wiadomoœæ (która byæ mo¿e przyjdzie, a byæ mo¿e nie przyjdzie) nie do koñca odpowiada naszym celom wprowadzone zosta³y dwie dodatkowe metody : <font class="code">receiveWinthin( timeout : Long )</font> oraz <font class="code">reactWithin( timeout : Long )</font>.
			
			<br><br>
			
			S¹ one odpowiednikami <font class="code">receive()</font> oraz <font class="code">react()</font> z tym, ¿e jeœli nast¹pi okreœlona iloœæ czasu od otrzymania ostatniej wiadomoœci to system automatycznie nada do nas wiadomoœæ <font class="code">scala.actors.TIMEOUT</font>.
			
			<br>
			
			<font class="code">
import scala.actors._
import scala.actors.Actor._

def act
{
    loop
    {
        reactWithin( 2000 )
        {
            case TIMEOUT => println( "znow minely 2 sekundy, a ja nic nie otrzymalem !!" )
            
            case _ => println( "jednak cos otrzymalem :))" )
        }
    }
}
			</font>
		
		</font>
		
		<a name="S3Rozpr.11"></a><h2>1.1.9. Odpowiadanie nadawcy</h2>
		
		<font class="chapter">
		
			Wewn¹trz ka¿dego aktora znajduje siê metoda <font class="code">sender()</font>, która zwraca nadawcê ostatnio przetworzonej wiadomoœci. Pozwala to w ³atwy sposób odes³aæ wynik do nadawcy :
			
			<br>
			
			<font class="code">
import scala.actors._
import scala.actors.Actor._

case class WykonajMnozenie( x : Int , y : Int )

object MnozacyAktor extends Actor
{
    start

    def act
    {
        loop
        {
            react
            {
                case WykonajMnozenie( x , y ) =>
                {
                    val wynikMnozenia = x * y
                    sender ! wynikMnozenia // odsylamy senderowi odpowiedz, czyli wynik mnozenia
                }

                case unknownMessage => println( "nierozpoznana wiadomosc " + unknownMessage )
            }
        }
    }
}

object Tester extends Actor
{
    def act
    {
        MnozacyAktor ! new WykonajMnozenie( 2 , 2 )

        loop
        {
            react
            {
                case i : Int => println( "wynik mnozenia to " + i )

                case unknownMessage => println( "nierozpoznana wiadomosc " + unknownMessage )
            }
        }
    }
}

Tester.start
	// zarejestrowanie singletonu Tester w puli aktywnych watkow spowoduje 'odpalenie'
	//jego metody act(), a w niej przeslanie wiadomosci do aktora mnozacego
			</font>
			
			<br>
			
			W powy¿szym przyk³adzie aktor <font class="code">Tester</font> wysy³a do aktora <font class="code">MnozacyAktor</font> wiadomoœæ <font class="code">WykonajMnozenie</font>, ten po wykonaniu dzia³ania odsy³a nadawcy odpowiedz (<font class="code">sender ! wynikMnozenia</font>). Odebrana wiadomoœæ (wynik mno¿enia) jest wy³apywana przez alternatywê <font class="code">case i : Int =></font> .
			
			<br><br>
			
			Oprócz metody <font class="code">sender()</font> mamy tak¿e metodê <font class="code">reply( message : Any )</font>, która odeœle nadawcy przekazan¹ jako argument wiadomoœæ.		
		
			<br><br>
				
			(Ciekawoskta : mamy tak¿e metodê <font class="code">forward( message : Any )</font>, która wywo³ana na rzecz innego aktora pozwala przes³aæ do niego wiadomoœæ wraz z przeniesieniem informacji o nadawcy, tak wiêc w przysz³oœci bêdzie móg³ on odpowiedzieæ bezpoœrednio do niego.)
		
		</font>

		<a name="S3Rozpr.12"></a><h2>1.1.10. Wysy³anie wiadomoœci z odbieraniem odpowiedzi</h2>
		
		<font class="chapter">

			Jeœli nadaj¹c wiadomoœæ bylibyœmy zainteresowani otrzymaniem odpowiedzi to powinniœmy u¿yæ metody <font class="code">!?</font> (wyœlij i poczekaj na odpowiedŸ):
			
			<br><br>
			
			<font class="code">val odpowiedz = AktorMnozacy !? new WykonajMnozenie( 2 , 2 )</font>
			
			<br><br>
			
			Powoduje ona stworzenie dedykowanego kana³u pomiêdzy nami, a odbiorc¹ (dla naszej nadawczej strony tworzony jest tymczasowy aktor). Kiedy odbiorca wykona <font class="code">sender ! wiadomoscDoOdeslania</font> mamy 100% gwarancjê, ¿e trafi ona w³aœnie do nas. Metoda <font class="code">!?</font> ('bang and wait') zakoñczy ona swoje dzia³anie dopiero w momencie otrzymania odpowiedzi. Tak otrzyman¹ wiadomoœæ zwrotn¹ (sta³a odpowiedŸ) powinniœmy rozpatrzyæ :
			
			<br>
			
			<font class="code">
odpowiedz match
{
    case i : Int => ...
    case _ => ...
}
			</font>
			
		</font>

		<a name="S3Rozpr.13"></a><h2>1.1.11. Wysy³anie wiadomoœci z ograniczonym zaufaniem podczas odbierania odpowiedzi</h2>
		
		<font class="chapter">
		
			Wa¿ne jest aby nie do koñca ufaæ, i¿ aktor, któremu nadajemy wiadomoœæ, zawsze i szybko odeœle nam odpowiedŸ. W przypadku lokalnych aktorów mo¿e on byæ obci¹zony d³ugotrwa³¹ operacj¹, w przypadku zdalnych dodatkowo dochodzi problem komunikacji sieciowej (zapchane ³¹cza lub wtrêcz utracone po³¹czenie).
			
			<br><br>
			
			Aby nasz program nie zawiesi³ siê wy¿ej wymienionych powdów mo¿emy skorzystaæ z metody <font class="code">!?( timeout : Long , message : Any )</font> (wyœlij i poczekaj na odpowiedŸ okreœlon¹ iloœæ czasu):
			
			<br>
			
			<font class="code">
val odpowiedz = AktorMnozacy !?( 2000 , new WykonajMnozenie( 2 , 2 ) )

odpowiedz match
{
    case Some( odpowiedz ) => // otrzymalismy odpowiedz, trzeba ja rozpatrzyc
    {
        case i : Int => ...
        case _ => ...
    }

    case None => ... // nastapil timeout w zwiazku z czym nie otrzymalismy odpowiedzi
}
			</font>
			
			<br>
			
			Jak widaæ metoda <font class="code">!?( timeout : Long , message : Any)</font> zwraca wynik typu <font class="code">Option[ Any ]</font>. W przypadku przekroczenia czasu oczekiwania na odpowiedŸ zwrotem bêdzie <font class="code">None</font>, zaœ jeœli jakakolwiek odpowiedŸ zostanie zwrócona to otrzymamy j¹ wy³uskuj¹c j¹ z <font class="code">Some( tutajSiedziOdpowiedz )</font>.		
					
		</font>

		<a name="S3Rozpr.14"></a><h2>1.1.12. Aktorzy anonimowi</h2>
		
		<font class="chapter">
		
			Metoda <font class="code">actor()</font> z obiektu <font class="code">scala.actors.Actor</font> pozwala na stworzenie anonimowego aktora 'na szybko' :
			
			<br>
			
			<font class="code">
import scala.actors.Actor._

val anonimowyAktor = actor
{
    loop
    {
        react
        {
            ...
        }
    }
}
			</font>
			
			<br>
			
			Ta jednoargumentowa metoda <font class="code">actor( actBody : => Unit )</font> pobiera metodê, której cia³o jest automatycznie wstawiane do metody <font class="code">act()</font> stworzonego (za nas) aktora. Dodatkowo aktor ten jest zg³aszany do puli aktywnych aktorów (poprzez wywo³anie <font class="code">start()</font>, a wiêc metoda <font class="code">act()</font> rozpoczyna swoje dzia³anie). Na koñcu zwracany jest stworzony aktor.		
					
		</font>

		<a name="S3Rozpr.15"></a><h2>1.1.13. Aktorzy lokalni</h2>
		
		<font class="chapter">

			Aktorzy lokalni s¹ to aktorzy pracuj¹cy w tej samej JVM. S¹ dla siebie osi¹galni jak ka¿da inna klasa/obiekt :
			
			<br>
			
			<font class="code">
val configurationActor = new ConfigurationActor
configurationActor ! new Put( "version" , "2.8" )

DatabaseActor ! new ClearAllRecords // DatabaseActor jest singletonem
			</font>
			
			<br>
			
			Rozpatrzmy nastêpuj¹cy przyk³ad aktorów ping - pong.
			
			<br>
			
			<font class="code">
case class PingPongMessage( value : Int )

object Ping extends Actor
{
    def act
    {
        loop
        {
            react
            {
                case PingPongMessage( value ) =>
                {
                    println( ”Ping : ” + value )

                    if( value > 0 ) sender ! PingPongMessage( value - 1 )
                }
            }
        }
    }
}

object Pong extends Actor
{
    def act
    {
        Ping ! PingPongMessage( 10 )

        loop
        {
            react
            {
                case PingPongMessage( value ) =>
                {
                    println( ”Pong : ” + value )

                    if( value > 0 ) sender ! PingPongMessage( value - 1 )
                }
            }
        }
    }
}
			</font>
			
			<br>
			
			Na pocz¹tku zostaje definiowana wiadomoœæ <font class="code">PingPongMessage( value : Int )</font>, która bêdzie przesy³ana pomiêdzy aktorami, jako argument bierze wartoœæ, która za ka¿dym razem bêdzie obni¿ana o 1. Kiedy spadnie do zera proces przesy³ania siê zakoñczy.
			
			<br><br>
			
			Aktor <font class="code">Ping</font> jest obiektem, a wiêc jego jedna (jedyna) instancja powstanie w momencie pierwszego dostêpu do niego. W swojej metodzie <font class="code">act()</font> odbiera on wiadomoœæ <font class="code">PingPongMessage</font>, wypisuje jej wartoœæ, a nastêpnie odsy³a nadawcy nowa instancjê wiadomoœci z wartoœci¹ obni¿on¹ o 1 (dzieje siê tak w przypadku kiedy jest ona wiêksza od 0).
			
			<br><br>
			
			Aktor <font class="code">Pong</font> jest podobnie singletonem. Robi dok³adnie to samo co <font class="code">Ping</font> z jedn¹ modyfikacj¹. W swojej metodzie <font class="code">act()</font> przed wejœciem w pêtlê odbieraj¹c¹ wiadomoœci wysy³a on pierwsz¹ wiadomoœæ <font class="code">PingPongMessage</font> z wartoœci¹ równ¹ 10. To rozpoczyna ca³y proces wymieniania pomiêdzy tymi aktorami wiadomoœci - a wiêc jest on inicjatorem.
			
			<br><br>
			
			Jak dot¹d wszystko jest poprawnie zdefiniowane. Wystarczy teraz rozpocz¹æ ten proces, a wiêc zg³osiæ aktorów do puli aktrywnych aktorów.
			
			<br>
			
			<font class="code">
Ping.start
	// zainicjowanie i zgloszenie jako aktywnego aktora, metoda act() rusza i
	// wchodzi w petle odbierania wiadomosci

Pong.start
	// zainicjowanie i zgloszenie jako aktywnego aktora, metoda act() rusza i
	przed wejsciem w petle odbierania wiadomosci wysyla pierwsza wiadomosc
			</font>
			
			<br>
			
			W wyniku wykonania tego kodu zostanie wyprowadzone na out :
			
			<br>
			
			<font class="code">
Ping : 10
Pong : 9
Ping : 8
Pong : 7
Ping : 6
Pong : 5
Ping : 4
Pong : 3
Ping : 2
Pong : 1
Ping : 0
			</font>
			
		</font>

		<a name="S3Rozpr.16"></a><h2>1.1.14. Aktorzy zdalni</h2>
		
		<font class="chapter">

			Oprocz aktorów lokalnych, mo¿emy mieæ tak¿e i aktorów zdalnych. S¹ to aktorzy pracuj¹cy na innej JVM i osi¹galni przez po³¹czenie internetowe (socket). Mog¹ siê oni znajdowaæ na tej samej maszynie, b¹dŸ na innej ulokowanej po drugiej stronie Ziemi.
			
			<br><br>
			
			Wysy³anie i odbieranie wiadomoœci od nich odbywa siê dok³adnie tak samo jakby byli aktorami lokalnymi. Jedyn¹ ró¿nic¹ jest proces pozyskania namiastki takowego aktora w lokalnej JVM.
			
			<br><br>
			
			Wiadomoœci przesy³ane do takich aktorów (i jako odpowiedzi) musz¹ byæ serializowalne.
			
			<br><br>
			
			Wszystkie potrzebne metody ( <font class="code">alive()</font> , <font class="code">register()</font> , <font class="code">select()</font> ) znajduj¹ siê w <font class="code">scala.actors.remote.RemoteActor</font> (warto wiêc dodaæ sobie na pocz¹tku <font class="code">import scala.actors.remote.RemoteActor._</font>).
			
			<br><br>
			
			Aby aktor sta³ siê osi¹galny dla innych poprzez adres internetowy musi on otworzyæ port oraz zarejestrowaæ siê na nim. W tym celu ze swojej metody <font class="code">act()</font> powinien wywo³aæ :
			
			<br>
			
			<font class="code">
alive( 15123)
	// na porcie 15123 bedzie mozna podlaczyc sie do tego (i innych) aktorow

register( 'udostepnionyAktor , self )
	// zarejestrowanie siebie pod nazwa wywolawcza 'udostepnionyAktor'
			</font>
			
			<br>
			
			(Notacja z apostrofem <font class="code">'tutajJakasNazwa</font> tworzy automatycznie instancjê klasy <font class="code">scala.Symbol</font> - w tym wypadku <font class="code">scala.Symbol( "tutajJakasNazwa" )</font>.)
			
			<br><br>
			
			(U¿ywanie metody <font class="code">scala.actors.Actor.self()</font> zamiast <font class="code">this</font> jest polecane by pobieraæ instancjê obecnego aktora w ciele metody <font class="code">act()</font>.)
			
			<br><br>
			
			Tak zarejestrowany aktor jest ju¿ gotowy aby mo¿na by³o siê do niego pod³¹czyæ. W tym celu potrzeba w innej JVM stworzyæ jego lokaln¹ namiastkê :
			
			<br>
			
			<font class="code">
val adres = new scala.actors.remote.Node( "127.0.0.1" , 15123 )
	// tworzymy adres pod ktory bedziemy sie laczyc, czyli 127.0.0.1:15123

val namiastkaZdalnegoAktora = select( adres , 'udostepnionyAktor )
			</font>
			
			<br>
			
			Od tej pory mo¿emy u¿ywaæ sta³ej <font class="code">namiastkaZdalnegoAktora</font> tak jakby by³ to aktor lokalny - wszystkie wiadomoœci wysy³ane do niego bêd¹ serializowane i przesy³ane do realnego aktora znajduj¹cego siê w innej JVM. Jeœli zechce on odpowiedzieæ <font class="code">sender ! jakasOdpowiedz</font> to <font class="code">jakasOdpowiedz</font> tak¿e zostanie zserializowana i przes³ana do nas poprzez po³¹czenie sieciowe.
			
			<br><br>
			
			Z tego procesu widaæ, i¿ pod danym portem (metoda <font class="code">alive()</font>) mo¿e byæ zarejestorwanych (metoda <font class="code">register()</font>) bardzo du¿o aktorów. Nastêpnie pod³¹czaj¹c siê do nich (metoda <font class="code">select()</font>) musimy podaæ nazwê któregoœ z nich.
			
			<br><br>
			
			Zobaczmy jak wygl¹daj¹ dwaj aktorzy ping - pong osadzeni na innych JVM.

			<br><br>
			
			<b>JVM 1 (ping)</b> :
			
			<br>
			
			<font class="code">
import scala.actors._
import scala.actors.Actor._
import scala.actors.remote.RemoteActor._

case class PingPongMessage( value : Int )

object Ping extends Actor
{
    classLoader = getClass().getClassLoader()
    
    def act
    {
        alive( 15123 )
        register( 'Ping , self )
                
        loop
        {
            react
            {
                case PingPongMessage( value ) =>
                {
                    println( "Ping : " + value )

                    if( value > 0 ) sender ! PingPongMessage( value - 1 )
                }
            }
        }
    }
}

object PingStarter
{
    def main( args : Array[String] )
    {
        Ping.start
    }
}
			</font>
			
			<br>
			
			<b>JVM 2 (pong)</b> :
			
			<br>
			
			<font class="code">
import scala.actors._
import scala.actors.Actor._
import scala.actors.remote._
import scala.actors.remote.RemoteActor._

case class PingPongMessage( value : Int )

object Pong extends Actor
{
    classLoader = getClass().getClassLoader()
    
    def act
    {
        select( Node( "127.0.0.1" , 15123 ) , 'Ping ) ! PingPongMessage( 10 )

        loop
        {
            react
            {
                case PingPongMessage( value ) =>
                {
                    println( "Pong : " + value )
                    
                    if( value > 0 ) sender ! PingPongMessage( value - 1 )
                }
            }
        }
    }
}

object PongStarter
{
    def main( args : Array[String] )
    {
        Pong.start
    }
}
			</font>
			
			<br>
			
			(W ka¿dym z aktorów musieliœmy dodaæ wywo³anie metody <font class="code">classLoader_=()</font> (umiejscowion¹ w <font class="code">scala.actors.remote.RemoteActor</font>) pozwalaj¹c¹ powi¹zaæ lokalny <font class="code">ClassLoader</font> z systemem zdalnych aktorów.)
			
			<br><br>
			
			Jak widzimy definicja klasy <font class="code">PingPongMessage</font> (przesy³anej pomiêdzy aktorami wiadomoœci) musi znajdowaæ siê po obu stronach (dok³adnie taka sama nazwa klasy umieszczonej w dok³adnie tym samym package).
			
			<br><br>
			
			Na pocz¹tku uruchamiamy JVM 1, a wiêc <font class="code">Ping</font>, który to zarejestruje siê na przychodz¹ce po³¹czenia (na porcie 15123). Nastêpnie zapalamy JVM 2, a wiêc <font class="code">Pong</font>, który to nawi¹ze po³¹czenie i przeœle pierwsz¹ wiadomoœæ.
			
			<br><br>
			
			Output JVM 1 :
			
			<br>
			
			<font class="code">
Ping : 10
Ping : 8
Ping : 6
Ping : 4
Ping : 2
Ping : 0
			</font>
			
			<br>
			
			Output JVM 2 :
			
			<br>
			
			<font class="code">
Pong : 9
Pong : 7
Pong : 5
Pong : 3
Pong : 1
			</font>

		</font>

		<a name="S3Rozpr.17"></a><h2>1.1.15. Systemy rozproszone i aktorzy</h2>
		
		<font class="chapter">

			Jak widaæ aktorzy pozwalaj¹ w szybki i elegancki sposób pisaæ programy rozproszone.
			
			<br><br>
			
			Za pomoc¹ aktorów mo¿emy zrealizowaæ najró¿niejsze konstrukcje :
			
			<br>
			
			- aktor-broadcaster - przesy³amy do niego wiadomoœæ, a on rozy³a j¹ innym zarejestrowany (lub przekazanym przez konstruktor) aktorom-sluchaczom
			
			<br>
			
			- w celach debbugingu i u³atwienia tworzenia aplikacji niektóre z aktorów mog¹ odsy³aæ do aktora-s³uchacza przychodz¹ce do nich wiadomoœci, ten zaœ mo¿e logowaæ je do pliku, wypisywaæ na out lub robiæ z nimi inne rzeczy
			
			<br>
			
			- aktor-synchronizacyjny (zbieraj¹cy wiadomoœci) zaprojektowany mo¿e byæ tak, i¿ oczekuje, a¿ przyjd¹ do niego okreœlone wiadomoœci, nastêpnie po otrzymaniu ostatniej rozpoczyna swoj¹ akcjê (np. odsy³aj¹c zbiorcz¹ wiadomoœæ do innego aktora)
			
			<br>
			
			- na systemie aktorów mo¿na zrealizowaæ ca³y system loggera jaki mamy dostêpny w <font class="code">java.util.logging</font>, a wiêc <font class="code">Logger</font> do którego przesy³ane s¹ komunikaty, w nim rejestrujemy s³uchaczy (<font class="code">Handler</font>), w s³uchaczach filtry (<font class="code">Filter</font>) mog¹ce odrzucaæ niektóre komunikaty.
			
			<br><br>
			
			Dany program mo¿e siê wykonywaæ na jednej lub wielu maszynach. Jeœli jest to aplikacja klient-serwer to klient mo¿e pojawiaæ siê na serwerze jako grupa czasowo dostêpnych aktorów z którymi mo¿na siê komunikowaæ. Sam serwer dla klienta tak¿e mo¿e jawiæ siê jako seria aktorów, które dostêpne s¹ czasowo.
			
			<br><br>
			
			Dobrze napisany program mo¿e od razu zak³adaæ, i¿ jego aktorzy czasami bêda aktorami lokalnymi, a czasami zdalnymi. Wszystko zale¿y od jego cyklu rozwojowego (podczas powstawania) i wdro¿eniowego (podczas docelowej pracy). Aby sprostaæ temu wymaganiu mo¿e on nie odwo³ywaæ siê bezpoœrednio do aktorów, ale poprzez klasê proxy. To ona bêdzie odpowiedzialna za dostarczenie referencji do zadanego aktora. Dziêki temu bardzo ³atwo mo¿na zmieniaæ czy ma to byæ referencja lokalna czy zdalna.
			
			<br><br>
			
			Jeœli dana czêœæ programu (powiedzmy jeden aktor) pracuje na innej JVM to odpowiednio oprogramowuj¹c t¹ sytuacje zyskujemy mo¿liwoœæ czasowego go gaszenia i natychmiastowego uruchamiania w jego miejsce jego innej, ulepszonej wersji. Pozosta³a czêœæ aktorów wiedz¹c, i¿ mo¿e siê to zda¿yæ powinna umieæ obs³u¿yæ tak¹ sytuacjê (np. owa wspomniana wy¿ej klasa proxy mog³aby siê tym zajmowaæ).
			
			<br><br>
			
			Aktorzy s¹ ow¹ skalowalnoœci¹ jêzyka Scala. To nowoczesne i elastyczne podejœcie do programowania pozwala tworzyæ programy wydatnie wykorzystuj¹ce dostêpne zasoby (procesory, rdzenie). Ma³e program od du¿ych mog¹ ró¿niæ siê jedynie iloœci¹ wiadomoœci, które przesy³aj¹ pomiêdzy sob¹ aktorzy.

		</font>

		<a name="S3Rozpr.18"></a><h2>1.1.16. Przyk³adowy program : przetwarzanie zadañ w modelu klient-serwer</h2>
		
		<font class="chapter">

			W tym dziale znajduje siê mini-przyk³ad serwera, który przygotowuje zadania i rozsy³a je klientom - kiedy oni o nie pytaj¹. Nastêpnie odbiera wyniki, a na sam koniec wypisuje statystyki.
			
			<br><br>
			
			<b>1) Klasy wspólne</b>
			
			<br><br>
			
			Na pocz¹tku zdefiniujmy klasy wspólne dla serwera i klienta. Mo¿na je umieœciæ np. w oddzielnym projekcie i do³¹czyæ go potem do tych¿e dwóch projektów :
			
			<br>
			
			<font class="code">
package komunikacja

class ZadanieMnozace( iloscMnozen : Int ) extends java.io.Serializable
{
    def wykonaj =
    {
        var wynik : Long = 1;
        for( i <- 0 to iloscMnozen ) wynik *= wynik
        wynik
    }
}

case class PodajMiZadanie( nazwaKlienta : String )

case class WynikZadania( nazwaKlienta : String , wynik : Long )
			</font>
			
			<br>
			
			Mamy tutaj jedno zadanie (<font class="code">ZadaineMnozace</font>) oraz <i>case class</i> do poproszenia serwera o zadanie i <i>case class</i> do odes³ania serwerowi wyniku.
			
			<br><br>
			
			<b>2) Klient</b>
			
			<br>
			
			<font class="code">
package klient

object KlientZadanStarter
{
    def main( args : Array[String] )
    {
        KlientZadan.start
    }
}

object KlientZadan extends scala.actors.Actor
{
    import scala.actors.Actor._
    import scala.actors.remote._
    import scala.actors.remote.RemoteActor._
    import komunikacja._
    
    classLoader = getClass().getClassLoader()
    
    def act
    {
            val nazwaKlienta = "klient" + System.currentTimeMillis
            
            val serwerZadan = select( new Node( "127.0.0.1" , 15123 ) , 'serwerZadan )

            while( true )
            {
                println( "pobieram zadanie..." )
                
                val zadanie = serwerZadan !? new PodajMiZadanie( nazwaKlienta )
                
                println( "otrzymalem zadanie " + zadanie )
                
                zadanie.asInstanceOf[ Option[ ZadanieMnozace ] ] match
                {
                    case Some( zadanie ) =>
                    {
                        println( "odebralem i wykonuje zadanie..." )
                        val wynik = zadanie.wykonaj
                        println( "odsylam wynik..." )
                        
                        serwerZadan ! new WynikZadania( nazwaKlienta , wynik )
                    }
                    
                    case None =>
                    {
                        println( "nie ma nic wiecej do pracy, koncze..." )
                        System exit 0
                    }
                }
            }
            
    }
}
			</font>
			
			<br>
			
			Klient cyklicznie pyta siê serwer o zadanie dla niego, po czym je wykonuje. Jeœli ju¿ nie ma ¿adnych zadañ do wykonania to otrzymuje <font class="code">None</font> (jest to jedna z dwóch wykluczaj¹cych siê opcji <font class="code">Option[T]</font>).
			
			<br><br>
			
			<b>3) Serwer</b>
			
			<br>
			
			<font class="code">
package serwer

object SerwerZadanStarter
{
    def main(args : Array[String])
    {
        val serwerZadan = new SerwerZadan( 20 )
    }
}

class SerwerZadan( iloscZadan : Int ) extends scala.actors.Actor
{
    import scala.actors.Actor._
    import scala.actors.remote.RemoteActor._
    import komunikacja._

    classLoader = getClass().getClassLoader()
    
    start
    
    def act
    {
        alive( 15123 )
        register( 'serwerZadan , self )
        
        println( "serwer zadan uruchomiony na porcie 15123" )
                
        var wydanoZadan = 0
        var iloscWynikow = 0
        var czasWydaniaPierwszegoZadania : Long = 0
        
        loop
        {
            react
            {
                case PodajMiZadanie( nazwaKlienta ) =>
                {
                    reply ( if( wydanoZadan < iloscZadan )
                    {
                        if( wydanoZadan == 0 ) czasWydaniaPierwszegoZadania = System.currentTimeMillis
                        
                        wydanoZadan += 1
                        println( "klient " + nazwaKlienta + " prosi o kolejne zadanie, " + 
                        	"wydaje zadanie " + wydanoZadan )
                        	
                        Some( new ZadanieMnozace( Int.MaxValue/10 ) )                        
                    }
                    else
                    {
                        println( "klient " + nazwaKlienta + " prosi o kolejne zadanie, ale " +
                        	"juz nie ma nic do roboty" )
                        	
                        None
                    } )
                }
                
                case WynikZadania( nazwaKlienta , wynik ) =>
                {
                    iloscWynikow += 1
                    
                    if( iloscWynikow < iloscZadan )
                    {
                        println( "klient " + nazwaKlienta + " przyslal wynik zadania : " +
                        	wynik + ", i jest to juz " + iloscWynikow +
                        	" odebrany wynik na " + iloscZadan + " wymaganych" )
                    }
                    else
                    {
                        val czasWykonania =
                        	( System.currentTimeMillis - czasWydaniaPierwszegoZadania ) / 1000
                        	
                        val iloscZadanNaSekunde : Double = iloscZadan / czasWykonania
                        
                        println( "wszystkie " + iloscZadan + " zadan zostalo przetworzonych w " +
                        	czasWykonania + " s, wykonano " + iloscZadanNaSekunde +
                        	" zadania na sekunde" )
                    }
                }
                
                case m => println( "nierozpoznana wiadomosc " + m )
            }
        }
    }
}
			</font>
			
			<br>
			
			Serwer wydaje zadania klientom zliczaj¹c ich iloœæ, a tak¿e odbiera wyniki i zlicza ich iloœæ. Na koñcu przy jednym kliencie mo¿emy zobaczyæ wynik :
			
			<br>
			
			<font class="code">
...
klient klient1264979762091 prosi o kolejne zadanie, wydaje zadanie 18
klient klient1264979762091 przyslal wynik zadania : 1, i jest to juz 18 odebrany wynik na 20 wymaganych
klient klient1264979762091 prosi o kolejne zadanie, wydaje zadanie 19
klient klient1264979762091 przyslal wynik zadania : 1, i jest to juz 19 odebrany wynik na 20 wymaganych
klient klient1264979762091 prosi o kolejne zadanie, wydaje zadanie 20
<b>wszystkie 20 zadan zostalo przetworzonych w 79 s, wykonano 0.25316455696202533 zadania na sekunde</b>
klient klient1264979762091 prosi o kolejne zadanie, ale juz nie ma nic do roboty
			</font>
			
			<br>
			
			a przy trzech klientach :
			
			<br>
			
			<font class="code">
...
klient klient1264979934310 prosi o kolejne zadanie, wydaje zadanie 19
klient klient1264979920857 przyslal wynik zadania : 1, i jest to juz 17 odebrany wynik na 20 wymaganych
klient klient1264979920857 prosi o kolejne zadanie, wydaje zadanie 20
klient klient1264979927273 przyslal wynik zadania : 1, i jest to juz 18 odebrany wynik na 20 wymaganych
klient klient1264979927273 prosi o kolejne zadanie, ale juz nie ma nic do roboty
klient klient1264979934310 przyslal wynik zadania : 1, i jest to juz 19 odebrany wynik na 20 wymaganych
klient klient1264979934310 prosi o kolejne zadanie, ale juz nie ma nic do roboty
<b>wszystkie 20 zadan zostalo przetworzonych w 36 s, wykonano 0.5555555555555556 zadania na sekunde</b>
klient klient1264979920857 prosi o kolejne zadanie, ale juz nie ma nic do roboty
			</font>
	
			<br>
			
			Tak wiêc : pierwsze wykonanie 79s, drugie wykonanie 36s (4-ro rdzeniowy procesor Intel Core2Quad 2.6GHz).

		</font>

		<a name="S3Rozpr.19"></a><h2>1.2. Inni aktorzy</h2>
		
		<font class="chapter">

			Teraz, kiedy ju¿ wiecie Pañstwo tak du¿o o aktorach, z pewnoœci¹ zainteresuje Was informacja, i¿ dla Scali zosta³y opracowane tak¿e inne implementacje aktorów.
			
			<br><br>
			
			(Tak samo istniej¹ ró¿ne implementacje aktorów dla Java - niektóre s¹ nawet wspólne dla Javy i Scali. Jednak w Javie ze wzglêdu na ubogoœæ - w porównaniu ze Scal¹ - oraz nastawienie na struktury mutable u¿ywanie ich jest mniej efektowne.)
			
			<br><br>
			
			Ma³e porównanie aktorów :
			
			<br><br>
			
			1) aktorzy standardowi (wbudowani) :
			
			<br>
			
			- dobrze udokumentowane
			
			<br>
			
			- wsparcie dla zagnie¿d¿onego odbierania wiadomoœci (metody <font class="code">react()</font>/<font class="code">receive()</font> umieszczone w innych <font class="code">react()</font>/<font class="code">receive()</font>)
			
			<br>
			
			- problemy z wyciekami pamiêci, ca³y czas trwaj¹ prace nad ich usuniêciem, obecnie (styczeñ 2010) prawie wyeliminowane
			
			<br><br>
			
			2) aktorzy Akka :
			
			<br>
			
			- nie obs³uguj¹ zagnie¿d¿onego odbierania wiadomoœci (ale mo¿na to rozwi¹zaæ innymi sposobami)
			
			<br>
			
			- bardzo dobra obs³uga zdalnych aktorów
			
			<br>
			
			- posiadaj¹ mo¿liwoœæ tworzenia hierarchii nadzorców
			
			<br>
			
			- interfejsy pozwalaj¹ce pracowaæ z Javy (bez u¿ywania Scali)
			
			<br>
			
			- wspó³dzieli wspólne interfejsy z aktorami Lift
			
			<br><br>
			
			3) aktorzy Lift :
			
			<br>
			
			- nie obs³uguj¹ zagnie¿d¿onego odbierania wiadomoœci (ale mo¿na to rozwi¹zaæ innymi sposobami)
			
			<br>
			
			- wspó³dzieli wspólne interfejsy z aktorami Akka
			
			<br>
			
			- czêsto u¿ytkowane przez programistów zgromadzonych wokó³ Lift (Lift jest kontenerem servletów)
			
			<br><br>
			
			4) aktorzy Scalaz :
			
			<br>
			
			- nie najlepiej udokumentowane
			
			<br>
			
			- skomplikowane, nieelegancko rozwi¹zane

		</font>

		<a name="S3Rozpr.20"></a><h2>1.2.1. Akka</h2>
		
		<font class="chapter">

			Biblioteka Akka (http://akkasource.org/) rozwijana jest przez Jonasa Bonera. Pomimo znajdowania siê we wczesnej fazie rozwojowej (v0.6 - styczeñ 2010) mo¿e przyprawiæ o szybsze bicie serca ka¿dego programistê preferuj¹cego ten styl programowania.
			
			<br><br>
			
			Aktorzy Akka zapewniaj¹ :
			
			<br>
			
			- STM (Software Transactional Memory) zapewniaj¹ce transakcyjne operowanie na pamiêci, w przypadku jakiegoœ problemu istnieje gwarancja, i¿ dane zostan¹ przywrócone do poprzedniego stanu
			
			<br>
			
			- persystence danych poprzez zewnêtrzne modu³y, obecnie s¹ to <font class="code">Redis</font>, <font class="code">Cassandra</font>, <font class="code">MongoDB</font>, oczywiœcie wspó³pracuj¹ z STM
			
			<br>
			
			- 2-3 razy szybsze od aktorów standartowych Scali
			
			<br>
			
			- bardzo ma³y rozmiar (600B per aktor), ~6.5 mln aktorów na komputerze z 4GB RAM
			
			<br>
			
			- bardzo sprawna komunikacja ze zdalnymi aktorami (ponowne nawi¹zywanie zerwanego po³¹czenia, kompresja, ...)
			
			<br>
			
			- aktorzy-nadzorcy (supervisor actors) kontruluj¹ce pracê jednego lub wielu aktorów, rózne polotyki restartowania w przypadku problemu
			
			<br>
			
			- wspó³praca z Comet
			
			<br>
			
			- praca aktorów w klastrze
			
			<br>
			
			- najró¿niejsze standardy serializacji danych : <font class="code">SBinary</font>, <font class="code">JSON</font>, <font class="code">Protobuf</font>
			
			<br>
			
			- wspó³praca z AMQP (Advanced Message Queuing Protocol) - ta otwarta specyfikacja zapewnia sposób na wymianê wiadomoœci pomiêdzy aplikacjami (biznesowymi i infrastrukturalnymi)
			
			<br><br>
			
			Na szczêœcie wraz z powy¿szymi zaletami nie wzrasta trudnoœæ programowania :
			
			<br>
			
			<font class="code">
class AkkaAktor extends Actor
{  
    def receive =
    {  
        case "Ala" => println("odebralem 'Ala'")  
        case _ => println("nierozpoznana wiadomosc")  
    }  
}  
   
val akkaAktor = new AkkaAktor
akkaAktor.start
			</font>
			
			<br>
			
			W powy¿szym przyk³adzie definiujemy aktor poprzez domiksowanie traitu Actor, w poni¿szym poprzez metodê tworz¹c¹ aktora 'na skróty' :
			
			<br>
			
			<font class="code">
val akkaAktor = actor
{   
    case "Ala" => println("odebralem 'Ala'")  
    case _ => println("nierozpoznana wiadomosc")
}
			</font>
			
			<br>
			
			Ponadto dystrybucja Akka umo¿liwia pracê w trybie samodzielnym. Po spakowaniu aktorów w pliku JAR i umieszczeniu go w odpowiednim katalogu (<font class="code">AKKA_HOME/deploy/</font>) dystrybucji zapalamy mikrokernel, który zapewnia dostêp do aktorów w trybie zdalnym.
			
			<br><br>
			
			W projekcie Akka ewentualne problemy jakie mog¹ wyst¹piæ traktuje siê bardzo naturalnie. Autor poleca nie walczyæ i nie zabezpieczaæ kodu w nieskoñczonoœæ gdy¿ to i tak nie zagwarantuje niewyst¹pienia b³êdu. Jeœli ma coœ pójœæ nie tak to i tak pójdzie. Styl przyjêty w Akka mówi 'let it crash' (niech siê wy³o¿y), a pomimo to wszystko ma nadal dobrze pracowaæ.
			
			<br><br>
			
			Do komunikacji sieciowej Akka wykorzystuje bardzo wydajn¹ bibliotekê NIO - Jboss Netty. Dziêki wykorzystaniu nieblokuj¹cej komunikacji mamy pewnoœæ, i¿ w¹tki s¹ wydajnie u¿ytkowane (nie nastêpuje zale¿noœæ 1 po³¹czenie sieciowe = 1 w¹tek, a czêsto dwa i wiêcej).
			
			<br><br>
			
			Poniewa¿ aktorzy z definicji nie powinni wspó³dzieliæ ze sob¹ wspólnego stanu (w zamian za to ka¿dy z nich przetrzymuje swój w³asny stan bez wiedzy o stanach innych aktorów) pojawia siê  realny problem kiedy dochodzimy do  takiej potrzeby. Jak zrobiæ to dobrze, jak w modelu aktorów u¿ywaæ STM ? Otó¿ w Akka ka¿dy z aktorów mo¿emy uczyniæ transakcyjnym domiksowuj¹c do naszej klasy trait <font class="code">Transactor</font>. Od tej pory ka¿da odebrana wiadomoœæ odbywa siê w transakcji.

		</font>

		<a name="S3Rozpr.21"></a><h2>1.2.2. Lift</h2>
		
		<font class="chapter">

			Aktorzy Lift zostali powo³ani do ¿ycia przez Davida Pollaka, twórcê Lift (kontener servletów napisany w Scali). Poniewa¿ wielokrotne poprawki aktorów wbudowanych nie przynosi³y efektów (jedne naprawy powodowa³y kolejne wycieki pamiêci) postanowi³ on w maju 2009 rozpocz¹æ now¹ implementacjê.
			
			<br><br>
			
			W szczególnoœci przeszkadzaj¹ce by³o to, i¿ aktorzy standardowi Ÿle sprawdzali siê w przypadkach czêstego tworzenia i niszczenia (raczej czêstego 'niepotrzebowania') - dzieje siê tak gdy¿ Lift tworzy aktora przy ka¿dorazowym zapytaniu Comet.
			
			<br><br>
			
			Tworz¹c Lift Actors David Pollak wspó³pracowa³ z Jonasem Bonerem - a wiêc twórc¹ Akka Actors. St¹d wywodz¹ siê wspó³dzielone przez nich interfejsy, a wiêc potencjalna mo¿liwoœæ zrezygnowania z jednej z tych implementacji na rzecz drugiej (w ³atwy i bez bólowy sposób).
			
			<br><br>
			
			W odró¿nieniu od aktorów Scala :
			
			<br>
			
			- brak metod <font class="code">start()</font>, <font class="code">stop()</font> oraz <font class="code">exit()</font> (do zakañczania aktora) - aktor automatycznie po stworzeniu odbiera wiadomoœci, a kiedy jego referencja zostanie upuszczona trafia do GC
			
			<br>
			
			- wszyscy aktorzy u¿ywaj¹ tego samego zarz¹dcy (scheduler), który do poolingu w¹tków wykorzystuje <font class="code">java.util.concurrent</font>
			
			<br>
			
			- aktorzy nie obs³uguj¹ ³¹czenia hierarchicznego, tak wiêc nie ma metod <font class="code">link()</font>/<font class="code">unlink()</font> (dostêpne <font class="code">scala.actors.Actor</font> do ³¹czenia aktorów w wiêksze ca³oœci)
			
			<br>
			
			- jeœli podczas przetwarzania wiadomoœci wyskoczy jakiœ wyj¹tek to aktor nie przestanie pracowaæ, wyj¹tek zostanie prze³apany i przekazany do pattern matching zdefiniowanego w metodzie <font class="code">exceptionHandler()</font>
			
			<br>
			
			- przychodz¹ce wiadomoœci przetwarzane s¹ w chronionej (<font class="code">protected</font>) metodzie <font class="code">messageHandler()</font>, której implementacja mo¿e byæ zmieniana pomiêdzy przetwarzanymi wiadomoœciami

		</font>

		<a name="S3Rozpr.22"></a><h2>1.2.3. Scalaz</h2>
		
		<font class="chapter">

			Przyk³ad u¿ycia aktorów Scalaz wykorzystuj¹c metodê <font class="code">scalaz.Scalaz.actor()</font> do stworzenia aktora :
			
			<br>
			
			<font class="code">
object ExampleActor
{
    import java.util.concurrent.{ TimeUnit , Executors }
    
    def main( args : Array[String] )
    {
        sealed trait Event
        case class Login(user: String) extends Event
        case class Logout(user: String) extends Event
        case class ChatMessage(from: String, message: String) extends Event
    
        val executor = Executors.newFixedThreadPool( 5 )
        
        val strategia = scalaz.concurrent.strategy.Executor.strategy[Unit]( executor )
        
        val odbieranieWiadomosci = ( e : Event ) => e match
        {
            case Login( uzytkownik ) => println("uzytkownik: " + uzytkownik + " zalogowany.")
            
            case Logout( uzytkownik ) => println("uzytkownik: " + uzytkownik + " wylogowany.")
            
            case ChatMessage( uzytkownik , wiadomosc ) =>
            {
            	println("uzytkownik: " + uzytkownik + " przyslal wiadomosc : " + wiadomosc )
            }
            
            case _ =>
        }
        
        val chatServer = scalaz.Scalaz.actor[Event]( odbieranieWiadomosci )( strategia )
    
        val uzytkownik = "Adam"
            
        chatServer ! Login( uzytkownik )
        
        for(i <- 1 to 5) chatServer ! ChatMessage( uzytkownik , "wiadomosc : " + i )
        
        chatServer ! Logout( uzytkownik )
    
        Thread.sleep( 1000 )
        
        executor.shutdown()
        
        executor.awaitTermination( 60L , TimeUnit.SECONDS )
    }
}
			</font>
			
			<br>
			
			Jak widaæ aktorzy Scalaz pozwalaj¹ okreœliæ jakiego typu wiadomoœci bêd¹ odbierane (w tym wypadku <font class="code">Event</font>).
			
			<br><br>
			
			Program da na out :
			
			<br>
			
			<font class="code">
uzytkownik: Adam zalogowany.
uzytkownik: Adam przyslal wiadomosc : wiadomosc : 1
uzytkownik: Adam przyslal wiadomosc : wiadomosc : 2
uzytkownik: Adam przyslal wiadomosc : wiadomosc : 3
uzytkownik: Adam przyslal wiadomosc : wiadomosc : 4
uzytkownik: Adam przyslal wiadomosc : wiadomosc : 5
uzytkownik: Adam wylogowany.
			</font>

		</font>

		<hr>

		<a name="S3Rozpr.23"></a><h2>2. Kontynuacje (delimited portable continuations)</h2>
		
		<font class="chapter">
			
			Kontynuacje pochodz¹ z funkcyjnego stylu programowania i s¹ technik¹ pozwalaj¹c¹ nam zapamiêtaæ aktualny stan wykonywania siê programu. Stan ten nastêpnie mo¿na zapisaæ na dysku lub przes³aæ przez sieæ po czym odmroziæ i kontynuowaæ w przysz³oœci.
			
			<br><br>
			
			W odró¿nieniu mo¿liwoœci prostego uœpienia aktualnie wykonywanego w¹tku (np. <font class="code">Object.wait()</font>) kontynuacje pozwalaj¹ dzia³aæ bardziej dok³adnie, gdy¿ mo¿emy okreœliæ co/jak¹ partiê chcemy zamroziæ (<i>delimited</i>). Dziêki temu dzia³amy bardziej wydajnie.
			
			<br><br>
			
			Kontynuacje w Scali s¹ przenoœne (<i>portable</i>) i to w³aœnie ta cecha pozwala na czerpaæ dodatkowe zalety w postaci mo¿liwoœci serializowania i zapisywania b¹dŸ przesy³ania przez sieæ. Okreœlenie 'serializowania' nie jest tutaj dok³adne gdy¿ kontynuacje dzia³aj¹ bardziej na zasadzie przekszta³cania kodu - tak wiêc nie wszystkie dane (a czêsto jest ich bardzo du¿o!) s¹ bez wiêkszego namys³u i rozeznania zamieniane na ci¹g bajtów (trzeba pamiêtaæ, ¿e obiekty przez nas trzymane same trzymaj¹ kolejne obiekty, a te znów kolejne, tak wiêc zagro¿eniem jest taka niekontrolowana serializacja).
			
			<br><br>
			
			Obecnie (wczesne bety Scala 2.8) kontynuacje dodane s¹ jako wtyczka do kompilatora Scali. Tak wiêc chc¹c z nich korzystaæ (u¿ytkowaæ podczas programowani) musimy owy plugin œci¹gn¹æ i dodaæ do kompilatora.

		</font>

		<a name="S3Rozpr.24"></a><h2>2.1. Co pozwalaj¹ zrobiæ kontynuacje ?</h2>
		
		<font class="chapter">

			Otó¿ potrafi¹ pomóc odwróciæ dekompozycjê programów, któr¹ m.in. ze wzglêdu na wielordzeniowe procesory zaczynamy preferowaæ. Event-driven-programming oraz callback-oriented rozwi¹zuj¹ bardzo du¿o problemów, ale kosztem jego jest dekompozycja kodu. Musimy pisaæ w stylu 'poszarpanym', poprzerywanym na ró¿ne sekcje, a ca³oœæ sk³adaæ logicznie w g³owie maj¹c nadziejê, ¿e jeszcze wszystko ogarniamy/kontrolujemy.
			
			<br>
			
			Kontynuacje pozwalaj¹ odwróciæ t¹ sytuacjê ponownie zamieniaj¹c kod na ³atwy w zapisie i odczycie czyli linia-po-linii.

		</font>

		<a name="S3Rozpr.25"></a><h2>2.2. Gdzie siê mog¹ przydaæ ?</h2>
		
		<font class="chapter">

			- podczas asynchronicznych IO
			
			<br>
			
			- podczas zarejestrowania siê na ró¿ne zdarzenia i oczekiwania na ich zaistnienie
			
			<br>
			
			- podczas u¿ytkowania wykonawców (executors) oraz poolingu w¹tków
			
			<br>
			
			- podczas wykonywania siê web naszej aplikacji w stylu request-response

		</font>

		<a name="S3Rozpr.26"></a><h2>2.3. Jak s¹ zrealizowane ?</h2>
		
		<font class="chapter">

			Otó¿ kontynuacje opakowuj¹ pewn¹ czêœæ dalszego wykonywania siê metody (kodu) i mog¹ byæ traktowane jak funkcja. Zapamiêtana na zmiennej mo¿e byæ wykonana w przysz³oœci raz, wiele razy albo w ogóle.
			
			<br><br>
			
			Do naszej dyspozycji zosta³y przekazane tylko dwie funkcje :
			
			<br><br>
			
			- <font class="code">shift()</font> - która to prze³apuje kontynuacjê
			
			<br>
			
			- <font class="code">reset()</font> - która pozwala programiœcie okreœliæ zakres kontynuacji
			
			<br><br>
			
			Metody te mog¹ byæ ustawione blisko siebie (np. w jednej metodzie) :
			
			<br>
			
			<font class="code">
reset
{
    ...
    shift{ ... }
    ...
}
			</font>
			
			<br>
			
			lub w zupe³nie innych metodach (wtedy potrzebna jest na adnotacja <font class="code">@cps</font>). Tak jak to ma miejsce w bloku <font class="code">try-catch</font> i wylatuj¹cym wyj¹tku. W pewnej metodzie ustawiamy blok prze³apania wyj¹tku (<font class="code">try{ ... }catch{ ... }</font>) w którego œrodku wywo³ujemy jak¹œ metodê. Ta metoda w wywo³uje szereg innych metod, one znów jakieœ inne, a¿ z którejœ wyleci wyj¹tek. Podró¿uj¹c w górê po stosie wywo³ania jest poszukiwany pierwszy okalaj¹cy blok <font class="code">try-catch</font>.

		</font>

		<a name="S3Rozpr.27"></a><h2>2.4. Gdzie dok³adnie s¹ te ca³e kontynuacje ?</h2>
		
		<font class="chapter">

			Zobaczmy :
			
			<br>
			<font class="code">
reset
{
    ...

    shift{ ... }
   
    {
        // tutaj znajduje sie kontynuacja
    }

}
			</font>
			
			<br>
			
			Aby wywo³aæ zaznaczon¹ powy¿ej kontynuacjê musimy u¿yæ funkcji dostarczonej do <font class="code">shift()</font> :
			
			<br>
			
			<font class="code">
reset
{
    // jakis nasz kod wywolany przed kontynuacja

    shift
    {
        kontynuacja =>

            // jakis nasz kod wywolany przed kontynuacja

            kontynuacja() // wywolanie kontynuacji

            // jakis nasz kod wywolany po kontynuacji
    }
   
    {
        // tutaj znajduje sie kontynuacja
    }

}
			</font>

		</font>

		<a name="S3Rozpr.28"></a><h2>2.5. Przyk³ad krok po kroku</h2>
		
		<font class="chapter">

			Poniewa¿ na pocz¹tku trudno siê po³apaæ jak wygl¹da œcie¿ka wykonania zamieszczam odpowiedŸ jak¹ uzyska³em od jednego z czytelników strony Scali (www.scala-lang.org).
			
			<br>
			
			<font class="code">
reset
{
    println(1)
}
//da: 1
			</font>
			
			<br>
			
			Jak wiêc widaæ w tym kodzie nic siê nie dzieje poza okreœleniem zakresu kontynuacji.
			
			<br>
			
			<font class="code">
reset
{
    println(1)
    shift { cont => }
    println(2)
}
//da: 1
			</font>
			
			<br>
			
			Do metody <font class="code">shift()</font> dostarczyliœmy cia³o anonimowej funkcji, która pobiera jako swój argument resztê kontynuacji (<font class="code">cont</font>) oraz puste cia³o.
			
			<br>
			
			<font class="code">
reset
{
    println(1)

    shift
    {
        cont => println(2)
    }

    println(3)
}
//da: 1 2
			</font>
			
			<br>
			
			W porównaniu do przyk³adu powy¿ej dostarczyliœmy cia³o funkcji <font class="code">count</font>.
			
			<br>
			
			<font class="code">
reset
{
    println(1)

    shift
    {
        cont =>
            cont()
            println(2)
    }

    println(3)
}
//da: 1 3 2
			</font>
			
			<br>
			
			Poniewa¿ <font class="code">cont</font> jest funkcj¹, mo¿emy j¹ swobodnie wywo³aæ <font class="code">cont()</font>, co siê okazuje, nastêpuje wywo³anie kodu od koñca bloku <font class="code">shift{}</font>, a¿ do koñca okreœlonego przez nas zasiêgu metod¹ <font class="code">reset{}</font>.
			
			<br>
			
			<font class="code">
reset
{
    println(1)

    shift
    {
        cont =>
            cont()
            cont()
            println(2)
    }

    println(3)
}
//da: 1 3 3 2
			</font>
			
			<br>
			
			W porównaniu do przyk³adu powy¿ej dwukrotne wywo³anie <font class="code">cont()</font> uzmys³awia nam, i¿ mo¿emy dowoln¹ iloœæ razy wyprowadziæ na ekran 3.

		</font>

		<a name="S3Rozpr.29"></a><h2>2.6. Przyk³ad : echo serwer NIO</h2>
		
		<font class="chapter">

			Zobaczmy bardzo prosty echo serwer oparty na NIO.
			
			<br>
			
			<font class="code">
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.nio.channels.{SelectionKey, Selector, ServerSocketChannel, SocketChannel}

val selector = Selector.open()

// 1) na podczatek definicje metod

def konwersjaDoRunnable( body: => Unit ) = new Runnable { def run() { body() } }

def accept( s : ServerSocketChannel ) : SocketChannel @cps[ Unit , Unit ] =
{
    shift
    {
        cont =>
            selector.register( s , SelectionKey.OP_ACCEPT , konwersjaDoRunnable
            {
                val c = s.accept()
                c.configureBlocking(false)
                cont( c )
            })
    }
}

def read( s : SocketChannel , b : ByteBuffer) : Int @cps[ Unit , Unit ] =
{
    shift
    {
        cont =>
            selector.register( s , SelectionKey.OP_READ , konwersjaDoRunnable { cont( s.read(b) ) })
    }
}

def write( s : SocketChannel , b : ByteBuffer) : Int @cps[ Unit , Unit ] =
{
    shift
    {
        cont =>
            selector.register( s , SelectionKey.OP_WRITE , konwersjaDoRunnable { cont( s.write(b) ) })
    }
}

// 2) dalej program w stylu blokujacym

val ssc = ServerSocketChannel.open()
ssc.socket().bind( new InetSocketAddress( 12345 ) )
ssc.configureBlocking( false )

reset
{
    while( true )
    {
        val socket = accept( ssc )

        reset
        {
            val bufor = ByteBuffer.allocateDirect( 1 )

            def iter(): Unit @cps[ Unit , Unit ] =
            {
                bufor.clear()

                val ilePrzeczytano = read( socket , bufor )

                if( ilePrzeczytano < 1 )
                    socket.close()
                else
                {
                    bufor.flip()
                    write( socket , bufor )
                    iter()
                }
            }

            iter()
        }
    }
}

// 3) na koncu wywolania runnable

while( true )
{
    selector.select()

    val gotoweKlucze = selector.selectedKeys().toList

    selector.selectedKeys().clear()

    for( gotowyKlucz <- gotoweKlucze )
    {
        gotowyKlucz.interestOps( 0 )
        gotowyKlucz.attachment().asInstanceOf[ Runnable ].run()
     }
}
			</font>
			
			<br>
			
			Z powy¿szego kodu widaæ, i¿ kontynuacje mog¹ zwracaæ wartoœæ. I tak wywo³ana <font class="code">cont( c )</font> w metodzie <font class="code">accept()</font> zwraca wys³uchane po³¹czenie przychodz¹ce. Wywo³ana <font class="code">cont( s.read(b) )</font> w metodzie <font class="code">read()</font> zwraca iloœæ odebranych bajtów.
			
			<br><br>
			
			St¹d wniosek, ¿e aby kontynuowaæ kontynuacjê trzeba wywo³aæ <font class="code">cont()</font>, zaœ to co ma ona zwróciæ przekazujemy jako jej argument <font class="code">cont( tutajCosDoZwrocenia )</font>.
			
			<br><br>
			
			Adnotacja <font class="code">@cps</font>, która siê tutaj pojawi³a, jest potrzebna w momencie kiedy <font class="code">reset()</font> i <font class="code">shift()</font> nie stoj¹ w tej samej metodzie (w sprawie jej wyt³umaczenia odsy³am do dokumentacji).

		</font>

		<a name="S3Rozpr.30"></a><h2>2.7. Projekt Swarm</h2>
		
		<font class="chapter">

			Swarm (http://code.google.com/p/swarm-dpl/) w bardzo nowatorski i interesuj¹cy sposób wykorzystuje kontynuacje do tworzenia rozproszonych programów w elegancki sposób. Osadzony zosta³ w Scali gdy¿ posiada ona* przenoœne kontynuacje (których brak m.in. w Haskell, Ruby, Phyton, Java czy C++). Projekt rozpocz¹³ i prowadzi Ian Clarke posiadaj¹cy bogate doœwiadczenie w sztucznej inteligencji oraz tworzeniu sieci P2P (Freenet, video streaming dla telewizji internetowej Joost).
			
			<br><br>
			
			* - co ciekawsze, kiedy powstawa³ Swarm nie ma jeszcze Scali 2.8, a to w niej bêd¹ wprowadzone kontynuacje.
			
			<br><br>
			
			Ciekawym za³o¿eniem projektu jest przyjête od pocz¹tku has³o : przenoœ wykonywanie, a nie dane. Chodzi o to aby nie przenosiæ danych jeœli ulokowane s¹ na oddzielnej maszynie. Zamiast tego przenieœæ kod, który potrzebuje operowaæ na nich.
			
			<br>
			
			Zadaniem Swarm jest przenoszenie kodu do miejsca gdzie ulokowane s¹ dane w sposób zupe³nie przeŸroczysty dla programisty (wystarczy tylko podaæ adres ip:port). Dodatkowym zadaniem Swarm jest przygotowanie kodu i przeprowadzanie przesy³ania tak aby by³o to jak najbardziej efektywne. Warto wiedzieæ, ¿e zwyk³e serializowanie kontynuacji, przesy³anie jej, deserializowanie i uruchamianie jest powolne.
			
			<br><br>
			
			Aby dzia³aæ sprawniej Swarm wymaga aby na ka¿dej maszynie by³ dostêpny ten sam kod. Jeœli nie zapewnimy tego w sposób oczywisty to mo¿na wykorzystaæ do tego ClassLoader, którego zadaniem bêdzie sprowadzanie na ¿¹danie odpowiedniego kodu klas.
			
			<br><br>
			
			Swarm znajduje siê obecnie (styczeñ 2010) we wczesnej fazie rozwoju.

		</font>

		<a name="S3Rozpr.31"></a><h2>2.7.1. Przyk³ady</h2>
		
		<font class="chapter">

			Oto proste przyk³ady dostarczone przez autora.
			
			<br><br>
			
			<b>Przyk³ad 1)</b> : zmuszanie Swarm do przenoszenia kontynuacji.
			
			<br>
			
			<font class="code">
val imie = readLine( "Jak masz na imie ? : " )

moveTo( new Location( "127.0.0.1" , 9997 ) )

val wiek = Integer.parseInt( readLine( "Witaj " + imie + ", ile masz lat ? : " ) )

moveTo( new Location( "127.0.0.1" , 9998 ) )

println( "Witaj Stary ! " + imie +
	", nie martw sie, nie jestes jeszcze taki stary (masz zaledwie " + wiek + " lat) !" )
			</font>
			
			<br>
			
			Wykonanie da :
			
			<br><br>
			
			- <b>konsola 1</b> (program wystartowany na porcie 9998) :
			
			<br>
			
			<font class="code">
Jak masz na imie ? : Artur
Witaj Stary ! Artur, nie martw sie, nie jestes jeszcze taki stary (masz zaledwie 29 lat) !
			</font>
			
			<br>
			
			- <b>konsola 2</b> (tylko s³uchacz na porcie 9997) :

			<br>
			
			<font class="code">
Witaj Artur, ile masz lat ? : 29
			</font>
			
			<br>
			
			Po poleceniu <font class="code">moveTo()</font> w sposób dla nas przeŸroczysty przenoszone jest wykonywanie programu na inn¹ maszynê (w tym wypadku jest to tylko inna konsola ;).
			
			<br><br>
			
			<b>Przyk³ad 2)</b> : Inicjowanie zmiennych/sta³ych.
			
			<br>
			
			<font class="code">
println( "1" )

val stalaLokalna = Ref( "lokalny lancuch" )

println( "2" )

val stalaZdalna = Ref( new Location( "127.0.0.1" , 9997 ) , "zdalny lancuch" )

println( "3" )

println( stalaLokalna )

println( "4" )

println( stalaZdalna )

println( "5" )
			</font>
			
			<br>
			
			Wykonanie da :
			
			<br><br>
			
			- <b>konsola 1</b> (program wystartowany na porcie 9998) :
			
			<br>
			
			<font class="code">
1
2
lokalny lancuch
4
			</font>
			
			<br>
			
			- <b>konsola 2</b> (tylko s³uchacz na porcie 9997) :
			
			<br>
			
			<font class="code">
3
zdalny lancuch
5
			</font>
			
			<br>
			
			Witaæ tutaj dobrze jak wykonywanie pod¹¿a za danymi. Pojawia siê <font class="code">1</font>, potem tworzymy <font class="code">stalaLokalna</font>, pojawia siê <font class="code">2</font>. Podczas tworzenia referencji <font class="code">stalaZdalna</font> nastêpuje przeniesienie wykonania na drug¹ konsole, dlatego <font class="code">3</font> pojawia siê tam. Podczas wypisywania <font class="code">stalaLokalna</font> powracamy na pierwsz¹ konsolê (gdy¿ tam jest ona zlokalizowana), <font class="code">4</font> pojawia siê tak¿e na niej. Wypisuj¹c <font class="code">stalaZdalna</font> ponownie pojawiamy siê na drugiej konsoli i na koniec pojawia siê tam <font class="code">5</font>.
			
			<br><br>
			
			Ten sam proces opisany w kodzie :
			
			<br>
			
			<font class="code">
// start na pierwszej konsoli

println( "1" )

val stalaLokalna = Ref( "lokalny lancuch" )

println( "2" )

// nastepuje przeniesienie na druga konsole

val stalaZdalna = Ref( new Location( "127.0.0.1" , 9997 ) , "zdalny lancuch" )

println( "3" )

// nastepuje powrot na pierwsza konsole gdyz tam sa dane tej referencji

println( stalaLokalna )

println( "4" )

// nastepuje przeniesienie za danymi, a wiec na druga konsole

println( stalaZdalna )

println( "5" )
			</font>

		</font>















		<br><hr>
				
	</body>

</html>