<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1250">
		<meta name="author" content="Artur Stanek">
		<meta name="description" content="Scala - techniki rozproszone">
		<meta name="copyright" content="(c) autor PJWSTK 2010">
		<link rel="stylesheet" type="text/css" href="../STYLE/common.css">
		
		<title>Scala - techniki rozproszone - WYK£AD 1</title>
		
	</head>

	<body>

		<div align="center">
			<a name="S1Wstep"></a><h1>Scala - techniki rozproszone - WYK£AD 1</h1>
		</div>
		
		<hr><br>
		
		<i>
			Ci¹g wyk³adów dotycz¹cy technik rozproszonych realizowanych za pomoc¹ Scali poprzedzony zdobyciem wiedzy o tym jêzyku programowania. 
			
			<br><br>
			
			Wyk³ad 1 : podstawowe informacje o jêzyku
		</i>
		
		<br><hr>
		
		<a name="S1Wstep.1"></a><h2>1. Wstêp</h2>
		
		<a name="S1Wstep.2"></a><h2>1.1. Wyk³ady</h2>
		
		<font class="chapter">
			
			Niniejsze wyk³ady przeznaczone s¹ dla osób znaj¹cych jêzyk programowania Java. Czêste odniesienia i porównania do Javy pozwalaj¹ szybciej zrozumieæ Scale, która wg. autora tych wyk³adów, mo¿e pretendowaæ do miana nastêpcy Javy.
			
			<br><br>
			
			Z uwagi na to, ¿e wci¹¿ jest dosyæ ma³o ksi¹¿ek na temat Scali (w tym nie ma ¿adnej w jêzyku polskim)  w pierwszych dwóch wyk³adach opisane zosta³y podstawy jêzyka, które pozwalaj¹ swobodnie rozumieæ treœæ ostatniego wyk³adu - traktuj¹cego o technikach rozproszonych.
			
			<br><br>
			
			Struktura podzia³u wyk³adów wygl¹da nastêpuj¹co :
			<br>
			- <b>wyk³ad 1</b> - wstêpne informacje o Scali, niezbyt daleko odbiegaj¹ce od Javy
			<br>
			- <b>wyk³ad 2</b> - zaawansowane œwiat Scali, techniki niemaj¹ce odpowiednika w Javie
			<br>
			- <b>wyk³ad 3</b> - techniki rozproszone
			<br>
			
			<br>
			
			W treœci wyk³adów pojêcie metody i funkcji jest stosowane zamiennie i oznacza dok³adnie to samo. Metoda nie zwracaj¹ca nic (w Javie <font class="code">void</font>) w Scali zwraca <font class="code">Unit</font>. Sam autor Scali (Pan Martin Odersky) okreœla je jako funkcje, zaœ bardzo zas³u¿ona i zaawansowana w Scali postaæ - Pan David Pollak - czêsto nazywa je metodami.
			
			<br><br>
			
			Poprzez czêste podobieñstwo kodu Javy i Scali - ten pierwszy zawsze jest oznaczony specjalnym komentarzem <font class="code">//kod Java</font.
			
		</font>	

		<br>

		<a name="S1Wstep.3"></a><h2>1.2. Scala</h2>
		
		<font class="chapter">
		
			www.scala-lang.org
			
			<br><br>
			
			Scala, z powodu jej twórcy, jest bardzo podobna do Javy. Wiele rzeczy nieporuszonych w tych wyk³adach mo¿na uznaæ za takie same jak w Javie. U³atwia to poznawanie tego jêzyka, gdy¿ mo¿na eksperymentowaæ i znaleŸæ rozwi¹zanie, jak coœ wykonaæ i zapisaæ, poprzez analogiê do Javy.
			
			<br><br>
			
			Nazwa jêzyka wywodzi siê od skalowalnoœci, a wiêc mo¿liwoœci budowania prostego programu, który bêdzie tak samo dobrze dzia³a³ z ma³¹ iloœci¹ klientów (u¿ytkowników) jak i du¿¹. Jedyne co bêdzie wymagane z naszej strony to dostarczenie odpowiednich zasobów (jak pamiêæ, procesory/rdzenie).				
							
		</font>
				
		<br>
		
		<a name="S1Wstep.4"></a><h2>1.2.1. Historia</h2>
		
		<font class="chapter">
		
			Oko³o roku 2003 Pan Martin Odersky zakoñczy³ wspó³pracê z Sun Microsystems, gdzie by³ odpowiedzialny za prace nad kompilatorem Javy 1.5, a w szczególnoœci wprowadzeniem parametryzowania klas (generics). Maj¹c tak du¿¹ wiedzê o pracy Javy oraz zdolnoœci w postaci pisania kompilatorów postanowi³ napisaæ swój w³asny jêzyk zawieraj¹cy na starcie funkcjonalnoœci (np. domkniêcia), na które jeszcze d³ugo przysz³oby czekaæ w Javie (styczeñ 2010 - ci¹gle czekamy na JDK7, w którym byæ mo¿e znajd¹ siê wspomniane domkniêcia). Pan Martin stwierdzi³, ¿e mo¿e powstaæ nowy jêzyk, który bêdzie siê rozwija³ znacznie szybciej ni¿ 'olbrzymia Java' (tak naprawdê prace nad Scala rozpocz¹³ oko³o 2001 roku, zaœ w 2003 wydano pierwsz¹ dystrybucjê). I tak - od wersji do wersji - Scala nabiera rozpêdu (17 tysiêcy œci¹gniêæ miesiêcznie w 2009 roku) i przekonuj¹ siê co do niej coraz wiêksze œwiatowe firmy (jak np. Twitter, Xerox, Sony, LinkedIn, Siemens, EDFT, Reaktor, Gridgain, Foursquare).
			
			<br><br>
			
			Poniewa¿ Twórca jêzyka jest œcis³ym umys³em to ca³oœæ powstaje jako matematyczne wzory definiuj¹ce wszystkie operacje i przekszta³cenia do kodu Java. Na stronach mo¿na znaleŸæ dokumenty SID (Scala Improvement Documents) gdzie s¹ one spisane.
			
			<br><br>
			
			Nazwa jêzyka wywodzi siê od skalowalnoœci, a wiêc mo¿liwoœci budowania prostego programu, który bêdzie tak samo dobrze dzia³a³ z ma³¹ iloœci¹ klientów (u¿ytkowników) jak i du¿¹. Jedyne co bêdzie wymagane z naszej strony to dostarczenie odpowiednich zasobów (jak pamiêæ, procesory/rdzenie).				
							
		</font>
				
		<br>
		
		<a name="S1Wstep.5"></a><h2>1.2.2. Informacje ogólne</h2>
		
		<font class="chapter">
		
			Scala jest jêzykiem o statycznym typowaniu, tak wiêc wszystkie problemy dotycz¹ce niezgodnoœci typów wy³apywane s¹ podczas kompilacji. Pomimo to patrz¹c w kod mo¿na siê nabraæ i powiedzieæ, i¿ jest to dynamiczny, skryptowy jêzyk. Dzieje siê tak, gdy¿ dziêki rozwiniêtemu kompilatorowi wielokrotnie mo¿emy pomijaæ definiowanie typów zmiennych lub sta³ych - kompilator zrobi to za nas. Ma to oczywiœcie swoje zalety (przejrzysty kod), jak i wady (gdy kompilator ustali bardzo dobrze typ - mo¿e to nie byæ typ, którego siê spodziewaliœmy).
			
			<br><br>
			
			Scala jest tak¿e jêzykiem obiektowo-funkcyjnym. Na obiektowoœci nie bêdziemy siê skupiaæ, gdy¿ znamy j¹ z Javy. Dziêki funkcjom/metodom jako typ (np. closures) mo¿na do metod przekazywaæ kawa³ek luŸno napisanego kodu jako argument. Mo¿na tak¿e przekazywaæ inne metody. Tracimy tutaj mo¿e trochê na czytelnoœci, jednak okazuje siê, i¿ tego kodu jest mniej - a mniej kodu to mniejsze koszty zwi¹zane z analizowaniem i utrzymaniem. Podwy¿szony poziom abstrakcji pozwala nam robiæ rzeczy, które w Javie niedostêpne bêd¹ jeszcze przez d³ugie lata.
			
			<br><br>
			
			Kompiluj¹c kod napisany w Scali produkowane s¹ w pe³ni zgodne z JVM pliki <font class="code">.class</font>, tak wiêc kompatybilnoœæ zachowana jest na poziomie byte code. Z programów pisanych w Scali bez problemu mo¿na u¿ywaæ ca³ego API i wszystkich innych kodów napisanych w Javie. Znaj¹c drobne regu³y generacji nazw klas i metod w Scali mo¿emy tak¿e u¿ywaæ jej kodów (skompilowanych kodów) z poziomu Javy.
			
			<br><br>
			
			Poniewa¿ mo¿na uznaæ, ¿e Scala jest pewnego rodzaju przed-jêzykiem (przed/ponad Jav¹) to daje nam mo¿liwoœæ kompilowania nie tylko pod Jave ale i pod inne platformy. Obecnie istnieje mo¿liwoœæ kompilowania Scali do .Net jednak jest to ci¹gle w tyle w porównaniu do platformy JVM.
						
		</font>				
				
		<br>
		
		<a name="S1Wstep.6"></a><h2>1.2.3. IDE (Integrated Development Environment)</h2>
		
		<font class="chapter">
		
			Pracê w Scali mo¿na rozpocz¹æ od œci¹gniêcia pluginu do najbardziej popularnych IDE czyli do Eclipse oraz NetBeans. Musimy jednak pamiêtaæ, i¿ Scala nie jest tak dobrze przez nie wspierana jak to znamy w przypadku Javy. Scala jest stosunkowo m³oda w odró¿nieniu od Javy, dla której zosta³y opracowane ju¿ dziesi¹tki podpowiedzi i pomocy dla tworz¹cego projekt programisty. Niektóre z nich traktujemy ju¿ jako podstawê dlatego mo¿emy siê zdziwiæ jeœli nie odnajdziemy ich dla Scali.
			
			<br><br>
			
			Koduj¹c w Scali i pracuj¹c w jej projekcie (w IDE) tworzymy pliki <font class="code">.scala</font>. Jeœli jednak zajdzie taka potrzeba to bez wiêkszych przeszkód mo¿emy stworzyæ w tym samym projekcie pliki <font class="code">.java</font> i napisaæ je w czystej Javie.
			
			<br><br>
			
			Podczas prac w IDE (ale i nie tylko) z pewnoœci¹ mo¿ecie Pañstwo napotkaæ na bardzo popularny b³¹d mówi¹cy o tym, ¿e kod nie ma metody <font class="code">main()</font> (od której program móg³by zacz¹æ siê wykonywaæ). Z pewnoœci¹ jest to bardzo dziwne kiedy w³aœnie patrzy siê na jeszcze co przed chwil¹ dzia³aj¹c¹ metodê <font class="code">main()</font> - w której w dodatku nic nie zosta³o zmienione! Otó¿ warto na wstêpie poznaæ przyczynê tego i uodporniæ siê na ca³¹, rozpoczynaj¹c¹ siê przygodê z tym jêzykiem programowania.
			<br>
			W miarê poznawania Scali zauwa¿ycie Pañstwo, jak wiele robi ona operacji na kodzie przygotowuj¹c finalny kod Javy. Jest to dobre dla nas - programistów - i¿ tak wiele rzeczy dzieje siê za nas, a my czerpiemy z tego korzyœci w postaci przyjemnego, wysokopoziomowego programowania. Jednak tak trudne przekszta³cenia odbywaj¹ce siê na kodzie w wypadku zaistnienia w nim ma³ego b³êdu mog¹ doprowadziæ do tego, ¿e kompilator nie mo¿e wygenerowaæ nawet metody <font class="code">main()</font> - i st¹d ten komunikat o b³êdzie.
					
		</font>	
				
		<br>
		
		<a name="S1Wstep.7"></a><h2>1.2.4. S³odycze (syntactic sugar)</h2>
		
		<font class="chapter">
		
			Rozpoczynaj¹c przygodê ze Scal¹ warto zapoznaæ siê z prostymi i mi³ymi ró¿nicami w porównaniu do Javy.
			
			<br><br>
			
			<b>1)</b> Otó¿ w Scali mo¿emy (ale nie musimy!) pomin¹æ :
			<br>
			- œredniki na koñcu ka¿dej linii kodu, jeœli jest ona sama w jednym wierszu (w przypadku wielu linii kodu w jednym wierszu œrednik mo¿na pomin¹æ tylko na samym koñcu)
			<br>
			- kropki pomiêdzy nazw¹ obiektu, a nazw¹ metody wykonywanej na tym obiekcie
			<br>
			- wszystkie puste nawiasy pó³okr¹g³e oznaczaj¹ce wywo³anie metody nie posiadaj¹cej argumentów
			<br>
			- nie we wszystkich przypadkach, ale mo¿na tak¿e pomin¹æ nawiasy pó³okr¹g³e kiedy wykonujemy metodê z jednym argumentem
			
			<br><br>
			
			Jak zosta³o wy¿ej napisane, te elementy mo¿na ale nie trzeba pomijaæ. Wszystko zale¿y od tego do czego jesteœmy przyzwyczajeni oraz od ogólnych ustaleñ notacji przyjêtej przez zespó³, w którym pracujemy.
			
			<br><br>
			
			Jak to wygl¹da w praktyce ?
			
			<br><br>
			
			<font class="code">Thread sleep 20*2000 // pominieta kropka oraz nawiasy ()</font>
			
			<br><br>
			
			Przyk³ad bardziej zaawansowany, dodanie <font class="code">ActionListener</font> do instancji <font class="code">JButton</font> :
			
			<br>
			
			<font class="code">
// kod Java
jButton.addActionListener(
    new ActionListener()
    {
        @Override
        public void actionPerformed( ActionEvent e )
        {
            ...
        }
    }
);
			</font>
			
			<br>
			
			Pomijamy kropki i nawiasy :
			
			<br>
			
			<font class="code">
// kod Scala
jButton addActionListener new ActionListener
{
    override def actionPerformed( e : ActionEvent )
    {
        ...
    }
}
			</font>
			
			<br>
			
			Kod wydaje siê byæ przyjemniejszy.
			
			<br><br>
			
			Mo¿emy iœæ dalej (tutaj jednak ju¿ zadzia³aj¹ ukryte konwersje - <i>implicit conversions</i>) :
			
			<br>
			
			<font class="code">
jButton addActionListener( ( e:ActionEvent ) => ... )
			</font>
			
			<br>
			
			<b>2)</b> Pracê ze Scal¹ umilaj¹ tak¿e komentarze wieloliniowe (<font class="code">/* ... */</font>), które - w odró¿nieniu od Javy - mog¹ zawieraæ w œrodku inne komentarze wieloliniowe :
			
			<br>

			<font class="code">					
/*
    komentarz zewnetrzny - linia 1

    /*
        komentarz wewnetrzny - linia 1
        komentarz wewnetrzny - linia 2
    */

    komentarz zewnetrzny - linia 2
*/
			</font>
			
			<br>
			
			Komentarze jednoliniowe s¹ realizowane tak samo jak w Javie :
			
			<br>
			
			<font class="code">
println( "hej" ) // komentarz jednoliniowy
			</font>
			
			<br><br>
			
			<b>3)</b> W jednym pliku <font class="code">.scala</font> mo¿e znajdowaæ siê wiele klas publicznych. Nie ma ¿adnego obostrzenia co do ich iloœci (jak javowy limit tylko jednej klasy publicznej per plik).
			
			<br><br>
			
			<b>4)</b> Pliki <font class="code">.scala</font> mog¹ byæ logicznie przypisane do ró¿nych paczek (<font class="code">package</font>), jednak niekoniecznie musi siê to wi¹zaæ z umiejscowieniem pliku w danym katalogu na dysku - tak jak jest to w Javie.
					
		</font>	
								
		<br>
		
		<a name="S1Wstep.8"></a><h2>1.2.5. scala.Predef</h2>
		
		<font class="chapter">
		
			Wielokrotnie podczas przegl¹dania przyk³adów u¿ytych podczas tych wyk³adów spotkamy na przyk³ad wywo³anie metody <font class="code">println()</font>. Sk¹d ona siê bierze, kto j¹ dostarcza ?
			<br>
			Otó¿ warto wiedzieæ, ¿e do ka¿dego pliku <font class="code">.scala</font> mamy automatycznie zaimportowan¹ ca³¹ zawartoœæ pliku <font class="code">scala.Predef</font> (<font class="code">import scala.Predef._</font>). W jego œrodku znajduje siê wiele pomocnych i u¿ytecznych metod, w³aœnie takich jak <font class="code">println()</font> czy <font class="code">require()</font>.
				
		</font>	
								
		<br><hr>
		
		<a name="S1Wstep.9"></a><h2>2. Importy</h2>
		
		<font class="chapter">
		
			Importowanie - wskazywanie kompilatorowi gdzie poszukiwaæ u¿ywanych klas, obiektów - zosta³o rozwiniête w porównaniu do tego co znamy z Javy.
				
		</font>	
				
		<br>
		
		<a name="S1Wstep.10"></a><h2>2.1. Importy domyœlne</h2>
	
		<font class="chapter">
		
			 Oto paczki i obiekty importowane domyœlnie do ka¿deog pliku :
			
			<br><br>
			
			- paczka <font class="code">java.lang._</font>
			<br>
			- paczka <font class="code">scala._</font>
			<br>
			- obiekt <font class="code">scala.Predef._</font> zawieraj¹cy du¿o u¿ytecznych metod 'statycznych' (w Scali nie ma kontentu statycznego, w zamian za niego wystêpuj¹ singletony zwane obiektami)
			
			<br><br>
			
			U¿yty znaczek podkreœlenia '<font class="code">_</font>' ma w Scali specjalne znaczenie i oznacza 'wszystko' albo 'dowolny', w tym przypadku oznacza oczywiœcie ca³¹ zawartoœæ danej paczki.
			
			<br><br>
			
			W paczce <font class="code">scala._</font> znajduj¹ siê podstawowe typy danych jak <font class="code">Byte</font>, <font class="code">Int</font>, <font class="code">Long</font>, ..., u¿yteczne konstrukcje jak <font class="code">Option</font>, <font class="code">Either</font> lub <font class="code">Tuple</font>. 

		</font>	
				
		<br>
		
		<a name="S1Wstep.11"></a><h2>2.2. Umiejscawianie</h2>

		<font class="chapter">
		
			 Przyjrzyjmy siê dostêpnym dla nas mo¿liwoœciom umiejscowienia.
			 
		</font>					
								
		<br>
		
		<a name="S1Wstep.12"></a><h2>2.2.1. W nag³ówku pliku</h2>
		
		<font class="chapter">
		
			Znane z Javy.
			
			<br>
			
			<font class="code">
import java.util.Vector

class VectorTest
{
    def test
    {
        val v = new Vector[ String ]
        v.add( "a1" )
        v.add( "a2" )

        println( "rozmiar vektora to " + v.size )
    }
}
		</font>

			<br>

			Zamiast u¿ytej linii <font class="code">import java.util.Vector</font> mo¿na napisaæ <font class="code">import java.util._</font> importuj¹c wszystko z package java.util .
			<br>
			Nasz¹ uwagê przykuwa oczywiœcie znaczek '<font class="code">_</font>' oznaczaj¹cy w tym przypadku 'wszystko' - czyli znan¹ z Javy '*'. Z powodu mo¿liwoœci wykorzystania znaczka gwiazdki '*' jako nazwy metody jej rolê znan¹ z Javy przejmuje podkreœlenie '<font class="code">_</font>'.

		</font>									
										
		<br>
		
		<a name="S1Wstep.13"></a><h2>2.2.2. W klasie</h2>
		
		<font class="chapter">
		
			<font class="code">
class VectorTest
{
    import java.util.Vector

    def test
    {
        val v = new Vector[ String ]
        v.add( "a1" )
        v.add( "a2" )

        println( "rozmiar vektora to " + v.size )
    }
}
			</font>	
						
			<br>
			
			Poniewa¿ Scala daje nam mo¿liwoœci umiejscawiania wielu klas publicznych w jednym, sekcja nag³ówkowa mog³aby urosn¹æ do niebotycznych rozmiarów. To z pewnoœci¹ zmniejszy³o by jej czytelnoœæ i zwiêkszy³o nasz - programistów - czas na jej przeanalizowanie.
			
			<br><br>
			
			Elastycznoœæ Scali pozwala nam na umiejscawianie importów bezpoœrednio w ciele klasy, jego zasiêg ograniczony jest do zasiêgu klasy - tak samo jak to ma miejsce w przypadku zmiennych klasowych.				
				
				
		</font>									
										
		<br>	
				
		<a name="S1Wstep.14"></a><h2>2.2.3. W metodzie</h2>
		
		<font class="chapter">
		
			<font class="code">
class VectorTest
{
    def test
    {
        import java.util.Vector

        val v = new Vector[ String ]
        v.add( "a1" )
        v.add( "a2" )

        println( "rozmiar vektora to " + v.size )
    }
}
			</font>	
						
			<br>
			
			W przypadku, jeœli chcielibyœmy u¿yæ jakiejœ klasy jednorazowo byæ mo¿e obierzemy drogê nie 'zaœmiecania' importów klasowych b¹dŸ plikowych. Import umiejscowiony w metodzie ma taki sam zasiêg jak zainicjowane w niej zmienne.
				
		</font>									
										
		<br>				
			
		<a name="S1Wstep.15"></a><h2>2.2.4. W dowolnym bloku kodu</h2>
		
		<font class="chapter">
		
			<font class="code">
def test
{
    while( true )
    {
        import java.util.Vector

        val v = new Vector[ String ]
        v.add( "a1" )
        v.add( "a2" )

        println( "rozmiar vektora to " + v.size )
    }
}
			</font>	
							
		</font>									
										
		<br>				
			
		<a name="S1Wstep.16"></a><h2>2.3. Mo¿liwoœci importu</h2>				
			
		<a name="S1Wstep.17"></a><h2>2.3.1. Import wielu klas z tego samego package</h2>				
			
		<font class="chapter">
		
			<font class="code">import top.{ A , B , C , D }</font>	
			
			<br><br>
			
			Ta konstrukcja chyba nie wymaga ani s³owa komentarza :).
							
		</font>							
			
		<a name="S1Wstep.18"></a><h2>2.3.2. Import 'statyczny'</h2>				
			
		<font class="chapter">
		
			<font class="code">import java.lang.System._</font>	
				
			<br><br>
						
			W tym przypadku zostan¹ zaimportowane wszystkie statyczne pola oraz metody obiektu <font class="code">java.lang.System</font>. W porównaniu do Java brak jest s³ówka <i>static</i> - które w Scali nie wystêpuje.
			
			<br><br>
						
			Ciekawostka : <font class="code">import java.lang.System.{ _ }</font> oznacza dok³adnie to samo co <font class="code">import java.lang.System._</font> .
						
		</font>				
			
		<br>				
			
		<a name="S1Wstep.19"></a><h2>2.3.3. Import ze zmian¹ nazwy klasy, metody, pola</h2>				
			
		<font class="chapter">
		
			<font class="code">import top2.{ A => OtherA }</font>	
				
			<br><br>	
					
			Przydatny w sytuacji kiedy do naszej przestrzeni nazewniczej mamy ju¿ obecnie sprowadzon¹ jak¹œ inna klasê A (np. <font class="code">top1.A</font>). W tym wypadku podczas u¿ywania A kompilator nie by³by do koñca pewien o które A nam chodzi - w zwi¹zku z czym zmusi³by nas do pisania pe³nych, kwalifikowanych nazw <font class="code">top1.A</font>  oraz <font class="code">top2.A</font> . To z kolei nie by³oby mi³e dla nas.
			
			<br><br>
			
			Sytuacja, w której przyda siê przemianowanie nazwy klasy :
			
			<br>
			
			<font class="code">			
import top1.A
import top2.{ A => OtherA }
			</font>
			
			<br>
			
			Podobnie mo¿emy przemianowaæ nazwê metody oraz pola :
			
			<br>
			
			<font class="code">
import java.lang.System.out.{ println => pln }
import java.lang.System.{ out => o }
			</font>
			
			<br>
			
			Przyk³ad u¿ycia :
			
			<br>
			
			<font class="code">
class ImportTest
{
    def test()
    {
        o.println( "przemianowany output" )
        pln( "przemianowana metoda println()" )
    }
}
			</font>
			
			<br>
			Importowanie ca³oœci z jednoczesn¹ zmian¹ nazwy :
			
			<br><br>
			
			<font class="code">import java.lang.System.{ out => o , _ }</font>
			
			<br><br>
			
			Widzimy tutaj zmianê <font class="code">out</font> na <font class="code">o</font> z jednoczesnym zaimportowaniem wszystkich innych pól (znak '<font class="code">_</font>').
				
		</font>				
			
		<br>				
			
		<a name="S1Wstep.20"></a><h2>2.3.4. Importowanie z wy³¹czeniem</h2>				
			
		<font class="chapter">
		
			Zaimporotwanie wszystkiego oprócz jednego pola (klasy, paczki) wygl¹da nastêpuj¹co :
			
			<br><br>
			
			<font class="code">import java.lang.System.{ out => _ , _ }</font>
			
			<br><br>
			
			(<font class="code">out</font> jest wy³¹czony z importwania).
		
		</font>	
			
		<br>				
			
		<a name="S1Wstep.21"></a><h2>2.3.5. Hierarchicznoœæ</h2>				
			
		<font class="chapter">
		
			Importowanie jest hierarchiczne, tak wiêc jeœli ju¿ mamy zaimportowane do naszej przestrzeni <font class="code">scala.actors._</font> wystarczy napisaæ <font class="code">import remote._</font> aby zaimportowaæ <font class="code">scala.actors.remote</font> :
			
			<br><br>
			
			<font class="code">
import scala.actors._

class A
{
    import remote._
}
			</font>

		</font>	
		
		<br><hr>				
			
		<a name="S1Wstep.22"></a><h2>3. Paczki</h2>				
			
		<font class="chapter">
		
				Definiowanie paczki mo¿e odbywaæ siê na drodze podobnej jak w Javie, czyli w nag³ówku pliku :

				<br>
				
				<font class="code">
package sklep.produkty

class Ksiazka
				</font>

				<br>
				
				Jeœli przyjmiemy, ¿e w powy¿szym przyk³adzie zosta³y upuszczone nawiasy klamrowe <font class="code">{}</font> to :

				<br>
				
				<font class="code">
package sklep.produkty
{
    class Ksiazka
}
				</font>

				<br>

				package pozwala nam tak¿e na :

				<br>
				
				<font class="code">
package sklep
{
    package produkty
    {
        class Ksiazka
    }
}
				</font>

				<br>

				a opuszczaj¹c nawiasy klamrowe :

				<br>

				<font class="code">
package sklep
package produkty
   
class Ksiazka
				</font>

			</font>

		</font>			
						
		<br>				
			
		<a name="S1Wstep.23"></a><h2>3.1. Paczka _root_</h2>				
			
		<font class="chapter">
		
			Przyjrzyjmy siê nastêpuj¹cemu przyk³adowi :

			<br>
			
			<font class="code">
// ---- umieszczone w Pliku1

package sklep
{
    class BazaDanych
}

// ---- umieszczone w Pliku2

package skleptesty
{
    class TestujCalosc

    package sklep
    {
        class TestujSklep
    }

    class TestujSklep
    {
        // jak tutaj odwolac sie do sklep.BazaDanych
        // kiedy powyzej mamy paczke sklep z klasa TestujSklep ???
        
        val bazaDanych = new sklep.BazaDanych // ??? !!!
    }
}
			</font>
			
			<br>

			Uwidoczniony tutaj problem polega na tym, i¿ paczka <font class="code">sklep</font> z paczki <font class="code">skleptesty</font> (Plik2) przykrywa paczke <font class="code">sklep</font> z Plik1. Dostaæ siê do niej mo¿emy poprzez odwo³anie siê do nad-paczki wszystkich paczek, a wiêc <font class="code">_root_</font> :

			<br>
			
			<font class="code">
class TestujSklep
{
    val bazaDanych = new _root_.sklep.BazaDanych
}
			</font>

			<br>
			
			U¿ywaj¹c <font class="code">_root_</font> mo¿emy wiêc ponownie, id¹c od pocz¹tku hierarchii, okreœliæ ka¿d¹ paczkê.

		</font>	
			
		<br><hr>				
			
		<a name="S1Wstep.24"></a><h2>4. Klasy</h2>				
						
		<a name="S1Wstep.25"></a><h2>4.1. Konstruktory</h2>		
			
		<a name="S1Wstep.26"></a><h2>4.1.1. Definiowanie</h2>					
		
		<font class="chapter">	
		
			<font class="code">
class Samochod( var kolor : Color , var rokProdukcji : Int )
			</font>

			<br>

			Linia kodu zaprezentowana powy¿ej przedstawia klasê <font class="code">Samochod</font> z jej konstruktorem podstawowym, do którego przekazujemy dwie zmienne: kolor oraz rok produkcji. W³aœnie tak niewiele potrzeba do zadeklarowania klasy, a zmienne przekazane przez konstruktor staj¹ siê od razu zmiennymi klasowymi.
		
			<br><br>
			
			W Scali generalnie wszystko ma modyfikator dostêpu publicznego, tak wiêc chc¹c ukryæ pola przed œwiatem zewnêtrznym, musimy dodaæ <font class="code">private</font> lub <font class="code">protected</font> :
			
			<br>
			
			<font class="code">
class Samochod( private var kolor : Color , protected var rokProdukcji : Int )
			</font>	
			
			<br>
			
			(Przekazane przez nas zmienne mo¿emy zamieniæ na sta³e zamieniaj¹c s³ówko kluczowe <font class="code">var</font> na <font class="code">val</font>.)
			
			<br><br>
			
			Jak stworzyæ instancjê klasy <font class="code">Samochod</font> ?
			
			<br>
			
			<font class="code">
val samochod = new Samochod( Color.RED , 1999 )
			</font>
			
			<br>
			
			Istnieje tak¿e mo¿liwoœæ dodawania modyfikatorów dostêpu do konstruktora podstawowego :
			
			<br>
			
			<font class="code">
class Samochod private ( var kolor : Color , var rokProdukcji : Int )
			</font>
			
			<br>
			
			Jak zosta³o wspomniane powy¿ej argumenty przekazane do konstruktora podstawowego staj¹ siê od razu polami klasowymi. Wynika to z pewnej obserwacji ¿ycia codziennego programisty, gdzie w wiêkszoœci przypadków definiowanie nowej klasy wygl¹da dosyæ boleœnie :
			
			<br>
			
			<font class="code">
// kod Java
class Samochod
{
    private Color kolor;
    private Int rokProdukcji;

    public Samochod( Color kolor , Int rokProdukcji )
    {
        this.kolor = kolor;
        this.rokProdukcji = rokProdukcji;
    }
}
			</font>
			
			<br>
			
			Warto zauwa¿yæ jak wiele linii kodu mo¿emy pomin¹æ w Scali oraz jak du¿o bardziej przejrzysty staje siê kod.
			
			<br><br>
			
			Wa¿n¹ zmian¹ w tej sytuacji (argumenty konstruktora staj¹ siê polami klasowymi) jest przeniesienie obci¹¿enia gdzie zostaj¹ przygotowane i stworzone argumenty dla klasy.
			
			<br>
			
			W Javowym modelu do konstruktora mo¿na by³o przekazaæ dowolnie wszystko, najró¿niejsze pó³fabrykaty i inne dane niedocelowe. To zadaniem konstruktora by³o je przetworzyæ i przygotowaæ, a nastêpnie zapamiêtaæ na zmiennych klasowych. To wymusza umieszczenie czasem ca³kiem pokaŸnej logiki w ciele konstruktora.
			
			<br>
			
			W Scali widzimy odejœcie od tego na rzecz przetworzenia danych wczeœniej, a wywo³anie samego konstruktora argumentami docelowymi.

		</font>	
			
		<br>
		
		<a name="S1Wstep.27"></a><h2>4.1.2. Cia³o konstruktora</h2>					
		
		<font class="chapter">

			Skoro wiemy ju¿ prawie wszytko o definiowaniu konstruktora to przyjrzyjmy siê gdzie umieœciæ jego cia³o.

			<br>
			
			<font class="code">
class Samochod( var kolor : Color , var rokProdukcji : Int )
{
    if( rokProdukcji < 1980 )
    	throw new IllegalArgumentException( "rok produkcji nie moze byc mniejszy niz 1980" )
}
			</font>

			<br>
			
			Ewentualnie mo¿emy pos³u¿yæ siê ogólnie dostêpn¹ metod¹ <font class="code">require()</font> :

			<br>
			
			<font class="code">
class Samochod( var kolor : Color , var rokProdukcji : Int )
{
    require( rokProdukcji > 1980 )

    // lub
    // require( rokProdukcji > 1980 , "rok produkcji nie moze byc mniejszy niz 1980" )
}
			</font>

			<br>
						
			Ka¿dy kod wstawiony 'luŸno' w cia³o klasy zostanie zebrany i potraktowany jako konstruktor podstawowy.

		</font>	
			
		<br>
		
		<a name="S1Wstep.28"></a><h2>4.1.3. Przeci¹¿anie konstruktora podstawowego</h2>					
		
		<font class="chapter">
		
			W Scali zosta³o przyjête pojêcie konstruktora podstawowego oraz konstruktorów go przeci¹¿aj¹cych.

			<br><br>
			
			Podobnie jak w metodach, jest tylko jedno miejsce za pomoc¹, którego mo¿emy wejœæ do metody, tak samo jest tylko jedno miejsce, które umo¿liwia stworzenie instancji klasy za pomoc¹ operatora <font class="code">new</font>. Konstruktory przeci¹¿aj¹ce podstawowy musz¹ w swoim ciele wywo³aæ go lub inny konstruktor przeci¹¿ony.

			<br>
			
			<font class="code">
class Osoba( imie : String , wiek : Int , czyMaRodzenstwo : Boolean )
{
    def this( imie : String , wiek : Int ) = this( imie , wiek , false )
}
			</font>
			
			<br>
			
			Wynika to z dobrej praktyki, ale tak¿e i poczynionych obserwacji typowych zachowañ programistów.
			
			<br>
			
			Kiedy pierwszy programista tworzy klasê ogarnia myœlami wszystko co siê w niej dzieje. Dba i dok³adnie inicjuje wszystkie pola klasowe w konstruktorze. Kiedy nastêpnie klasa ta trafi do drugiego programisty, którego zadaniem bêdzie lekkie jej rozwiniecie, doda on kilka nowych konstruktorów. Jeœli ka¿dy konstruktor jest równowa¿ny sobie to ka¿dy mo¿e prowadziæ do stworzenia instancji klasy. Jednak dodane na prêdko kolejne konstruktory wcale nie musz¹ ju¿ byæ tak dok³adne, mog¹ pomijaæ inicjacje pewnych zmiennych. Doprowadza to w ³atwy sposób do powstawania pó³-zainicjowanych, b³êdnych instancji.

			<br><br>
			
			Powy¿ej zosta³ poruszony temat prywatnego konstruktora podstawowego. Jak zatem pozwoliæ œwiatu zewnêtrznemu na stworzenie instancji klasy ? Otó¿ trzeba dodaæ koniecznie dodatkowy konstruktor :

			<br>
			
			<font class="code">
class Samochod private ( var kolor : Color , var rokProdukcji : Int )
{
    def this( kolor : Color , rokProdukcji : String ) =
    {
    	this( kolor , Integer.parseInt( rokProdukcji ) )
    }
}
			</font>

			<br>
			
			(Uwaga : znak równoœci w powy¿szym przyk³adzie ma znaczenie !)

		</font>
			
		<br>
		
		<a name="S1Wstep.29"></a><h2>4.1.4. Wywo³anie konstruktora superklasy</h2>					
		
		<font class="chapter">	
		
 			W przypadku tak odmiennej sk³adni z konstruktorami warto zobaczyæ jak wywo³aæ konstruktor klasy, z której dziedziczymy.
			
			<br><br>
			
			Zdefiniujmy klasê <font class="code">Zwierze</font> :

			<br>
			
			<font class="code">
class Zwierze( nazwa: String , wiek : Int )
			</font>
			
			<br>
			
			Dla klasy <font class="code">Pies</font> dziedzicz¹cej ze <font class="code">Zwierze</font> wywo³anie superkonstruktora odbywa siê w tej samej, jednej linii kodu :

			<br>
			
			<font class="code">
class Pies( nazwa : String , wiek : Int , dlugoscOgona : Int ) extends Zwierze( nazwa , wiek )
			</font>
					
		</font>		
			
		<br>
		
		<a name="S1Wstep.30"></a><h2>4.2. Umiejscawianie</h2>					
		
		<font class="chapter">	
		
 			W przeciwieñstwie do Javy, w Scali w jednym pliku mo¿emy mieæ dowoln¹ iloœæ klas publicznych.
			
		</font>					
			
		<br><hr>
		
		<a name="S1Wstep.31"></a><h2>5. Obiekty</h2>					
		
		<font class="chapter">	
		
		Czyli inaczej singletony.
		
		<br><br>
		
		Zobaczmy jak w Javie wygl¹da zadeklarowanie singletonu :
		
		<br>
		
		<font class="code">
// kod Java
class DatabaseManager
{
    private static DatabaseManager me;

    private DatabaseManager() {}

    public static final synchronized getInstance()
    {
        if( me == null ) me = new DatabaseManager();
        return me;
    }

    public void polacz() { ... }
}
		</font>
		
		<br>
		
		Zobaczmy jak ten sam kod wygl¹da w Scali :
		
		<br>
		
		<font class="code">
object DatabaseManager
{
    def polacz { ... }
}
		</font>
		
		<br>
		
		Kluczow¹ rolê odgrywa tutaj s³ówko object w miejsce spodziewanego <font class="code">class</font>. Dziêki niemu nie musimy tworzyæ prywatnego konstruktora oraz metody fabrycznej.
		
		<br><br>
		
		Instancja takiej klasy powstanie automatycznie przy pierwszej próbie jej u¿ycia:
		
		<br><br>
		
		<font class="code">DatabaseManager.polacz</font>
		
		<br><br>
		
		Singletony w Scali nie mog¹ posiadaæ konstruktora.

		</font>				
			
		<br>
		
		<a name="S1Wstep.32"></a><h2>5.1. Statyczne klasy, metody, pola</h2>					
		
		<font class="chapter">	
		
			W Scali wyeliminowane zosta³o s³ówko <i>static</i>, tak wiêc nie ma, znanych nam z Javy, statycznych klas, metod oraz pól.
			
			<br><br>
			
			W zamian za to to czemu w Javie dodawaliœmy s³ówko static umieszczamy w obiektach (w signletonach).
			
			<br><br>
			
			Tak wiêc :
			
			<br>
			
			<font class="code">
object Zwierze
{
    val MAX_AGE : Int = 100

    def getWiek( wiekWStringu : String ) : Int = Integer.parseInt( wiekWStringu )
}
			</font>	
			
			<br>
			
			Powoduje to 'wysprz¹tanie' wszelakiego kodu i kontekstu statycznego, dzisiaj umieszczanego pomiêdzy kodem niestatycznym, do specjalnie wydzielonego miejsca.
			
			<br><br>
			
			Zaprezentowany powy¿ej obiekt <font class="code">Zwierze</font>	mo¿e mieæ tak¿e klasê o takiej samej nazwie :
			
			<br>
			
			<font class="code">
object Zwierze
{
    val MAX_AGE : Int = 100

    def getWiek( wiekWStringu : String ) : Int = Integer.parseInt( wiekWStringu )
}

class Zwierze( age : Int )
{
    requre( age <= Zwierze.MAX_AGE , "wiek nie moze byc wiekszy niz " + Zwierze.MAX_AGE )
}
			</font>	
			
			<br>
			
			W tym wypadku mówimy o <font class="code">class Zwierze</font> i <font class="code">object Zwierze</font>, ¿e s¹ <i>companion objects</i>.
			
			<br><br>
			
			Jak widaæ z poziomu klasy <font class="code">Zwierze</font>	 dostajemy siê do pól obiektu <font class="code">Zwierze</font> tak samo jak w Javie do pól statycznych - a wiêc podaj¹c nazwê klasy oraz kropkê <font class="code">Zwierze.</font> .		
		
		</font>			
		
		<br><hr>
		
		<a name="S1Wstep.33"></a><h2>6. Pola</h2>					
		
		<font class="chapter">	
		
		W tym rozdziale przyjrzymy siê jak definiowaæ zmienne oraz sta³e.
			
		</font>
			
		<br>
		
		<a name="S1Wstep.34"></a><h2>6.1. Zmienne</h2>					
		
		<font class="chapter">	
		
			Ka¿da nowa zmienna jest poprzedzana s³ówkiem kluczowym <font class="code">var</font> (variable) :
			
			<br>
			
			<font class="code">
var i : Int = 0
var i = 0
var ht : Hashmap[ String , Int ] = new Hashmap[ String , Int ]()
var ht = new Hashmap[ String , Int ]
			</font>
			
			<br>
			
			To co od razu mo¿emy zauwa¿yæ to odwrócona notacja w porównaniu do Javy. Po s³ówku kluczowym <font class="code">var</font> nastêpuje nazwa zmiennej. Nastêpnie mo¿e (ale nie musi) nast¹piæ jej typ. Potem znak równoœci i wartoœæ zmiennej.
			
			<br><br>
			
			Jak widaæ Scala pozwala nam na pomijanie deklaracji typu w miejscach gdzie jest on mo¿liwy do wywnioskowania przez kompilator. Pierwsze dwie linie przyk³adu powy¿ej oraz dwie nastêpne s¹ równoznaczne.
				
		</font>
			
		<br>
		
		<a name="S1Wstep.35"></a><h2>6.2. Sta³e</h2>					
		
		<font class="chapter">	
		
			Ka¿da sta³a powinna byæ poprzedzona s³ówkiem kluczowym <font class="code">val</font> (jak value) :

			<br>
			
			<font class="code">
val i : Int = 0
val i = 0
			</font>
			
			<br>
			
			W odró¿nieniu od Javy nie jesteœmy zmuszeni aby pisaæ d³ugie, dodatkowe s³ówko <i>final</i>. Jak wiadomo programiœci nale¿¹ do osób leniwych - st¹d nie nale¿y wymagaæ, ¿e za ka¿dym razem kiedy bêdzie to konieczne bêd¹ pisali jakieœ dodatkowe s³ówko 'skoro bez niego i tak wszystko dzia³a'. Otó¿ tutaj znajduje siê ukryty problem. Czasem to co powinno byæ sta³¹ bêdzie sta³¹, a czasem - poprzez pominiêcie dodatkowego s³ówka - bêdzie zmienn¹. Wbrew pozorom to jest diametralna ró¿nica wp³ywaj¹ca na jakoœæ i niezawodnoœæ kodu.
			
			<br><br>
			
			Na szczêœcie twórcy Scali wiedzieli o tym bardzo dobrze i jedyny wybór przed którym stoj¹ programiœci Scala to <font class="code">-r</font> czy <font class="code">-l</font> na koñcu krótkiego, 3 literowego , obowi¹zkowego wyrazu.
			
			<br><br>
			
			Dobr¹ praktyk¹ przekazywan¹ przez autorów Scali w wielu publikacjach jest zawsze stawianie s³ówka <font class="code">val</font> w momencie jeœli chcemy stworzyæ now¹ zmienn¹ b¹dŸ sta³¹. Twórcy pragn¹ doprowadziæ, aby powsta³ w programistach taki w³aœnie nawyk: nie wiesz co napisaæ, napisz <font class="code">val</font>, jedynie potem, kiedy kompilator ciê upomni, zmieñ niektóre <font class="code">val</font> na <font class="code">var</font>. W ten sposób powstaje du¿o bezpieczniejszy kod, zw³aszcza w czasach procesorów wielordzeniowych i wielow¹tkowoœci w tworzonych programach.

		</font>
			
		<br>
		
		<a name="S1Wstep.36"></a><h2>6.2.1. Sta³e leniwe</h2>					
		
		<font class="chapter">	
		
			W przypadku sta³ych mo¿emy dodaæ s³ówko kluczowe <font class="code">lazy</font> w celu opóŸnienia czasu ich inicjacji.

			<br>

			<font class="code">
object Storage
{
    val MAX_SIZE = 100
    lazy val ht = new Hashmap[ String , Int ]
}
			</font>

			<br>
			
			Tak zdefiniowana sta³a nie zostanie zainicjowana, a¿ do pierwszego odwo³ania siê do niej :

			<br>
			
			<font class="code">
val i = Storage.MAX_SIZE
	// <- w tym momencie zosta³ zainicjowany singleton 'Storage'
	// (jesli wczesniej nie bylo do niego zadnego odwolania)

val ht = Storage.ht
	// <- dopiero w tym momencie zostala zainicjowana stala 'ht',
	// przez to ze jest lazy nie jest inicjowana w momencie inicjacji singletonu
			</font>

		</font>
			
		<br>
		
		<a name="S1Wstep.37"></a><h2>6.3. Zasiêg zmiennych i sta³ych (scope)</h2>					
		
		<font class="chapter">
				
			Jest nieomal identyczny jak w Javie z t¹ drobn¹ ró¿nic¹, i¿ w Scali w bloku zagnie¿d¿onym mo¿emy zdefiniowaæ zmienn¹/sta³¹ o tej samej nazwie jak zmienna/sta³a, która ju¿ istnieje.

			<br>

			<font class="code">
val i = 0

{
    var i = 7
    
    println( i ) // 7
    
    i = 6 // wszystko dziala, w koncu i to zmienna
    
    println( i ) // 6
    
}

println( i ) // 0

i = 1 // blad kompilacji, proba zmiany stalej
				
			</font>
				
		</font>	
			
		<br><hr>
		
		<a name="S1Wstep.38"></a><h2>7. Metody</h2>					
		
		<a name="S1Wstep.39"></a><h2>7.1. Definiowanie</h2>					
		
		<font class="chapter">
			
			Metody tworzymy za pomoc¹ s³ówka kluczowego def :

			<br>

			<font class="code">
def drukujRaport() { System.out.println( "raport" ) }
def drukujRaport { System.out.println( "raport" ) } // <- pomiete puste nawiasy argumentow
			</font>		
			
		</font>			
			
		<br>
		
		<a name="S1Wstep.40"></a><h2>7.2. Nazewnictwo</h2>	
			
		<font class="chapter">	
			
			Kolejn¹ ciekaw¹ rzecz na temat Scali odkryjemy poznaj¹c jakie mog¹ byæ nazwy metod.
			
			<br><br>
			
			Otó¿ nazwy metod mog¹ byæ ... dowolne*, a skoro tak jest to znaczy, ¿e ... w Scali nie ma operatorów ! Ka¿de wywo³anie *, +, -, += itp. jest wywo³aniem metody :).
			
			<br>
			
			Mo¿na definiowaæ metody wygl¹daj¹ce jak operatory z Javy, ale ci¹gle bêd¹ to metody. Skoro s¹ to metody, to mo¿na je przeci¹¿aæ oraz przes³aniaæ.
			
			<br><br>
			
			*- poza zastrze¿onym znakiem '<font class="code">_</font>' oznaczaj¹cym 'wszystko' lub 'dowolny'.
			
			<br><br>
			
			Po³¹czmy t¹ wiedzê z informacj¹, i¿ wszystko w Scali jest obiektem i zobaczmy przyk³ad:

			<br>
			
			<font class="code">
1 + 2 // <- ale 1 jest przeciez obiektem
(1) + 2 // <- chyba brak tutaj kropki
(1).+ 2 // <- tutaj brak nawiasow z argumentami metody '+'
(1).+(2) // <- teraz wyglada to jak wywolane metody znane nam z Javy
			</font>	
			
			<br>
			
			Teraz jasno widaæ jak na obiekcie <font class="code">Int(1)</font> wywo³ujemy metodê <font class="code">.+()</font> z argumentem '<font class="code">2</font>'.
			
		</font>			
			
		<br>
		
		<a name="S1Wstep.41"></a><h2>7.3. Zwracanie wartoœci</h2>	
			
		<font class="chapter">	
			
			Jeœli chcemy, aby metoda coœ zwraca³a, musimy dodaæ znak równoœci oraz mo¿emy (ale nie musimy) okreœliæ typ zwracanych danych :

			<br>
			
			<font class="code">
def getAge() : Int = { age }
def getAge = { age } // <- pomijamy typ zwracanych danych, pominiete puste nawiasy
def getAge = age // <- skoro to jest tylko jedna instrukcja to pomijamy nawiasy klamrowe
			</font>
			
			<br>
			
			Wystêpuje brak s³ówka <i>return</i>. Zasada jest bardzo prosta - ka¿de ostatnie wyra¿enie w metodzie jest traktowane zwracane jako wartoœæ tej¿e metody. Warunkiem wymaganym jest postawienie znaku równoœci przed blokiem kodu.
			
			<br><br>
			
			(Jeœli by nie by³o znaku <font class="code">=</font> to metoda ta by nic nie zwraca³a - tak naprawdê bêdzie zwracaæ <font class="code">Unit</font>.)
			
		</font>	
			
		<br>
		
		<a name="S1Wstep.42"></a><h2>7.4. Przekazywanie argumentów</h2>	
			
		<font class="chapter">	
			
			Definiowanie :

			<br><br>
			
			<font class="code">def polacz( ip : String , port : Int ) { ... }</font>

			<br><br>
			
			i przekazywanie argumentów do metody (wywo³anie metody) :

			<br><br>
			
			<font class="code">polacz( "127.0.0.1" , 80 )</font>
			
		</font>		
				
		<br>
		
		<a name="S1Wstep.43"></a><h2>7.4.1. Zmienna iloœæ argumentów (varargs)</h2>	
			
		<font class="chapter">	
			
			Definicjê :

			<br><br>

			<font class="code">def sumuj( i1 : Int , i2 : Int , i3 : Int , i4 : Int ) = { ... }</font>

			<br><br>

			mo¿na zamieniæ na :

			<br><br>

			<font class="code">def sumuj( i : Int* ) = { ... }</font>

			<br><br>

			W tym wypadku mechanizm jest podobny jak w Javie, a wiêc do metody zostanie przekazana tablica Int'ów (<font class="code">scala.Array[ Int ]</font>). Jeœli nic nie zostanie przekazane to taka tablica bêdzie zainicjowana, a jej rozmiar równy bêdzie 0.

			<br><br>

			Dla metody :

			<br>

			<font class="code">
def sumuj( i : Int* ) =
{
	println( "ilosc przekazanych argumentow " + i.length )
	var wynik = 0
	i.foreach( i => { println( "dosumowuje " + i ); wynik += i } )
	println( "zwracam wynik " + wynik )
	wynik
}
			</font>
			
			<br>
			
			Wywo³ania :

			<br>

			<font class="code">
val result = sumuj( 1 , 2 , 3 )
val result = sumuj( 1 )
val result = sumuj()
			</font>
			
			<br>
			
			dadz¹ :
			
			<br>
			
			<font class="code">
ilosc przekazanych argumentow 3
dosumowuje 1
dosumowuje 2
dosumowuje 3
zwracam wynik 6

ilosc przekazanych argumentow 1
dosumowuje 1
zwracam wynik 1

ilosc przekazanych argumentow 0
zwracam wynik 0
			</font>
			
		</font>
		
		<br>
		
		<a name="S1Wstep.44"></a><h2>7.5. Umiejscawianie</h2>	
			
		<font class="chapter">
		
			Najbardziej naturalnym miejscem dla metod jest klasa (ewentualnie obiekt) ... ale okazuje siê, ¿e mog¹ one wystêpowaæ jeszcze w jednym miejscu.
			
			<br><br>
			
			Rozwa¿my nastêpuj¹cy przyk³ad z Javy.
			
			<br><br>
			
			Jest sobie klasa <font class="code">C</font>, która posiada metody <font class="code">m1()</font>, <font class="code">m2()</font> oraz <font class="code">m3()</font> :
			
			<br>
			
			<font class="code">
// uwaga, przyklad 'z Javy' - czyli tak jak to by bylo w Javie
// ale zapisany w Scali

class C
{
    def m1() = { ... }
    def m2() = { ... }
    def m3() = { ... }
}
			</font>
			
			<br>
			
			Metoda <font class="code">m2()</font> jest zdefiniowana nastêpuj¹co :
			
			<br>
			
			<font class="code">
def m2 =
{
    val kolejka = new scala.collection.mutable.Queue[ Int ]()
    var i = 0

    println( ”Podaj dane...” )
    while( i >=0 )
    {
        i = new java.util.Scanner( System.in ).nextInt()
        if( i >=0 ) kolejka += i
    }

    var wynik = 0
    kolejka.foreach( ii => wynik += ii )
    println( ”Suma liczb to : ” + wynik )
    wynik
}
			</font>
			
			<br>
			
			Po pewnym czasie siê ona rozrasta. W wyniku nowych wymagañ przyda³oby siê, aby w swoim ciele dwukrotnie wczytywa³a dane od u¿ytkownika :
			
			<br>
			
			<font class="code">
def m2 =
{
    val kolejka = new scala.collection.mutable.Queue[ Int ]()

    var i = 0
    println( ”Podaj dane...” )
    <font color="blue">
    while( i >=0 )
    {
        i = new java.util.Scanner( System.in ).nextInt()
        if( i >=0 ) kolejka += i
    }
    </font>
    var wynik1 = 0
    kolejka.foreach( ii => wynik1 += ii )
    println( ”Suma liczb to : ” + wynik1 + ”, podaj kolejne dane...” )
	<font color="blue">
    while( i >=0 )
    {
        i = new java.util.Scanner( System.in ).nextInt()
        if( i >=0 ) kolejka += i
    }
    </font>
    var wynik2 = 1
    kolejka.foreach( ii => wynik2 *= ii )
    println( ”Iloczyn to : ” + wynik2 )

    ( wynik1 , wynik2 )
}
			</font>
			
			<br>
			
			Podczas procesu rozwojowego powsta³o nam powtórzenie kodu (i to nie jedno), które powinno zostaæ wy³¹czone przed nawias :
			
			<br>
			
			<font class="code">
class C
{
    def m1 = { … }
    private def wczytajKolejkeIntowOdUzytkownika = { … }
    def m2 = { … }
    def m3 = { … }
}
			</font>
			
			<br>
			
			Okazuje siê, ¿e nie ma nic za darmo. W wyniku 'oczyszczenia' kodu powstaje ... zanieczyszczenie klasy.
			
			<br><br>
			
			Od tej pory metoda <font class="code">wczytajKolejkeIntowOdUzytkownika()</font>, nawet jeœli z modyfikatorem dostêpu <font class="code">private</font>, przewija siê nam przed oczami. Musimy j¹ analizowaæ, przegl¹daæ, a czasem nawet zastanawiaæ siê, przez które z metod (<font class="code">m1</font>, <font class="code">m2</font>, <font class="code">m3</font>) jest ona wywo³ywana. To marnuje nasz czas i nasz¹ energiê.
			
			<br><br>
			
			Sytuacja ³atwo mo¿e ulec pogorszeniu :
			
			<br>
			
			<font class="code">
class C
{
    def pomocniczaMetoda1dlaM1 = {}
    def pomocniczaMetoda2dlaM1 = {}
    def m1 = { … }

    private def wczytajKolejkeIntowOdUzytkownika = { … }
    def pomocniczaMetoda1dlaM2 = {}
    def pomocniczaMetoda2dlaM2 = {}
    def m2 = { … }

    def pomocniczaMetoda1dlaM3 = {}
    def pomocniczaMetoda2dlaM3 = {}
    def m3 = { … }
}
			</font>
			
			<br>
			
			Nasza klasa wygl¹da fatalnie, a wszystko przez to, ¿e - rozumuj¹c tokiem Javowym - musieliœmy do jej przestrzeni w³o¿yæ 'prywatne metody pomocnicze' kilku g³ównych metod publicznych.
			
			<br><br>
			
			Na szczêœcie w Scali mo¿emy dowolnie umieszczaæ metody w jeszcze jednym miejscu, a mianowicie w metodach :
			
			<br>
			
			<font class="code">
def m2 =
{
    val kolejka = new scala.collection.mutable.Queue[ Int ]()

	<font color="blue"><b>
    def wczytaJKolejkeIntowOdUzytkownika()
    {
        var i = 0
        println( ”Podaj dane...” )
        while( i >=0 )
        {
            i = new java.util.Scanner( System.in ).nextInt()
            if( i >=0 ) kolejka += i
        }
    }</b></font>

	<br>
    <font color="blue">wczytaJKolejkeIntowOdUzytkownika()</font>

    var wynik1 = 0
    kolejka.foreach( ii => wynik1 += ii )
    println( ”Suma liczb to : ” + wynik1 )
    
    <font color="blue">wczytaJKolejkeIntowOdUzytkownika()</font>

    var wynik2 = 1
    kolejka.foreach( ii => wynik2 *= ii )
    println( ”Iloczyn to : ” + wynik2 )

    ( wynik1 , wynik2 )
}
			</font>
			
			<br>
			
			Skoro metoda <font class="code">wczytajKolejkeIntowOdUzytkownika()</font> jest tylko na u¿ytek metody <font class="code">m2()</font> to nie potrzeby, aby wysz³a ona poza ni¹.
			
			<br><br>
			
			Nie ma ¿adnych ograniczeñ, aby umieszczaæ metody w metodach w metodach... - jednak zbyt g³êboka hierarchia prawdopodobnie bêdzie wynikiem z³ego zaprojektowania i rozwi¹zywania danego problemu.
		
		</font>		
		
		<br><hr>
		
		<a name="S1Wstep.45"></a><h2>8. Typy danych</h2>	
			
		<font class="chapter">	
			
			Podstawowe typy danych znajdziemy w paczce <font class="code">scala._</font> i s¹ to : <font class="code">Byte</font>, <font class="code">Short</font>, <font class="code">Int</font>, <font class="code">Long</font>, <font class="code">Char</font>, <font class="code">Float</font>, <font class="code">Double</font>, <font class="code">Boolean</font>. Typy te w niczym nie odbiegaj¹ zakresami od typów przyjêtych w Javie co pozwala kompilatorowi na t³umaczenie ich w stosunku 1:1. Dla ³añcuchów tekstowych u¿ywana jest klasa <font class="code">String</font> z dobrze nam znanej paczki <font class="code">java.lang</font>.

			<br><br>
			
			Warto zauwa¿yæ i¿ s¹ pisane z du¿ej litery. Wynika to z ogólnie przyjetej notacji w Scali, aby nazwy klasy i obiektów pisaæ z du¿ej litery - bez tworzenia pewnych wyj¹tków jakimi w œwiecie Javy s¹ prymitywy. To na co jest to t³umaczone po skompilowaniu nie powinno nas interesowaæ. Wiadomo natomiast, ¿e kompilator dok³ada wszelkich starañ aby by³o to rozwi¹zanie najwydajniejsze i nie jest wykluczone, ¿e wielokrotnie bêd¹ to javowe prymitywy.

			<br><br>
			
			Klasy z paczki <font class="code">scala._</font> wzbogacone s¹ o wiele u¿ytecznych metod, a tak¿e w pakiet standartowych metod jak <font class="code">+</font>, <font class="code">-</font> czy <font class="code">*</font> (wato pamiêtaæ, ¿e w Scali nie ma operatorów, w zamian za to wszystko s¹ to metody).
			
		</font>	
					
		<br>
		
		<a name="S1Wstep.46"></a><h2>8.1. Ogólna hierarchia typów</h2>	
					
		<font class="chapter">	
			
			Informacje o ca³ej zaawansowanej hierarchi typów w Scali pominiemy w treœci tego wyk³adu przedstawiaj¹c tylko kilka najwa¿niejszych informacji w skrócie.

			<br><br>
			
			Wszystkie klasy w Scali dziedzicz¹ z <font class="code">Any</font>. Ma ona tylko dwie klasy pochodne : <font class="code">AnyVal</font> oraz <font class="code">AnyRef</font>.
			
			<br><br>
			
			<font class="code">AnyVal</font> przedstawiaj¹ wszystkie typy wbudowane w Scale przetrzymuj¹ce wartoœæ : <font class="code">Byte</font>, <font class="code">Short</font>, <font class="code">Int</font>, <font class="code">Long</font>, <font class="code">Char</font>, <font class="code">Float</font>, <font class="code">Double</font>, <font class="code">Boolean</font>.
			
			<br><br>
			
			<font class="code">AnyRef</font> przedstawiaj¹ wszystkie typy referencyjne (a wiêc wszystkie normalne klasy jak <font class="code">java.lang.String</font>, <font class="code">scala.Iterable</font>, ...) i w rzeczywistoœci jest to tylko alias na <font class="code">java.lang.Object</font>. Takie podejœcie pozostawia jednak furtkê na rozszerzenie funkcjonalnoœci w przysz³oœci.
			
		</font>	
		
		<br>
		
		<a name="S1Wstep.47"></a><h2>8.2. Tablice</h2>	
					
		<font class="chapter">	
			
			Do obs³ugi tablic zosta³a wprowadzona klasa parametryzowalna <font class="code">scala.Array[ T ]</font>  (uwaga : nawiasy [] nie s¹ nawiasami znanymi z Javy, gdzie oznaczaj¹ tworzenie nomen omen tablicy, tutaj oznaczaj¹ one parametryzacje klasy).
			
			<br><br>
			
			Tak wiêc nie jest to jak w Javie, gdzie ka¿dy typ mo¿e byæ tablic¹* sam przez siê. Zosta³a stworzona dedykowana klasa do tego celu. Dostarcza ona wiele przydatnych metod m.in. konwersji do kolekcji <font class="code">toList()</font>.
			
			<br><br>
			
			Zdefiniujmy tablicê :
			
			<br><br>
			
			<font class="code">val tablica = new Array( 1 , 2 , 3 )</font>
			
			<br><br>
			
			lub
			
			<br><br>
			
			<font class="code">val tablica : = new Array[ Int ]( 3 )</font>
			
			<br><br>
			
			Pobranie elementu z tablicy :
			
			<br><br>
			
			<font class="code">val pierwszyElement = tablica( 0 )</font>
			
			<br><br>
			
			Ustawienie (drugiego) elementu tablicy :
			
			<br><br>
			
			<font class="code">tablica( 1 ) = 10</font>
			
			<br><br>
			
			(W innych rozdzia³ach tego wyk³adu opisane zosta³y metody <font class="code">apply()</font> oraz <font class="code">update()</font> które odgrywaj¹ tutaj wa¿n¹ rolê.).
			
			<br><br>
			
			* - pierwsze wersje Javy (do wersji 1.5) nie posiada³y mo¿liwoœci parametryzowania klas, ale od samego pocz¹tku posiada³y tablice, st¹d rozwi¹zanie, aby definiowaæ tablicê dodaj¹c do typu nawiasy kwadratowe '<font class="code">[]</font>'

		</font>	
		
		<br>
		
		<a name="S1Wstep.48"></a><h2>8.3. Niezmienne (immutable)</h2>	
					
		<font class="chapter">	
					
			Scala jako nowoczesny jêzyk nastawiony na skalowalnoœæ oraz pracê w nowo rozpoczynaj¹cej siê erze komputerów wielo-procesorowo-wielo-rdzeniowych (ró¿ne typy procesorów, ka¿dy z nich posiada wiele rdzeni) promuje dwie techniki pozwalaj¹ce odnaleŸæ siê w tym œwiecie pisz¹c poprawnie dzia³aj¹ce programy.
			
			<br><br>
			
			Pierwsza z nich to (wspomniane wczeœniej) odruchowe pisanie <font class="code">val</font> w momencie, jeœli chcemy stworzyæ jakaœ now¹ sta³¹ (b¹dŸ zmienn¹ !). Jeœli mia³a byæ to rzeczywiœcie zmienna to kompilator na pewno nam o tym przypomni, wtedy odnajdziemy <font class="code">val</font> i zamienimy je na <font class="code">var</font>.
			
			<br><br>
			
			Drug¹ technik¹ jest u¿ywanie niezmiennych struktur danych. Niezmiennych, czyli nieposiadaj¹cych efektów ubocznych (side effect) podczas wywo³ywania metod.
			
			<br><br>
			
			Jak rozpoznaæ, ¿e obiekt mo¿e mieæ efekt uboczny? Otó¿ jeœli wywo³ujemy jego metodê dwa raz z tymi samymi argumentami, a ona zwóci nam dwa ró¿ne wyniki to istnieje du¿e prawdopodobieñstwo, i¿ obiekt przechowuje wewn¹trz jakiœ stan, który zosta³ zmodyfikowany podczas pierwszego wywo³ania metody. To spowodowa³o zmianê w zwróconych wynikach podczas drugiego wywo³ania metody.
			
			<br><br>
			
			W zamian za brak stanu, ka¿de wywo³anie metody powoduje stworzenie nowego obiektu i zwórcenie go. Naj³atwiej zobrazowaæ to na klasie <font class="code">java.lang.String</font>, która jest immutable. Wywo³anie metody <font class="code">replace( "a" , "b" )</font> nie powoduje zmodyfikowania obecnego ³ancucha z zamienionymi wszystkimi 'a' na 'b'. W zamian za to jest zwracana nowa instancja, która posiada odpowiedni¹ zamianê. W tym momencie istniej¹ dwa obiekty, poprzedni (Ÿród³owy ³añcuch dla zmian) oraz nowy (z dokonanymi zmianami).
			
			<br><br>
			
			Scala posiada bardzo dobrze rozbudowan¹ bibliotekê kolekcji. W paczce <font class="code">scala.collection.immutable._</font> znajdziemy tylko i wy³¹cznie struktury niemodyfikowalne.
					
		</font>		
		
		<br>
		
		<a name="S1Wstep.49"></a><h2>8.4. Zmienne (mutable)</h2>	
					
		<font class="chapter">	
		
			W przeciwieñstwie do struktur niezmiennych, struktury mutable nie tworz¹ nowej isntacji, a jedynie modyfikuj¹ swój wewnêtrzny stan.
			
			<br><br>
			
			Dobrym przyk³adem mo¿e byæ znany z Javy <font class="code">java.util.Vector</font>, który pozwala na takie operacje jak dodawanie <font class="code">add()</font>, usuwanie <font class="code">remove()</font> czy zamienianie <font class="code">set()</font>, a wszystko to na tej samej istancji.
			
			<br><br>
			
			W czasach programów wielow¹tkowych powoduje to pewne komplikacje, które zostan¹ omówione w innym rozdziale tej serii wyk³adów.
			
			<br><br>
			
			Kolekcje mutable znajduj¹ siê w <font class="code">scala.collection.mutable._</font>.
					
		</font>		
		
		<br>
		
		<a name="S1Wstep.50"></a><h2>8.5. Generics</h2>	
					
		<font class="chapter">
						
			Jak ka¿dy nowoczesny jêzyk Scala posiada mo¿liwoœæ parametryzowania klas i robi z tego bardzo dobry u¿ytek. Przegl¹daj¹c API mo¿emy byæ a¿ zaskoczeni iloœci¹ klas sparametryzowanych.
			
			<br><br>
			
			Definiujemy bardzo podobnie (czêsto wrêcz tak samo) jak w Javie :
			
			<br>
			
			<font class="code">
class Worek[ T ]
{
    def dodajDoWorka( t : T ) { ... }
    def usunZWorka( t : T ) { ... }
}
			</font>	
			
			<br>
			
			Parametryzacja w Scali funkcjonalnie nie odbiega od Javy (a byæ mo¿e nawet j¹ przewy¿sza) chocia¿ nie bêdzie tutaj omawiana tak szczegó³owo.			
						
		</font>	
		
		<br><hr>
		
		<a name="S1Wstep.51"></a><h2>9. Punkt startowy programu</h2>	
		
		<a name="S1Wstep.52"></a><h2>9.1. Metoda main()</h2>	
					
		<font class="chapter">	
			
			Podobnie jak w Javie program rozpoczynamy od metody main() pobieraj¹cej jako argument tablicê String (parametry przekazane do programu poprzez liniê poleceñ).
			
			<br>
			
			Poniewa¿ w Scali nie ma s³ówka static, jego rolê przejmuje umieszczanie statycznego kontentu w obiektach (singletonach).
	
			<br>
	
			<font class="code">
object WitajSwiecie
{
    def main( args : Array[ String ] )
    {
        println( "Witaj swiecie !" )
    }
}
			</font>

		</font>	
		
		<a name="S1Wstep.53"></a><h2>9.2. Trait scala.Application</h2>	
					
		<font class="chapter">	
		
			Istnieje tak¿e klasa (a dok³adniej trait) <font class="code">scala.Application</font>. Poniewa¿ ma on w sobie metodê startow¹ (opisan¹ powy¿ej) to dziedzicz¹c z niego mo¿emy jeszcze szybciej napisaæ dzia³aj¹c¹ aplikacjê :

			<br>

			<font class="code">
object WitajSwiecie extends Application
{
    println( "Witaj swiecie !" )
}
			</font>

			<br>

			Zyskujemy na czasie, jednak tracimy mo¿liwoœæ dostêpu do parametrów przekazanych programowi z linii poleceñ.

			<br><br>

			Linie kodu wpisane bezpoœrednio 'w cia³o klasy' zbierane s¹ i umieszczane w konstruktorze podstawowym. St¹d linia <font class="code">println()</font> zostanie wykonana w momencie wykonania wykonywania siê konstruktora (a ten zostanie wykonany, poniewa¿ Scala bêdzie tworzyæ instancjê tego¿ obiektu, gdy¿ zawiera on metodê <font class="code">main()</font>).
		
		</font>	
		
		<br><hr>
		
		<a name="S1Wstep.54"></a><h2>10. Dziedziczenie</h2>	
		
		<font class="chapter">	
		
			W Scali (tak jak w Javie) nie ma wielodziedziczenia i odbywa siê podobnie, jak to znamy do tej pory :
			
			<br><br>
			
			<font class="code">class Pies extends Zwierze</font>
			
			<br><br>
			
			Ewentualnie dla klas z konstruktorami :

			<br><br>
			
			<font class="code">class Pies( nazwa : String , wiek : Int , dlugoscOgona : Int ) extends Zwierze( nazwa , wiek )</font>

			<br><br>

			Wiêcej o konstruktorach podstawowych mo¿na znaleŸæ w dziale Klasy/Konstruktory.
		
		</font>
		
		<br>
		
		<a name="S1Wstep.55"></a><h2>10.1. Przes³anianie metod</h2>	
		
		<font class="chapter">	
		
			Inaczej jak w Javie, przes³anianie metod w Scali wymaga obowi¹zkowego s³ówka <font class="code">override</font>. Eliminuje ona pewne nieœcis³oœci projektowe, jakie mog¹ powstaæ kiedy w Javie programista czasem doda adnotacje <font class="code">@Override</font>, a czasem nie.

			<br>
			
			<font class="code">
class Pies( nazwa : String , wiek : Int , dlugoscOgona : Int ) extends Zwierze( nazwa , wiek )
{
    override def toString =
    {
        super.toString + ", dlugosc ogona = " + dlugoscOgona
    }
}
			</font>
		
		</font>
		
		<br><hr>
		
		<a name="S1Wstep.56"></a><h2>11. Wyj¹tki</h2>	
			
		<font class="chapter">	
			
			Wyj¹tki w Scali to bardzo przyjemna sprawa ... prawdopodobnie przez to, ¿e s¹ totalnie przeŸroczyste.
			
			<br><br>
			
			Nie ma wyj¹tków weryfikowalnych i nieweryfikowalnych, przez co ju¿ w momencie pisania metody nie jesteœmy zmuszani do umiejscowienia s³ówka <font class="code">throws</font>. Ogólna praktyka pokazuje, ¿e przez to, i¿ tak bardzo w Javie siê nam 'narzucaj¹' w trakcie pisania, to s¹ najprostsz¹ technik¹ unicestwiane otrzymuj¹c status 'do zrobienia na potem'. Czêsto jednak to potem nie nastêpuje, a sprawa koñczy siê kilkoma wielkimi sekcjami <font class="code">try-catch</font> prze³apuj¹cymi <font class="code">Exception</font> (lub wrêcz <font class="code">Throwable</font>).
			
			<br><br>
			
			Poza nie zmuszaniem nas do myœlenia o wyj¹tkach ju¿ od wczesnych momentów tworzenia ka¿dej metody dzia³aj¹ one dok³adnie tak samo jak w Javie. Tak wiêc wyrzucamy je s³ówkiem throw oraz ³apiemy w sekcjach <font class="code">try-catch</font>.			
						
		</font>	
		
		<br>
		
		<a name="S1Wstep.57"></a><h2>11.1. Prze³apywanie wyj¹tkow</h2>	
		
		<font class="chapter">	

			Jedyn¹ ró¿nic¹ w porównaniu do Javy jest lekka modyfikacja sekcji catch (ponadto sekcja <font class="code">try-cach</font> potrafi zwracaæ wartoœæ).

			<br>

			<font class="code">
try
{
    ...
}
catch
{
    case ioe : IOException =>
    {
        println( ioe )
    }

    case e : Excetpion =>
    {
        println( e )
    }
}
finally
{
    ...
}
			</font>


			<br>
			
			W sekcji <font class="code">try-catch</font> kolejnoœæ prze³apywanych wyj¹tków liczy siê tak samo jak w Javie. Zbudowana jest ona z bloku <i>pattern maching</i>. Zdobycie informacji o nim powoduje automatyczne zrozumienie sk³adni (która w gruncie rzeczy nie jest a¿ tak skomplikowana).

		</font>
		
		<br><hr>
		
		<a name="S1Wstep.58"></a><h2>12. Modyfikatory dostêpu</h2>	
			
		<font class="chapter">	
		
			W Scali wszystko jest domyœlnie publiczne, tak wiêc modyfikator <i>public</i> zosta³ wycofany. Dostêpne s¹ tylko <font class="code">protected</font> oraz <font class="code">private</font>.

			<br><br>
			
			Dostêp 'paczkowy' zapewniamy przez :

			<br><br>
			
			<font class="code">protected[ nazwaPaczki ] def metoda() ...</font>

			<br><br>
			
			lub

			<br><br>
			
			<font class="code">private[ nazwaPaczki ] def metoda() ...</font>
		
		</font>
		
		<br><hr>
				
	</body>

</html>