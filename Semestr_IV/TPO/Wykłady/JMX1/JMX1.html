<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1250"> 
    <meta name="author" content="Bart³omiej Starosta"> 
    <meta name="description" content="opis"> 
    <meta name="copyright" content="(c) Bart³omiej Starosta PJWSTK 2010"> 
    <link rel="stylesheet" type="text/css" href="../STYLE/common.css"> 
    <title>JMX 1</title>
</head>
<body>
<div align="center">
  <a name="JMX1"></a><h1>JMX - Czêœæ 1</h1>
  <h1>Praktyczne wprowadzenie</h1>
</div>
<hr>
<br>
<i> 
    <P>
    JMX to skrót od <EM>Java Management Extensions</EM>.
    Z jednej strony jest to technologia programowania rozproszonego,
    z drugiej - metodologia projektowania aplikacji w taki sposób, 
    aby mo¿na by³o je kontrolowaæ i ³atwo nimi zarz¹dzaæ ju¿ na poziomie poszczególnych obiektów, 
    równie¿ zdalnie, przy u¿yciu rozmaitych protoko³ów komunikacyjnych.
    Ponadto JMX umo¿liwia nadzorowanie zasobów maszyny wirtualnej Javy.
    </P>
    <P>
    Wa¿n¹ zalet¹ tej technologii jest prostota i wyj¹tkowa ³atwoœæ w u¿yciu. 
    Nie wymaga ona du¿ej iloœci dodatkowego kodu do uzyskania gotowego rozwi¹zania. 
    Jest przy tym uniwersalna i skalowalna - 
    mo¿na j¹ stosowaæ we wszelkiego rodzaju aplikacjach: 
    od urz¹dzeñ mobilnych po wielkie serwery korporacyjne.
    Ze wzglêdu na swe mo¿liwoœci staje siê coraz bardziej popularna na œwiecie i 
    wielu dostawców oprogramowania biznesowego w³¹cza j¹ do swoich 
    <A HREF="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/jmxadoption.jsp">produktów</A>
    (np. IBM WebSphere, JBoss, BEA WebLogic, Tomcat).
    </P>
    Pierwszy z dwóch wyk³adów przedstawia podstawowe koncepcje JMX na prostych przyk³adach.   
</i>


<BR><HR><a name="JMX1.1"></a><H2>1. Szybki start</H2>

<P>
PrzejdŸmy od razu do rzeczy. 
Zademonstrujemy bardzo prosty przyk³ad. 
Poka¿e on, ¿e JMX jest narzêdziem o potê¿nych mo¿liwoœciach 
bêd¹c jednoczeœnie bardzo prostym w u¿yciu. 
Na pocz¹tek dokonamy zdalnego pobrania  wartoœci pola pewnego obiektu oraz jego modyfikacji. 
Oczywiœcie, mo¿liwoœci JMX nie ograniczaj¹ siê wy³¹cznie
do odczytu i zapisu stanów obiektów. 
Równie ³atwo mo¿emy np. rejestrowaæ s³uchaczy, którzy bêd¹
powiadamiani o zachodz¹cych zmianach, co zobaczymy dalej. 
</P>

<H3>1.1. M-ziarno</H3>
<P>
W oparciu o specyfikacjê JMX stworzymy klasê, 
której obiekty - tzw. m-ziarna (ang. <EM>mbean</EM>) - 
bêd¹ mog³y udostêpniaæ swoj¹ sk³adow¹. 
Dla uproszczenia bêdzie to jedyne pole tej klasy, 
powiedzmy <CODE>value</CODE> typu <CODE>int</CODE>. 
Klasa bêdzie siê nazywaæ <CODE>SomeValue</CODE>. 
Oto ona: 
</P>
<pre>
public class SomeValue
   implements SomeValueMBean {

   public int getValue() {
      System.out.println("Wywo³ano metodê getValue(), która zwróci³a wynik: " + value);
      return value;
   }

   public void setValue(int val) {
      this.value = val;  
      System.out.println("Wywo³ano metodê setValue() z argumentem: " + val);
   }

   /**
    * Atrybut, który udostêpniamy 
    */
   private int value = 0; 
}
</pre>
<P>
Klasa m-ziarna musi byæ publiczna i musi mieæ publiczny konstruktor
(tu domyœlny). 
</P>

<H3>1.2. Interfejs zarz¹dzania</H3>

<P>
Jak widaæ, klasa <CODE>SomeValue</CODE> nie zawiera nic
wyj¹tkowego, poza implementacj¹ interfejsu <CODE>SomeValueMBean</CODE>.
Interfejs ten - zwany interfejsem zarz¹dzania albo krócej:
m-interfejsem - musimy sami stworzyæ. 
Opisuje on w³aœciwoœci klasy poprzez deklaracje akcesorów - metod dostêpu do atrybutów
(mo¿e zawieraæ równie¿ deklaracje dowolnych innych metod - patrz dalej).
Interfejs zarz¹dzania - podobnie jak klasa m-ziarna - musi byæ
publiczny. Oto on: 
</P>
<pre>
public interface SomeValueMBean {
    
   /**
    * Getter dla atrybutu "Value"
    */
   public int getValue();

   /**
    * Setter dla atrybutu "Value"
    */
   public void setValue(int value);

}
</pre>
<P>
Interfejs zarz¹dzania <CODE>SomeValueMBean</CODE> zawiera 
deklaracje gettera i settera dla atrybutu <CODE>"Value"</CODE>
udostêpnionego w klasie implementuj¹cej <CODE>SomeValue</CODE>.
Nazwa tego atrybutu - jako napis, który bêdzie u¿ywany w infrastrukturze JMX - 
zaczyna siê du¿¹ liter¹ w przeciwieñstwie do nazwy sk³adowej <CODE>value</CODE>, 
która zaczyna siê liter¹ ma³¹. 
</P>
<P>
Proszê zwróciæ uwagê, ¿e nazwa interfejsu zarz¹dzania jest
nazw¹ klasy, która go implementuje z dodanym obowi¹zkowym
przyrostkiem <CODE>MBean</CODE>. Taki interfejs musimy zawsze
dostarczyæ i - w najprostszym przypadku - jest to jedyny wymóg
wobec klasy, która chce udostêpniaæ jakieœ atrybuty poprzez
JMX. Oczywiœcie, musimy przestrzegaæ standardowych regu³ nazewniczych
wobec akcesorów - setterów i getterów. Metody
pobieraj¹ce wartoœci musz¹ zaczynaæ siê od przedrostka <CODE>get</CODE>
a ustalaj¹ce wartoœci - od przedrostka <CODE>set</CODE>. Po nich
nastêpuje nazwa atrybutu pisana du¿¹ liter¹ zak³adaj¹c, ¿e nazwa pola
klasy zaczyna siê liter¹ ma³¹. 
</P>
<P>
Atrybuty udostêpniane przez m-ziarna nie musz¹ byæ bezpoœrednio
zwi¹zane ze sk³adowymi klasy. Mog¹ to byæ dowolne wartoœci np.
wyliczane dynamicznie przez jakieœ metody. Jeœli nie dostarczymy
settera, to atrybut bêdzie tylko do odczytu. Podobnie, jeœli nie
dostarczymy gettera, to atrybut bêdzie tylko do zapisu. 
</P>

<H3>1.3. Agent</H3>

<P>
Aby uruchomiæ nasz przyk³adowy program potrzebujemy jeszcze
agenta, który utworzy obiekt m-ziarna i zarejestruje go w serwerze m-ziaren,
oraz klienta, który bêdzie z niego korzysta³. 
</P>
<DIV CLASS=notec>
<H4>m-serwer</H4>
<P>
Serwer m-ziaren - inaczej m-serwer - s³u¿y do przechowywania m-ziaren 
i udostêpniania ich na zewn¹trz.
Po stronie agenta jest reprezentowany przez interfejs <CODE>MBeanServer</CODE>
pakietu <CODE>javax.management</CODE>,
natomiast po stronie klienta przez jego nadinterfejs <CODE>MBeanServerConnection</CODE>
(w zwi¹zku z tym klient ma mniejsze mo¿liwoœci w korzystaniu z m-serwera ni¿ agent).
</P>
<P>
Aplikacje mog¹ tworzyæ w³asne m-serwery statycznymi metodami klasy <CODE>MBeanServerFactory</CODE>, 
jednak zaleca siê korzystanie z systemowego serwera m-ziaren zwracanego przez metodê
<CODE>getPlatformMBeanServer()</CODE> klasy <CODE>ManagementFactory</CODE>
(pakiet <CODE>java.lang.management</CODE>).
</P>
</DIV>
<P>
Oto kod agenta. 
<pre>
import java.lang.management.*;
import javax.management.*;

import javax.management.remote.*;

public class Agent {

   public static void main(String[] args) 
      // dla uproszczenia przyk³adu nie obs³ugujemy wyj¹tków
      throws Exception { 

      // Pobieramy odniesienie do m-serwera systemowego
      MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();

      // Tworzymy nazwê dla m-ziarna, 
      // pod któr¹ zostanie on zarejestrowany
      ObjectName name = new ObjectName("software.JMX:example=standard"); 

      // Tworzymy m-ziarno SomeValue 
      SomeValue mbean = new SomeValue();

      // Rejestrujemy m-ziarno w m-serwerze
      mbs.registerMBean(mbean, name);


      // Czekamy na zg³oszenia klientów
      System.out.println("Czekam na zg³oszenia...");
      Thread.sleep(Long.MAX_VALUE);
   }
}
</pre>
</P>
<P>
Pierwszym krokiem, który zawsze musi wykonaæ agent jest pobranie odniesienia do m-serwera, 
w którym zostanie zarejestrowane m-ziarno. 
Wykorzystujemy do tego metodê <CODE>getPlatformMBeanServer()</CODE>, 
która zwraca odniesienie do domyœlnego m-serwera.
Drugim krokiem jest utworzenie nazwy dla
m-ziarna, pod któr¹ zostanie ono zarejestrowane. Nazwa dla
m-ziarna jest obiektem klasy <CODE>ObjectName</CODE> z pakietu
<CODE>javax.management</CODE>. Opakowuje on napis - reprezentuj¹cy
m-ziarno w sposób zrozumia³y dla cz³owieka - w obiekt, który
jest u¿ywany do identyfikacji tego m-ziarna. 
W trzecim i ostatnim kroku - 
metod¹ <CODE>registerMBean()</CODE> -
rejestrujemy w m-serwerze sam obiekt m-ziarna. 
Od tej pory m-ziarno jest dostêpne dla klientów,
którzy mog¹ odczytywaæ i modyfikowaæ wartoœæ jego atrybutu. 
</P>

<DIV CLASS=notec>
<A NAME="MNAME"><H4>Nazwy m-ziaren</H4></A>
<P>
Nazwa dla m-ziarna - jako napis przekazywany do konstruktora klasy <CODE>ObjectName</CODE> -
sk³ada siê z:
<UL>
  <LI>
  nazwy dziedziny - dowolny napis (nie mo¿e zawieraæ znaku ":");
  zgodnie z konwencj¹ przyjmuje siê odwrócon¹ nazwê domeny internetowej dostawcy zakoñczon¹ kropk¹, 
  po której nastêpuje dowolny napis, np.:
  <CODE>pl.edu.pjwstk.JMX</CODE>; w naszym przyk³adzie u¿ywaliœmy dziedziny <CODE>software.JMX</CODE>
  </LI>
  <LI>
  znaku ":"
  </LI>
  <LI>
  zestawu par <CODE>klucz=wartoœæ</CODE> oddzielonych przecinkami; 
  co najmniej jedna taka para musi wyst¹piæ, kolejnoœæ nie jest istotna:
  <UL>
    <LI>
    ka¿dy <CODE>klucz</CODE> jest napisem nios¹cym jak¹œ informacjê o m-ziarnie;
    w naszym przyk³adzie u¿ywaliœmy klucza <CODE>example</CODE>,
    </LI>
    <LI>
    wartoœæ skojarzon¹ z kluczem nale¿y traktowaæ jako informacjê uzupe³niaj¹c¹ dla klucza.
    </LI>
    </UL>
  </LI>
  </UL>
</P>
</DIV>
<P>
W tym prostym przyk³adzie dzia³anie aplikacji (np. serwera)
udostêpniaj¹cej m-ziarno zosta³o zasymulowane poprzez uœpienie w¹tku
(gdybyœmy tego nie zrobili - program zakoñczy³by siê). 
Oczywiœcie, w rzeczywistych aplikacjach takie uœpienie jest zbêdne,
gdy¿ zwykle podejmuj¹ one jakieœ dzia³ania po skonfigurowaniu œrodowiska.
</P>

<H3>1.4. Klient</H3>

<P>
Teraz pora na klienta. Jego jedynym zadaniem - w tym prostym
przypadku - bêdzie pobranie i modyfikacja atrybutu "Value"
z m-ziarna zarejestrowanego pod nazw¹ <CODE>"software.JMX:example=standard"</CODE>.
Klient mo¿e byæ uruchomiony na maszynie lokalnej lub zdalnej - z
punktu widzenia kodu nie robi to ¿adnej ró¿nicy. Oto kod
klienta: 
</P>

<pre>
import javax.management.*;
import javax.management.remote.*;

public class Client {

   public static void main(String[] args) 
      // dla uproszczenia przyk³adu nie obs³ugujemy wyj¹tków
      throws Exception { 

      int port = 2006;
      String host = "localhost";

      if(args.length > 0)
         host = args[0];
      if(args.length > 1)
         port = Integer.parseInt(args[1]);

      String url = "service:jmx:rmi:///jndi/rmi://" + host + ":" + port + "/jmxrmi";

      // Nawi¹zujemy po³¹czenie z m-serwerem w kilku krokach
      JMXConnector jmxcon = JMXConnectorFactory.connect(new JMXServiceURL(url));
      MBeanServerConnection server = jmxcon.getMBeanServerConnection();

      // Tworzymy nazwê m-ziarna, z którego chcemy skorzystaæ
      ObjectName name = new ObjectName("software.JMX:example=standard");


      // Pobieramy wartoœæ atrybutu Value z naszego m-ziarna
      int value = (Integer)server.getAttribute(name, "Value");    
      System.out.println("Wartoœæ atrybutu Value: " + value);

      // Zmieniamy wartoœæ atrybutu
      server.setAttribute(name, new Attribute("Value", value+1));

      // Ponownie pobieramy wartoœæ atrybutu Value
      value = (Integer)server.getAttribute(name, "Value");    
      System.out.println("Nowa wartoœæ atrybutu: " + value);
   }
}
</pre>
<P>
Najpierw pobieramy ewentualne argumenty: 
nazwê hosta, z którym siê po³¹czymy oraz 
numer portu, przez który bêdzie odbywaæ siê komunikacja. 
</P>
<P>
Pierwszym zadaniem klienta jest nawi¹zanie po³¹czenia z m-serwerem, 
w którym jest zarejestrowane nasze m-ziarno. 
W tym celu musimy pozyskaæ obiekt typu <CODE>MBeanServerConnection</CODE>,
który bêdzie reprezentowa³ m-serwer po stronie klienta.
Nie tworzymy go konstruktorem, 
lecz pobieramy jako rezultat metody <CODE>getMBeanServerConnection()</CODE>
wywo³anej na rzecz ³¹cznika typu <CODE>JMXConnector</CODE>.
Z kolei ³¹cznik ten jest uzyskany na podstawie URLa,
który identyfikuje serwer m-ziaren.
</P>
<P>
URL m-serwera jest reprezentowany przez obiekt klasy <CODE>JMXServiceURL</CODE>,
który opakowuje napis postaci: <CODE>service:jmx:rmi:///jndi/rmi://host:port/jmxrmi</CODE>
Jego jedynym zmiennym fragmentem (tj. takim, którym mo¿emy manipulowaæ) jest 
nazwa hosta <CODE>host</CODE> (mo¿e to byæ jego adres IP) i numer portu <CODE>port</CODE>,
poprzez który bêdzie odbywaæ siê komunikacja z m-serwerem, a wiêc i m-ziarnem.
Ten sam numer portu jest podawany agentowi podczas
uruchamiania i mo¿e on przyjmowaæ dowolne sensowne wartoœci. 
</P>
<P>
Po nawi¹zaniu po³¹czenia z m-serwerem tworzymy nazwê dla m-ziarna,
podaj¹c konstruktorowi <CODE>ObjectName</CODE> dok³adnie taki sam
napis, jaki by³ u¿yty podczas rejestracji m-ziarna w m-serwerze. 
</P>
<P>
Na zakoñczenie pobieramy wartoœæ atrybutu <CODE>"Value"</CODE>
(odnosz¹cego siê w tym przyk³adzie do pola <CODE>value</CODE> klasy
<CODE>SomeValue</CODE>). Proszê zwróciæ uwagê, ¿e wynik metody
<CODE>getAttribute()</CODE> (typu <CODE>Object</CODE>) zosta³
zrzutowany na typ <CODE>Integer</CODE> a nastêpnie przypisany na
zmienn¹ typu <CODE>int</CODE>. Ma tu miejsce tzw. <EM>unboxing</EM>
obecny w Javie od wersji 1.5. Metoda <CODE>setAttribute(ObjectName name, Attribute attr)</CODE> s³u¿y do nadania nowej wartoœci
atrybutowi reprezentowanemu przez nazwê <CODE>name</CODE>. Nowa
wartoœæ atrybutu jest opakowana w obiekt klasy <CODE>Attribute</CODE>.
Jej konstruktorowi przekazujemy jako argumenty: nazwê atrybutu (nie
nazwê sk³adowej!) oraz now¹ wartoœæ jako obiekt. Podobnie jak przy
pobieraniu wartoœci wykorzystujemy tu <EM>autoboxing</EM>, dziêki
któremu zmienna typu <CODE>int</CODE> zostanie automatycznie
opakowana w obiekt klasy <CODE>Integer</CODE>. Aby przekonaæ siê, ¿e
zmiana rzeczywiœcie zasz³a, ponownie pobieramy i wypisujemy wartoœæ
atrybutu. 
</P>

<H3>1.5. Uruchomienie</H3>

<P>
Teraz pozosta³o ju¿ tylko uruchomiæ nasz przyk³ad, sk³adaj¹cy siê
z dwóch programów: agenta (który rejestruje
m-ziarno i udaje dzia³aj¹c¹ aplikacjê) oraz klienta (który
³¹czy siê z m-serwerem i korzysta z m-ziarna). Agentowi musimy
przekazaæ specjalne opcje podczas uruchamiania, które
spowoduj¹ nadanie odpowiednich wartoœci w³aœciwoœciom maszyny
wirtualnej zwi¹zanym z infrastruktur¹ JMX.
W szczególnoœci musimy przekazaæ numer
portu, poprzez który bêdzie odbywaæ siê komunikacja z
klientami. 
Oto sposób uruchomienia agenta:
</P>
<DIV CLASS=listingful STYLE=white-space:pre;>java -Dcom.sun.management.jmxremote.port=2006 
     -Dcom.sun.management.jmxremote.ssl=false 
     -Dcom.sun.management.jmxremote.authenticate=false 
      Agent
</DIV>
<P>
Po uruchomieniu na konsoli agenta pojawi siê napis 
<CODE>Czekam na zg³oszenia...</CODE>. 
Teraz uruchamiamy klienta. Jako argumenty
podajemy nazwê hosta na którym dzia³a agent oraz numer portu
taki sam jak przy uruchamianiu agenta. 
</P>
<DIV CLASS=listingful STYLE=white-space:pre;>java Client localhost 2006
</DIV>
<P>
W tym momencie na konsoli klienta pojawi siê napis 
</P>
<DIV CLASS=listingful STYLE=white-space:pre;>Wartoœæ atrybutu Value: 0
Nowa wartoœæ atrybutu: 1
</DIV>
<P>
natomiast na konsoli agenta - na skutek wywo³ania metod <CODE>getValue()</CODE>
i <CODE>setValue()</CODE>- pojawi siê napis: 
</P>
<DIV CLASS=listingful STYLE=white-space:pre;>Wywo³ano metodê getValue(), która zwróci³a wynik: 0
Wywo³ano metodê setValue() z argumentem: 1
Wywo³ano metodê getValue(), która zwróci³a wynik: 1
</DIV>
<P>
Wyniki dzia³ania programu mo¿na zaobserwowaæ na zrzutkach 1 i 2.
<P>
<IMG SRC="images/Agent_1.png">
</P>
<P>
<IMG SRC="images/Client_1.png">
</P>
</P>
<P>
W ten prosty sposób dostaliœmy siê do wnêtrza obiektu
zlokalizowanego byæ mo¿e na innej maszynie. Wa¿ne jest, ¿e narzut - w
sensie dodatkowych instrukcji kodu niezbêdnych do wykorzystania JMX -
jest niewielki i do tego sta³y, w zasadzie niezale¿ny od poziomu
skomplikowania aplikacji. Zatem technologia ta jest ³atwo skalowalna.
</P>

<BR><HR><a name="JMX1.2"></a><H2>2. Sygna³y i operacje</H2>

<P>
Mo¿liwoœci operowania na m-ziarnach nie ograniczaj¹ siê do
odczytywania i modyfikowania wartoœci atrybutów tych obiektów.
Mo¿emy wywo³ywaæ dowolne (publiczne) metody przekazuj¹c im argumenty
i odbieraj¹c wyniki ich dzia³ania. Mo¿emy równie¿ odbieraæ
sygna³y. 
</P>

<H3>2.1. Sygna³y</H3>

<P>
Sygna³ jest obiektem klasy <CODE>Notification</CODE> (pakiet
<CODE>javax.management</CODE>) nios¹cym informacjê o jakimœ
zdarzeniu. Taki obiekt mo¿e zostaæ wyemitowany przez m-ziarno.
Zostanie wtedy dostarczony do s³uchaczy sygna³ów
zarejestrowanych wczeœniej w tym m-ziarnie. Typowym przyk³adem
takiego zdarzenia jest modyfikacja atrybutu. Odpowiada mu dedykowana
klasa <CODE>AttributeChangeNotification</CODE>, bêd¹ca podklas¹ klasy
<CODE>Notification</CODE>. Obiekt tej klasy zawiera informacje o
starej i nowej wartoœci atrybutu. 
</P>

<P>Klasa m-ziarna chc¹cego wysy³aæ sygna³y musi implementowaæ
interfejs <CODE>NotificationEmitter</CODE> z pakietu
<CODE>javax.management</CODE>. W praktyce dziedziczy siê klasê
<CODE>NotificationBroadcasterSupport</CODE>, która
implementuje ten interfejs dostarczaj¹c dodatkowo u¿ytecznych metod. 
</P>

<P>
Emisja sygna³u nastêpuje na skutek wywo³ania metody
<CODE>sendNotification(Notification)</CODE> odziedziczonej z klasy
<CODE>NotificationBroadcasterSupport</CODE>. Obiekt sygna³u
przekazany jako argument zostanie rozes³any do s³uchaczy (obiektów
klas implementuj¹cych interfejs <CODE>NotificationListener</CODE>)
zarejestrowanych wczeœniej metod¹ <CODE>addNotificationListener()</CODE>.
</P>

<H3>2.2. Pe³ny przyk³ad</H3>

<P>
Rozszerzymy nasz wstêpny przyk³ad o mo¿liwoœæ wywo³ywania metod i
emisji sygna³ów. Metod¹, któr¹ bêdziemy wywo³ywaæ
bêdzie <CODE>void reset()</CODE> (dodamy j¹ do klasy m-ziarna),
natomiast sygna³ bêdzie wysy³any na skutek modyfikacji atrybutu
<CODE>"Value"</CODE>. W tym celu trzeba bêdzie zmodyfikowaæ
metodê <CODE>set(int)</CODE>. 
</P>

<H4>2.2.1. Interfejs zarz¹dzania</H4>

<P>
Poniewa¿ dodaliœmy do m-ziarna metodê, musimy uwzglêdniæ to w
m-interfejsie. 
</P>

<pre>
public interface SomeValueMBean {
    
   public int getValue();

   public void setValue(int value);

   /*
    * Dodatkowa metoda
    */
   public int reset();
    
}
</pre>

<H4>2.2.2. Klasa m-ziarna</H4>

<P>
Do klasy <CODE>SomeValue</CODE> dodamy implementacjê metody
<CODE>reset()</CODE> i zmodyfikujemy metodê <CODE>set()</CODE> tak,
by po zmianie wartoœci sk³adowej <CODE>value</CODE> by³ wysy³any
sygna³. Proszê zwróciæ uwagê na dodatkowe prywatne pole
<CODE>sequenceNumber</CODE>. Bêdzie ono przechowywaæ kolejny numer
sygna³u (bowiem ka¿dy sygna³ ma swój numer). 
</P>
<pre>
import javax.management.*;

public class SomeValue
   extends NotificationBroadcasterSupport
   implements SomeValueMBean {


   public int getValue() {
      return value;
   }

   public void setValue(int val) {

      Notification notify =             // tworzymy sygna³
         new AttributeChangeNotification(
            this,                       // Ÿród³o sygna³u
            sequenceNumber++,           // numer sygna³u
            System.currentTimeMillis(), // czas wys³ania
            "Wartoœæ zmieniona",        // wiadomoœæ    
            "Value",                    // nazwa atrybutu
            "int",                      // typ atrybutu
            value,                      // stara wartoœæ
            val                         // nowa wartoœæ
         );

      this.value = val;  
      sendNotification(notify);         // rozsy³amy sygna³    

      System.out.println("Nowa wartoœæ atrybutu \\\\\\\\"Value\\\\\\\\": " + value);
   }

   public int reset() {
      if (value == 0)
         return 0;
      int oldval = value;
      setValue(0); 
      return oldval;
   }

   /**
    * Numer sygna³u
    */
   private long sequenceNumber = 1;      // dodatkowy pole

   private int value = 0; 
}
</pre>
<P>
Tworz¹c obiekt sygna³u (w tym wypadku klasy
<CODE>AttributeChangeNotification</CODE>) przekazujemy konstruktorowi
jako argumenty: Ÿród³o sygna³u, kolejny numer, czas emisji,
komunikat s³owny, nazwê atrybutu, jego typ oraz star¹ i now¹ wartoœæ.
Ta informacja dotrze do s³uchaczy. 
</P>

<H4>2.2.3. Klient</H4>

<P>
Kod klienta w zasadzie nie ró¿ni siê od poprzedniego przypadku 
(obs³uga b³êdów zosta³a uszczegó³owiona).
Tym razem wywo³ujemy metodê <CODE>reset()</CODE> 
(modyfikuj¹c wczeœniej wartoœæ atrybutu "Value" tak by by³a ró¿na od 0). 
Oprócz tego tworzymy obiekt s³uchacza sygna³ów i rejestrujemy go w m-serwerze, 
który po stronie klienta jest reprezentowany przez obiekt klasy <CODE>MBeanServerConnection</CODE>. 
</P>

<pre>
import javax.management.*;
import javax.management.remote.*;
import java.io.*;

public class Client {

   public static void main(String[] args) {

      int port = 2006;
      String host = "localhost";

      if(args.length > 0)
         host = args[0];
      if(args.length > 1)
         port = Integer.parseInt(args[1]);

      String url = "service:jmx:rmi:///jndi/rmi://" + host + ":" + port + "/jmxrmi";
      ObjectName name = null;
      JMXConnector jmxcon = null;
      MBeanServerConnection srvcon = null;

      try {
         // Nawi¹zujemy po³¹czenie z m-serwerem
         JMXServiceURL jmxurl = new JMXServiceURL(url);
         jmxcon = JMXConnectorFactory.connect(jmxurl);
         srvcon = jmxcon.getMBeanServerConnection();

         // Tworzymy nazwê m-ziarna, z którego chcemy skorzystaæ
         name = new ObjectName("software.JMX:example=standard");

         // Tworzymy nas³uch
         ClientListener listener = new ClientListener();
         srvcon.addNotificationListener(name, listener, null, null);
      }
      catch(JMException e){
         System.err.println(e);
      }
      catch(IOException e){
         System.err.println(e);
      }

      try {
         // Zmieniamy wartoœæ atrybutu tak by by³a != od 0
         srvcon.setAttribute(name, new Attribute("Value", 1));
      
         // I wywo³ujemy metodê reset:
         Object[] params = new Object[0];
         String[] signature = new String[0];
         int retval = (Integer)srvcon.invoke(name, "reset", params, signature);
      }
      catch(JMException e){
         System.err.println(e);
      }
      catch(IOException e){
         System.err.println(e);
      }

      // Musimy poczekaæ na nadejœcie sygna³u.
      try {
         Thread.sleep(1000);
      }
      catch(InterruptedException e){
      }
   }
}
</pre>
<P>
Dodaj¹c s³uchacza w metodzie <CODE>addNotificationListener()</CODE>
podajemy jako argumenty: nazwê dla m-ziarna bêd¹cego Ÿród³em
zdarzenia, obiekt s³uchacza, ewentualny filtr sygna³ów (tutaj
<CODE>null</CODE>) oraz opcjonalny obiekt (dowolnej klasy), który
bêdzie przekazywany pomiêdzy Ÿród³em a s³uchaczem w celu
identyfikacji (tu równie¿ <CODE>null</CODE>). 
</P>
<P>
Metodê <CODE>reset()</CODE> z naszego m-ziarna wywo³ujemy poœrednio,
poprzez wywo³anie <CODE>invoke()</CODE> ze zdalnego reprezentanta m-serwera.
Jako argumenty przekazujemy jej: 
<UL>
  <LI>
  nazwê m-ziarna (typu <CODE>ObjectName</CODE>), z którego bêdziemy wywo³ywaæ metodê,
  </LI>
  <LI>
  nazwê wywo³ywanej metody, 
  </LI>
  <LI>
  tablicê (typu <CODE>Object[]</CODE>) z argumentami, 
  jeœli metoda jest bezargumentowa to tablica musi mieæ d³ugoœæ 0,
  </LI>
  <LI>
  sygnaturê - tablicê napisów z nazwami typów parametrów (w przypadku klas s¹ to nazwy kwalifikowane).
  </LI>
</UL>
Wynik jest typu <CODE>Object</CODE>.
Poniewa¿ nasza metoda <CODE>reset()</CODE> zwraca <CODE>int</CODE>,
wiêc faktycznym typem wyniku jest <CODE>Integer</CODE>.
Po zrzutowaniu wykorzystujemy <EM>unboxing</EM> aby wy³uskaæ ze zwróconego obiektu 
wartoœæ pierwotnego typu <CODE>int</CODE>.
</P>
<P>
Uœpienie w¹tku na koñcu programu jest potrzebne, aby maszyna
wirtualna nie zakoñczy³a dzia³ania przed nadejœciem sygna³u. 
Oczywiœcie, w przypadku rzeczywistej aplikacji jest to zbêdne.
</P>
<P>
S³uchacz sygna³ów musi dostarczyæ implementacji metody
<CODE>handleNotification()</CODE> wymuszonej przez interfejs nas³uchu
<CODE>NotificationListener</CODE>. Bêdzie ona wywo³ywana (poprzez
<EM>callback</EM>) zawsze, kiedy nadejdzie sygna³. 
</P>
<pre>
import java.util.Date;
import javax.management.*;

public class ClientListener 
   implements NotificationListener {
    
   public void handleNotification(Notification notification, Object handback) {
      System.out.println("Odebrano sygna³:");
      System.out.println("Wiadomoœæ:         " + notification.getMessage());
      System.out.println("Numer:             " + notification.getSequenceNumber());
      System.out.println("Wys³ano:           " + new Date(notification.getTimeStamp()));
      System.out.println("Dane u¿ytkownika:  " + notification.getUserData());

      AttributeChangeNotification attrNotif = (AttributeChangeNotification)notification;
      System.out.println("Stara wartoœæ:     " + attrNotif.getOldValue());
      System.out.println("Nowa wartoœæ:      " + attrNotif.getNewValue());
   }
}
</pre>
<P>
Obiektu sygna³u <CODE>notification</CODE>, 
który jest przekazany jako argument mo¿emy wypytaæ o szczegó³y dotycz¹ce zdarzenia. 
Oprócz niego, jako dodatkowy argument, jest dostêpny obiekt identyfikuj¹cy (<CODE>handback</CODE>), 
który by³ przekazany podczas rejestracji s³uchacza (tu go ignorujemy). 
</P>

<H4>2.2.4. Uruchomienie</H4>

<P>
Kod agenta jest identyczny jak w poprzednim przypadku. 
Sposób uruchomienia równie¿. 
Na konsoli agenta powinniœmy zobaczyæ taki komunikat: 
</P>

<DIV CLASS=listingful STYLE=white-space:pre;>Czekam na zg³oszenia...
Nowa wartoœæ atrybutu "Value": 1
Nowa wartoœæ atrybutu "Value": 0
</DIV>

<P>
Natomiast po stronie klienta zobaczymy opisy sygna³ów wys³anych po
zmianie wartoœci atrybutu a nastêpnie wywo³aniu <CODE>reset()</CODE>: 
</P>

<DIV CLASS=listingful STYLE=white-space:pre;>Odebrano sygna³:
Wiadomoœæ:         Wartoœæ zmieniona
Numer:             1
Wys³ano:           Wed Mar 08 21:35:35 CET 2006
Dane u¿ytkownika:  null
Stara wartoœæ:     0
Nowa wartoœæ:      1
Odebrano sygna³:
Wiadomoœæ:         Wartoœæ zmieniona
Numer:             2
Wys³ano:           Wed Mar 08 21:35:35 CET 2006
Dane u¿ytkownika:  null
Stara wartoœæ:     1
Nowa wartoœæ:      0
</DIV>

<P>
Wynik dzia³ania jest widoczny na obrazkach:
<P>
<IMG SRC="images/Agent_2.png">
</P>
<P>
<IMG SRC="images/Client_2.png">
</P>
</P>

<P>
Proszê zwróciæ uwagê, ¿e po stronie klienta 
nie jest potrzebna znajomoœæ interfejsu zarz¹dzania m-ziarna 
(ani tym bardziej jego klasy)!
Wystarczy znajomoœæ nazw i typów atrybutów, ewentualnie sygnatur metod. 
Jest to niezwykle wygodne dla klientów,
zw³aszcza jeœli oprogramowanie m-ziarna podlega zmianom,
b¹dŸ jego interfejs nie mo¿e byæ udostêpniony ze wzglêdów komercyjnych czy innych.
</P>

<BR><HR><a name="JMX1.3"></a><H2>3. U¿ycie poœrednika</H2>

<P>
Jeœli interfejs zarz¹dzania jest dostêpny po stronie klienta, 
to ca³y proces dostêpu do m-ziarna jest jeszcze prostszy i szybszy. 
Jest on zw³aszcza wygodny przy operowaniu m-ziarnami maszyny wirtualnej, 
co opiszemy w dalszej czêœci. 
</P>
<P>
Skoro mamy dostêp do interfejsu zarz¹dzania, to znamy sygnatury
wszystkich metod, równie¿ akcesorów - a przez to i
atrybuty m-ziarna (zak³adaj¹c, ¿e zosta³o zbudowane zgodnie z
konwencjami). Moglibyœmy je wywo³ywaæ bezpoœrednio, ale niestety
klasa m-ziarna z regu³y nie jest dostêpna po stronie klienta. W
zwi¹zku z tym infrastruktura JMX dostarcza tzw. poœrednika (ang.
<EM>proxy</EM>). Jest to obiekt klasy implementuj¹cej interfejs
zarz¹dzania, który deleguje wywo³ania wszystkich metod do
w³aœciwego m-ziarna (poprzez sieæ). 
</P>
<P>
Wykorzystamy klasê m-ziarna i interfejs zarz¹dzania z poprzedniego
przyk³adu. Kod agenta jest identyczny. Inny bêdzie tylko kod klienta,
jednak ró¿nice - z punktu widzenia kodu - bêd¹ minimalne. Jak
zwykle, na pocz¹tku klient musi wykonaæ standardowe czynnoœci
polegaj¹ce na uzyskaniu po³¹czenia z m-serwerem i utworzeniu nazwy
dla m-ziarna. 
</P>
<pre>
import javax.management.*;
import javax.management.remote.*;
import java.io.*;

public class ProxyClient {

   public static void main(String[] args) {

      int port = 2006;
      String host = "localhost";

      if(args.length > 0)
         host = args[0];
      if(args.length > 1)
         port = Integer.parseInt(args[1]);

      String url = "service:jmx:rmi:///jndi/rmi://" + host + ":" + port + "/jmxrmi";
      ObjectName name = null;
      JMXConnector jmxcon = null;
      MBeanServerConnection srvcon = null;

      try {
         // Nawi¹zujemy po³¹czenie z m-serwerem
         JMXServiceURL jmxurl = new JMXServiceURL(url);
         jmxcon = JMXConnectorFactory.connect(jmxurl);
         srvcon = jmxcon.getMBeanServerConnection();

         // Tworzymy nazwê m-ziarna
         name = new ObjectName("software.JMX:example=standard");

         // Tworzymy nas³uch
         ClientListener listener = new ClientListener();
         srvcon.addNotificationListener(name, listener, null, null);
      }
      catch(JMException e){
         System.err.println(e);
      }
      catch(IOException e){
         System.err.println(e);
      }

      // Tworzymy poœrednika
      SomeValueMBean someValueMBeanProxy = (SomeValueMBean)
         MBeanServerInvocationHandler.newProxyInstance(
            srvcon, name, SomeValueMBean.class, false
         );
      // Wywo³ujemy metody:
      someValueMBeanProxy.setValue(2);        
      someValueMBeanProxy.getValue();        
      someValueMBeanProxy.reset();        

        
      // Musimy poczekaæ na nadejœcie sygna³u.
      try {
         Thread.sleep(500);
      }
      catch(InterruptedException e){
      }
   }

}
</pre>
<P>
Nastêpnie - za pomoc¹ statycznej metody <CODE>newProxyInstance</CODE>
z klasy <CODE>MBeanServerInvocationHandler</CODE> (pakiet
<CODE>javax.management</CODE>) - tworzymy obiekt poœrednika
<CODE>someValueMBeanProxy</CODE> typu <CODE>SomeValueMBean</CODE>, a
wiêc takiego samego typu jak m-ziarno. Jako argumenty przekazujemy
tej metodzie: 
</P>

<UL>
<LI>odniesienie do zdalnego reprezentanta m-serwera (<CODE>srvcon</CODE>), 
<LI>nazwê obiektu m-ziarna (<CODE>name</CODE>),
<LI>interfejs zarz¹dzania m-ziarna, który ma byæ implementowany przez zwróconego
     poœrednika, oraz 
<LI>informacjê, czy zwrócony obiekt ma implementowaæ
     interfejs <CODE>NotificationEmitter</CODE> dziêki czemu bêdziemy
     mogli zdalnie dodawaæ i usuwaæ s³uchaczy sygna³ów. 
</UL>

<P>
Obiektu <CODE>someValueMBeanProxy</CODE> u¿ywamy w zwyk³y sposób wywo³uj¹c metody,
tak jakby m-ziarno znajdowa³o siê w lokalnej maszynie wirtualnej.
Osoby obeznane z RMI zauwa¿¹ tu pewne podobieñstwa.
W istocie, JMX wykorzystuje RMI jako jeden z mo¿liwych protoko³ów komunikacji.
</P>
<P>
Uruchomienie tego przyk³adu jest identyczne jak w poprzednim przypadku.
Metody <CODE>setValue()</CODE> i <CODE>reset()</CODE> powoduj¹ emisjê sygna³u,
co mo¿na zaobserwowaæ na zrzutkach.
</P>
<P>
<P>
<IMG SRC="images/Agent_3.png">
</P>
<P>
<IMG SRC="images/Client_3.png">
</P>
</P>

<P>
Ten sposób u¿ycia m-ziarna jest preferowany, 
jeœli klient ma dostêp do interfejsu zarz¹dzania ju¿ na etapie kompilacji,
co nie zawsze jest mo¿liwe.
</P>

<BR><HR><a name="JMX1.4"></a><H2>4. Nadzorowanie maszyny wirtualnej</H2>

<P>
Pocz¹wszy od wersji 5 maszyna wirtualna Javy udostêpnia niektóre swoje zasoby 
jako tzw. m-ziarna systemowe (ang. <EM>platform mxbean</EM>) - inaczej mx-ziarna. 
S¹ one reprezentowane przez interfejsy zarz¹dzania pakietu <CODE>java.lang.management</CODE>. 
Mx-ziarna umo¿liwiaj¹ monitorowanie i zarz¹dzanie nastêpuj¹cymi zasobami JVM: 
</P>
<UL>
<LI>za³adowane klasy i wykonywane w¹tki, 
<LI>czas dzia³ania JVM, jej argumenty wywo³ania i w³aœciwoœci systemowe, 
<LI>stany w¹tków, wgl¹d w stos dzia³aj¹cego w¹tku, wykrywanie blokad, 
<LI>zu¿ycie pamiêci, odœmiecanie. 
</UL>

<P>
Obiekty mx-ziaren s¹ tworzone przez JVM a odniesienia do nich 
zwracaj¹ statyczne metody klasy <CODE>ManagementFactory</CODE>
(pakiet <CODE>java.lang.management</CODE>). 
Po uzyskaniu odniesienia mo¿emy takiego obiektu u¿ywaæ (lokalnie) w zwyk³y sposób, np.: 
</P>

<pre>RuntimeMXBean runmxb = ManagementFactory.getRuntimeMXBean();
long start = runmxb.getStartTime(); 
</pre>

<P>
Powy¿szy kod zwróci czas uruchomienia JVM. 
</P>
<P>
To podejœcie ma istotne ograniczenie: pozwala na odpytywanie
wy³¹cznie tej maszyny wirtualnej, na której siê wykonuje.
Jeœli chcemy skorzystaæ z mx-ziaren zdalnej maszyny wirtualnej,
musimy uzyskaæ dostêp do nich w jeden z wy¿ej opisanych sposobów:
</P>
<UL>
<LI>pos³uguj¹c siê nazwami atrybutów i metod 
   (i wywo³uj¹c <CODE>set/getAttribute()</CODE> i <CODE>invoke()</CODE>);
   nazwy atrybutów mo¿na wydedukowaæ z nazw akcesorów zadeklarowanych w tych interfejsach,
<LI>korzystaj¹c z poœrednika. 
</UL>
<P>
Drugi sposób jest prostszy i mo¿emy go zastosowaæ, 
poniewa¿ interfejsy zarz¹dzania odpowiednich mx-ziaren s¹ dostêpne w
standardowym pakiecie <CODE>java.lang.management</CODE>,
a wiêc s¹ obecne w JDK.
</P>

<H3>4.1. Przyk³ad</H3>

<P>
Pod³¹czymy siê do dzia³aj¹cej maszyny wirtualnej, w której
jest uruchomiony jakiœ program i sprawdzimy iloœæ u¿ywanej pamiêci.
Oto program klienta pobieraj¹cego informacje: 
</P>
<pre>
import java.io.*;
import java.net.*;
import javax.management.*;
import javax.management.remote.*;
import java.lang.management.*;

import static java.lang.management.ManagementFactory.*;


public class MXClient {

   public static void main(String[] args) {

      int port = 2006;
      String host = "localhost";

      if(args.length > 0)
         host = args[0];
      if(args.length > 1)
         port = Integer.parseInt(args[1]);

      String url = "service:jmx:rmi:///jndi/rmi://" + host + ":" + port + "/jmxrmi";

      JMXServiceURL jmxurl = null;
      JMXConnector jmxcon = null;
      MBeanServerConnection srvcon = null;
      MemoryMXBean memxbean = null;

      try {
         jmxurl = new JMXServiceURL(url);
      }
      catch(MalformedURLException e){
         System.err.println(e);
      }

      try {
         // Nawi¹zujemy po³¹czenie z m-serwerem
         jmxcon = JMXConnectorFactory.connect(jmxurl);
         srvcon = jmxcon.getMBeanServerConnection();

         // Pobieramy mx-ziarno reprezentuj¹ce pamiêæ
         memxbean = newPlatformMXBeanProxy(srvcon, MEMORY_MXBEAN_NAME, MemoryMXBean.class);
      }
      catch(IOException e){
         System.err.println(e);
      }

      // Pobieramy rozmiar sterty i uruchamiamy odœmiecanie.
      long used = memxbean.getHeapMemoryUsage().getUsed();
      System.out.println("Rozmiar sterty: " + used);

      memxbean.gc();
      System.out.println("Odœmiecanie...");

      used = memxbean.getHeapMemoryUsage().getUsed();
      System.out.println("Rozmiar sterty: " + used);
   }
}
</pre>
<P>
Po wykonaniu standardowych czynnoœci tworzymy poœrednika dla mx-ziarna reprezentuj¹cego pamiêæ. 
W tym celu wywo³ujemy statyczn¹ metodê <CODE>newPlatformMXBeanProxy()</CODE> 
z klasy <CODE>ManagementFactory</CODE> 
(proszê zwróciæ uwagê na statyczny import tej klasy, 
dziêki któremu mo¿na u¿ywaæ jej statycznych sk³adowych bez kwalifikacji). 
Jako argumenty przekazujemy: 
</P>
<UL>
<LI>odniesienie do reprezentanta po³¹czenia <CODE>srvcon</CODE>, 
<LI>statyczn¹ sta³¹ <CODE>MEMORY_MXBEAN_NAME</CODE>
   z tej samej klasy, bêd¹c¹ nazw¹ dla mx-ziarna reprezentuj¹cego pamiêæ oraz 
<LI>interfejs zarz¹dzania ¿¹danego mx-ziarna. 
</UL>
<P>
Teraz mo¿emy ju¿ operowaæ mx-ziarnem wywo³uj¹c z niego metody
bezpoœrednio. W tym przyk³adzie pobieramy rozmiar u¿ywanej pamiêci, a
nastêpnie wywo³ujemy odœmiecacz (metod¹ <CODE>gc()</CODE>). W ten
prosty sposób mo¿na dokonaæ zdalnego odœmiecenia maszyny
wirtualnej. Ten przyk³ad dobitnie pokazuje jak potê¿nym
narzêdziem jest JMX. 
</P>

<H3>4.2. Uruchomienie</H3>

<P>
Powy¿szego klienta mo¿na pod³¹czyæ do dowolnej maszyny wirtualnej
- nie musi ona wykonywaæ specjalnie przygotowanego
kodu. Natomiast musi byæ w specjalny sposób uruchomiona (tzn.
tak jak poprzednie programy agenta). Dla przyk³adu uruchomimy program
demonstracyjny zawarty w archiwum SwingSet2.jar (dostêpny wraz z JDK
w katalogu <EM>demo/jfc</EM>, o ile zainstalowano): 
</P>
<DIV CLASS=listingful STYLE=white-space:pre;>java -Dcom.sun.management.jmxremote.port=2006 
     -Dcom.sun.management.jmxremote.ssl=false 
     -Dcom.sun.management.jmxremote.authenticate=false 
     -jar SwingSet2.jar
</DIV>
<P>
Nastêpnie uruchamiamy klienta (oczywiœcie, zamiast localhost
wstawiamy odpowiedni¹ nazwê hosta, a numer portu ma byæ taki, jak
podano podczas uruchamiania badanej maszyny wirtualnej): 
</P>
<DIV CLASS=listingful STYLE=white-space:pre;>java MXClient localhost 2006
Rozmiar sterty: 23156624
Odœmiecanie...
Rozmiar sterty: 20929312
</DIV>
<P>
Sposób uruchomienia i komunikaty prezentuj¹ obrazki:
<P>
<IMG SRC="images/JVM.png">
</P>
<P>
<IMG SRC="images/MXClient.png">
</P>
</P>

<P>
Jak widzimy zdalne odœmiecanie odnios³o skutek! 
</P>

<BR><HR><a name="JMX1.5"></a><H2>5. Aplikacja jconsole</H2>

<P>
JDK zawiera program narzêdziowy jconsole, który mo¿na wykorzystaæ jako uniwersalnego
klienta m-ziaren. W szczególnoœci mo¿na go u¿ywaæ do badania
stanu maszyny wirtualnej poprzez odpytywanie mx-ziaren, zarówno
lokalnej jak i zdalnej (choæ z uwagi na swoj¹ zasobo¿ernoœæ twórcy
odradzaj¹ stosowanie go do nadzorowania maszyny lokalnej). 
</P>
<P>
Maszyna wirtualna, do której chcemy przy³¹czyæ jconsole
musi byæ uruchomiona w specjalny sposób. Mo¿e ona wykonywaæ
dowolny program, w szczególnoœci taki, który tworzy i
rejestruje m-ziarna. Jeœli chcemy umo¿liwiæ wy³¹cznie lokalne
po³¹czenia z jconsole, to nale¿y ustaliæ w³aœciwoœæ
<CODE>com.sun.management.jmxremote</CODE>: 
</P>
<DIV CLASS=notel33>
Pocz¹wszy od wersji JDK 6, lokalne po³¹czenia z jconsole s¹ dostêpne automatycznie.
Nie trzeba zatem ustalaæ w³aœciwoœci <CODE>com.sun.management.jmxremote</CODE> 
podczas uruchamiania nadzorowanej maszyny wirtualnej.
Dotyczy to wy³¹cznie po³¹czeñ w obrêbie jednego hosta.
</DIV>
<DIV CLASS=listingful STYLE=white-space:pre;>java -Dcom.sun.management.jmxremote Klasa
</DIV>
<P>
gdzie <CODE>Klasa</CODE> jest jakimœ programem. Spowoduje to
uaktywnienie warstwy JMX dla po³¹czeñ lokalnych. Aby umo¿liwiæ
równie¿ zdalne po³¹czenia nale¿y maszynê uruchomiæ tak: 
</P>
<DIV CLASS=listingful STYLE=white-space:pre;>java -Dcom.sun.management.jmxremote.port=PORT 
     -Dcom.sun.management.jmxremote.ssl=false 
     -Dcom.sun.management.jmxremote.authenticate=false 
      Klasa
</DIV>
<P>
Tu <CODE>PORT</CODE> jest numerem portu, przez który bêdzie
odbywaæ siê komunikacja. 
</P>

<P>Do tak uruchomionej maszyny mo¿emy przy³¹czyæ jconsole. Na
pocz¹tku pojawia siê okno dialogowe s³u¿¹ce do wyboru JVM, z któr¹
bêdziemy siê ³¹czyæ. 
</P>

<P>
<IMG SRC="images/jconsole-select-local.png">
</P>

<P>
Zawiera ono panel zak³adkowy z trzema zak³adkami odpowiadaj¹cymi
trzem mo¿liwym sposobom ³¹czenia siê z maszynami wirtualnymi: 
</P>
<UL>
<LI>lokalnie (zak³adka Local) - ³¹czymy siê JVM uruchomion¹ przez tego samego u¿ytkownika na tej
    samej maszynie. Uwierzytelnianie jest wykonywane na podstawie
    informacji zawartych w systemie plików. 
<LI>zdalnie (zak³adka Remote) -
 podajemy nazwê hosta i numer portu (przez który bêdzie odbywaæ siê komunikacja - 
 zosta³ on okreœlony podczas uruchamiania badanej JVM).
 Jeœli nie zrezygnowano z autoryzacji podczas uruchamiania badanej JVM
 (w³aœciwoœæ <CODE>com.sun.management.jmxremote.authenticate</CODE> ustalono na <CODE>true</CODE>),
 to nale¿y równie¿ podaæ nazwê u¿ytkownika i has³o (szczegó³y w <A HREF="../JMX2/JMX2.html#SECURITY">nastêpnym wyk³adzie</A>),
<LI>sposób ogólny (zak³adka Advanced) - jest stosowany jeœli u¿ywamy innych (ni¿ domyœlny) 
 protoko³ów do komunikacji z docelow¹ maszyn¹ lub jest ona starszej wersji (1.4.*).
 W tym wypadku nale¿y podaæ url us³ugi, z któr¹ siê ³¹czymy oraz nazwê u¿ytkownika i has³o. 
</UL>
<P>
Domyœlna zak³adka Local prezentuje dzia³aj¹ce w macierzystym systemie 
maszyny wirtualne z aktywnym agentem JMX, do których mamy dostêp. 
Na obrazku widaæ, ¿e w lokalnym systemie dzia³aj¹ dwie maszyny wirtualne - 
jedna wykonuje program zawarty w archiwum SwingSet2.jar a druga klasê Agent. 
Zaznaczamy jedn¹ z nich i klikamy przycisk "Connect".
</P>
<P>
<IMG SRC="images/jconsole-select-remote.png">
</P>

<P>
Aby zbadaæ mo¿liwoœci aplikacji jconsole uruchommy klasê <CODE>Agent</CODE>
z poprzedniego przyk³adu. Nastêpnie - byæ mo¿e na innej maszynie -
odpalamy jconsole i ³¹czymy siê z JVM, na której dzia³a <CODE>Agent</CODE>.
Powinniœmy zobaczyæ podsumowanie podstawowych informacji o maszynie wirtualnej, 
z któr¹ siê po³¹czyliœmy. 
</P>
<P>
<IMG SRC="images/jconsole-summary.png">
</P>
<P>
Wybieramy zak³adkê <CODE>MBeans</CODE>. Prezentuje ona informacje
o wszystkich m-ziarnach zarejestrowanych w JVM. Pozwala na pe³ny
dostêp do zasobów nadzorowanej maszyny wirtualnej - w tym
równie¿ umo¿liwia manipulowanie w³asnymi m-ziarnami. 
</P>
<P>
<IMG SRC="images/jconsole-mbeans-attributes.png">
</P>

<P>
W lewym panelu otwieramy wêze³ "software.JMX". Powinien
ukazaæ siê liœæ "standard" odpowiadaj¹cy m-ziarnu
zarejestrowanemu przez agenta. Zaznaczamy go, co powoduje
uaktywnienie prawego panelu zak³adkowego. W nim mo¿emy dokonywaæ
operacji na m-ziarnie. Zak³adka <CODE>Attributes</CODE> prezentuje
atrybuty m-ziarna i umo¿liwia nadawanie im wartoœci poprzez zwyk³e
wpisanie nowych danych w kolumnie "Value". Otwieramy
zak³adkê "Notifications". Zawarty tam panel prezentuje
sygna³y emitowane przez m-ziarno i odebrane przez jconsole. Aby
zarejestrowaæ siê jako s³uchacz klikamy przycisk "Subscribe".
Od tej pory zmiany wartoœci atrybutu <CODE>"Value"</CODE> w
naszym m-ziarnie bêd¹ powodowaæ emisjê sygna³u. 
</P>
<P>
<IMG SRC="images/jconsole-mbeans-notifications.png">
</P>

<P>
Spróbujmy. W zak³adce "Attributes" nadajemy now¹
wartoœæ atrybutowi "Value". W tym momencie na etykiecie
zak³adki "Notifications" pojawia siê liczba 1 oznaczaj¹ca,
¿e nadszed³ sygna³. Mo¿emy siê mu przyjrzeæ otwieraj¹c zak³adkê
"Notifications". A teraz otwieramy zak³adkê "Operations".
Pozwala ona na wywo³ywanie metod m-ziarna. Aby wywo³aæ metodê <CODE>reset()</CODE>
klikamy na przycisk znajduj¹cy siê w panelu. W tym momencie pojawia
siê okno dialogowe prezentuj¹ce wartoœæ zwrócon¹ przez metodê,
a na etykiecie zak³adki "Notifications" pojawia siê liczba
odpowiadaj¹ca kolejnemu odebranemu sygna³owi (jak pamiêtamy metoda
<CODE>reset()</CODE> powodowa³a emisjê sygna³u poprzez wywo³anie
<CODE>set()</CODE>). 
</P>
<P>
<IMG SRC="images/jconsole-mbeans-operations.png">
</P>

<H3>5.1 Nadzorowanie w¹tków i wykrywanie blokad</H3>
<P>
Zak³adka <VAR>Threads</VAR> prezentuje informacje dotycz¹ce dzia³aj¹cych w¹tków.
Zaznaczaj¹c w¹tek na liœcie (w lewym-dolnym rogu) mo¿emy obejrzeæ zawartoœæ jego stosu i
inne dane.
Pole <VAR>Filter</VAR> pozwala filtrowaæ w¹tki pojawiaj¹ce siê na liœcie:
bêdzie ona zawieraæ tylko te, których nazwy zawieraj¹ napis podany w tym polu.
</P>
<P>
Wiêcej informacji mo¿emy uzyskaæ pos³uguj¹c siê mx-ziarnami bezpoœrednio.
Wybieramy zak³adkê <VAR>MBeans</VAR> a w drzewie m-ziaren rozwijamy ga³¹Ÿ <VAR>java.lang</VAR>
i zaznaczamy element <VAR>Threading</VAR> (odpowiada on mx-ziarnu <CODE>ThreadMXBean</CODE>).
Zak³adka <VAR>Operations</VAR> prawego panelu pozwala wywo³ywaæ metody tego mx-ziarna.
W szczególnoœci mo¿emy dowiedzieæ siê ile czasu wykonywa³ siê dany w¹tek.
</P>
<DIV CLASS=important>
Te w³aœciwoœci s¹ szczególnie przydatne, 
jeœli chcemy sprawdziæ czy nasz program siê nie zawiesi³
lub te¿ czy nie dosz³o do blokady.
</DIV>
<P>
Zobaczymy jak wykryæ ewentualn¹ blokadê.
W tym celu uruchomimy przyk³adowy program z katalogu 
<SAMP><VAR>JDK_HOME</VAR>/demo/management/FullThreadDump/</SAMP>,
który demonstruje to zjawisko uruchamiaj¹c trzy wzajemnie blokuj¹ce siê w¹tki.
Nastêpnie, na innej maszynie uruchomimy konsolê i wywo³amy metodê 
<CODE>findMonitorDeadlockedThreads()</CODE> z mx-ziarna <CODE>ThreadMXBean</CODE>.
Przy okazji zobaczymy jak uruchamiaæ program aby umo¿liwiæ jego zdalne nadzorowanie.
</P>
<P>
<DIV CLASS=notel>
Program demonstruj¹cy blokadê uruchamiamy na komputerze o adresie <SAMP>192.168.0.2</SAMP>.
</DIV>
Oto sposób uruchomienia powy¿szego programu, demonstruj¹cego blokadê:
<DIV CLASS=listingful STYLE=white-space:pre;>java -Dcom.sun.management.jmxremote.port=1234 
     -Dcom.sun.management.jmxremote.ssl=false 
     -Dcom.sun.management.jmxremote.authenticate=false 
     -cp FullThreadDump.jar Deadlock
</DIV>
Pierwsze trzy wiersze powinny byæ ju¿ jasne (instalujemy ³¹cznik na porcie <CODE>1234</CODE>).
Klasa <CODE>Deadlock</CODE> - zawieraj¹ca metodê startow¹ - 
jest zawarta w archiwum <CODE>FullThreadDump.jar</CODE>,
st¹d opcja <SAMP>-cp FullThreadDump.jar</SAMP>.
Program tworzy trzy w¹tki, które wpadaj¹ w blokadê, poniewa¿ ka¿dy z nich wymaga do dzia³ania
zasobu zajêtego przez inny.
W efekcie program nie mo¿e siê wykonywaæ i trzeba go zakoñczyæ.
Oto wydruk jego dzia³ania:
<DIV CLASS=listingful STYLE=white-space:pre;>Deadlock found :-
"DeadlockedThread-3" Id=13 in BLOCKED on lock=java.lang.Object@1820dda
     owned by DeadlockedThread-1 Id=11
    at Deadlock$DeadlockThread3.A(Deadlock.java:185)
    at Deadlock$DeadlockThread3.C(Deadlock.java:173)
    at Deadlock$DeadlockThread3.run(Deadlock.java:162)

"DeadlockedThread-1" Id=11 in BLOCKED on lock=java.lang.Object@15b7986
     owned by DeadlockedThread-2 Id=12
    at Deadlock$DeadlockThread1.B(Deadlock.java:118)
    at Deadlock$DeadlockThread1.A(Deadlock.java:106)
    at Deadlock$DeadlockThread1.run(Deadlock.java:95)

"DeadlockedThread-2" Id=12 in BLOCKED on lock=java.lang.Object@87816d
     owned by DeadlockedThread-3 Id=13
    at Deadlock$DeadlockThread2.C(Deadlock.java:151)
    at Deadlock$DeadlockThread2.B(Deadlock.java:139)
    at Deadlock$DeadlockThread2.run(Deadlock.java:128)


Press &lt;Enter&gt; to exit this Deadlock program.

</DIV>
</P>
<P>
Teraz uruchamiamy konsolê w zwyk³y sposób wybieraj¹c zak³adkê <VAR>Remote</VAR> i
wype³niaj¹c j¹ tak, jak to wczeœniej opisano.
Poniewa¿ uruchamiaj¹c badan¹ JVM zrezygnowaliœmy z autoryzacji
(w³aœciwoœæ <CODE>com.sun.management.jmxremote.authenticate=false</CODE>), 
podawanie identyfikacji u¿ytkownika nie jest konieczne.
Zatem wystarczy w zak³adce <VAR>Remote</VAR> wpisaæ coœ takiego:
<DIV CLASS=notel>
£¹czymy siê z komputerem o adresie <SAMP>192.168.0.2</SAMP>.
Numer portu <SAMP>1234</SAMP> zosta³ podany podczas uruchamiania maszyny docelowej.
</DIV>
<CENTER><IMG SRC="images/jconsole_select_remote_simple.gif"></CENTER>
</P>
<P>
Teraz otwieramy zak³adkê <VAR>MBeans</VAR>, w drzewie m-ziaren rozwijamy ga³¹Ÿ 
<VAR>java.lang</VAR> i zaznaczamy element <VAR>Threading</VAR>.
Z prawego panelu wybieramy zak³adkê <VAR>Operations</VAR> i klikamy przycisk z nazw¹ metody
<CODE>findMonitorDeadlockedThreads()</CODE>.
Pojawi siê okienko z numerami w¹tków, które s¹ w stanie blokady.
</P>
<CENTER><IMG SRC="images/jconsole-deadlock.gif"></CENTER>
<P>
Jak widaæ, w¹tki o identyfikatorach <VAR>11, 12, 13</VAR> s¹ w stanie blokady.
W zak³adce <VAR>Threads</VAR> mo¿emy przeanalizowaæ zawartoœæ stosu ka¿dego z nich
aby siê dowiedzieæ, co powoduje blokadê.
Mo¿na te¿ - podobnie jak metodê wykrywaj¹c¹ blokadê - 
wywo³aæ metodê <CODE>getThreadInfo(long id, int maxDepth)</CODE> z tego samego mx-ziarna.
Pozwala ona szczegó³owo analizowaæ zawartoœæ stosu
(trzeba jej przekazaæ numer w¹tku i g³êbokoœæ na jak¹ chcemy wnikn¹æ w stos).
</P>
<P>
Mo¿liwoœæ zdalnego wykrycia blokady jest bardzo cenna,
poniewa¿ pozwala rozstrzygn¹æ dlaczego program siê nie wykonuje.
Przyczyn zawsze mo¿e byæ wiele.
Niektóre z nich ustêpuj¹ - inne wymagaj¹ si³owego zakoñczenia programu.
<DIV CLASS=important>
Zauwa¿my, ¿e analizuj¹c dane udostêpniane przez mx-ziarna za poœrednictwem konsoli
mo¿emy równie¿ wykryæ, czy jakiœ w¹tek naszego programu siê nie zawiesza.
</DIV>
</P>

<BR><HR><a name="JMX1.6"></a><H2>6. Æwiczenia</H2>
<P>
<UL>
<LI>
Uruchomiæ dowolny program - na przyk³ad któryœ z katalogu <SAMP>demo/jfc/</SAMP> - 
i pod³¹czyæ do niego <SAMP>jconsole</SAMP>.
</LI>
<LI>
Uruchomiæ zaprezentowane przyk³adowe programy i do³¹czyæ do nich <SAMP>jconsole</SAMP>.
Nastêpnie odnaleŸæ nasze m-ziarna (zak³adka <SAMP>MBeans</SAMP>) i
manipulowaæ atrybutami oraz wykonywaæ operacje.
Zarejestrowaæ <SAMP>jconsole</SAMP> jako odbiorcê sygna³ów.
</LI>
<LI>
Wykonywaæ obydwa æwiczenia dla lokalnej i zdalnej JVM.
</LI>
</UL>
</P>

<BR><HR><a name="JMX1.7"></a><H2>7. Dokumentacja, literatura, aplikacje</H2>

<VAR>JDK_HOME</VAR> oznacza katalog instalacji JDK 6.

<H3>Elektroniczna</H3>
<P>
Dokumentacja podstawowa:
</P>
<UL>
  <LI>
    Witryna <A HREF="http://java.sun.com/products/JavaManagement">java.sun.com/products/JavaManagement</A> - strona domowa JMX.
  </LI>
  <LI>Specyfikacja API - pakiety:
    <UL type="i">
      <LI>
         <CODE>javax.management</CODE> wraz z podpakietami
      </LI>
      <LI>
        <CODE>java.lang.management</CODE>
      </LI>
    </UL>
  </LI>
  <LI>
    Dokument <A HREF="http://java.sun.com/javase/6/docs/technotes/guides/management/">java.sun.com/javase/6/docs/technotes/guides/management/</A>
    (wersja lokalna: JDK_HOME/docs/technotes/guide/management/index.html)
    wprowadza w koncepcje nadzorowania i zarz¹dzania dla jêzyka Java.
  </LI>
  <LI>
    Dokument <A HREF="http://java.sun.com/javase/6/docs/technotes/guides/jmx/index.html">java.sun.com/javase/6/docs/technotes/guides/jmx/index.html</A>
    (wersja lokalna JDK_HOME/docs/technotes/guide/jmx/index.html)
    zawiera odnoœniki do specyfikacji i tutoriala wraz z przyk³adami.
  </LI>
  <LI>
    W¹tek w Java Tutorial poœwiêcony JMX: <A HREF="http://java.sun.com/docs/books/tutorial/jmx/">java.sun.com/docs/books/tutorial/jmx/</A>.
  </LI>
</UL>

<H3>Papierowa</H3>
<P>
Po polsku:
<UL>
  <LI>
   artyku³: "JMX - Zdalne zarz¹dzanie aplikacjami i maszyn¹ wirtualn¹ Javy", Bart³omiej Starosta, Software Developer's Journal, 06.2006, str. 54-63.   
  </LI>
  <LI>
   ksi¹¿ka: "JMX. Zarz¹dzanie aplikacjami w jêzyku Java", Bart³omiej Starosta, PJWSTK 2006.
  </LI>
</UL>
Dostêpnych jest równie¿ kilka ksi¹¿ek w jêzyku angielskim.
</P>

<H3>Oprogramowanie</H3>
<P>
Przyk³adowe programy znajduj¹ siê w katalogach:
<UL>
  <LI>
   <SAMP><VAR>JDK_HOME</VAR>/demo/management/</SAMP>   
  </LI>
  <LI>
   <SAMP><VAR>JDK_HOME</VAR>/sample/jmx/</SAMP>   
  </LI>
  <LI>
   na stronie <A HREF="http://coldjava.hypermart.net/jmx/jmx-html.htm">coldjava.hypermart.net/jmx/jmx-html.htm</A> znajduje siê adapter dla jêzyka HTML. 
  </LI>    
</UL>
Witryna <A HREF="http://java-source.net/open-source/jmx">java-source.net/open-source/jmx</A> udostêpnia narzêdzia <EM>open-source</EM> dla JMX.
</P>
<HR>
    
</body>
</html>
